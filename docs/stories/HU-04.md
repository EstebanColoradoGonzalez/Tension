# HU-04 — Consultar y gestionar Plan de Entrenamiento

## Requisitos relacionados

RF05, RF06, RF08, RF63, RF64

## Descripción

Como ejecutante, quiero consultar el Plan de Entrenamiento completo, visualizando para cada módulo y versión los ejercicios asignados con sus detalles, y poder asignar o desasignar ejercicios de versiones del plan, para entender la estructura de mi programa, conocer las variantes disponibles, personalizar las versiones según mi necesidad y anticipar qué me espera en cada sesión.

## Criterios de Aceptación

### CA-04.01 — Plan precargado y completo

**Dado que** el ejecutante abre la aplicación,
**cuando** accede a la consulta del Plan de Entrenamiento,
**entonces** el sistema muestra el plan precargado con los 3 módulos (A, B, C) y sus respectivas versiones: Módulo A con 3 versiones (V1, V2, V3), Módulo B con 3 versiones (V1, V2, V3) y Módulo C con 3 versiones (V1, V2, V3), sin requerir carga de datos externa ni conexión a internet.

### CA-04.02 — Detalle de ejercicios por módulo-versión

**Dado que** el ejecutante selecciona un módulo y una versión específica,
**cuando** consulta el detalle de esa combinación módulo-versión,
**entonces** el sistema muestra la lista completa de ejercicios asignados, con la siguiente información para cada uno: nombre del ejercicio, zona muscular objetivo, tipo de equipo, número de series (4) y rango de repeticiones (8-12, "Al fallo técnico" o rango en segundos para isométricos).

### CA-04.03 — Listado sin orden obligatorio

**Dado que** el ejecutante consulta los ejercicios de una versión del plan,
**cuando** visualiza la lista de ejercicios,
**entonces** el sistema presenta los ejercicios como un listado que no implica secuencia obligatoria de ejecución; el orden de presentación es referencial, no prescriptivo.

### CA-04.04 — Ejercicios con condiciones especiales identificados

**Dado que** el ejecutante consulta una versión del plan que contiene ejercicios con condiciones especiales,
**cuando** visualiza la lista de ejercicios,
**entonces** el sistema diferencia claramente los ejercicios con rango de repeticiones estándar (8-12) de aquellos con condición especial: "Al fallo técnico" para ejercicios de peso corporal (ej. Flexiones) y rango en segundos (30-45 seg) para ejercicios isométricos (ej. Plancha, Plancha Lateral).

### CA-04.05 — Consulta de todos los módulos y versiones

**Dado que** el ejecutante desea explorar el plan completo,
**cuando** navega entre módulos y versiones,
**entonces** el sistema permite acceder a cualquier combinación módulo-versión del plan (A-V1, A-V2, A-V3, B-V1, B-V2, B-V3, C-V1, C-V2, C-V3), mostrando los ejercicios correspondientes a cada una.

### CA-04.06 — Cantidad de ejercicios por versión

**Dado que** el ejecutante consulta una versión del plan,
**cuando** visualiza los ejercicios,
**entonces** el sistema muestra la cantidad correcta de ejercicios por versión según las asignaciones vigentes: inicialmente 11 ejercicios para cada versión del Módulo A, 11 ejercicios para cada versión del Módulo B y 9 ejercicios para cada versión del Módulo C. Estas cantidades pueden variar si el ejecutante asigna o desasigna ejercicios.

### CA-04.07 — Asignar ejercicio a una versión del plan

**Dado que** el ejecutante quiere agregar un ejercicio a una versión específica del plan,
**cuando** selecciona la opción de asignar ejercicio en el detalle de una versión (D4),
**entonces** el sistema presenta los ejercicios del Diccionario pertenecientes al mismo módulo que aún no están asignados a esa versión. El ejecutante selecciona uno, confirma series (por defecto 4) y rango de repeticiones (por defecto "8-12"), y la asignación se persiste. El nuevo ejercicio aparece inmediatamente en la lista de la versión. La asignación no afecta otras versiones del plan.

### CA-04.08 — Desasignar ejercicio de una versión del plan

**Dado que** el ejecutante quiere remover un ejercicio de una versión específica del plan,
**cuando** selecciona la opción de desasignar en un ejercicio de la versión (D4),
**entonces** el sistema solicita confirmación, y al confirmar, elimina la asignación de esa versión. El ejercicio permanece en el Diccionario y su historial de registros no se ve afectado. La desasignación no afecta otras versiones donde el ejercicio esté asignado ni las sesiones pasadas donde fue ejecutado.

---

## Análisis Arquitectónico

> HU-04 es la cuarta historia en implementarse. Transforma el stub `TrainingPlanScreen` (D3) creado en HU-03 en una vista funcional y construye la nueva vista D4 (Detalle de Versión del Plan) con las funcionalidades de asignación (RF63) y desasignación (RF64) de ejercicios. Esta historia reutiliza la infraestructura de datos creada en HU-03 — las entidades `ModuleVersionEntity`, `PlanAssignmentEntity`, `ModuleEntity` y `ExerciseEntity` ya existen con su seed data (9 module_versions, 93 plan_assignments). El volumen de entidades nuevas es mínimo (0 tablas nuevas); el esfuerzo se concentra en nuevos DAOs con JOINs, un repositorio nuevo (`PlanRepository`), 4 Use Cases, 2 ViewModels y 2 pantallas funcionales. D4 introduce la primera operación de escritura en el catálogo del plan (insert/delete en `plan_assignment`), lo que marca un nuevo patrón: hasta ahora toda la capa de datos del catálogo era solo lectura.

### Patrón arquitectónico

MVVM con capa Domain explícita (4 capas: UI → ViewModel → Domain → Data), según ADR-05. Mismo patrón establecido en HU-01/HU-02/HU-03.

### Componentes afectados

#### 1. Data Layer — DAO Modificaciones (Existentes)

Paquete: `data.local.dao`.

- **`PlanAssignmentDao`** (Modificación): Actualmente solo tiene `getByModuleVersionId(Long): Flow<List<PlanAssignmentEntity>>` y `insertAll()`. Se necesitan queries adicionales:
  - `getDetailsByModuleVersionId(moduleVersionId: Long): Flow<List<PlanAssignmentWithExerciseDetails>>` — Query JOIN entre `plan_assignment`, `exercise`, `equipment_type`, `exercise_muscle_zone` y `muscle_zone` para obtener toda la información visual de D4 (nombre del ejercicio, zona muscular, tipo de equipo, sets, reps, flags de condición especial) en una sola consulta. Patrón similar al `ExerciseDao.getAll()` existente pero filtrado por `module_version_id`.
  - `insert(assignment: PlanAssignmentEntity)` — Insert individual para CA-04.07 (asignar un ejercicio a una versión).
  - `delete(moduleVersionId: Long, exerciseId: Long)` — Delete por PK compuesta para CA-04.08 (desasignar). Implementado como `@Query("DELETE FROM plan_assignment WHERE module_version_id = :moduleVersionId AND exercise_id = :exerciseId")`.

- **`PlanAssignmentWithExerciseDetails`**: Data class intermedia (no `@Entity`), definida en `PlanAssignmentDao.kt` (patrón establecido por `ExerciseWithDetails` en `ExerciseDao.kt`). Campos: `exerciseId: Long`, `exerciseName: String`, `moduleCode: String`, `equipmentTypeName: String`, `muscleZones: String` (GROUP_CONCAT), `sets: Int`, `reps: String`, `isBodyweight: Int`, `isIsometric: Int`, `isToTechnicalFailure: Int`, `isCustom: Int`.

- **`ModuleVersionWithCount`**: Data class intermedia (no `@Entity`), definida en `ModuleVersionDao.kt`. Campos: `id: Long`, `moduleCode: String`, `versionNumber: Int`, `exerciseCount: Int`. Obtenida mediante query combinada: `SELECT mv.id, mv.module_code AS moduleCode, mv.version_number AS versionNumber, COUNT(pa.exercise_id) AS exerciseCount FROM module_version mv LEFT JOIN plan_assignment pa ON mv.id = pa.module_version_id GROUP BY mv.id ORDER BY mv.module_code ASC, mv.version_number ASC`. Esta query única reemplaza la necesidad de 9 Flows individuales de conteo, optimizando D3.

- **`ModuleVersionDao`** (Modificación): Actualmente tiene `getAll()` y `insertAll()`. Se necesita:
  - `getAllWithExerciseCount(): Flow<List<ModuleVersionWithCount>>` — Query combinada con LEFT JOIN a `plan_assignment` + COUNT + GROUP BY (ver `ModuleVersionWithCount` arriba). Usado para D3. Reemplaza la necesidad de `getByModuleCode()` + conteos individuales.
  - `getById(moduleVersionId: Long): Flow<ModuleVersionEntity?>` — Para obtener el module_code y version_number de una versión específica (usado en D4 para construir el título "Módulo {code} — Versión {N}").

- **`ExerciseDao`** (Modificación): Se necesita un query adicional para CA-04.07:
  - `getByModuleCodeNotInVersion(moduleCode: String, moduleVersionId: Long): Flow<List<ExerciseWithDetails>>` — Ejercicios del mismo módulo que NO están asignados a la versión dada. Query: `SELECT ... FROM exercise e ... WHERE e.module_code = :moduleCode AND e.id NOT IN (SELECT exercise_id FROM plan_assignment WHERE module_version_id = :moduleVersionId)`. Reutiliza `ExerciseWithDetails` existente. Alimenta el selector de asignación en D4.

#### 2. Data Layer — Repository (Nuevo)

Paquete: `data.repository`.

- **`PlanRepositoryImpl`**: Implementa `PlanRepository`. Inyecta `PlanAssignmentDao`, `ModuleVersionDao`, `ModuleDao`, `ExerciseDao`. Métodos:
  - `getModulesWithVersionCounts(): Flow<List<ModuleWithVersions>>` — Combina `ModuleDao.getAll()` con `ModuleVersionDao.getAllWithExerciseCount()` usando `combine()`. Agrupa las versiones por `moduleCode` y las asocia al módulo correspondiente para producir la estructura jerárquica de D3: 3 módulos, cada uno con 3 versiones y su conteo de ejercicios. Una sola query al DAO de versiones resuelve los 9 conteos.
  - `getVersionDetail(moduleVersionId: Long): Flow<PlanVersionDetail?>` — Combina `ModuleVersionDao.getById()` con `PlanAssignmentDao.getDetailsByModuleVersionId()` para producir el detalle completo de D4.
  - `getAvailableExercisesForVersion(moduleCode: String, moduleVersionId: Long): Flow<List<Exercise>>` — Delega a `ExerciseDao.getByModuleCodeNotInVersion()` y mapea a dominio. Para el selector de asignación CA-04.07.
  - `assignExercise(moduleVersionId: Long, exerciseId: Long, sets: Int, reps: String)` — Insert en `plan_assignment`. Valida que no exista previamente (PK compuesta lo garantiza).
  - `unassignExercise(moduleVersionId: Long, exerciseId: Long)` — Delete de `plan_assignment`. CA-04.08.

#### 3. Domain Layer — Models del plan (Nuevo)

Paquete: `domain.model`.

- **`ModuleWithVersions`**: Data class — `module: Module`, `versions: List<VersionSummary>`. Representa un módulo con sus versiones para D3.
- **`VersionSummary`**: Data class — `moduleVersionId: Long`, `versionNumber: Int`, `exerciseCount: Int`. Una fila dentro de la sección de un módulo en D3.
- **`PlanVersionDetail`**: Data class — `moduleVersionId: Long`, `moduleCode: String`, `moduleName: String`, `versionNumber: Int`, `exercises: List<PlanExercise>`. El detalle completo para D4.
- **`PlanExercise`**: Data class — `exerciseId: Long`, `name: String`, `equipmentTypeName: String`, `muscleZones: List<String>`, `sets: Int`, `reps: String`, `isBodyweight: Boolean`, `isIsometric: Boolean`, `isToTechnicalFailure: Boolean`, `isCustom: Boolean`. Representa un ejercicio dentro de una versión del plan en D4. El campo `reps` se mapea en la UI: `"8-12"` → "8-12 reps", `"TO_TECHNICAL_FAILURE"` → "Al fallo técnico", `"30-45_SEC"` → "30-45 seg".

#### 4. Domain Layer — Repository Interface (Nuevo)

Paquete: `domain.repository`.

- **`PlanRepository`**: Interfaz Kotlin puro. Contratos:
  - `fun getModulesWithVersionCounts(): Flow<List<ModuleWithVersions>>`
  - `fun getVersionDetail(moduleVersionId: Long): Flow<PlanVersionDetail?>`
  - `fun getAvailableExercisesForVersion(moduleCode: String, moduleVersionId: Long): Flow<List<Exercise>>`
  - `suspend fun assignExercise(moduleVersionId: Long, exerciseId: Long, sets: Int, reps: String)`
  - `suspend fun unassignExercise(moduleVersionId: Long, exerciseId: Long)`

#### 5. Domain Layer — Use Cases (Nuevo)

Paquete: `domain.usecase.plan`.

- **`GetTrainingPlanUseCase`**: Invoca `PlanRepository.getModulesWithVersionCounts()`. Retorna `Flow<List<ModuleWithVersions>>`. Lectura pura para D3. Produce los 3 módulos con sus 3 versiones y conteos de ejercicios.
- **`GetPlanVersionDetailUseCase`**: Invoca `PlanRepository.getVersionDetail(moduleVersionId)`. Retorna `Flow<PlanVersionDetail?>`. Lectura pura para D4.
- **`AssignExerciseToVersionUseCase`**: Invoca `PlanRepository.assignExercise(moduleVersionId, exerciseId, sets, reps)`. Operación de escritura para CA-04.07. Valida que `sets > 0` y `reps` sea un valor válido (`"8-12"`, `"TO_TECHNICAL_FAILURE"`, `"30-45_SEC"`).
- **`UnassignExerciseFromVersionUseCase`**: Invoca `PlanRepository.unassignExercise(moduleVersionId, exerciseId)`. Operación de escritura para CA-04.08. No elimina el ejercicio del Diccionario ni afecta el historial de sesiones.

**Nota sobre `GetAvailableExercisesForVersion`:** No se crea un Use Case separado para esta operación — el `PlanVersionDetailViewModel` puede invocar directamente `PlanRepository.getAvailableExercisesForVersion()` ya que es una consulta de soporte para la UI de asignación, no lógica de negocio reutilizable. Alternativa: si se prefiere pureza, crear `GetAvailableExercisesForVersionUseCase`, pero duplica un pass-through trivial.

#### 6. Data Layer — Repository Implementation (Nuevo)

Paquete: `data.repository`.

- **`PlanRepositoryImpl`**: `@Inject constructor`. Inyecta `PlanAssignmentDao`, `ModuleVersionDao`, `ModuleDao`, `ExerciseDao`. Implementa `PlanRepository`.
  - `getModulesWithVersionCounts()`: Usa `combine()` de `moduleDao.getAll()` y `moduleVersionDao.getAllWithExerciseCount()`. El segundo Flow ya trae el conteo resuelto por la query JOIN. Agrupa versiones por `moduleCode`, asocia con el módulo correspondiente. Mapea a `ModuleWithVersions`.
  - `getVersionDetail(moduleVersionId)`: Combina `moduleVersionDao.getById()` con `planAssignmentDao.getDetailsByModuleVersionId()` + lookup de moduleName desde `moduleDao`. Mapea a `PlanVersionDetail`.
  - `getAvailableExercisesForVersion(moduleCode, moduleVersionId)`: Delega a `exerciseDao.getByModuleCodeNotInVersion()` y mapea `ExerciseWithDetails` → `Exercise` (reutiliza el mapper de `ExerciseRepositoryImpl`).
  - `assignExercise(moduleVersionId, exerciseId, sets, reps)`: Inserta `PlanAssignmentEntity(moduleVersionId, exerciseId, sets, reps)` via `planAssignmentDao.insert()`.
  - `unassignExercise(moduleVersionId, exerciseId)`: Delega a `planAssignmentDao.delete(moduleVersionId, exerciseId)`.

#### 7. Data Layer — Database (Modificación menor)

- **`TensionDatabase`**: No necesita cambios de schema — las entities `ModuleVersionEntity` y `PlanAssignmentEntity` ya existen (creadas en HU-03). La versión de BD no incrementa.

#### 8. UI Layer — D3 Plan de Entrenamiento (Reemplazo del stub)

Paquete: `ui.catalog`.

- **`TrainingPlanScreen`** (Reemplazo): Se reemplaza el contenido del stub existente ([TrainingPlanScreen.kt](Tension/app/src/main/java/com/estebancoloradogonzalez/tension/ui/catalog/TrainingPlanScreen.kt)) con la implementación funcional. Se mantiene la firma existente: `fun TrainingPlanScreen(onNavigateToExerciseDictionary: () -> Unit, onNavigateToPlanVersionDetail: (Long) -> Unit)`, agregando `viewModel: TrainingPlanViewModel = hiltViewModel()`. Estructura según Wireframes D3 y Especificación Visual §8 D3:
  - **Top Bar**: Reutiliza la misma estructura del stub actual — `CenterAlignedTopAppBar` con título "Diccionario" + `TabRow` con "Ejercicios" (inactivo, navega a D1) / "Plan" (activo). Ya implementado en el stub, se preserva tal cual.
  - **Body**: `LazyColumn` con 3 secciones de módulo. Cada sección:
    - Encabezado: `Title Medium, On Surface` con nombre del módulo ("Módulo A — Superior (Pull + Abs)"). Subtítulo: `Body Small, On Surface Variant` con grupo muscular ("Espalda, Bíceps, Abdomen").
    - 3 `ListItem` M3 de 56 dp por versión: `headlineContent = "Versión N"`, `trailingContent = "(X ej.)"` con conteo dinámico. Clickable → `onNavigateToPlanVersionDetail(moduleVersionId)`.
    - Separación entre módulos: `Spacer 12 dp + Divider Outline Variant + Spacer 12 dp` (Especificación Visual §8 D3).
  - **No tiene Bottom Navigation propia** — ya se maneja en el `Scaffold` del `TensionNavHost`.

**Firma actualizada:**

```kotlin
@Composable
fun TrainingPlanScreen(
    onNavigateToExerciseDictionary: () -> Unit,
    onNavigateToPlanVersionDetail: (Long) -> Unit,
    viewModel: TrainingPlanViewModel = hiltViewModel(),
)
```

- **`TrainingPlanViewModel`**: `@HiltViewModel`. Inyecta `GetTrainingPlanUseCase`. Estado: `StateFlow<TrainingPlanUiState>`. En `init`, recolecta el Flow del Use Case y mapea a `TrainingPlanUiState`.

- **`TrainingPlanUiState`**: Data class con `isLoading: Boolean = true`, `modules: List<ModuleSectionItem> = emptyList()`.

- **`ModuleSectionItem`**: Data class — `moduleCode: String`, `moduleName: String` (ej: "Módulo A — Superior (Pull + Abs)"), `groupDescription: String` (ej: "Espalda, Bíceps, Abdomen"), `versions: List<VersionItem>`.

  **Nota sobre `groupDescription` de Módulo C:** El campo `ModuleEntity.groupDescription` almacena "Cuádriceps, Isquiotibiales, Glúteos, Aductores, Abductores, Gemelos" (Modelo de Datos §3.1). Los Wireframes y Especificación Visual D3 muestran "(Pierna)" como subtítulo simplificado para Módulo C. Se usa `groupDescription` directamente en la implementación porque es informativamente más preciso y refleja los datos reales del sistema; el Wireframe usa una representación abreviada que no se ajusta al modelo de datos. Los subtítulos de Módulos A y B coinciden exactamente con sus `groupDescription` — para Módulo C el subtítulo será más largo pero correcto.

- **`VersionItem`**: Data class — `moduleVersionId: Long`, `versionNumber: Int`, `exerciseCount: Int`.

#### 9. UI Layer — D4 Detalle de Versión del Plan (Nuevo)

Paquete: `ui.catalog`.

- **`PlanVersionDetailScreen`**: Composable de nivel pantalla. Recibe `moduleVersionId` como argumento de navegación. Estructura según Wireframes D4 y Especificación Visual §8 D4:
  - **Top Bar**: `TensionTopAppBar` con retorno + título dinámico "Módulo X — Versión N" (construido desde `PlanVersionDetail.moduleCode` + `versionNumber` usando string resource `plan_version_title_format`: "Módulo %1$s — Versión %2$d"). No se usa `moduleName` porque contiene el nombre completo "Módulo A — Superior (Pull + Abs)" que no corresponde al formato del título de D4.
  - **Subtítulo informativo**: `Text Body Small, On Surface Variant`: "N ejercicios · Sin orden obligatorio" (CA-04.03, RF06). Padding bottom 16 dp.
  - **Lista de ejercicios**: `LazyColumn` con `ListItem` M3 de 80 dp por ejercicio. Cada fila tiene 3 líneas:
    - Línea 1 (`headlineContent`): Title Medium, On Surface — nombre del ejercicio.
    - Línea 2 (`supportingContent`): Body Medium, On Surface Variant — "Pecho Medio · Máquina" (zona muscular + tipo de equipo, separados por " · "). Para ejercicios multi-zona, zonas concatenadas con ", ".
    - Línea 3 (`supportingContent`): Body Medium, On Surface Variant — prescripción. Según tipo:
      - Estándar: "4 series · 8-12 reps"
      - Al fallo técnico (Flexiones): "4 series · Al fallo técnico" — **fontStyle: italic** (Especificación Visual §8 D4)
      - Isométrico (Plancha, Plancha Lateral): "4 series · 30-45 seg" — **fontStyle: italic**
      - Peso corporal otros (Abdominales, Escalador, etc.): "4 series · 8-12 reps" — sin distinción visual especial (son rango estándar)
    - `trailingContent`: `IconButton` Delete con tint `Error` (48 dp touch target) para desasignar (CA-04.08). Al tocar → diálogo de confirmación.
    - Clickable → navega a D2 con `exerciseId`.
    - `HorizontalDivider` 1 dp Outline Variant entre filas.
  - **FAB asignar ejercicio** (CA-04.07): `FloatingActionButton` M3, ícono Add (24 dp), containerColor Primary Container, contentColor On Primary Container, posición bottom-end margin 16 dp. Al tocar → presenta Bottom Sheet o diálogo con lista de ejercicios del mismo módulo no asignados a esta versión. El ejecutante selecciona uno, confirma sets (default 4) y reps (default "8-12"), y se inserta la asignación.
  - **Diálogo de confirmación desasignación** (CA-04.08): `AlertDialog` M3 con título "Desasignar ejercicio", texto "¿Estás seguro de que deseas remover [nombre] de esta versión? El ejercicio permanecerá en el Diccionario.", botones "Cancelar" / "Desasignar" (color Error).
  - **Bottom Sheet de asignación** (CA-04.07): `ModalBottomSheet` M3 con `LazyColumn` de ejercicios disponibles. Cada fila: nombre + zona muscular + equipo. Al seleccionar uno, se muestra un sub-formulario mínimo para confirmar sets (campo numérico, default "4") y reps (selector: "8-12", "Al fallo técnico", "30-45 seg"). Botón "Asignar" confirma y cierra el sheet.
  - **Estado vacío**: Si no hay ejercicios asignados (todos desasignados), mostrar texto centrado: "No hay ejercicios asignados a esta versión." Body Large, On Surface Variant.

**Firma:**

```kotlin
@Composable
fun PlanVersionDetailScreen(
    onNavigateBack: () -> Unit,
    onNavigateToExerciseDetail: (Long) -> Unit,
    viewModel: PlanVersionDetailViewModel = hiltViewModel(),
)
```

- **`PlanVersionDetailViewModel`**: `@HiltViewModel`. Recibe `moduleVersionId: Long` via `SavedStateHandle`. Inyecta `GetPlanVersionDetailUseCase`, `AssignExerciseToVersionUseCase`, `UnassignExerciseFromVersionUseCase`, `PlanRepository` (para `getAvailableExercisesForVersion`). Estado principal: `StateFlow<PlanVersionDetailUiState>`. Estados secundarios: `StateFlow<AssignExerciseSheetState>` para el Bottom Sheet de asignación.
  - Funciones: `onDeleteExercise(exerciseId: Long)` → muestra diálogo de confirmación, `onConfirmDelete()` → ejecuta unassign, `onDismissDeleteDialog()`, `onFabClick()` → carga ejercicios disponibles y abre el sheet, `onExerciseSelected(exerciseId: Long)`, `onSetsChanged(sets: String)`, `onRepsSelected(reps: String)`, `onConfirmAssign()`, `onDismissSheet()`.

- **`PlanVersionDetailUiState`**: Data class — `isLoading: Boolean = true`, `moduleCode: String = ""`, `moduleName: String = ""`, `versionNumber: Int = 0`, `exercises: List<PlanExerciseItem> = emptyList()`, `showDeleteDialog: Boolean = false`, `exerciseToDelete: PlanExerciseItem? = null`.

- **`PlanExerciseItem`**: Data class para UI — `exerciseId: Long`, `name: String`, `equipmentTypeName: String`, `muscleZonesSummary: String` (zonas concatenadas con ", "), `sets: Int`, `repsDisplay: String` (ya mapeado a español: "8-12 reps", "Al fallo técnico", "30-45 seg"), `isSpecialCondition: Boolean` (true si es fallo técnico o isométrico — para aplicar italic), `isCustom: Boolean`.

- **`AssignExerciseSheetState`**: Data class — `isVisible: Boolean = false`, `availableExercises: List<ExerciseItem> = emptyList()` (reutiliza `ExerciseItem` de D1 o una variante), `selectedExerciseId: Long? = null`, `sets: String = "4"`, `reps: String = "8-12"`, `isAssigning: Boolean = false`.

#### 10. UI Layer — Mapeo de `reps` a texto español

El campo `reps` en `PlanAssignmentEntity` almacena valores codificados: `"8-12"`, `"TO_TECHNICAL_FAILURE"`, `"30-45_SEC"`. La UI D4 los mapea a texto legible:

| Valor en DB | Texto en D4 | Estilo visual |
| --- | --- | --- |
| `"8-12"` | "8-12 reps" | Normal |
| `"TO_TECHNICAL_FAILURE"` | "Al fallo técnico" | *Italic* |
| `"30-45_SEC"` | "30-45 seg" | *Italic* |

Este mapeo se realiza en el ViewModel al transformar `PlanExercise` → `PlanExerciseItem`. La función helper se puede definir como extensión o en un objeto utilitario dentro del paquete `ui.catalog`:

```kotlin
fun mapRepsToDisplay(reps: String): Pair<String, Boolean> = when (reps) {
    "TO_TECHNICAL_FAILURE" -> "Al fallo técnico" to true
    "30-45_SEC" -> "30-45 seg" to true
    else -> "$reps reps" to false
}
```

#### 11. UI Layer — Navegación (Modificación)

- **`NavigationRoutes`**: Agregar constante: `PLAN_VERSION_DETAIL = "plan-version-detail/{moduleVersionId}"` (Arquitectura Técnica §4.3 #8). Helper function: `fun planVersionDetailRoute(moduleVersionId: Long) = "plan-version-detail/$moduleVersionId"`.
- **`TensionNavHost`**:
  - Actualizar composable `TRAINING_PLAN`: pasar `onNavigateToPlanVersionDetail` con navegación real `{ moduleVersionId -> navController.navigate(NavigationRoutes.planVersionDetailRoute(moduleVersionId)) }` (reemplaza el `/* TODO: HU-04 */` actual).
  - Agregar composable para `PLAN_VERSION_DETAIL` con `navArgument("moduleVersionId", NavType.LongType)` → `PlanVersionDetailScreen(onNavigateBack = { navController.popBackStack() }, onNavigateToExerciseDetail = { exerciseId -> navController.navigate(NavigationRoutes.exerciseDetailRoute(exerciseId)) })`.
- **`BottomNavigationBar`**: Agregar `"plan-version-detail"` al `childRoutePrefixes` del ítem Diccionario para que el tab se marque como activo en D4 (ruta con argumento, mismo patrón de `"exercise-detail"` ya implementado en HU-03).

#### 12. DI Layer — Módulos (Modificación)

- **`RepositoryModule`**: Agregar binding `PlanRepository` ↔ `PlanRepositoryImpl` con `@Binds @Singleton`.

#### 13. Recursos (Modificación)

- **`strings.xml`**: Agregar strings para D3: `version_label_format` = "Versión %d", `exercise_count_format_short` = "(%d ej.)". Nota: el encabezado de cada módulo (ej: "Módulo A — Superior (Pull + Abs)") se obtiene directamente de `ModuleEntity.name`, no requiere format string. Para D4: `plan_version_title_format` = "Módulo %1$s — Versión %2$d", `plan_exercise_count_subtitle` = "%d ejercicios · Sin orden obligatorio", `reps_standard_format` = "%s reps", `reps_technical_failure` = "Al fallo técnico", `reps_isometric_format` = "30-45 seg", `sets_format` = "%d series", `prescription_format` = "%1$d series · %2$s", `unassign_dialog_title` = "Desasignar ejercicio", `unassign_dialog_message` = "¿Estás seguro de que deseas remover \"%1$s\" de esta versión? El ejercicio permanecerá en el Diccionario.", `unassign_dialog_confirm` = "Desasignar", `cancel` = "Cancelar", `assign_exercise_title` = "Asignar ejercicio", `assign_exercise_empty` = "No hay ejercicios disponibles para asignar en este módulo.", `assign_button` = "Asignar", `sets_label` = "Series", `reps_label` = "Repeticiones", `no_exercises_assigned` = "No hay ejercicios asignados a esta versión.", `fab_assign_exercise` = "Asignar ejercicio".

### Integraciones

| Interfaz / Contrato | Productor | Consumidor | Descripción |
| --- | --- | --- | --- |
| `PlanRepository` | `PlanRepositoryImpl` (Data) | Use Cases de plan (Domain) | Contrato de acceso al plan de entrenamiento: lectura de módulos/versiones, detalle de versión, asignación/desasignación. Definido en Domain, implementado en Data, inyectado por Hilt |
| `StateFlow<TrainingPlanUiState>` | `TrainingPlanViewModel` | `TrainingPlanScreen` | Estructura jerárquica de 3 módulos × 3 versiones con conteos de ejercicios para D3 |
| `StateFlow<PlanVersionDetailUiState>` | `PlanVersionDetailViewModel` | `PlanVersionDetailScreen` | Lista de ejercicios de una versión con prescripción, estado de diálogo de desasignación |
| `StateFlow<AssignExerciseSheetState>` | `PlanVersionDetailViewModel` | `PlanVersionDetailScreen` | Estado del Bottom Sheet de asignación: ejercicios disponibles, selección, sets/reps |
| `SavedStateHandle` | Navigation Compose | `PlanVersionDetailViewModel` | `moduleVersionId: Long` extraído de la ruta `plan-version-detail/{moduleVersionId}` |
| `ExerciseDao.getByModuleCodeNotInVersion()` | `ExerciseDao` | `PlanRepositoryImpl` | Ejercicios del mismo módulo no asignados a una versión — alimenta el selector de CA-04.07 |
| `PlanAssignmentDao.insert()` / `.delete()` | `PlanAssignmentDao` | `PlanRepositoryImpl` | Operaciones de escritura en `plan_assignment` — primera mutación del catálogo del plan |
| D4 → D2 navegación | `PlanVersionDetailScreen` | `ExerciseDetailScreen` | Al tocar un ejercicio en D4, navega a D2 con `exerciseId`. D2 ya es reutilizable (HU-03) — el retorno via `popBackStack()` vuelve a D4 automáticamente. Bottom Nav visible (origen D4, §4.5.1) |

### Riesgos

| Riesgo | Probabilidad | Impacto | Mitigación |
| --- | --- | --- | --- |
| Bottom Sheet de asignación con muchos ejercicios disponibles si el módulo tiene muchos custom | Baja | Bajo | Inicialmente el pool es limitado (máx ~15 ejercicios por módulo seed). Si crecen los custom, agregar búsqueda o scroll con indices. Riesgo bajo en MVP |
| Desasignación de último ejercicio de una versión deja versión vacía | Baja | Medio | No se impone mínimo de ejercicios por versión — el plan es personalizable (RF64). El estado vacío se maneja con UI placeholder. HU-05 (sesión) debe manejar el caso de versión sin ejercicios mostrando mensaje informativo |
| Conteo de ejercicios en D3 se desincroniza si se asigna/desasigna en D4 | Certeza | Bajo | Los conteos se obtienen via `Flow` reactivo. Al insertar/eliminar en `plan_assignment`, Room invalida automáticamente las queries que dependen de esa tabla. El Flow de `countByModuleVersionId()` emite el nuevo valor y D3 se actualiza al regresar. Si D3 usa `restoreState`, el ViewModel ya está subscrito y refleja el cambio |
| El selector de reps en el Bottom Sheet de asignación no cubre todos los valores válidos | Media | Bajo | Limitar el selector a los 3 valores del CHECK constraint (`"8-12"`, `"TO_TECHNICAL_FAILURE"`, `"30-45_SEC"`). El valor por defecto es `"8-12"`. La UI no permite valores fuera de este set |
| La ruta `plan-version-detail/{moduleVersionId}` no marca Diccionario como activo en Bottom Nav | Certeza | Bajo | Agregar `"plan-version-detail"` a `childRoutePrefixes` del ítem Diccionario. Mismo patrón ya resuelto en HU-03 para `"exercise-detail"` |
| `PlanAssignmentEntity` usa PK compuesta — Room previene duplicados automáticamente | Muy baja | Bajo | `OnConflictStrategy.REPLACE` o `ABORT` en el insert individual. Si se intenta asignar un ejercicio ya asignado, Room lanza excepción o reemplaza. La UI filtra ejercicios ya asignados (query `NOT IN`), previniendo el caso en condiciones normales |

### Hitos de implementación

| Hito | Contenido | Dependencias |
| --- | --- | --- |
| 1 | Data Layer — DAO Modificaciones: `PlanAssignmentDao` (+2 queries: getDetails/insert, +delete), `PlanAssignmentWithExerciseDetails`, `ModuleVersionDao` (+getAllWithExerciseCount, +getById), `ModuleVersionWithCount`, `ExerciseDao` (+getByModuleCodeNotInVersion) | HU-03 completada (entities y seed data existentes) |
| 2 | Domain Layer: 4 modelos (`ModuleWithVersions`, `VersionSummary`, `PlanVersionDetail`, `PlanExercise`), `PlanRepository` interfaz, 4 Use Cases | — (Kotlin puro) |
| 3 | Data Layer — Repository: `PlanRepositoryImpl` | Hito 1, Hito 2 |
| 4 | DI: actualizar `RepositoryModule` (+PlanRepository binding) | Hito 3 |
| 5 | UI — D3: `TrainingPlanScreen` (reemplazo del stub), `TrainingPlanViewModel`, `TrainingPlanUiState` | Hito 2, Hito 3 |
| 6 | UI — D4: `PlanVersionDetailScreen`, `PlanVersionDetailViewModel`, `PlanVersionDetailUiState`, `AssignExerciseSheetState`, diálogos de asignación/desasignación | Hito 2, Hito 3 |
| 7 | Navegación: `NavigationRoutes` (+PLAN_VERSION_DETAIL), `TensionNavHost` (actualizar D3, agregar D4), `BottomNavigationBar` (+childRoutePrefix) | Hito 5, Hito 6 |
| 8 | Recursos: `strings.xml` (+strings D3/D4) | — (independiente) |

### Notas de auditoría

1. **CA-04.01 (plan precargado) se cumple con el seed data de HU-03.** Las 93 filas de `plan_assignment` y 9 filas de `module_version` ya existen en la BD. HU-04 solo las lee — no necesita seed adicional. Los Flows de Room emiten los datos precargados inmediatamente. Sin conexión a internet (RNF09).
2. **CA-04.02 (detalle de ejercicios) requiere un JOIN multi-tabla.** `PlanAssignmentDao.getDetailsByModuleVersionId()` debe resolver nombre del ejercicio, tipo de equipo, zonas musculares (via GROUP_CONCAT), sets y reps en una sola consulta. Patrón idéntico al `ExerciseDao.getAll()` de HU-03 pero filtrado por `module_version_id` y con los campos `sets` y `reps` adicionales.
3. **CA-04.03 (sin orden obligatorio) se cumple por diseño UI.** El subtítulo "N ejercicios · Sin orden obligatorio" (Wireframes D4 #3, Especificación Visual §8 D4) comunica explícitamente que el listado no implica secuencia. RF06 queda satisfecho.
4. **CA-04.04 (condiciones especiales) se resuelve en el mapeo `reps` → display.** Los ejercicios con `reps = "TO_TECHNICAL_FAILURE"` muestran "Al fallo técnico" en italic; los con `reps = "30-45_SEC"` muestran "30-45 seg" en italic. Los demás (incluyendo peso corporal con rango estándar como Abdominales) muestran "8-12 reps" sin distinción visual. Verificado contra Especificación Visual §8 D4 tabla de diferenciación.
5. **CA-04.05 (todos los módulos y versiones) se cumple con la estructura D3 → D4.** D3 muestra las 9 combinaciones (3 módulos × 3 versiones cada uno). Cada combinación navega a D4 con su `moduleVersionId`. Los IDs son: A-V1=1, A-V2=2, A-V3=3, B-V1=4, B-V2=5, B-V3=6, C-V1=7, C-V2=8, C-V3=9 (seed data en Modelo de Datos §3.6).
6. **CA-04.06 (cantidad de ejercicios) se obtiene reactivamente.** D3 muestra el conteo de ejercicios por versión — inicialmente A×3=11, B×3=11, C×3=9. Si el ejecutante asigna o desasigna (CA-04.07/CA-04.08), el conteo se actualiza automáticamente via Flow reactivo de Room.
7. **CA-04.07 (asignar ejercicio) requiere filtrar ejercicios del mismo módulo no asignados.** La query `ExerciseDao.getByModuleCodeNotInVersion()` usa `WHERE e.module_code = :moduleCode AND e.id NOT IN (SELECT exercise_id FROM plan_assignment WHERE module_version_id = :moduleVersionId)`. El pool incluye tanto ejercicios seed como custom del mismo módulo (patrón extensible con catálogo base extensible RF62).
8. **CA-04.08 (desasignar) es un DELETE con confirmación.** La operación elimina solo la fila en `plan_assignment` (PK compuesta). El ejercicio permanece en `exercise` (Diccionario) y los registros históricos en `exercise_set` no se afectan (FK no cascadea). La desasignación no afecta otras versiones — cada versión tiene su propia fila en `plan_assignment`.
9. **D3 reutiliza la estructura de tabs de HU-03.** El stub `TrainingPlanScreen` ya tiene la `CenterAlignedTopAppBar` con título "Diccionario" y `TabRow` con "Ejercicios"/"Plan". Se preserva el TopBar y se reemplaza solo el body (el `Box` con "Próximamente" → `LazyColumn` con módulos y versiones).
10. **D4 navega a D2 (Detalle de Ejercicio).** D2 ya es reutilizable desde HU-03. Al navegar D4→D2, el back stack es: D3 → D4 → D2. El retorno de D2 via `popBackStack()` vuelve a D4. La Bottom Nav es visible en D4 y en D2 (origen D4, Arquitectura Técnica §4.5.1). El ítem Diccionario mantiene resaltado porque D4 y D2 están en las childRoutes/childRoutePrefixes del ítem.
11. **`PlanRepository` es un repositorio separado de `ExerciseRepository`.** Aunque ambos acceden a tablas del catálogo, sus responsabilidades son distintas: `ExerciseRepository` gestiona el Diccionario (lectura de ejercicios y filtros), `PlanRepository` gestiona el Plan de Entrenamiento (lectura de versiones con prescripción, asignación/desasignación). Esta separación sigue el principio de Single Responsibility. `PlanRepository` depende de `ExerciseDao` para la query de ejercicios disponibles, lo cual es aceptable a nivel de Data Layer.
12. **No se incrementa la versión de la BD.** HU-04 no agrega ni modifica tablas — solo agrega queries y operaciones DML (INSERT/DELETE) sobre tablas existentes. Las entities `ModuleVersionEntity` y `PlanAssignmentEntity` ya están registradas en `TensionDatabase` (HU-03, version = 3).
13. **Compatibilidad con HU-05 (sesión) verificada.** HU-05 necesita obtener los ejercicios de una combinación módulo-versión para armar la sesión. La query `PlanAssignmentDao.getDetailsByModuleVersionId()` creada en HU-04 será reutilizable para HU-05 o extensible con campos adicionales (carga objetivo). El `PlanRepository` queda preparado para ser extendido. Si una versión queda sin ejercicios (todos desasignados), HU-05 debe detectarlo y mostrar mensaje informativo.
14. **El Bottom Sheet de asignación usa defaults conservadores.** Sets = 4 (siempre 4 en MVP, Modelo de Datos §3.7), reps = "8-12" por defecto. El ejecutante puede cambiar reps a "Al fallo técnico" o "30-45 seg" desde el selector. Los sets se mantienen en 4 como campo numérico editable por si futuras versiones permiten cambio. El CHECK constraint de `plan_assignment.reps` (`IN ('8-12', 'TO_TECHNICAL_FAILURE', '30-45_SEC')`) se respeta.
15. **El selector de reps SOLO muestra las 3 opciones válidas.** No es un campo de texto libre — es un selector con las opciones: "8-12 reps" (valor: `"8-12"`), "Al fallo técnico" (valor: `"TO_TECHNICAL_FAILURE"`), "30-45 seg" (valor: `"30-45_SEC"`). Esto garante el CHECK constraint de la BD.
16. **Tabs D1 ↔ D3 ya implementados en HU-03.** La navegación lateral entre tabs usa `launchSingleTop = true` y `restoreState = true` sin apilamiento (Arquitectura Técnica §4.8). El `TensionNavHost` ya tiene ambos composables conectados. No requiere cambio.
17. **`ExerciseRepositoryImpl.toDomainModel()` se puede reutilizar.** La conversión de `ExerciseWithDetails` → `Exercise` ya existe en `ExerciseRepositoryImpl`. `PlanRepositoryImpl` necesita el mismo mapeo para `getAvailableExercisesForVersion()`. Para evitar duplicación, se puede extraer el mapper a una función top-level o un object `ExerciseMapper` en `data.repository` — o crear una extensión accesible desde ambos repositorios. Alternativa pragmática: duplicar el mapper (es <15 líneas) para mantener independencia de repositorios.
18. **Validación de integridad cruzada módulo-ejercicio.** El Modelo de Datos §3.7 documenta: *"El `exercise_id` referenciado debe pertenecer al mismo módulo que el `module_version_id`."* Esta restricción no es expresable como CHECK en SQLite. La query `getByModuleCodeNotInVersion(moduleCode, ...)` ya filtra por módulo, previniendo la asignación cruzada en condiciones normales. Un caso edge: si el ejecutante navega rápido entre módulos, el sheet podría mostrar datos stale. El Flow reactivo mitiga esto.
19. **Conteo en D3 — implementación resuelta.** Se adopta el enfoque de query única con COUNT: `ModuleVersionDao.getAllWithExerciseCount()` retorna `Flow<List<ModuleVersionWithCount>>` con la query `SELECT mv.id, mv.module_code AS moduleCode, mv.version_number AS versionNumber, COUNT(pa.exercise_id) AS exerciseCount FROM module_version mv LEFT JOIN plan_assignment pa ON mv.id = pa.module_version_id GROUP BY mv.id ORDER BY mv.module_code ASC, mv.version_number ASC`. Este enfoque es más eficiente que 9 Flows individuales y se propaga reactivamente: al insertar/eliminar en `plan_assignment`, Room invalida la query y emite los conteos actualizados.
