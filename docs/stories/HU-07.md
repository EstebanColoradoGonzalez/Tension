# HU-07 — Sustituir ejercicio puntualmente en sesión activa

## Requisitos relacionados

RF16

## Descripción

Como ejecutante, quiero poder sustituir puntualmente un ejercicio prescrito por otro ejercicio del mismo módulo durante una sesión activa sin modificar el Plan de Entrenamiento, para adaptar el entrenamiento a las circunstancias del gimnasio (equipo no disponible, dolor articular) sin comprometer la cobertura muscular ni corromper mi plan original.

## Criterios de Aceptación

### CA-07.01 — Sustitución durante sesión activa

**Dado que** el ejecutante tiene una sesión activa y un ejercicio prescrito no puede ejecutarse (equipo ocupado, en mantenimiento o genera dolor articular),
**cuando** selecciona la opción de sustituir ese ejercicio,
**entonces** el sistema presenta la lista de ejercicios elegibles como sustitutos: todos los ejercicios del mismo módulo (A, B o C) del Diccionario — incluyendo tanto los precargados como los creados por el ejecutante — disponibles en cualquier versión del módulo, excluyendo los ya prescritos en la sesión activa.

### CA-07.02 — Restricción al mismo módulo

**Dado que** el ejecutante está seleccionando un ejercicio sustituto,
**cuando** el sistema presenta los ejercicios disponibles,
**entonces** únicamente muestra ejercicios que pertenecen al mismo módulo de la sesión activa; ningún ejercicio de otro módulo es elegible como sustituto.

### CA-07.03 — Sustitución puntual sin alterar el plan

**Dado que** el ejecutante realiza una sustitución de un ejercicio en la sesión activa,
**cuando** la sesión se cierra (Completada o Incompleta),
**entonces** el Plan de Entrenamiento original permanece intacto e inalterado para todas las sesiones futuras; la sustitución solo afecta la sesión en curso.

### CA-07.04 — Sesión futura sin rastro de sustitución anterior

**Dado que** el ejecutante sustituyó un ejercicio en una sesión anterior,
**cuando** inicia la próxima sesión del mismo módulo y versión,
**entonces** el sistema prescribe los ejercicios originales del Plan de Entrenamiento, sin arrastrar la sustitución de la sesión anterior.

### CA-07.05 — Sustitución de ejercicio no iniciado

**Dado que** el ejecutante desea sustituir un ejercicio que aún está en estado "No Iniciado" (0 series registradas),
**cuando** ejecuta la sustitución,
**entonces** el sistema reemplaza el ejercicio prescrito por el sustituto en la sesión activa, y las series registradas posteriormente se vincularán al ejercicio sustituto.

### CA-07.06 — Restricción de sustitución con series registradas

**Dado que** el ejecutante desea sustituir un ejercicio que ya tiene series registradas ("En Ejecución" o "Completado"),
**cuando** intenta ejecutar la sustitución,
**entonces** el sistema no permite la sustitución, ya que las series ya registradas están vinculadas al ejercicio original y cambiar el ejercicio después de registrar datos corrompería la integridad de los registros.

## Análisis Arquitectónico (Arquitecto)

### Decisiones de Diseño

**Patrón Arquitectónico:** Clean Architecture (MVVM + Use Cases + Repository) — consistente con HU-01 a HU-06.

**Justificación:** HU-07 introduce la pantalla E3 (Selección de Ejercicio Sustituto) con un flujo simple: lista filtrada + diálogo de confirmación + UPDATE atómico. La complejidad reside en: (1) el query correcto para la lista de sustitutos elegibles, (2) la corrección del query de E1 que actualmente usa INNER JOIN a `plan_assignment` y rompería con ejercicios sustituidos, y (3) la preservación del `original_exercise_id` ante sustituciones múltiples. No se requieren entidades nuevas — `SessionExerciseEntity` ya tiene la columna `original_exercise_id` (creada en HU-05).

**Hallazgo Crítico — Bug en query de E1:**

La query `getBySessionIdWithDetails()` actualmente usa:

```sql
INNER JOIN plan_assignment pa ON pa.module_version_id = s.module_version_id
    AND pa.exercise_id = se.exercise_id
```

Un ejercicio sustituido (cuyo `exercise_id` es el sustituto, no el original del plan) **no existe** en `plan_assignment` para ese `module_version_id`. Resultado: el ejercicio sustituido **desaparece de E1** tras la sustitución — bug bloqueante que se corrige obligatoriamente en HU-07.

**Corrección:** Cambiar `INNER JOIN` → `LEFT JOIN` + `COALESCE(pa.sets, 4)` + `COALESCE(pa.reps, '8-12')`. Este patrón ya fue validado exitosamente en `getExerciseInfoForSet()` de HU-06.

**Componentes Afectados:**

```
┌─────────────────────────────────────────────────────────────────────┐
│  Archivos NUEVOS (4)                                                │
│  SubstituteExerciseInfo.kt          (domain/model)                  │
│  SubstituteExerciseUseCase.kt       (domain/usecase/session)        │
│  SubstituteExerciseViewModel.kt     (ui/session)                    │
│  SubstituteExerciseScreen.kt        (ui/session)                    │
├─────────────────────────────────────────────────────────────────────┤
│  Archivos MODIFICADOS (9)                                           │
│  SessionExerciseDao.kt              (+3 métodos, fix query E1)      │
│  ExerciseDao.kt                     (+1 método)                     │
│  SessionRepository.kt               (+3 métodos)                    │
│  SessionRepositoryImpl.kt           (+3 métodos)                    │
│  ExerciseRepository.kt              (+1 método)                     │
│  ExerciseRepositoryImpl.kt          (+1 método)                     │
│  NavigationRoutes.kt                (+1 ruta + helper)              │
│  TensionNavHost.kt                  (wiring E1→E3 + showBottomBar)  │
│  strings.xml                        (+8 strings)                    │
└─────────────────────────────────────────────────────────────────────┘
```

#### 1. Data Layer — DAOs (Modificaciones)

Paquete: `data.local.dao`.

- **`SessionExerciseDao`** (Modificación Mayor):

  - **Corrección de `getBySessionIdWithDetails()`** (Bug fix): Cambiar INNER JOIN → LEFT JOIN en `plan_assignment` + COALESCE para `sets` y `reps`. Esto asegura que ejercicios sustituidos (cuyo `exercise_id` no está en `plan_assignment` para el `module_version_id` actual) sigan apareciendo en E1. La sustitución solo cambia `exercise_id` en `session_exercise`, no modifica `plan_assignment`.

    **Cambio concreto en la query:**

    ```sql
    -- ANTES (INNER JOIN — ROMPE con sustitución):
    INNER JOIN plan_assignment pa ON pa.module_version_id = s.module_version_id
        AND pa.exercise_id = se.exercise_id

    -- DESPUÉS (LEFT JOIN + COALESCE — CORRECTO):
    LEFT JOIN plan_assignment pa ON pa.module_version_id = s.module_version_id
        AND pa.exercise_id = se.exercise_id
    ```

    Y en los campos SELECT:

    ```sql
    -- ANTES:
    pa.sets,
    pa.reps,

    -- DESPUÉS:
    COALESCE(pa.sets, 4) AS sets,
    COALESCE(pa.reps, '8-12') AS reps,
    ```

    **Justificación de defaults `4` y `'8-12'`:** Son los valores estándar del Plan de Entrenamiento (Plan de Entrenamiento: "4 series con rango de 8-12 repeticiones"). Todo módulo usa 4 series y 8-12 reps. El COALESCE solo activa cuando `plan_assignment` no tiene fila para el ejercicio sustituido, lo cual es correcto: un sustituto no prescrito hereda los parámetros estándar.

  - **`updateExerciseId(sessionExerciseId: Long, newExerciseId: Long, originalExerciseId: Long)`** (Nuevo): `@Query` UPDATE suspend. Ejecuta la sustitución atómica en `session_exercise`.

    ```sql
    UPDATE session_exercise
    SET exercise_id = :newExerciseId,
        original_exercise_id = :originalExerciseId
    WHERE id = :sessionExerciseId
    ```

    **¿Por qué UPDATE directo y no `@Update` de Room?** El `@Update` de Room actualiza TODAS las columnas de la entity. Con `@Query` UPDATE controlamos exactamente qué columnas cambian, evitando sobrescribir accidentalmente `progression_classification` u otros campos que no deben modificarse durante la sustitución.

  - **`getExerciseIdsForSession(sessionId: Long): List<Long>`** (Nuevo): `@Query` suspend. Retorna los IDs de los ejercicios actualmente en la sesión, para excluirlos de la lista de sustitutos (CA-07.01).

    ```sql
    SELECT exercise_id FROM session_exercise WHERE session_id = :sessionId
    ```

  - **`getSessionExerciseForSubstitution(sessionExerciseId: Long): SessionExerciseForSubstitution?`** (Nuevo): `@Query` suspend. Obtiene datos del `session_exercise` individual necesarios para validar y ejecutar la sustitución.

    ```sql
    SELECT
        se.id,
        se.session_id AS sessionId,
        se.exercise_id AS exerciseId,
        se.original_exercise_id AS originalExerciseId,
        e.name AS exerciseName,
        e.module_code AS moduleCode,
        (SELECT COUNT(*) FROM exercise_set es WHERE es.session_exercise_id = se.id) AS completedSets
    FROM session_exercise se
    INNER JOIN exercise e ON se.exercise_id = e.id
    WHERE se.id = :sessionExerciseId
    ```

  - **`SessionExerciseForSubstitution`**: Data class intermedia (no `@Entity`), definida en `SessionExerciseDao.kt` (mismo patrón de `SessionExerciseWithDetails` y `SetExerciseInfo`). Campos: `id: Long`, `sessionId: Long`, `exerciseId: Long`, `originalExerciseId: Long?`, `exerciseName: String`, `moduleCode: String`, `completedSets: Int`.

- **`ExerciseDao`** (Modificación Menor):

  - **`getByModuleCodeNotInIds(moduleCode: String, excludedExerciseIds: List<Long>): Flow<List<ExerciseWithDetails>>`** (Nuevo): Query para la lista de sustitutos elegibles (CA-07.01). Filtra por módulo y excluye los ejercicios ya en la sesión activa.

    ```sql
    SELECT
        e.id,
        e.name,
        e.module_code AS moduleCode,
        m.name AS moduleName,
        et.name AS equipmentTypeName,
        e.is_bodyweight AS isBodyweight,
        e.is_isometric AS isIsometric,
        e.is_to_technical_failure AS isToTechnicalFailure,
        e.is_custom AS isCustom,
        e.media_resource AS mediaResource,
        GROUP_CONCAT(mz.name, ', ') AS muscleZones
    FROM exercise e
    INNER JOIN module m ON e.module_code = m.code
    INNER JOIN equipment_type et ON e.equipment_type_id = et.id
    LEFT JOIN exercise_muscle_zone emz ON e.id = emz.exercise_id
    LEFT JOIN muscle_zone mz ON emz.muscle_zone_id = mz.id
    WHERE e.module_code = :moduleCode
      AND e.id NOT IN (:excludedExerciseIds)
    GROUP BY e.id
    ORDER BY e.name ASC
    ```

    **¿Por qué no reusar `getByModuleCodeNotInVersion()`?** Ese método excluye ejercicios del `plan_assignment` para un `module_version_id`. HU-07 necesita excluir los ejercicios **actualmente en la sesión** (que podrían incluir sustitutos de otra versión). La semántica de exclusión es diferente: por sesión vs. por plan.

    **¿Por qué `Flow` y no `suspend`?** Mantiene consistencia con los otros queries de `ExerciseDao` que retornan `Flow<List<ExerciseWithDetails>>` (`getAll()`, `getById()`, `getByModuleCodeNotInVersion()`). Aunque la lista es una consulta puntual (E3 se abre, se carga y se cierra), usar `Flow` permite que si se agregan ejercicios custom en el futuro desde otra pantalla, la lista se actualice reactivamente (hipótesis de bajo costo técnico vs. alto valor de consistencia con el patrón establecido).

#### 2. Domain Layer — Modelo Nuevo

Paquete: `domain.model`.

- **`SubstituteExerciseInfo`**: Data class que encapsula la información necesaria para inicializar E3.
  - `sessionExerciseId: Long` — ID del ejercicio-en-sesión a sustituir.
  - `currentExerciseId: Long` — ID del ejercicio actual (el que se va a reemplazar).
  - `currentExerciseName: String` — Nombre mostrado en el subtítulo de E3 ("Reemplazar: [nombre]").
  - `moduleCode: String` — Código del módulo de la sesión. Usado para filtrar sustitutos por módulo (CA-07.02).
  - `sessionId: Long` — ID de la sesión activa. Usado para obtener los `exercise_ids` a excluir.

#### 3. Domain Layer — Repository Interfaces (Modificaciones)

Paquete: `domain.repository`.

- **`SessionRepository`** (Modificación): Agregar 3 métodos al contrato existente.

  - `suspend fun getSubstituteExerciseInfo(sessionExerciseId: Long): SubstituteExerciseInfo?` — Obtiene la información necesaria para inicializar E3. Retorna `null` si `sessionExerciseId` no existe o si el ejercicio ya tiene series registradas (`completedSets > 0`). Método `suspend` (no Flow) porque es una consulta one-shot al abrir E3.

  - `suspend fun getExerciseIdsForSession(sessionId: Long): List<Long>` — Retorna los `exercise_id` actualmente asignados a la sesión. Usado para construir la lista de exclusión de E3.

  - `suspend fun substituteExercise(sessionExerciseId: Long, newExerciseId: Long)` — Ejecuta la sustitución atómica. Lanza `IllegalStateException` si el ejercicio ya tiene series registradas (defensa en profundidad, CA-07.06).

- **`ExerciseRepository`** (Modificación): Agregar 1 método al contrato existente.

  - `fun getEligibleSubstitutes(moduleCode: String, excludedExerciseIds: List<Long>): Flow<List<Exercise>>` — Retorna la lista de ejercicios del módulo excluyendo los ya presentes en la sesión. El mapeo de `ExerciseWithDetails` → `Exercise` se realiza en el repository impl (patrón existente en `getAllExercises()`).

#### 4. Domain Layer — Use Case Nuevo

Paquete: `domain.usecase.session`.

- **`SubstituteExerciseUseCase`** (Nuevo): Delega la sustitución al repository.

  ```kotlin
  class SubstituteExerciseUseCase @Inject constructor(
      private val sessionRepository: SessionRepository,
  ) {
      suspend operator fun invoke(sessionExerciseId: Long, newExerciseId: Long) {
          sessionRepository.substituteExercise(sessionExerciseId, newExerciseId)
      }
  }
  ```

  **¿Por qué no hay `GetSubstituteExerciseInfoUseCase`?** El ViewModel necesita coordinar 3 operaciones secuenciales: (1) obtener info del ejercicio, (2) obtener IDs de la sesión, (3) cargar sustitutos. Crear un UseCase que coordine los 3 repos (Session + Exercise) violaría el principio de responsabilidad única del UseCase (que debe ser un wrapper fino de una operación de negocio atómica). El ViewModel inyecta directamente los 2 repositories para estas operaciones de lectura, y usa `SubstituteExerciseUseCase` para la operación de escritura. Este patrón es consistente con `ActiveSessionViewModel` (que inyecta `SessionRepository` directamente para `getSessionModuleVersion()`) y `RegisterSetViewModel` (que inyecta UseCase solo para las operaciones de negocio).

#### 5. Data Layer — Repository Implementations (Modificaciones)

Paquete: `data.repository`.

- **`SessionRepositoryImpl`** (Modificación): Implementar los 3 nuevos métodos. No requiere inyección de DAOs adicionales — `sessionExerciseDao`, `exerciseSetDao` y `database` ya están inyectados.

  - `getSubstituteExerciseInfo(sessionExerciseId: Long): SubstituteExerciseInfo?`:
    1. Consulta `sessionExerciseDao.getSessionExerciseForSubstitution(sessionExerciseId)`. Si `null` → retorna `null`.
    2. Si `info.completedSets > 0` → retorna `null` (ejercicio con series, no sustituible; CA-07.06).
    3. Mapea a `SubstituteExerciseInfo(sessionExerciseId, info.exerciseId, info.exerciseName, info.moduleCode, info.sessionId)`.

  - `getExerciseIdsForSession(sessionId: Long): List<Long>`:
    Delega a `sessionExerciseDao.getExerciseIdsForSession(sessionId)`.

  - `substituteExercise(sessionExerciseId: Long, newExerciseId: Long)`:
    Ejecuta en `database.withTransaction {}`:
    1. `val info = sessionExerciseDao.getSessionExerciseForSubstitution(sessionExerciseId)`. Si `null` → `IllegalStateException("Session exercise not found")`.
    2. Valida `info.completedSets == 0`. Si no → `IllegalStateException("Cannot substitute exercise with registered sets")`.
    3. Determina `originalExerciseId`:
       - Si `info.originalExerciseId != null` → usa `info.originalExerciseId` (ya fue sustituido antes; preserva el original del plan).
       - Si `info.originalExerciseId == null` → usa `info.exerciseId` (primera sustitución; el actual ES el del plan).
    4. Ejecuta `sessionExerciseDao.updateExerciseId(sessionExerciseId, newExerciseId, originalExerciseId)`.

    **¿Por qué transacción?** Los pasos 1-4 deben ser atómicos para evitar que entre la validación de `completedSets` y el UPDATE, se registre una serie por otra corrutina (defensa ante race condition teórica).

    **Nota sobre sustitución doble:** CA-07 no prohíbe sustituir un ejercicio que ya fue sustituido (siempre que tenga 0 series). Si el ejecutante sustituye A→B y luego B→C, `original_exercise_id` debe seguir siendo A (el del plan original), no B. El paso 3 garantiza esto.

- **`ExerciseRepositoryImpl`** (Modificación): Implementar 1 nuevo método.

  - `getEligibleSubstitutes(moduleCode: String, excludedExerciseIds: List<Long>): Flow<List<Exercise>>`:
    Delega a `exerciseDao.getByModuleCodeNotInIds(moduleCode, excludedExerciseIds)` y mapea `ExerciseWithDetails` → `Exercise` con el mismo patrón de `getAllExercises()`.

#### 6. UI Layer — Estado y ViewModel

Paquete: `ui.session`.

- **`SubstituteExerciseUiState`** (Nuevo — definido dentro de `SubstituteExerciseViewModel.kt`): Data class de estado reactivo del formulario E3.

  ```kotlin
  data class SubstituteExerciseUiState(
      val isLoading: Boolean = true,
      val originalExerciseName: String = "",
      val eligibleExercises: List<SubstituteExerciseUiItem> = emptyList(),
      val selectedExercise: SubstituteExerciseUiItem? = null,
      val showConfirmDialog: Boolean = false,
      val isSubstituting: Boolean = false,
  )

  data class SubstituteExerciseUiItem(
      val exerciseId: Long,
      val name: String,
      val muscleZones: String,
      val equipmentTypeName: String,
  )
  ```

  **Campo `isSubstituting`:** Protección anti-double-tap. Mientras la transacción de sustitución está en curso, el botón "Confirmar" del diálogo se deshabilita.

- **`SubstituteExerciseViewModel`** (Nuevo): `@HiltViewModel`. Gestiona el ciclo de vida de E3.

  - **Inyecta:** `SubstituteExerciseUseCase`, `SessionRepository`, `ExerciseRepository`, `SavedStateHandle`.
  - **Session exercise ID:** `savedStateHandle.get<Long>("sessionExerciseId")` — extraído del argumento de navegación.
  - **Estado:** `MutableStateFlow<SubstituteExerciseUiState>` → `StateFlow<SubstituteExerciseUiState>`.
  - **Evento de navegación:** `MutableSharedFlow<Boolean>(replay = 0)` → la UI observa con `LaunchedEffect` y navega back al emitir `true`.

  - **`init`:** En `viewModelScope.launch`:
    1. `val info = sessionRepository.getSubstituteExerciseInfo(sessionExerciseId)`. Si `null` → permanece en loading (E3 no debería alcanzarse con ID inválido o ejercicio con series).
    2. `val excludedIds = sessionRepository.getExerciseIdsForSession(info.sessionId)`.
    3. Observa `exerciseRepository.getEligibleSubstitutes(info.moduleCode, excludedIds).collect { exercises -> ... }`. Mapea `Exercise` → `SubstituteExerciseUiItem(exerciseId, name, muscleZones.joinToString(", "), equipmentTypeName)`. Se usa coma como separador entre zonas musculares (consistente con `ActiveSessionViewModel`, `ExerciseDictionaryViewModel`, `PlanVersionDetailViewModel`); el separador ` · ` se usa solo al concatenar zonas con tipo de equipo en el `supportingContent` de E3.
    4. Actualiza estado: `isLoading = false`, `originalExerciseName = info.currentExerciseName`, `eligibleExercises = mappedList`.

  - **`onExerciseSelected(exercise: SubstituteExerciseUiItem)`:** Actualiza `selectedExercise = exercise`, `showConfirmDialog = true`.

  - **`onDismissDialog()`:** Actualiza `showConfirmDialog = false`, `selectedExercise = null`.

  - **`onConfirmSubstitution()`:** Ejecuta en `viewModelScope.launch`:
    1. Si `selectedExercise == null` → retorna (defensa).
    2. Marca `isSubstituting = true`.
    3. `try { substituteExerciseUseCase(sessionExerciseId, selectedExercise.exerciseId) }`.
    4. Si éxito: emite `true` en `navigateBack` SharedFlow.
    5. Si `IllegalStateException`: emite `true` igualmente (graceful: ejercicio ya tiene series, retorna a E1).
    6. `finally { isSubstituting = false }`.

#### 7. UI Layer — Pantalla E3

Paquete: `ui.session`.

- **`SubstituteExerciseScreen`** (Nuevo): Composable que implementa la vista E3 según Wireframes E3 y Especificación Visual §8 E3.

  Firma:
  ```kotlin
  @Composable
  fun SubstituteExerciseScreen(
      onNavigateBack: () -> Unit,
      viewModel: SubstituteExerciseViewModel = hiltViewModel(),
  )
  ```

  **Estructura de layout:**

  - **Top Bar:** `CenterAlignedTopAppBar` (M3).
    - `navigationIcon`: `IconButton` con `Icons.Default.Close` (✕), tint `On Surface`. `onClick = onNavigateBack` (cancela sin sustituir).
    - `title`: `Column` con:
      - `Text` "Sustituir ejercicio" — `Title Large`.
      - `Text` "Reemplazar: [nombre]" — `Title Small`, `On Surface Variant`.

  - **Body:** `Column` con padding 16 dp.
    - **Texto informativo:** `Column` con 2 textos:
      - "Selecciona un ejercicio del mismo módulo como reemplazo." — `Body Medium`, `On Surface Variant`.
      - "La sustitución es puntual y no modifica el Plan." — `Body Medium`, `On Surface Variant`.
      - Spacer 16 dp.

    - **Lista de ejercicios elegibles:** `LazyColumn`.
      - Cada fila: `ListItem` M3 (64 dp).
        - `headlineContent`: `Text` nombre — `Title Medium`, `On Surface`.
        - `supportingContent`: `Text` "zona(s) muscular(es) · tipo equipo" — `Body Medium`, `On Surface Variant`.
        - `clickable` → `viewModel.onExerciseSelected(exercise)`.
      - `Divider` M3 entre filas: 1 dp, `Outline Variant`.

    - **TextButton "Cancelar":** Color `Primary`. Margin top 16 dp. `onClick = onNavigateBack`.

  - **Diálogo de confirmación:** `AlertDialog` M3. Condicional: solo visible cuando `uiState.showConfirmDialog == true`.
    - `title`: "¿Sustituir [original] por [sustituto]?" — `Title Medium`.
    - `text`: "Esta sustitución es solo para esta sesión." — `Body Medium`.
    - `confirmButton`: `Button` "Confirmar" con `containerColor = Primary`. `enabled = !uiState.isSubstituting`. `onClick = viewModel.onConfirmSubstitution()`.
    - `dismissButton`: `TextButton` "Cancelar". `onClick = viewModel.onDismissDialog()`.
    - Corner: 28 dp.

  - **Sin Bottom Navigation** (Arquitectura Técnica §4.5.1: E3 siempre oculta).

  - **Navegación de retorno:** `LaunchedEffect` que observa `viewModel.navigateBack` SharedFlow y llama a `onNavigateBack()` cuando emite `true`. Esto garantiza que la navegación ocurra después de la persistencia exitosa.

#### 8. Navegación (Modificaciones)

Paquete: `ui.navigation`.

- **`NavigationRoutes`** (Modificación Menor): Agregar ruta E3.
  - `const val SUBSTITUTE_EXERCISE = "substitute-exercise/{sessionExerciseId}"` (Arquitectura Técnica §4.3 ruta #11).
  - `fun substituteExerciseRoute(sessionExerciseId: Long) = "substitute-exercise/$sessionExerciseId"`.

- **`TensionNavHost`** (Modificación): 3 cambios.
  - **Wiring del callback** en `ACTIVE_SESSION`: reemplazar `onNavigateToSubstitute = { /* TODO: HU-07 */ }` por:
    ```kotlin
    onNavigateToSubstitute = { sessionExerciseId ->
        navController.navigate(NavigationRoutes.substituteExerciseRoute(sessionExerciseId))
    }
    ```
  - **Nuevo composable entry:** `composable(route = NavigationRoutes.SUBSTITUTE_EXERCISE, arguments = listOf(navArgument("sessionExerciseId") { type = NavType.LongType }))` que monta `SubstituteExerciseScreen(onNavigateBack = { navController.popBackStack() })`.

  - **`showBottomBar` exclusión:** Agregar `&& !currentRoute.startsWith("substitute-exercise")` a la condición existente.

#### 9. Recursos

Archivo: `app/src/main/res/values/strings.xml`.

- Agregar ~8 strings para E3:
  ```xml
  <!-- Substitute Exercise E3 -->
  <string name="substitute_exercise_title">Sustituir ejercicio</string>
  <string name="substitute_exercise_subtitle_format">Reemplazar: %1$s</string>
  <string name="substitute_exercise_info_line1">Selecciona un ejercicio del mismo módulo como reemplazo.</string>
  <string name="substitute_exercise_info_line2">La sustitución es puntual y no modifica el Plan.</string>
  <string name="substitute_exercise_dialog_title_format">¿Sustituir %1$s por %2$s?</string>
  <string name="substitute_exercise_dialog_text">Esta sustitución es solo para esta sesión.</string>
  <string name="substitute_exercise_confirm">Confirmar</string>
  <string name="substitute_exercise_cancel">Cancelar</string>
  ```

### Validación de Impacto

**Código verificado antes de proponer (paso 1.5):**

| Archivo | Estado verificado | Hallazgo |
|---|---|---|
| `SessionExerciseEntity.kt` | Completa con `original_exercise_id: Long? = null` (FK nullable) | ✅ Columna ya existe desde HU-05. No se necesita migración |
| `SessionExerciseDao.kt` | `getBySessionIdWithDetails()` usa INNER JOIN a `plan_assignment` | ⚠️ Bug: ejercicio sustituido desaparecería de E1. Se corrige a LEFT JOIN + COALESCE |
| `SessionExerciseDao.kt` | `SetExerciseInfo` y `SessionExerciseWithDetails` como data classes | ✅ Patrón establecido para `SessionExerciseForSubstitution` |
| `ExerciseDao.kt` | `getByModuleCodeNotInVersion()` existe como patrón de referencia | ✅ `getByModuleCodeNotInIds()` sigue el mismo patrón pero con semántica de exclusión diferente |
| `SessionRepositoryImpl.kt` | Inyecta 7 DAOs + database (8 params). 206 líneas | ✅ No requiere DAOs adicionales |
| `ExerciseRepositoryImpl.kt` | Mapeo `ExerciseWithDetails → Exercise` establecido en `getAllExercises()` | ✅ Reusar patrón para `getEligibleSubstitutes()` |
| `SessionRepository.kt` | 8 métodos actuales | ✅ Se agregan 3 |
| `ExerciseRepository.kt` | 8 métodos actuales | ✅ Se agrega 1 |
| `NavigationRoutes.kt` | 15 rutas + 5 helpers, sin `SUBSTITUTE_EXERCISE` | ✅ Se agrega |
| `TensionNavHost.kt` | `onNavigateToSubstitute = { /* TODO: HU-07 */ }` | ✅ Stub confirmado. Se reemplaza con navegación real |
| `TensionNavHost.kt` — `showBottomBar` | Excluye `active-session`, `register-set`, `exercise-detail` desde sesión | ⚠️ No excluye `substitute-exercise`. Se agrega |
| `ActiveSessionScreen.kt` | Botón "Sustituir" solo en `NotStartedExerciseRow`. `onSubstitute` callback recibe `sessionExerciseId` | ✅ CA-07.06 ya cumplido por diseño de E1. No se necesita cambio en E1 |
| `strings.xml` | Sin strings de E3 | ✅ Se agregan 8 strings |

**Impacto en el Flow reactivo de E1:** Al hacer UPDATE en `session_exercise` (cambiar `exercise_id`), Room invalida automáticamente el query `getBySessionIdWithDetails()`. El Flow re-emite la lista actualizada y el ejercicio sustituido aparece con su nuevo nombre, equipo, zonas musculares, etc. La card se re-renderiza en estado "No Iniciado" (0 series, como debe ser post-sustitución). No se requiere ningún refresh manual.

**Impacto en E2 (RegisterSetScreen):** E2 usa `getExerciseInfoForSet()` que busca por `se.id` (sessionExerciseId), no por `exercise_id`. Tras la sustitución, el `exercise_id` cambió pero el `sessionExerciseId` sigue siendo el mismo. E2 funciona correctamente sin cambios: el JOIN a `exercise` retorna los datos del nuevo ejercicio (sustituto) y el LEFT JOIN a `plan_assignment` con COALESCE (ya implementado en HU-06) retorna defaults si el sustituto no está en el plan.

**Impacto en `getLastWeightForExercise()` (HU-06):** Esta query busca el último peso por `exercise_id`. Tras sustituir A→B, E2 busca el historial de B (el sustituto). Si B fue usado antes en otra sesión, precarga su último peso. Si es la primera vez que se usa B, el campo queda vacío (`null`). Esto es correcto por diseño (CA-06.04: "último peso utilizado" para ese ejercicio específico).

### Notas Técnicas

1. **CA-07.01 (lista de sustitutos) se resuelve con query por módulo + exclusión por sesión.** La query `getByModuleCodeNotInIds()` filtra por `module_code` (CA-07.02) y excluye los `exercise_id` actualmente en la sesión (no los del plan). Esto incluye ejercicios de CUALQUIER versión del módulo y ejercicios custom del ejecutante (CA-07.01: "disponibles en cualquier versión del módulo").

2. **CA-07.03 y CA-07.04 (sustitución puntual) se cumplen por diseño.** La sustitución solo modifica `session_exercise` (tabla de runtime). `plan_assignment` (tabla del plan) permanece intacta. `startSession()` (HU-05) crea `session_exercise` desde `plan_assignment` — no consulta sustituciones de sesiones anteriores.

3. **CA-07.05 (sustitución de ejercicio no iniciado) se implementa como UPDATE.** `session_exercise.exercise_id = newExerciseId`, `session_exercise.original_exercise_id = currentExerciseId`. Las series registradas posteriormente se vincularán al nuevo `exercise_id` porque se insertan referenciando `session_exercise_id` (que no cambió), y `session_exercise.exercise_id` ahora apunta al sustituto.

4. **CA-07.06 (restricción con series registradas) se cumple en 3 capas.**
   - **UI (capa 1):** El botón "Sustituir" solo aparece en `NotStartedExerciseRow` (implementado en HU-05). No existe en `InProgressExerciseRow` ni `CompletedExerciseRow`.
   - **Repository (capa 2):** `getSubstituteExerciseInfo()` retorna `null` si `completedSets > 0`. E3 no se abre.
   - **Transacción (capa 3):** `substituteExercise()` valida `completedSets == 0` dentro de la transacción. Defensa ante race condition teórica.

5. **Sustitución doble (A→B→C).** CA-07 no prohíbe sustituir un ejercicio ya sustituido. Si el ejecutante sustituye A por B, y luego B por C (sin haber registrado series de B), `original_exercise_id` debe preservar A (el del plan original). El paso 3 del repositorio implementa esta lógica: `if (info.originalExerciseId != null) use it; else use info.exerciseId`.

6. **UNIQUE constraint `(session_id, exercise_id)`.** Tras sustituir, el nuevo `exercise_id` no puede ser uno que ya esté en la sesión. La exclusión en la lista de E3 (`getExerciseIdsForSession()`) previene que el ejecutante seleccione un ejercicio ya presente. Si por algún error se intentara, el UNIQUE constraint de la BD actuaría como safety net y la transacción fallaría con error (no hay datos corruptos).

7. **Relación con HU-06 (query de E2).** El LEFT JOIN en `getExerciseInfoForSet()` con `COALESCE(pa.sets, 4)` ya fue implementado en HU-06. Un ejercicio sustituido funciona correctamente en E2 sin cambios: la query busca por `session_exercise_id`, obtiene el nuevo `exercise_id` del sustituto, y si no está en `plan_assignment`, COALESCE proporciona defaults (4 series).

8. **Relación con HU-24 (historial de sesiones).** Cuando F2 muestre el detalle de una sesión pasada, el `session_exercise.exercise_id` apuntará al sustituto y `session_exercise.original_exercise_id` al ejercicio del plan. Esto permite mostrar "Sustituyó a: [original]" (CA-24.04). No se requiere acción en HU-07 — HU-24 consultará estos campos en su implementación.

### Referencias y Validación

**Documentación consultada:**

- Modelo de Datos (§3.11 `session_exercise`) — Columnas `exercise_id`, `original_exercise_id`, validación de integridad a nivel de aplicación
- Wireframes E3 — Selección de Ejercicio Sustituto (lista, diálogo, comportamiento)
- Especificación Visual §8 E3 — Componentes M3: ListItem 64 dp, AlertDialog 28 dp corner, estilos de texto
- Mapa de Navegación §5 (E3) — Flujo E1→E3→E1 (confirm/cancel)
- Arquitectura Técnica §4.3 (ruta #11: `substitute-exercise/{sessionExerciseId}`) y §4.5.1 (Bottom Nav oculta en E3) y §4.6 (Top Bar: Center Aligned con cierre)
- ADR (D-02: sustitución solo con "No Iniciado")
- Requerimientos: RF16
- Manifiesto de Dominio Sistémico §4 — Sustitución de Ejercicio: "temporal y no modifica el Plan de Entrenamiento original"
- Plan de Entrenamiento — Defaults (4 series, 8-12 reps) para COALESCE

**Historias relacionadas:**

- HU-03: Crear ejercicio — CA-03.10: un ejercicio custom creado por el ejecutante "queda disponible en las sustituciones de sesión (HU-07)". La query `getByModuleCodeNotInIds()` incluye ejercicios custom (`is_custom = 1`) del mismo módulo sin exclusión.
- HU-05: Determinar e iniciar sesión — Creó `SessionExerciseEntity` con `original_exercise_id`. Creó E1 con callbacks `onNavigateToSubstitute`. Botón "Sustituir" solo en `NotStartedExerciseRow`.
- HU-06: Registrar series — `getExerciseInfoForSet()` ya usa LEFT JOIN + COALESCE. `getLastWeightForExercise()` busca por `exercise_id` del sustituto, retornando historial correcto.
- HU-08: Ejercicios de peso corporal e isométricos — Un ejercicio sustituto puede ser bodyweight o isométrico. E2 (HU-06) ya maneja las 3 variantes, por lo que la sustitución no requiere lógica adicional para estos tipos.
- HU-09: Cerrar sesión — `session_exercise.exercise_id` apunta al ejercicio efectivamente ejecutado (sustituto). El cierre de sesión y cálculo de progresión operan sobre los datos reales. No se requiere lógica condicional para sustituciones.
- HU-10: Clasificación de progresión — Compara datos de `exercise_set` del sustituto con historial previo **del sustituto** (no del original). Si el sustituto no tiene historial, CA-10.07 aplica: "Sin Historial", no se emite clasificación.
- HU-23: Historial de ejercicio — CA-23.03: "un ejercicio puede haber sido ejecutado como sustitución → incluye todos los registros independientemente del módulo-versión". La query de historial busca por `exercise_id` (el sustituto), consolidando datos de todas las sesiones donde fue usado (como prescrito o como sustituto). No requiere lógica especial — `session_exercise.exercise_id` ya apunta al ejercicio real.
- HU-24: Historial de sesiones pasadas — Usará `session_exercise.original_exercise_id` para mostrar "Sustituyó a: [original]" (CA-24.04). Los datos están disponibles desde HU-07.

**Validado por:** esteban.colorado | **Fecha:** 2026-02-14 | **Enfoque:** Exploratorio

---

### Hitos de implementación

| # | Entregable | Dependencia |
|---|---|---|
| 1 | Data Layer — DAOs: `SessionExerciseDao` (fix query E1 + 3 nuevos métodos + `SessionExerciseForSubstitution`), `ExerciseDao` (+`getByModuleCodeNotInIds`) | — |
| 2 | Domain — Model: `SubstituteExerciseInfo` | — |
| 3 | Domain — Repository Interfaces: `SessionRepository` (+3 métodos), `ExerciseRepository` (+1 método) | Hito 2 |
| 4 | Domain — Use Case: `SubstituteExerciseUseCase` | Hito 3 |
| 5 | Data — Repository Impls: `SessionRepositoryImpl` (+3 métodos), `ExerciseRepositoryImpl` (+1 método) | Hito 1, 3 |
| 6 | UI — ViewModel: `SubstituteExerciseViewModel` (+ `SubstituteExerciseUiState`, `SubstituteExerciseUiItem`) | Hito 4 |
| 7 | UI — Screen: `SubstituteExerciseScreen` (E3 completo con lista + diálogo) | Hito 6 |
| 8 | Navegación: `NavigationRoutes` (+SUBSTITUTE_EXERCISE), `TensionNavHost` (wiring E1→E3 + showBottomBar exclusión) | Hito 7 |
| 9 | Recursos: `strings.xml` (~8 strings E3) | — (independiente) |

### Notas de auditoría

1. **CA-07.01 (lista de sustitutos elegibles) se resuelve con query por módulo + exclusión.** `WHERE module_code = :moduleCode AND id NOT IN (sessionExerciseIds)`. Incluye ejercicios de cualquier versión y custom (seed + runtime). CA validado contra Wireframes E3 #5 y Especificación Visual §8 E3.
2. **CA-07.02 (restricción al mismo módulo) se cumple con `WHERE module_code = :moduleCode`.** La `moduleCode` se obtiene del JOIN `exercise e ON se.exercise_id = e.id` → `e.module_code`. El módulo del ejercicio actual y el módulo de la sesión son siempre el mismo (la sesión es de un `module_version`, y todos los ejercicios del plan pertenecen a ese módulo).
3. **CA-07.03 y CA-07.04 (sustitución puntual, sin efecto en futuro) se cumplen por arquitectura.** `session_exercise` = runtime. `plan_assignment` = plan estable. `startSession()` siempre crea desde `plan_assignment`.
4. **CA-07.05 (reemplazo efectivo) se cumple con UPDATE atómico.** `exercise_id = newExerciseId`. Series futuras se vincularán al nuevo ejercicio via `session_exercise_id`.
5. **CA-07.06 (bloqueo con series registradas) se cumple en 3 capas.** UI: botón solo en `NotStartedExerciseRow`. Repository: `completedSets > 0 → null`. Transacción: validación final atómica.
6. **RF16 (sustitución puntual sin modificar plan) cubierto integralmente.** La sustitución modifica solo `session_exercise`, no `plan_assignment`. El botón "Sustituir" está condicionado a estado "No Iniciado". La lista filtra por módulo y excluye prescritos en la sesión.

### Riesgos y mitigaciones

| Riesgo | Probabilidad | Impacto | Mitigación |
|---|---|---|---|
| Ejercicio sustituido desaparece de E1 (INNER JOIN bug) | Segura sin fix | Bloqueante | Fix obligatorio: INNER JOIN → LEFT JOIN + COALESCE en `getBySessionIdWithDetails()` |
| Race condition: registro de serie entre validación y UPDATE | Muy baja | Alto | `database.withTransaction {}` serializa. UI: botón "Sustituir" solo en estado "No Iniciado" |
| UNIQUE constraint violation al sustituir por ejercicio ya en sesión | Nula (por diseño) | Alto | Lista de E3 excluye `exerciseIds` de la sesión. UNIQUE constraint como safety net |
| Sustitución doble pierde `original_exercise_id` | Media sin lógica | Medio | Paso 3 del repository: `if (info.originalExerciseId != null) use it` preserva el original del plan |
| Lista de sustitutos vacía (ningún ejercicio elegible) | Baja | Bajo | E3 muestra lista vacía. El ejecutante cancela y vuelve a E1. No se requiere manejo especial |
| `COALESCE(pa.reps, '8-12')` no coincide con reps del ejercicio real | Nula en MVP | Bajo | Todos los ejercicios del plan usan '8-12'. En futuro, si se agregan rangos diferentes, el COALESCE se ajustará |

### Verificación cruzada de CAs

| CA | Mecanismo de cumplimiento | Verificado contra |
|---|---|---|
| CA-07.01 | Query `getByModuleCodeNotInIds()`: filtra por módulo, excluye IDs de la sesión | Wireframes E3 #5, Especificación Visual §8 E3, RF16 |
| CA-07.02 | `WHERE module_code = :moduleCode` en la query de sustitutos | MDS §4 "mismo módulo" |
| CA-07.03 | UPDATE solo en `session_exercise` (runtime). `plan_assignment` intacto | MDS §4 "no modifica el Plan de Entrenamiento original" |
| CA-07.04 | `startSession()` (HU-05) crea desde `plan_assignment`, no consulta sustituciones | Modelo de Datos §3.11 |
| CA-07.05 | `updateExerciseId()` cambia `exercise_id` + registra `original_exercise_id` | Modelo de Datos §3.11 columnas |
| CA-07.06 | 3 capas: UI (botón condicional), Repository (`completedSets == 0`), Transacción (validación atómica) | ADR D-02, Modelo de Datos §3.11 validación |

---

## Refinamiento Técnico (Developer)

<!-- SECCIÓN AGREGADA POR: Workflow refinamiento-tecnico -->
<!-- ETAPA: Refinamiento Técnico -->
<!-- RESPONSABLE: Developer -->
<!-- BASE: Análisis Arquitectónico (Arquitecto) - Ver sección arriba -->
<!-- FECHA: 2026-02-14 -->
<!-- ESTADO: Listo para Desarrollo -->
<!-- AUDITORÍA: Completada 2026-02-14 — Auditoría exhaustiva: cruce archivo-por-archivo contra código implementado (HU-01 a HU-06), documentación de arquitectura, y análisis del arquitecto.

DIMENSIONES AUDITADAS (7):
- A. Código implementado: 13 archivos verificados contra claims del arquitecto. 11/13 TRUE, 2 correcciones menores (line count, param description).
- B. Modelo de Datos §3.11 (session_exercise): original_exercise_id nullable, UNIQUE(session_id, exercise_id), FK RESTRICT — todo confirmado.
- C. Especificación Visual §8 E3: Componentes M3 (CenterAlignedTopAppBar, ListItem 64dp, AlertDialog 28dp corner, Divider 1dp) — todo correcto.
- D. Wireframes E3: 7/7 elementos + diálogo confirmación + cancelar — todo cubierto.
- E. Arquitectura Técnica §4.3(#11)/§4.5/§4.6: Ruta substitute-exercise/{sessionExerciseId}, Bottom Nav oculta, Top Bar Center Aligned con cierre — todo correcto.
- F. Mapa de Navegación: E1→E3 (Sustituir), E3→E1 (confirmar/cancelar) — todo correcto.
- G. Cross-check HUs: HU-03 (CA-03.10 custom en sustituciones), HU-05 (original_exercise_id, NotStartedExerciseRow), HU-06 (LEFT JOIN ya implementado en getExerciseInfoForSet), HU-08/HU-09/HU-10/HU-23/HU-24 — impacto documentado.

CORRECCIONES APLICADAS (2 LOW → auditoría inicial + 2 LOW → auditoría profunda):
(L1) "206 líneas" en SessionRepositoryImpl corregido a "225 líneas" (actual post-HU-06).
(L2) "inyecta 7 DAOs + database (8 params)" verificado: sessionDao, sessionExerciseDao, planAssignmentDao, rotationStateDao, moduleVersionDao, exerciseSetDao, exerciseProgressionDao + database = 8 params (7 DAOs + TensionDatabase). Correcto.
(L3) "117 líneas" en ExerciseRepositoryImpl corregido a "106 líneas" (actual post-HU-06).
(L4) "§4.5.1" (Bottom Navigation) corregido a "§4.5" — el heading real en Arquitectura Técnica es "4.5. Bottom Navigation Bar" (sin subsección .1).

AUDITORÍA PROFUNDA (2026-02-14):
Scope: 7 docs arquitectura + 5 docs business + 32 HUs + 13 archivos de código.
Docs cruzados: Modelo de Datos §3.4/§3.7/§3.11/§3.12/§4, Arquitectura Técnica §4.3/§4.5/§4.6/§5.7, Especificación Visual §8 E3, Wireframes E3, Mapa de Navegación §E3, ADR D-02, Requerimientos RF16, MDS §4.
HUs cruzadas (10 con referencias): HU-03 (CA-03.10 custom→sustituciones ✅), HU-05 (original_exercise_id, NotStartedExerciseRow, TODO stub, showBottomBar — 14 refs ✅), HU-06 (LEFT JOIN + COALESCE, CA-06.11 — 8 refs ✅), HU-08 (variantes ejercicio ✅), HU-09 (cierre sesión ✅), HU-10 (CA-10.07 Sin Historial ✅), HU-23 (CA-23.03 historial independiente ✅), HU-24 (CA-24.04 sustituciones en historial ✅).
Código verificado: SessionExerciseDao.kt (query INNER JOIN confirmado, 2 data classes), ExerciseDao.kt (getByModuleCodeNotInVersion como patrón), SessionRepository.kt (8 métodos), ExerciseRepository.kt (8 métodos), SessionRepositoryImpl.kt (226 líneas, 8 params, throw pattern), ExerciseRepositoryImpl.kt (106 líneas, toDomainModel()), NavigationRoutes.kt (15 const + 5 helpers), TensionNavHost.kt (TODO HU-07, showBottomBar sin E3), ActiveSessionScreen.kt (onNavigateToSubstitute, NotStartedExerciseRow), strings.xml (session_substitute existe, Register Set E2 comment).
Discrepancia doc INFO: Especificación Visual tabla genérica "Lista de ejercicios (catálogo)" dice 3 líneas para E3, pero tabla específica E3 dice 2 líneas (ListItem 64dp). E3 spec específica prevalece → refinamiento correcto.

RESULTADO FINAL: 0 HIGH, 0 MEDIUM, 4 LOW corregidas. -->

### Consideraciones Generales

**Basado en análisis arquitectónico:**
Análisis Arquitectónico de HU-07 con 9 hitos, 4 archivos nuevos + 9 archivos modificados, 6 riesgos identificados. Patrón MVVM con capa Domain explícita (ADR-05). Séptima historia — introduce la pantalla E3 (Selección de Ejercicio Sustituto) con flujo lista + diálogo de confirmación + UPDATE atómico. Hallazgo crítico: bug en query `getBySessionIdWithDetails()` (INNER JOIN a `plan_assignment` rompe con ejercicios sustituidos) — se corrige obligatoriamente con LEFT JOIN + COALESCE.

**Nivel de complejidad:**
BAJA-MEDIA — No introduce entidades nuevas (`session_exercise` ya tiene `original_exercise_id` desde HU-05). Modifica 2 DAOs existentes (+4 métodos), extiende 2 Repository interfaces (+4 métodos), crea 1 modelo de dominio, 1 Use Case (wrapper fino), 1 pantalla E3 con ViewModel y UiState, 1 ruta de navegación, y ~8 strings. La complejidad reside en: (a) la corrección del bug crítico en el query de E1, (b) la lógica de preservación de `original_exercise_id` ante sustituciones dobles, y (c) la transacción atómica con validación de `completedSets`.

**Riesgos técnicos conocidos:**

1. **Ejercicio sustituido desaparece de E1** (bug INNER JOIN) — Fix obligatorio: INNER JOIN → LEFT JOIN + COALESCE en `getBySessionIdWithDetails()`. Probabilidad: segura sin fix. Impacto: bloqueante.
2. **Race condition: registro de serie entre validación y UPDATE** — `database.withTransaction {}` serializa. UI: botón "Sustituir" solo visible en estado "No Iniciado". Probabilidad: muy baja.
3. **Sustitución doble pierde `original_exercise_id`** — Lógica en repository: `if (info.originalExerciseId != null) use it` preserva el original del plan. Probabilidad: media sin la lógica.
4. **UNIQUE constraint violation al sustituir por ejercicio ya en sesión** — Lista de E3 excluye `exerciseIds` de la sesión. UNIQUE `(session_id, exercise_id)` como safety net.
5. **Lista de sustitutos vacía** — E3 muestra lista vacía. El ejecutante cancela y vuelve a E1. No requiere manejo especial.

**Patrones y convenciones del equipo (establecidos en HU-01—HU-06):**

- Código fuente en inglés, UI y datos de dominio en español (Arquitectura Técnica §5.1)
- Mensajes de validación de dominio (`require()`, `IllegalStateException`) en inglés (§5.7)
- Naming: `{Feature}Screen`, `{Feature}ViewModel`, `{Acción}{Entidad}UseCase`, `{Entidad}Entity`, `{Entidad}Dao` (§5.2)
- Estructura Composable: `hiltViewModel()` + `collectAsStateWithLifecycle()` + `LaunchedEffect` para eventos oneshot (§5.3)
- Estructura ViewModel: `_uiState MutableStateFlow` / `uiState StateFlow` + `MutableSharedFlow` para eventos de navegación (§5.4)
- `operator fun invoke()` en Use Cases
- Callbacks en Composables con prefijo `on` (`onNavigateBack`)
- Data classes intermedias de query en archivos DAO (patrón `SessionExerciseWithDetails`, `SetExerciseInfo`)
- Separador de zonas musculares: `, ` (coma + espacio) internamente, ` · ` (interpunto) en UI display

**Dependencias nuevas a instalar:**
Ninguna — todos los frameworks ya están en el proyecto.

**Estrategia de testing:**
JUnit 4 + MockK + kotlinx-coroutines-test | Tests unitarios para Use Case y lógica de Repository | Cobertura: todos los CAs cubiertos por tests | Builders: mock directo, sin Test Data Builders (patrón existente en RegisterSetUseCaseTest, StartSessionUseCaseTest)

### Historias Relacionadas Consultadas

**Implementaciones similares analizadas:**

- HU-06 (RegisterSet) — Patrón ViewModel con `SavedStateHandle`, `MutableSharedFlow` para navegación back, `viewModelScope.launch`, transacción atómica en repository.
- HU-05 (ActiveSession) — Creó `session_exercise` con `original_exercise_id`. E1 con callbacks `onNavigateToSubstitute`. Botón "Sustituir" solo en `NotStartedExerciseRow`.
- HU-03 (CreateExercise) — Patrón de lista filtrada con `Flow<List<Exercise>>`, mapeo `ExerciseWithDetails → Exercise`.
- HU-04 (PlanVersionDetail) — Patrón de query de ejercicios por módulo con exclusión (`getByModuleCodeNotInVersion`).

**Patrones de código reutilizados:**

- HU-06 `database.withTransaction {}` en `SessionRepositoryImpl.registerSet()` → reutilizado en `SessionRepositoryImpl.substituteExercise()`
- HU-06 `SavedStateHandle` en `RegisterSetViewModel` → reutilizado en `SubstituteExerciseViewModel`
- HU-06 `MutableSharedFlow<Boolean>(replay = 0)` para evento oneshot de navegación back → reutilizado
- HU-06 Data class intermedia en DAO (`SetExerciseInfo`) → patrón reutilizado para `SessionExerciseForSubstitution`
- HU-06 `showBottomBar` exclusión por prefijo `"register-set"` → se extiende para prefijo `"substitute-exercise"`
- `ExerciseRepositoryImpl.toDomainModel()` conversión `ExerciseWithDetails → Exercise` → reutilizado en `getEligibleSubstitutes()`
- `ExerciseDao.getByModuleCodeNotInVersion()` → patrón de referencia para `getByModuleCodeNotInIds()` (diferente semántica de exclusión)

**Mejores prácticas aplicadas:**

- Transacción atómica para operaciones de escritura multi-paso (validación + update)
- Validación en 3 capas para CA-07.06: UI (botón condicional) → Repository (`completedSets == 0` → `null`) → Transacción (validación atómica final)
- LEFT JOIN + COALESCE para tolerancia a ejercicios fuera de `plan_assignment` (sustitutos, futuros ejercicios custom)
- Preservación de `original_exercise_id` ante sustituciones dobles (A→B→C mantiene A como original)

### Código existente verificado (HU-01 a HU-06 implementados)

| Componente | Archivo | Estado |
| --- | --- | --- |
| `SessionExerciseDao` | `data/local/dao/SessionExerciseDao.kt` | ✅ Existe — `insertAll()`, `getBySessionId()`, `getBySessionIdWithDetails()`, `getExerciseInfoForSet()`. Se modifica: fix query E1 (INNER→LEFT JOIN) + 3 nuevos métodos + 1 data class |
| `SessionExerciseEntity` | `data/local/entity/SessionExerciseEntity.kt` | ✅ Existe — `original_exercise_id: Long? = null`, UNIQUE `(session_id, exercise_id)`, FK RESTRICT a `exercise`. No se modifica |
| `ExerciseDao` | `data/local/dao/ExerciseDao.kt` | ✅ Existe — `getAll()`, `getById()`, `getByModuleCodeNotInVersion()`, `insertAll()`, `insert()`, etc. Se modifica: +1 método (`getByModuleCodeNotInIds`) |
| `ExerciseWithDetails` | `data/local/dao/ExerciseDao.kt` | ✅ Existe — data class con 11 campos (id, name, moduleCode, moduleName, equipmentTypeName, isBodyweight, isIsometric, isToTechnicalFailure, isCustom, mediaResource, muscleZones). Reutilizable |
| `SessionRepository` | `domain/repository/SessionRepository.kt` | ✅ Existe — 8 métodos actuales. Se modifica: +3 métodos |
| `ExerciseRepository` | `domain/repository/ExerciseRepository.kt` | ✅ Existe — 8 métodos actuales. Se modifica: +1 método |
| `SessionRepositoryImpl` | `data/repository/SessionRepositoryImpl.kt` | ✅ Existe — 225 líneas, 8 parámetros inyectados (7 DAOs + TensionDatabase). No requiere DAOs adicionales — `sessionExerciseDao`, `database` ya inyectados |
| `ExerciseRepositoryImpl` | `data/repository/ExerciseRepositoryImpl.kt` | ✅ Existe — 106 líneas, 4 DAOs inyectados. Se modifica: +1 método. Reutiliza `toDomainModel()` privado |
| `NavigationRoutes` | `ui/navigation/NavigationRoutes.kt` | ✅ Existe — 15 constantes + 5 helpers (post-HU-06). Se modifica: +1 constante + 1 helper |
| `TensionNavHost` | `ui/navigation/TensionNavHost.kt` | ✅ Existe — `onNavigateToSubstitute = { /* TODO: HU-07 */ }` confirmado. Se modifica: wiring callback + nuevo composable entry + extensión showBottomBar |
| `ActiveSessionScreen` | `ui/session/ActiveSessionScreen.kt` | ✅ Existe — botón "Sustituir" solo en `NotStartedExerciseRow`, pasa `exercise.sessionExerciseId` via `onNavigateToSubstitute`. No se modifica |
| `RepositoryModule` | `di/RepositoryModule.kt` | ✅ Existe — `bindSessionRepository()` y `bindExerciseRepository()` ya existen. No se modifica |
| `strings.xml` | `res/values/strings.xml` | ✅ Existe — string `session_substitute` = "Sustituir" ya existe. Sin strings E3. Se modifica: +8 strings |

**HUs futuras que dependen de artefactos de HU-07:**

- HU-09: Cerrar sesión → `session_exercise.exercise_id` apunta al sustituto. Cierre opera sobre datos reales sin lógica condicional
- HU-10: Clasificación progresión → compara datos del sustituto con historial del sustituto (no del original). Sin historial → "Sin Historial" (CA-10.07)
- HU-23: Historial de ejercicio → CA-23.03: consolida registros del ejercicio independientemente de si fue prescrito o sustituto
- HU-24: Historial de sesiones → `session_exercise.original_exercise_id` permite mostrar "Sustituyó a: [original]" (CA-24.04)

---

## Tareas de Implementación (Developer)

### Fase 1: Data Layer — DAOs (2 modificaciones + 1 bug fix)

> Basado en Hito #1 del Análisis Arquitectónico

- [ ] **Fix query `getBySessionIdWithDetails()` en SessionExerciseDao** (AC: 07.05, 07.03) — **BUG FIX CRÍTICO**
  - [ ] Cambiar `INNER JOIN plan_assignment pa` → `LEFT JOIN plan_assignment pa` en la query existente.
  - [ ] Cambiar `pa.sets,` → `COALESCE(pa.sets, 4) AS sets,` en el SELECT.
  - [ ] Cambiar `pa.reps,` → `COALESCE(pa.reps, '8-12') AS reps,` en el SELECT.
  - [ ] Justificación: Un ejercicio sustituido tiene un `exercise_id` que NO está en `plan_assignment` para el `module_version_id` actual. Sin este fix, el ejercicio sustituido desaparece de E1.
  - [ ] Defaults `4` y `'8-12'` son los valores estándar del Plan de Entrenamiento (Plan de Entrenamiento: "4 series con rango de 8-12 repeticiones").
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/data/local/dao/SessionExerciseDao.kt`

- [ ] **Agregar `SessionExerciseForSubstitution` data class + 3 nuevos métodos a SessionExerciseDao** (AC: 07.01, 07.05, 07.06)
  - [ ] **Definir `SessionExerciseForSubstitution`** como data class fuera de la interfaz (mismo patrón `SessionExerciseWithDetails`, `SetExerciseInfo`): `id: Long`, `sessionId: Long`, `exerciseId: Long`, `originalExerciseId: Long?`, `exerciseName: String`, `moduleCode: String`, `completedSets: Int`.
  - [ ] `@Query suspend fun getSessionExerciseForSubstitution(sessionExerciseId: Long): SessionExerciseForSubstitution?`:
    ```sql
    SELECT
        se.id,
        se.session_id AS sessionId,
        se.exercise_id AS exerciseId,
        se.original_exercise_id AS originalExerciseId,
        e.name AS exerciseName,
        e.module_code AS moduleCode,
        (SELECT COUNT(*) FROM exercise_set es WHERE es.session_exercise_id = se.id) AS completedSets
    FROM session_exercise se
    INNER JOIN exercise e ON se.exercise_id = e.id
    WHERE se.id = :sessionExerciseId
    ```
    Obtiene datos necesarios para validar y ejecutar la sustitución. `completedSets` determina si es sustituible (CA-07.06).
  - [ ] `@Query suspend fun getExerciseIdsForSession(sessionId: Long): List<Long>`:
    ```sql
    SELECT exercise_id FROM session_exercise WHERE session_id = :sessionId
    ```
    Retorna IDs de ejercicios actualmente en la sesión, para excluirlos de la lista de sustitutos (CA-07.01).
  - [ ] `@Query UPDATE suspend fun updateExerciseId(sessionExerciseId: Long, newExerciseId: Long, originalExerciseId: Long)`:
    ```sql
    UPDATE session_exercise
    SET exercise_id = :newExerciseId,
        original_exercise_id = :originalExerciseId
    WHERE id = :sessionExerciseId
    ```
    UPDATE selectivo — no usa `@Update` de Room para evitar sobrescribir `progression_classification`.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/data/local/dao/SessionExerciseDao.kt`

- [ ] **Agregar `getByModuleCodeNotInIds()` a ExerciseDao** (AC: 07.01, 07.02)
  - [ ] `@Query fun getByModuleCodeNotInIds(moduleCode: String, excludedExerciseIds: List<Long>): Flow<List<ExerciseWithDetails>>`:
    ```sql
    SELECT
        e.id,
        e.name,
        e.module_code AS moduleCode,
        m.name AS moduleName,
        et.name AS equipmentTypeName,
        e.is_bodyweight AS isBodyweight,
        e.is_isometric AS isIsometric,
        e.is_to_technical_failure AS isToTechnicalFailure,
        e.is_custom AS isCustom,
        e.media_resource AS mediaResource,
        GROUP_CONCAT(mz.name, ', ') AS muscleZones
    FROM exercise e
    INNER JOIN module m ON e.module_code = m.code
    INNER JOIN equipment_type et ON e.equipment_type_id = et.id
    LEFT JOIN exercise_muscle_zone emz ON e.id = emz.exercise_id
    LEFT JOIN muscle_zone mz ON emz.muscle_zone_id = mz.id
    WHERE e.module_code = :moduleCode
      AND e.id NOT IN (:excludedExerciseIds)
    GROUP BY e.id
    ORDER BY e.name ASC
    ```
    Reutiliza la estructura exacta de `getByModuleCodeNotInVersion()` pero con semántica de exclusión diferente: por IDs de sesión vs por plan. Retorna `Flow` por consistencia con el patrón del DAO. Incluye ejercicios custom (`is_custom = 1`) del mismo módulo (CA-03.10, CA-07.01).
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/data/local/dao/ExerciseDao.kt`

### Fase 2: Domain Layer — Model y Use Case

> Basado en Hitos #2, #3 y #4 del Análisis Arquitectónico

- [ ] **Crear `SubstituteExerciseInfo`** (AC: 07.01, 07.02, 07.05)
  - [ ] Data class: `sessionExerciseId: Long`, `currentExerciseId: Long`, `currentExerciseName: String`, `moduleCode: String`, `sessionId: Long`. Encapsula info necesaria para inicializar E3.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/domain/model/SubstituteExerciseInfo.kt`

- [ ] **Agregar 3 métodos a `SessionRepository`** (AC: 07.05, 07.06)
  - [ ] `suspend fun getSubstituteExerciseInfo(sessionExerciseId: Long): SubstituteExerciseInfo?`
  - [ ] `suspend fun getExerciseIdsForSession(sessionId: Long): List<Long>`
  - [ ] `suspend fun substituteExercise(sessionExerciseId: Long, newExerciseId: Long)`
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/domain/repository/SessionRepository.kt`

- [ ] **Agregar 1 método a `ExerciseRepository`** (AC: 07.01)
  - [ ] `fun getEligibleSubstitutes(moduleCode: String, excludedExerciseIds: List<Long>): Flow<List<Exercise>>`
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/domain/repository/ExerciseRepository.kt`

- [ ] **Crear `SubstituteExerciseUseCase`** (AC: 07.05, 07.06)
  - [ ] Inyecta `SessionRepository`. `suspend operator fun invoke(sessionExerciseId: Long, newExerciseId: Long)`. Wrapper fino que delega a `sessionRepository.substituteExercise(sessionExerciseId, newExerciseId)`.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/domain/usecase/session/SubstituteExerciseUseCase.kt`
  - [ ] Test unitario: verifica delegación caso exitoso, propaga `IllegalStateException` del repository. Archivo: `app/src/test/java/com/estebancoloradogonzalez/tension/domain/usecase/session/SubstituteExerciseUseCaseTest.kt`

### Fase 3: Data Layer — Repository Implementations

> Basado en Hito #5 del Análisis Arquitectónico

- [ ] **Agregar 3 métodos a `SessionRepositoryImpl`** (AC: 07.05, 07.06)
  - [ ] `getSubstituteExerciseInfo(sessionExerciseId: Long): SubstituteExerciseInfo?`:
    1. `val info = sessionExerciseDao.getSessionExerciseForSubstitution(sessionExerciseId)`. Si `null` → retorna `null`.
    2. Si `info.completedSets > 0` → retorna `null` (CA-07.06).
    3. Mapea a `SubstituteExerciseInfo(sessionExerciseId, info.exerciseId, info.exerciseName, info.moduleCode, info.sessionId)`.
  - [ ] `getExerciseIdsForSession(sessionId: Long): List<Long>`:
    Delega a `sessionExerciseDao.getExerciseIdsForSession(sessionId)`.
  - [ ] `substituteExercise(sessionExerciseId: Long, newExerciseId: Long)`:
    Ejecuta en `database.withTransaction {}`:
    1. `val info = sessionExerciseDao.getSessionExerciseForSubstitution(sessionExerciseId)`. Si `null` → `throw IllegalStateException("Session exercise not found")`.
    2. Valida `info.completedSets == 0`. Si no → `throw IllegalStateException("Cannot substitute exercise with registered sets")`.
    3. `val originalExerciseId = info.originalExerciseId ?: info.exerciseId` — Preserva el original del plan ante sustituciones dobles (A→B→C mantiene A).
    4. `sessionExerciseDao.updateExerciseId(sessionExerciseId, newExerciseId, originalExerciseId)`.
    Mensajes de error en inglés per Arquitectura Técnica §5.7.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/data/repository/SessionRepositoryImpl.kt`

- [ ] **Agregar 1 método a `ExerciseRepositoryImpl`** (AC: 07.01)
  - [ ] `getEligibleSubstitutes(moduleCode: String, excludedExerciseIds: List<Long>): Flow<List<Exercise>>`:
    Delega a `exerciseDao.getByModuleCodeNotInIds(moduleCode, excludedExerciseIds)` y mapea con `toDomainModel()` existente.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/data/repository/ExerciseRepositoryImpl.kt`

### Fase 4: UI Layer — ViewModel y UiState

> Basado en Hito #6 del Análisis Arquitectónico

- [ ] **Crear `SubstituteExerciseViewModel`** (AC: 07.01, 07.02, 07.05, 07.06)
  - [ ] Definir `SubstituteExerciseUiState` dentro del archivo:
    ```kotlin
    data class SubstituteExerciseUiState(
        val isLoading: Boolean = true,
        val originalExerciseName: String = "",
        val eligibleExercises: List<SubstituteExerciseUiItem> = emptyList(),
        val selectedExercise: SubstituteExerciseUiItem? = null,
        val showConfirmDialog: Boolean = false,
        val isSubstituting: Boolean = false,
    )

    data class SubstituteExerciseUiItem(
        val exerciseId: Long,
        val name: String,
        val muscleZones: String,
        val equipmentTypeName: String,
    )
    ```
  - [ ] `@HiltViewModel`. Inyecta: `SubstituteExerciseUseCase`, `SessionRepository`, `ExerciseRepository`, `SavedStateHandle`.
  - [ ] `sessionExerciseId` extraído de `savedStateHandle.get<Long>("sessionExerciseId")`.
  - [ ] `_uiState: MutableStateFlow<SubstituteExerciseUiState>` → `uiState: StateFlow`.
  - [ ] `navigateBack: MutableSharedFlow<Boolean>(replay = 0)` — evento oneshot.
  - [ ] **`init`:** En `viewModelScope.launch`:
    1. `val info = sessionRepository.getSubstituteExerciseInfo(sessionExerciseId)`. Si `null` → emite `navigateBack(true)` (graceful exit).
    2. `val excludedIds = sessionRepository.getExerciseIdsForSession(info.sessionId)`.
    3. Observa `exerciseRepository.getEligibleSubstitutes(info.moduleCode, excludedIds).collect { exercises -> ... }`. Mapea `Exercise` → `SubstituteExerciseUiItem(exerciseId = it.id, name = it.name, muscleZones = it.muscleZones.joinToString(", "), equipmentTypeName = it.equipmentTypeName)`.
    4. Actualiza estado: `isLoading = false`, `originalExerciseName = info.currentExerciseName`, `eligibleExercises = mappedList`.
  - [ ] **`onExerciseSelected(exercise: SubstituteExerciseUiItem)`:** Actualiza `selectedExercise = exercise`, `showConfirmDialog = true`.
  - [ ] **`onDismissDialog()`:** Actualiza `showConfirmDialog = false`, `selectedExercise = null`.
  - [ ] **`onConfirmSubstitution()`:** En `viewModelScope.launch`:
    1. Si `selectedExercise == null` || `uiState.value.isSubstituting` → retorna.
    2. `_uiState.update { it.copy(isSubstituting = true) }`.
    3. `try { substituteExerciseUseCase(sessionExerciseId, selectedExercise!!.exerciseId) }`.
    4. Éxito → emite `navigateBack.emit(true)`.
    5. `IllegalStateException` → emite `navigateBack.emit(true)` (graceful: ejercicio ya tiene series, retorna a E1).
    6. `finally { _uiState.update { it.copy(isSubstituting = false) } }`.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/ui/session/SubstituteExerciseViewModel.kt`

### Fase 5: UI Layer — Pantalla E3

> Basado en Hito #7 del Análisis Arquitectónico

- [ ] **Crear `SubstituteExerciseScreen`** (AC: 07.01, 07.02, 07.05, 07.06)
  - [ ] Firma: `@Composable fun SubstituteExerciseScreen(onNavigateBack: () -> Unit, viewModel: SubstituteExerciseViewModel = hiltViewModel())`.
  - [ ] Observar `viewModel.uiState` con `collectAsStateWithLifecycle()`.
  - [ ] `LaunchedEffect` que observa `viewModel.navigateBack` SharedFlow y llama a `onNavigateBack()`.
  - [ ] **Top Bar:** `CenterAlignedTopAppBar` M3.
    - `navigationIcon`: `IconButton` con `Icons.Default.Close`, `onClick = onNavigateBack`.
    - `title`: `Column` → `Text` "Sustituir ejercicio" (`Title Large`) + `Text` "Reemplazar: [nombre]" (`Title Small`, `On Surface Variant`). Usar strings de `strings.xml`.
  - [ ] **Body:** `Column` con padding 16 dp.
    - Texto informativo: 2 líneas `Body Medium`, `On Surface Variant`. Línea 1: "Selecciona un ejercicio del mismo módulo como reemplazo." Línea 2: "La sustitución es puntual y no modifica el Plan." `Spacer(16.dp)`.
    - **`LazyColumn`:** Lista de ejercicios elegibles.
      - Cada fila: `ListItem` M3 (min height 64 dp).
        - `headlineContent`: `Text` nombre (`Title Medium`, `On Surface`).
        - `supportingContent`: `Text` "zona(s) · equipo" (`Body Medium`, `On Surface Variant`). Separador ` · ` entre zonas y equipo.
        - `Modifier.clickable { viewModel.onExerciseSelected(exercise) }`.
      - `HorizontalDivider` M3 entre filas: 1 dp, `Outline Variant`.
    - **`TextButton`** "Cancelar": Color `Primary`. Margin top 16 dp. `onClick = onNavigateBack`.
  - [ ] **Diálogo de confirmación:** `AlertDialog` M3, visible cuando `uiState.showConfirmDialog == true`.
    - `title`: "¿Sustituir [original] por [sustituto]?" (`Title Medium`). Usar format string.
    - `text`: "Esta sustitución es solo para esta sesión." (`Body Medium`).
    - `confirmButton`: `Button` "Confirmar", `containerColor = Primary`, `enabled = !uiState.isSubstituting`, `onClick = viewModel::onConfirmSubstitution`.
    - `dismissButton`: `TextButton` "Cancelar", `onClick = viewModel::onDismissDialog`.
    - Corner: 28 dp.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/ui/session/SubstituteExerciseScreen.kt`

### Fase 6: Navegación

> Basado en Hito #8 del Análisis Arquitectónico

- [ ] **Modificar `NavigationRoutes`** (AC: 07.05)
  - [ ] Agregar constante: `const val SUBSTITUTE_EXERCISE = "substitute-exercise/{sessionExerciseId}"`.
  - [ ] Agregar helper: `fun substituteExerciseRoute(sessionExerciseId: Long) = "substitute-exercise/$sessionExerciseId"`.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/ui/navigation/NavigationRoutes.kt`

- [ ] **Modificar `TensionNavHost`** — 3 cambios (AC: 07.05, 07.06)
  - [ ] **Wiring callback E1→E3:** Reemplazar `onNavigateToSubstitute = { /* TODO: HU-07 */ }` por:
    ```kotlin
    onNavigateToSubstitute = { sessionExerciseId ->
        navController.navigate(NavigationRoutes.substituteExerciseRoute(sessionExerciseId))
    }
    ```
  - [ ] **Nuevo composable entry para E3:**
    ```kotlin
    composable(
        route = NavigationRoutes.SUBSTITUTE_EXERCISE,
        arguments = listOf(navArgument("sessionExerciseId") { type = NavType.LongType }),
    ) {
        SubstituteExerciseScreen(onNavigateBack = { navController.popBackStack() })
    }
    ```
  - [ ] **Extensión `showBottomBar`:** Agregar `&& !currentRoute.startsWith("substitute-exercise")` a la condición existente.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/ui/navigation/TensionNavHost.kt`

### Fase 7: Recursos

> Basado en Hito #9 del Análisis Arquitectónico

- [ ] **Agregar ~8 strings para E3 a `strings.xml`**
  - [ ] Insertar después del bloque `<!-- Register Set E2 -->`:
    ```xml
    <!-- Substitute Exercise E3 -->
    <string name="substitute_exercise_title">Sustituir ejercicio</string>
    <string name="substitute_exercise_subtitle_format">Reemplazar: %1$s</string>
    <string name="substitute_exercise_info_line1">Selecciona un ejercicio del mismo módulo como reemplazo.</string>
    <string name="substitute_exercise_info_line2">La sustitución es puntual y no modifica el Plan.</string>
    <string name="substitute_exercise_dialog_title_format">¿Sustituir %1$s por %2$s?</string>
    <string name="substitute_exercise_dialog_text">Esta sustitución es solo para esta sesión.</string>
    <string name="substitute_exercise_confirm">Confirmar</string>
    <string name="substitute_exercise_cancel">Cancelar</string>
    ```
  - Archivo: `app/src/main/res/values/strings.xml`

### Fase N: QA y Deployment

- [ ] **Ejecutar Agente Peer Review** (MANUAL)
- [ ] **Resolver incidentes del Peer Review** (MANUAL, condicional)
- [ ] **Crear Pull Request** (MANUAL)
- [ ] **Ejecutar pipeline deployment DEV** (MANUAL)
- [ ] **Diseñar set de pruebas manuales** (MANUAL)
- [ ] **Ejecutar pruebas manuales** (MANUAL)

---

**Notas sobre vinculación con Criterios de Aceptación:**

- CA-07.01 → Fases 1, 2, 3, 4, 5 (`ExerciseDao.getByModuleCodeNotInIds()` filtra por módulo + excluye IDs sesión → `SubstituteExerciseViewModel.init` carga lista → `SubstituteExerciseScreen` LazyColumn)
- CA-07.02 → Fase 1 (`WHERE module_code = :moduleCode` en query de sustitutos)
- CA-07.03 → Fase 3 (`substituteExercise()` solo hace UPDATE en `session_exercise`, `plan_assignment` intacto)
- CA-07.04 → Sin trabajo en HU-07 (ya implementado en HU-05: `startSession()` crea desde `plan_assignment`, no consulta sustituciones)
- CA-07.05 → Fases 1, 3, 4, 5, 6 (`updateExerciseId()` + `SubstituteExerciseUseCase` + ViewModel + E3 Screen + NavigationRoutes wiring)
- CA-07.06 → Fases 1, 3, 4, 5 (3 capas: UI `NotStartedExerciseRow` ya implementado en HU-05 + Repository `completedSets > 0 → null` + Transacción `completedSets == 0` validación atómica)
