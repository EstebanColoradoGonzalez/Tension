# HU-15 â€” AnalÃ­tica y KPIs del Entrenamiento

## Requisitos relacionados

RF42, RF44, RF45, RF46, RF47, RF48, RF49, RF52

## DescripciÃ³n

Como ejecutante, quiero que el sistema calcule y presente un panel de analÃ­tica completo con mÃ©tricas de rendimiento por ejercicio (Tasa de ProgresiÃ³n y Velocidad de Carga), volumen por grupo muscular (Tonelaje Acumulado y DistribuciÃ³n), intensidad y adherencia (RIR Promedio por MÃ³dulo e Ãndice de Adherencia Semanal), tendencias de progresiÃ³n por grupo muscular a lo largo de mÃºltiples microciclos, y la evoluciÃ³n temporal del tonelaje, para entender objetivamente cÃ³mo voy, identificar desequilibrios entre grupos musculares, validar que mi intensidad estÃ¡ en la zona Ã³ptima, y tomar decisiones de programaciÃ³n informadas a nivel macro.

## Historias originales consolidadas

Esta historia consolida las siguientes historias del diseÃ±o original, que comparten la misma secciÃ³n de navegaciÃ³n, los mismos datos fuente y la misma estructura de cÃ¡lculo-presentaciÃ³n:

- **HU-19 original** â€” Calcular KPIs de rendimiento por ejercicio (RF44, RF48)
- **HU-20 original** â€” Calcular KPIs de volumen por grupo muscular (RF45, RF49)
- **HU-21 original** â€” Calcular KPIs de intensidad y adherencia (RF46, RF47)
- **HU-22 original** â€” Monitorear tendencia de progresiÃ³n por grupo muscular (RF42)
- **HU-25 original** â€” Consultar evoluciÃ³n de tonelaje por grupo muscular (RF52)

---

## Criterios de AceptaciÃ³n

### Bloque A â€” KPIs de Rendimiento por Ejercicio (RF44, RF48)

#### CA-15.01 â€” CÃ¡lculo de la Tasa de ProgresiÃ³n por Ejercicio

**Dado que** un ejercicio tiene historial de mÃºltiples sesiones registradas,
**cuando** el sistema calcula la Tasa de ProgresiÃ³n,
**entonces** aplica la fÃ³rmula: (Sesiones con progresiÃ³n positiva / Total de sesiones del ejercicio) Ã— 100, expresando el resultado como porcentaje.

#### CA-15.02 â€” PerÃ­odo de evaluaciÃ³n configurable con valor por defecto

**Dado que** el sistema calcula la Tasa de ProgresiÃ³n de un ejercicio,
**cuando** determina el rango temporal de evaluaciÃ³n,
**entonces** utiliza por defecto un perÃ­odo de 4 semanas, pero permite configurar perÃ­odos alternativos para el anÃ¡lisis.

#### CA-15.03 â€” CÃ¡lculo de la Velocidad de ProgresiÃ³n de Carga

**Dado que** un ejercicio tiene historial con al menos 2 sesiones registradas donde se utilizÃ³ carga (Peso > 0),
**cuando** el sistema calcula la Velocidad de ProgresiÃ³n de Carga,
**entonces** aplica la fÃ³rmula: (Peso actual âˆ’ Peso inicial) / NÃºmero de sesiones intermedias, expresando el resultado en Kg por sesiÃ³n.

#### CA-15.04 â€” Velocidad de ProgresiÃ³n para ejercicios sin incremento

**Dado que** un ejercicio tiene historial pero no ha incrementado carga (Peso actual = Peso inicial),
**cuando** el sistema calcula la Velocidad de ProgresiÃ³n de Carga,
**entonces** el resultado es 0 Kg/sesiÃ³n, confirmando numÃ©ricamente una meseta activa en carga.

#### CA-15.05 â€” Ejercicios de peso corporal excluidos de Velocidad de Carga

**Dado que** un ejercicio es de peso corporal (Peso = 0 Kg),
**cuando** el sistema calcula KPIs de rendimiento,
**entonces** calcula la Tasa de ProgresiÃ³n normalmente pero no calcula la Velocidad de ProgresiÃ³n de Carga (no aplica ya que no hay variaciÃ³n de peso).

#### CA-15.06 â€” PresentaciÃ³n de KPIs de rendimiento al ejecutante

**Dado que** el sistema ha calculado los KPIs de rendimiento para un ejercicio,
**cuando** el ejecutante consulta las mÃ©tricas del ejercicio,
**entonces** muestra la Tasa de ProgresiÃ³n (%) y la Velocidad de ProgresiÃ³n de Carga (Kg/sesiÃ³n) de forma clara con el perÃ­odo de evaluaciÃ³n utilizado.

### Bloque B â€” KPIs de Volumen por Grupo Muscular (RF45, RF49)

#### CA-15.07 â€” CÃ¡lculo del Tonelaje Acumulado por Grupo Muscular

**Dado que** un microciclo incluye sesiones con ejercicios registrados,
**cuando** el sistema calcula el Tonelaje Acumulado por Grupo Muscular,
**entonces** suma el producto de Peso Ã— Repeticiones de todas las series de todos los ejercicios que trabajan cada grupo muscular dentro del microciclo, expresando el resultado en kilogramos por grupo muscular.

#### CA-15.08 â€” AgrupaciÃ³n por zona muscular del Diccionario

**Dado que** el sistema calcula el tonelaje por grupo muscular,
**cuando** asocia cada ejercicio a su grupo muscular,
**entonces** utiliza la clasificaciÃ³n de zona muscular definida en el Diccionario de Ejercicios como fuente de verdad, respetando que un ejercicio puede trabajar mÃºltiples zonas musculares (ej: Sentadilla BÃºlgara = CuÃ¡driceps + GlÃºteos).

#### CA-15.09 â€” Ejercicios con mÃºltiples zonas musculares

**Dado que** un ejercicio trabaja mÃºltiples zonas musculares segÃºn el Diccionario,
**cuando** el sistema calcula el tonelaje acumulado,
**entonces** contabiliza el tonelaje de ese ejercicio en cada una de las zonas musculares asociadas.

#### CA-15.10 â€” CÃ¡lculo de la DistribuciÃ³n de Volumen por Zona Muscular

**Dado que** un microciclo tiene sesiones registradas para un mÃ³dulo,
**cuando** el sistema calcula la DistribuciÃ³n de Volumen por Zona Muscular,
**entonces** calcula el porcentaje de series totales de cada zona muscular respecto al total de series del mÃ³dulo, expresando el resultado como porcentaje por zona.

#### CA-15.11 â€” CÃ¡lculo por microciclo completado

**Dado que** el sistema calcula KPIs de volumen,
**cuando** determina el alcance temporal del cÃ¡lculo,
**entonces** lo calcula por microciclo completado, asociando los resultados al nÃºmero de microciclo correspondiente para permitir comparaciÃ³n entre microciclos.

#### CA-15.12 â€” PresentaciÃ³n de KPIs de volumen al ejecutante

**Dado que** el sistema ha calculado los KPIs de volumen,
**cuando** el ejecutante consulta las mÃ©tricas de volumen,
**entonces** muestra el Tonelaje Acumulado desglosado por grupo muscular y la DistribuciÃ³n de Volumen (%) por zona muscular, ambos referenciados al microciclo consultado.

### Bloque C â€” KPIs de Intensidad y Adherencia (RF46, RF47)

#### CA-15.13 â€” CÃ¡lculo del RIR Promedio por MÃ³dulo

**Dado que** un mÃ³dulo tiene sesiones registradas en un perÃ­odo dado,
**cuando** el sistema calcula el RIR Promedio por MÃ³dulo,
**entonces** promedia aritmÃ©ticamente todos los valores de RIR registrados en todas las series de todas las sesiones del mÃ³dulo en el perÃ­odo, expresando el resultado con un decimal.

#### CA-15.14 â€” PerÃ­odo de evaluaciÃ³n del RIR Promedio

**Dado que** el sistema calcula el RIR Promedio por MÃ³dulo,
**cuando** determina el rango temporal,
**entonces** evalÃºa por defecto las Ãºltimas 2 ejecuciones del mismo mÃ³dulo, permitiendo al ejecutante consultar perÃ­odos mÃ¡s amplios.

#### CA-15.15 â€” InterpretaciÃ³n del RIR Promedio

**Dado que** el sistema muestra el RIR Promedio de un mÃ³dulo al ejecutante,
**cuando** presenta el resultado,
**entonces** incluye una referencia de interpretaciÃ³n: RIR 2-3 = zona Ã³ptima, RIR < 1.5 = demasiado cerca del fallo (riesgo de fatiga del SNC), RIR > 3.5 = estÃ­mulo posiblemente insuficiente.

#### CA-15.16 â€” CÃ¡lculo del Ãndice de Adherencia Semanal

**Dado que** una semana natural ha transcurrido,
**cuando** el sistema calcula el Ãndice de Adherencia semanal,
**entonces** aplica la fÃ³rmula: (Sesiones completadas en la semana / Sesiones planificadas) Ã— 100, donde "sesiones planificadas" es el objetivo de frecuencia del ejecutante (entre 4 y 6), expresando el resultado como porcentaje.

#### CA-15.17 â€” Objetivo de frecuencia del ejecutante

**Dado que** el sistema calcula el Ãndice de Adherencia,
**cuando** necesita el denominador (sesiones planificadas),
**entonces** utiliza el objetivo de frecuencia definido por el ejecutante en su perfil, aceptando valores entre 4 y 6 sesiones semanales.

#### CA-15.18 â€” Sesiones contabilizadas para adherencia

**Dado que** el sistema calcula las sesiones completadas en la semana,
**cuando** contabiliza sesiones,
**entonces** incluye sesiones cerradas tanto como Completadas como Incompletas, ya que ambos tipos representan asistencia al gimnasio y ambos avanzan la rotaciÃ³n.

#### CA-15.19 â€” PresentaciÃ³n de KPIs de intensidad y adherencia al ejecutante

**Dado que** el sistema ha calculado los KPIs de intensidad y adherencia,
**cuando** el ejecutante consulta las mÃ©tricas,
**entonces** muestra el RIR Promedio por MÃ³dulo (para cada mÃ³dulo A, B, C) y el Ãndice de Adherencia semanal con el perÃ­odo evaluado y la referencia de interpretaciÃ³n.

### Bloque D â€” Tendencia de ProgresiÃ³n por Grupo Muscular (RF42)

#### CA-15.20 â€” EvaluaciÃ³n de tendencia por grupo muscular

**Dado que** el ejecutante tiene al menos 4 microciclos completados,
**cuando** el sistema evalÃºa la tendencia de progresiÃ³n de un grupo muscular,
**entonces** analiza la trayectoria del tonelaje acumulado y la tasa de progresiÃ³n de los ejercicios asociados al grupo muscular a lo largo de los Ãºltimos 4 a 6 microciclos.

#### CA-15.21 â€” ClasificaciÃ³n de la tendencia

**Dado que** el sistema analiza la tendencia de un grupo muscular,
**cuando** presenta los resultados al ejecutante,
**entonces** clasifica la tendencia como: "Ascendente" (tonelaje y/o tasa de progresiÃ³n crecientes), "Estable" (valores sin cambio significativo) o "En declive" (tonelaje y/o tasa de progresiÃ³n decrecientes).

#### CA-15.22 â€” Rango de microciclos analizado

**Dado que** el sistema evalÃºa la tendencia,
**cuando** determina el rango temporal,
**entonces** analiza por defecto los Ãºltimos 4 a 6 microciclos completados, priorizando los microciclos mÃ¡s recientes para reflejar el estado actual del ejecutante.

#### CA-15.23 â€” Datos insuficientes para tendencia

**Dado que** el ejecutante tiene menos de 4 microciclos completados,
**cuando** intenta consultar la tendencia de un grupo muscular,
**entonces** el sistema indica que no hay datos suficientes para evaluar una tendencia significativa y muestra el nÃºmero de microciclos faltantes para habilitar el anÃ¡lisis.

#### CA-15.24 â€” PresentaciÃ³n por grupo muscular

**Dado que** el sistema ha evaluado la tendencia de todos los grupos musculares con datos suficientes,
**cuando** el ejecutante consulta las tendencias,
**entonces** muestra la tendencia de cada grupo muscular de forma desglosada, permitiendo comparar el comportamiento entre grupos musculares.

### Bloque E â€” EvoluciÃ³n de Tonelaje por Grupo Muscular (RF52)

#### CA-15.25 â€” VisualizaciÃ³n del tonelaje por grupo muscular a lo largo del tiempo

**Dado que** el ejecutante tiene mÃºltiples microciclos completados,
**cuando** consulta la evoluciÃ³n de tonelaje por grupo muscular,
**entonces** el sistema muestra el tonelaje acumulado de cada grupo muscular en cada microciclo, permitiendo visualizar la trayectoria temporal.

#### CA-15.26 â€” IdentificaciÃ³n de tendencias de tonelaje

**Dado que** el sistema presenta la evoluciÃ³n del tonelaje por grupo muscular,
**cuando** el ejecutante analiza los datos,
**entonces** la presentaciÃ³n permite identificar tendencias: ascendente (volumen creciente), estable (volumen mantenido) o en caÃ­da (volumen decreciente) para cada grupo muscular.

#### CA-15.27 â€” Desglose por grupo muscular

**Dado que** el ejecutante consulta la evoluciÃ³n de tonelaje,
**cuando** visualiza los resultados,
**entonces** el sistema presenta los datos desglosados por cada grupo muscular del sistema (Pecho, Espalda, Abdomen, Hombro, TrÃ­ceps, BÃ­ceps, CuÃ¡driceps, Isquiotibiales, GlÃºteos, Aductores, Abductores, Gemelos), permitiendo anÃ¡lisis individual.

#### CA-15.28 â€” Datos insuficientes para evoluciÃ³n de tonelaje

**Dado que** el ejecutante tiene menos de 2 microciclos completados,
**cuando** consulta la evoluciÃ³n de tonelaje,
**entonces** el sistema indica que se necesitan al menos 2 microciclos para mostrar una evoluciÃ³n comparativa.

---

## AnÃ¡lisis ArquitectÃ³nico (Arquitecto)

### Decisiones de DiseÃ±o

**PatrÃ³n ArquitectÃ³nico:** MVVM con lectura analÃ­tica multicapa â€” repositorio nuevo dedicado + reglas de cÃ¡lculo puras + 3 pantallas de presentaciÃ³n (G1/G2/G3).

**JustificaciÃ³n:** HU-15 es la historia mÃ¡s amplia del sistema en superficie de datos: lee TODAS las tablas transaccionales (session, session_exercise, exercise_set, exercise_muscle_zone, exercise_progression, rotation_state, profile) para producir 6 KPIs distintos (Tasa de ProgresiÃ³n, Velocidad de Carga, Tonelaje por Grupo Muscular, DistribuciÃ³n de Volumen, RIR Promedio por MÃ³dulo, Adherencia Semanal) mÃ¡s 2 anÃ¡lisis temporales (Tendencia de ProgresiÃ³n, EvoluciÃ³n de Tonelaje). Sin embargo, es una historia de **lectura pura** â€” no modifica ningÃºn dato existente, no ejecuta lÃ³gica al cierre de sesiÃ³n, y no produce efectos colaterales. Su complejidad estÃ¡ en la derivaciÃ³n de datos y la presentaciÃ³n visual, no en la orquestaciÃ³n transaccional. Se introduce un `MetricsRepository` separado de `SessionRepository` porque la responsabilidad es ortogonal: consultas analÃ­ticas agregadas vs. operaciones transaccionales de sesiÃ³n.

### Decisiones Fundamentadas

**1. Se crea un `MetricsRepository` (interfaz + implementaciÃ³n) como el quinto repositorio del sistema.**

Los 4 repositorios existentes (`SessionRepository`, `ProfileRepository`, `ExerciseRepository`, `PlanRepository`) gestionan entidades transaccionales individuales. HU-15 requiere consultas de agregaciÃ³n complejas que cruzan mÃºltiples tablas (exercise_set â†’ session_exercise â†’ session â†’ module_version â†’ exercise â†’ exercise_muscle_zone â†’ muscle_zone). Mezclar estas consultas en `SessionRepository` (ya con 18+ mÃ©todos) violarÃ­a SRP y harÃ­a el repositorio inmanejable. `MetricsRepository` recibe inyecciÃ³n de los DAOs necesarios (SessionDao, ExerciseSetDao, SessionExerciseDao, MuscleZoneDao, ProfileDao, RotationStateDao) y expone mÃ©todos `suspend` y `Flow` orientados al cÃ¡lculo analÃ­tico.

**2. Los 6 KPIs se calculan on-demand (al abrir G1), no al cierre de sesiÃ³n.**

Las mÃ©tricas de HU-15 son costosas en lectura pero no en escritura. Calcularlas al cierre de sesiÃ³n implicarÃ­a: (a) agregar latencia al flujo crÃ­tico `closeSession()`, (b) persistir valores derivados que se invalidan con cada nueva sesiÃ³n, (c) duplicar datos (las mÃ©tricas se derivan 100% de los datos existentes). En cambio, se calculan al abrir G1 con un loading state. Dado que el volumen de datos es limitado (mÃ¡ximo ~40 ejercicios Ã— ~6 sesiones/microciclo Ã— ~20 microciclos = ~4800 filas de exercise_set en un aÃ±o), las queries de agregaciÃ³n son despreciables en dispositivos modernos. ADR-06 valida este enfoque: reglas puras + queries derivadas.

**3. La asociaciÃ³n de sesiones a microciclos se deriva del orden de cierre, no de una columna persistida.**

La tabla `session` NO tiene columna `microcycle_number`. El `rotation_state.microcycle_count` es un acumulador global. Para agrupar sesiones por microciclo: las sesiones cerradas (COMPLETED/INCOMPLETE) se ordenan por fecha+id ascendente, y cada grupo de 6 sesiones consecutivas forma un microciclo. El microciclo N corresponde a las sesiones `[(N-1)*6 + 1, N*6]` en orden cronolÃ³gico. El microciclo parcial actual (posiciones 1 a `rotation_state.microcycle_position - 1`) se incluye solo si `microcycle_position > 1`. Esta derivaciÃ³n se encapsula en un mÃ©todo `getSessionsGroupedByMicrocycle()` del `MetricsRepository` que retorna `Map<Int, List<SessionWithSets>>`. Las sesiones IN_PROGRESS se excluyen (no estÃ¡n cerradas).

**4. Cada KPI se implementa como una funciÃ³n pura en su regla correspondiente dentro de `domain/rules/`.**

Siguiendo el patrÃ³n establecido por ADR-06 (8 reglas existentes), se crean 6 reglas nuevas:

| Regla | FunciÃ³n pura | Entrada | Salida |
|---|---|---|---|
| `ProgressionRateRule` | `calculate(positiveCount, totalCount)` | Int, Int | Double (%) |
| `LoadVelocityRule` | `calculate(currentWeightKg, initialWeightKg, sessionCount)` | Double, Double, Int | Double (Kg/sesiÃ³n) |
| `TonnageRule` | `calculateForMuscleGroup(sets)` | List&lt;SetForTonnage&gt; | Map&lt;String, Double&gt; (groupâ†’kg) |
| `VolumeDistributionRule` | `calculate(setsByZone, totalSets)` | Map&lt;String, Int&gt;, Int | Map&lt;String, Double&gt; (zoneâ†’%) |
| `AvgRirRule` | `calculate(rirValues)` | List&lt;Int&gt; | Double (promedio 1 decimal) |
| `AdherenceRule` | `calculate(completedSessions, plannedSessions)` | Int, Int | Double (%) |

Las reglas de Tendencia de ProgresiÃ³n (Bloque D) y EvoluciÃ³n de Tonelaje (Bloque E) no requieren reglas propias â€” son derivaciones de la presentaciÃ³n de los datos calculados por `TonnageRule` y `ProgressionRateRule` a lo largo de microciclos.

**5. La Tendencia de ProgresiÃ³n (G3) se clasifica con un algoritmo de pendiente lineal simplificado.**

CA-15.21 requiere clasificar como "Ascendente", "Estable" o "En declive". Se implementa como `TrendClassificationRule.classify(values: List<Double>): TrendDirection` donde `values` son los tonelajes (o tasas de progresiÃ³n) de los Ãºltimos 4-6 microciclos, ordenados cronolÃ³gicamente. El algoritmo calcula la pendiente de la lÃ­nea de mejor ajuste (regresiÃ³n lineal simple) y clasifica:

- Pendiente > umbral positivo (+5% del valor medio) â†’ `ASCENDING`
- Pendiente < umbral negativo (-5% del valor medio) â†’ `DECLINING`
- Otro â†’ `STABLE`

El umbral del 5% evita clasificar ruido estadÃ­stico como tendencia. La regresiÃ³n lineal simple (slope = Î£(xi - xÌ„)(yi - È³) / Î£(xi - xÌ„)Â²) es computacionalmente trivial para 4-6 puntos y no requiere dependencias externas.

**Nota sobre doble mÃ©trica (CA-15.20):** La tendencia por grupo muscular se evalÃºa sobre DOS mÃ©tricas: tonelaje acumulado y tasa de progresiÃ³n promedio de los ejercicios del grupo (promedio de las tasas individuales de los ejercicios que trabajan ese muscle_group). `classify()` se invoca una vez por cada mÃ©trica y la clasificaciÃ³n final toma la mÃ¡s conservadora: si alguna de las dos es DECLINING â†’ DECLINING; si ninguna es DECLINING pero alguna es STABLE â†’ STABLE; solo ASCENDING si ambas son ASCENDING. Esto impide clasificar como "Ascendente" un grupo cuyo tonelaje sube pero cuyos ejercicios dejan de progresar.

**6. El Ãndice de Adherencia usa semanas ISO 8601 (lunes a domingo) y consulta `profile.weekly_frequency`.**

CA-15.16 dice "semana natural". Se define como semana ISO (lunes=1, domingo=7) para consistencia. El query cuenta sesiones con `status IN ('COMPLETED', 'INCOMPLETE')` cuya `date` caiga en la semana ISO actual o la consultada. El denominador es `profile.weekly_frequency` (4, 5 o 6). La fÃ³rmula: `(sessionsInWeek / weeklyFrequency) * 100`, capped a 100% (si se entrena mÃ¡s del objetivo, no supera 100%). Para la vista G1, se muestra la semana actual.

**7. El RIR Promedio por MÃ³dulo filtra por las N Ãºltimas sesiones del mÃ³dulo, no por fecha.**

CA-15.14 dice "Ãºltimas 2 ejecuciones del mismo mÃ³dulo" como defecto. Esto NO es un rango de fechas â€” es un conteo de sesiones. Se consultan las Ãºltimas N sesiones (2, 4 o 6 â€” configurable en G1) del mÃ³dulo X, se obtienen todas las series (`exercise_set`) de esas sesiones, y se promedia `rir`. El query filtra por `session.module_version_id` que pertenezca al mÃ³dulo (JOIN module_version WHERE module_code = X), y ordena por `session.date DESC` / `session.id DESC`, tomando los primeros N. Se excluyen sesiones IN_PROGRESS.

**8. La Tasa de ProgresiÃ³n filtra por perÃ­odo configurable (4/8/12 semanas) usando `session.date`.**

CA-15.02 dice "perÃ­odo de 4 semanas" como defecto. El query: para cada ejercicio, contar sesiones donde `session_exercise.progression_classification = 'POSITIVE_PROGRESSION'` vs. total de sesiones (donde classification IS NOT NULL) dentro del rango de fechas. Los ejercicios sin clasificaciÃ³n (NO_HISTORY en su primera sesiÃ³n) se excluyen del cÃ³mputo. La fÃ³rmula: `positiveCount / totalWithClassification * 100`.

**9. La Velocidad de Carga se calcula como (peso mÃ¡s reciente - peso mÃ¡s antiguo) / sesiones intermedias.**

CA-15.03 define la fÃ³rmula. Para cada ejercicio estÃ¡ndar (no bodyweight, no isomÃ©trico): obtener el `AVG(weight_kg)` de las series de la primera sesiÃ³n registrada del ejercicio y el `AVG(weight_kg)` de la Ãºltima sesiÃ³n registrada. El denominador es el nÃºmero de sesiones distintas del ejercicio menos 1 (sesiones intermedias). Si solo hay 1 sesiÃ³n â†’ velocidad = 0 (CA-15.04). Si es bodyweight â†’ N/A (CA-15.05). El perÃ­odo de evaluaciÃ³n usa el mismo rango que la Tasa de ProgresiÃ³n (4/8/12 semanas) para consistencia.

**10. El Tonelaje por Grupo Muscular contabiliza ejercicios multi-zona en cada grupo al que pertenecen.**

CA-15.09 dice que un ejercicio que trabaja mÃºltiples zonas contabiliza su tonelaje en cada zona. El tonelaje de un ejercicio = Î£(weight_kg Ã— reps) de todas sus series en el microciclo. Para un ejercicio con 2 zonas (ej: Sentadilla BÃºlgara â†’ CuÃ¡driceps + GlÃºteos), ese mismo tonelaje se suma COMPLETO a ambos grupos. No se divide â€” se contabiliza al 100% en cada grupo. El query: JOIN exercise_set â†’ session_exercise â†’ exercise_muscle_zone â†’ muscle_zone, GROUP BY muscle_zone.muscle_group, SUM(weight_kg * reps).

**11. G1 (Panel de MÃ©tricas) es la pantalla que reemplaza el `PlaceholderScreen` existente en la ruta `METRICS`.**

Actualmente `NavigationRoutes.METRICS = "metrics"` ya existe y tiene un `PlaceholderScreen` registrado en `TensionNavHost`. Se reemplaza con `MetricsScreen`. La pantalla es scrollable con 4 secciones + 2 accesos rÃ¡pidos:
1. Ãndice de Adherencia (card con porcentaje + desglose)
2. RIR Promedio por MÃ³dulo (card con dropdown de perÃ­odo + 3 filas)
3. Tasa de ProgresiÃ³n (lista interactiva con dropdown de perÃ­odo + filas por ejercicio â†’ F3)
4. Velocidad de Carga (lista interactiva + filas por ejercicio â†’ F3)
5. Enlace "Volumen por Grupo Muscular â†’" (navega a G2)
6. Enlace "Tendencia de ProgresiÃ³n â†’" (navega a G3)

Sigue la estructura visual Â§G1 de la EspecificaciÃ³n Visual: `CenterAlignedTopAppBar` sin navigationIcon, Bottom Navigation con MÃ©tricas activo.

**12. G2 y G3 son pantallas independientes con sus propios ViewModels, accesibles desde G1.**

G2 (Volumen por Grupo Muscular) tiene 3 secciones: selector de microciclo (stepper â—€â–¶), tonelaje por grupo muscular (barras horizontales), distribuciÃ³n de volumen (%), y evoluciÃ³n temporal (grÃ¡fico multilÃ­nea). G3 (Tendencia de ProgresiÃ³n) es una lista simple con 12 filas (una por grupo muscular) y clasificaciÃ³n Ascendente/Estable/En declive. Ambas tienen navigationIcon ArrowBack â†’ G1 y Bottom Navigation con MÃ©tricas activo.

Se crean 3 ViewModels:
- `MetricsViewModel` â†’ carga datos para G1 (adherencia, RIR promedio, tasa de progresiÃ³n, velocidad de carga)
- `VolumeViewModel` â†’ carga datos para G2 (tonelaje por grupo, distribuciÃ³n, evoluciÃ³n)
- `TrendViewModel` â†’ carga datos para G3 (tendencia por grupo muscular)

**13. El grÃ¡fico de evoluciÃ³n temporal en G2 NO usa una librerÃ­a de charts externa.**

La EspecificaciÃ³n Visual Â§G2 describe un grÃ¡fico multilÃ­nea con leyenda y grid. Para fase MVP, se implementa como un `Canvas` Composable con draw commands bÃ¡sicos. Los puntos de datos (tonelaje por grupo por microciclo) son pocos (mÃ¡x ~12 lÃ­neas Ã— ~20 puntos) y la precisiÃ³n visual no requiere interpolaciÃ³n spline. Se dibuja: ejes (Label Small, On Surface Variant), lÃ­neas conectando puntos (Primary, Secondary, Tertiary + variantes), leyenda inferior (Label Small + punto de color). Si el equipo decide usar una librerÃ­a futura (Vico, YCharts), la interfaz de datos no cambia â€” solo el composable de renderizado.

**14. Los Use Cases orquestan Repository + Rules para cada bloque de KPIs.**

Siguiendo la convenciÃ³n `{AcciÃ³n}{Entidad}UseCase`:

| Use Case | Bloque | DescripciÃ³n |
|---|---|---|
| `GetAdherenceUseCase` | C | Obtiene sesiones de la semana + weekly_frequency â†’ `AdherenceRule.calculate()` |
| `GetAvgRirByModuleUseCase` | C | Obtiene sets de las N Ãºltimas sesiones del mÃ³dulo â†’ `AvgRirRule.calculate()` |
| `GetProgressionRateUseCase` | A | Obtiene clasificaciones por ejercicio en perÃ­odo â†’ `ProgressionRateRule.calculate()` |
| `GetLoadVelocityUseCase` | A | Obtiene peso inicial/actual por ejercicio â†’ `LoadVelocityRule.calculate()` |
| `GetTonnageByMuscleGroupUseCase` | B | Obtiene sets + muscle zones del microciclo â†’ `TonnageRule.calculateForMuscleGroup()` |
| `GetVolumeDistributionUseCase` | B | Obtiene conteo de sets por zona â†’ `VolumeDistributionRule.calculate()` |
| `GetTonnageEvolutionUseCase` | E | Obtiene tonelaje por grupo Ã— microciclo â†’ lista de snapshots |
| `GetMuscleGroupTrendUseCase` | D | Obtiene tonelaje + tasa promedio de progresiÃ³n por grupo Ã— microciclos â†’ `TrendClassificationRule.classify()` para cada mÃ©trica â†’ combina (la mÃ¡s conservadora prevalece) |

**15. Los estados vacÃ­os y de datos insuficientes se manejan como variantes explÃ­citas del UiState.**

- G3 (Tendencia): si `microcycleCount < 4` â†’ `TrendUiState.InsufficientData(remaining = 4 - microcycleCount)` (CA-15.23)
- G2 (EvoluciÃ³n de Tonelaje): si `microcycleCount < 2` â†’ `VolumeUiState.InsufficientEvolution` (CA-15.28)
- G1 (Tasa de ProgresiÃ³n): si un ejercicio no tiene sesiones con clasificaciÃ³n en el perÃ­odo â†’ se muestra "Sin datos" en vez de 0%

**16. Las rutas de G2 y G3 se agregan a `NavigationRoutes` como destinos secundarios.**

G1 ya existe como `METRICS`. Se agregan:
- `MUSCLE_VOLUME = "muscle-volume"` â†’ G2
- `PROGRESSION_TREND = "progression-trend"` â†’ G3

La navegaciÃ³n G1â†’G2 y G1â†’G3 usa `navController.navigate()` estÃ¡ndar. G2/G3 tienen ArrowBack que ejecuta `navController.popBackStack()`.

**17. La derivaciÃ³n de microciclos para agrupaciÃ³n temporal se implementa con lÃ³gica Kotlin.**

SQLite no soporta window functions robustas en todas las versiones de Android. Se opta por la lÃ³gica en Kotlin:

1. Obtener TODAS las sesiones cerradas ordenadas por (date ASC, id ASC)
2. Agrupar en bloques de 6: sesiones [0..5] = microciclo 1, [6..11] = microciclo 2, etc.
3. El bloque parcial final (< 6 sesiones) = microciclo actual en progreso
4. Retornar Map&lt;Int, List&lt;Long&gt;&gt; (microcycleNumber â†’ sessionIds)

Este mapeo se calcula una vez al abrir G2 o G3 y se cachea en el ViewModel durante la sesiÃ³n de visualizaciÃ³n. No se persiste porque es derivado puro. Las sesiones de deload participan del conteo de microciclos normalmente â€” un microciclo de deload es un microciclo vÃ¡lido (CA-14.13 ya implementado en HU-14).

**18. Los selectores de perÃ­odo en G1 (dropdown de semanas, dropdown de sesiones RIR) se implementan como `ExposedDropdownMenuBox` M3.**

EspecificaciÃ³n Visual Â§G1 define:
- Tasa de ProgresiÃ³n: opciones "4 semanas" (defecto), "8 semanas", "12 semanas"
- RIR Promedio: opciones "2 Ãºltimas sesiones" (defecto), "4 Ãºltimas sesiones", "6 Ãºltimas sesiones"

Los cambios de perÃ­odo disparan recarga del KPI correspondiente via `viewModelScope.launch`. No se persisten â€” al salir y reentrar a G1, se usan los defaults.

### Componentes Afectados

**Componentes nuevos:**

| # | Componente | Capa | Responsabilidad |
|---|---|---|---|
| 1 | `ProgressionRateRule` | Domain (rules) | FunciÃ³n pura: `calculate(positiveCount, totalCount)` â†’ porcentaje. ADR-06 |
| 2 | `LoadVelocityRule` | Domain (rules) | FunciÃ³n pura: `calculate(currentWeight, initialWeight, sessionCount)` â†’ Kg/sesiÃ³n. ADR-06 |
| 3 | `TonnageRule` | Domain (rules) | FunciÃ³n pura: `calculateForMuscleGroup(sets)` â†’ Map&lt;grupo, tonelaje&gt;. ADR-06 |
| 4 | `VolumeDistributionRule` | Domain (rules) | FunciÃ³n pura: `calculate(setsByZone, totalSets)` â†’ Map&lt;zona, %&gt;. ADR-06 |
| 5 | `AvgRirRule` | Domain (rules) | FunciÃ³n pura: `calculate(rirValues)` â†’ promedio con 1 decimal. ADR-06 |
| 6 | `AdherenceRule` | Domain (rules) | FunciÃ³n pura: `calculate(completed, planned)` â†’ porcentaje capped 100%. ADR-06 |
| 7 | `TrendClassificationRule` | Domain (rules) | FunciÃ³n pura: `classify(values)` â†’ TrendDirection (ASCENDING/STABLE/DECLINING). Pendiente lineal. ADR-06 |
| 8 | `TrendDirection` | Domain (model) | Enum: `ASCENDING`, `STABLE`, `DECLINING` |
| 9 | `MetricsRepository` | Domain (repository) | Interfaz: queries analÃ­ticas agregadas (progresiÃ³n, tonelaje, RIR, adherencia, agrupaciÃ³n por microciclo) |
| 10 | `MetricsRepositoryImpl` | Data (repository) | ImplementaciÃ³n con inyecciÃ³n de DAOs. Consultas SQL de agregaciÃ³n. Transforma DTOs â†’ modelos de dominio |
| 11 | `GetAdherenceUseCase` | Domain (usecase/metrics) | Orquesta: sesiones de la semana + weekly_frequency â†’ AdherenceRule |
| 12 | `GetAvgRirByModuleUseCase` | Domain (usecase/metrics) | Orquesta: sets de N Ãºltimas sesiones del mÃ³dulo â†’ AvgRirRule |
| 13 | `GetProgressionRateUseCase` | Domain (usecase/metrics) | Orquesta: clasificaciones por ejercicio en perÃ­odo â†’ ProgressionRateRule |
| 14 | `GetLoadVelocityUseCase` | Domain (usecase/metrics) | Orquesta: peso inicial/actual por ejercicio â†’ LoadVelocityRule |
| 15 | `GetTonnageByMuscleGroupUseCase` | Domain (usecase/metrics) | Orquesta: sets+zones del microciclo â†’ TonnageRule |
| 16 | `GetVolumeDistributionUseCase` | Domain (usecase/metrics) | Orquesta: conteo sets por zona â†’ VolumeDistributionRule |
| 17 | `GetTonnageEvolutionUseCase` | Domain (usecase/metrics) | Orquesta: tonelaje por grupo Ã— microciclos â†’ lista temporal |
| 18 | `GetMuscleGroupTrendUseCase` | Domain (usecase/metrics) | Orquesta: tonelaje histÃ³rico â†’ TrendClassificationRule.classify() |
| 19 | `MetricsUiState` | UI (metrics) | Sealed interface: Loading, Content(adherence, rirByModule, progressionRates, loadVelocities), Error |
| 20 | `MetricsViewModel` | UI (metrics) | Carga KPIs de G1, expone StateFlow&lt;MetricsUiState&gt;. Acciones: changePeriod, changeRirPeriod |
| 21 | `MetricsScreen` | UI (metrics) | Composable G1: 4 secciones + 2 accesos rÃ¡pidos + Bottom Navigation |
| 22 | `VolumeUiState` | UI (volume) | Sealed interface: Loading, Content(tonnageByGroup, distribution, evolution, microcycleCount, selectedMicrocycle), InsufficientEvolution, Error |
| 23 | `VolumeViewModel` | UI (volume) | Carga KPIs de G2. AcciÃ³n: selectMicrocycle(n) |
| 24 | `VolumeScreen` | UI (volume) | Composable G2: selector microciclo + barras + distribuciÃ³n + grÃ¡fico evoluciÃ³n |
| 25 | `TrendUiState` | UI (trend) | Sealed interface: Loading, Content(trends: List&lt;MuscleGroupTrend&gt;), InsufficientData(remaining), Error |
| 26 | `TrendViewModel` | UI (trend) | Carga tendencias de G3 |
| 27 | `TrendScreen` | UI (trend) | Composable G3: lista de 12 grupos con clasificaciÃ³n |
| 28 | `TonnageChartComposable` | UI (components) | Canvas composable reutilizable para grÃ¡fico multilÃ­nea de evoluciÃ³n de tonelaje |
| 29 | Domain models | Domain (model) | `AdherenceData`, `RirByModule`, `ExerciseProgressionRate`, `ExerciseLoadVelocity`, `MuscleGroupTonnage`, `MuscleGroupTrend`, `TonnageSnapshot`, `SetForTonnage`, `ClassificationCount`, `ExerciseSessionRange`, `SetTonnageData`, `SetDistributionData`, `ClassificationCountByGroup` |
| 30 | `GetMicrocycleMapUseCase` | Domain (usecase/metrics) | Obtiene Map&lt;Int, List&lt;Long&gt;&gt; de sesiones agrupadas por microciclo. Respeta ADR-05: Ãºnico punto de acceso a agrupaciÃ³n temporal |

**Componentes modificados:**

| # | Componente | ModificaciÃ³n | Nivel |
|---|---|---|---|
| 1 | `SessionDao` | Agregar queries: `getClosedSessionsOrdered()`, `countSessionsInWeek(startDate, endDate)`, `getSessionIdsByModuleInRange(moduleCode, limit)` | Medio |
| 2 | `ExerciseSetDao` | Agregar queries: `getRirValuesBySessionIds(ids)`, `getTonnageBySessionIds(ids)`, `getFirstWeightForExercise(exerciseId, startDate)`, `getAvgWeightByExerciseAndSession(exerciseId, sessionId)` | Medio |
| 3 | `SessionExerciseDao` | Agregar queries: `countClassificationsByExercise(exerciseId, startDate)`, `getExerciseIdsWithClassificationInRange(startDate)` | Medio |
| 4 | `NavigationRoutes` | Agregar `MUSCLE_VOLUME` y `PROGRESSION_TREND` | Menor |
| 5 | `TensionNavHost` | Reemplazar `PlaceholderScreen` de METRICS con `MetricsScreen`. Registrar composables G2 y G3 | Medio |
| 6 | `RepositoryModule` | Agregar 5to binding: `MetricsRepository` â†’ `MetricsRepositoryImpl` | Menor |
| 7 | `BottomNavigationBar` | Agregar `MUSCLE_VOLUME` y `PROGRESSION_TREND` como `childRoutes` del tab MÃ©tricas para que permanezca activo en G2 y G3 | Menor |

### Hitos de ImplementaciÃ³n

| # | Componente(s) | DescripciÃ³n | Dependencias |
|---|---|---|---|
| 1 | Reglas puras (7) + tests | `ProgressionRateRule`, `LoadVelocityRule`, `TonnageRule`, `VolumeDistributionRule`, `AvgRirRule`, `AdherenceRule`, `TrendClassificationRule`. Tests JUnit con edge cases | Ninguna |
| 2 | DAO queries nuevos | Queries de agregaciÃ³n en SessionDao, ExerciseSetDao, SessionExerciseDao. Tests instrumentados | Ninguna |
| 3 | Domain models | `AdherenceData`, `RirByModule`, `ExerciseProgressionRate`, `ExerciseLoadVelocity`, `MuscleGroupTonnage`, `MuscleGroupTrend`, `TonnageSnapshot`, `SetForTonnage`, `ClassificationCount`, `ExerciseSessionRange`, `SetTonnageData`, `SetDistributionData`, `ClassificationCountByGroup`, `TrendDirection` | Ninguna |
| 4 | `MetricsRepository` (interfaz + impl) | Interfaz + implementaciÃ³n con lÃ³gica de agrupaciÃ³n por microciclo | Hitos 1, 2, 3 |
| 5 | Use Cases (9) | 9 use cases orquestando repository + rules (incluye `GetMicrocycleMapUseCase`) | Hito 4 |
| 6 | DI binding | `RepositoryModule` â†’ `MetricsRepository` | Hito 4 |
| 7 | G1 â€” MetricsScreen + ViewModel | Reemplazo del PlaceholderScreen. 4 secciones + 2 accesos rÃ¡pidos. Dropdowns de perÃ­odo | Hito 5 |
| 8 | G2 â€” VolumeScreen + ViewModel | Selector microciclo + barras + distribuciÃ³n + grÃ¡fico Canvas | Hito 5 |
| 9 | G3 â€” TrendScreen + ViewModel | Lista de 12 grupos + clasificaciÃ³n + estado insuficiente | Hito 5 |
| 10 | NavegaciÃ³n G2/G3 | Rutas en NavigationRoutes, composables en TensionNavHost, childRoutes en BottomNavigationBar, enlaces G1â†’G2, G1â†’G3 | Hitos 7, 8, 9 |

### ValidaciÃ³n de Impacto

**CÃ³digo real verificado (paso 1.5):**

- `NavigationRoutes.kt`: Ya tiene `METRICS = "metrics"`. Falta `MUSCLE_VOLUME` y `PROGRESSION_TREND`.
- `TensionNavHost.kt`: `composable(NavigationRoutes.METRICS) { PlaceholderScreen(...) }` â€” se reemplaza con `MetricsScreen`.
- `BottomNavigationBar.kt`: Ya tiene tab de MÃ©tricas apuntando a `METRICS`. Requiere agregar `MUSCLE_VOLUME` y `PROGRESSION_TREND` como `childRoutes` para que el tab MÃ©tricas se mantenga activo en G2 y G3.
- `SessionDao.kt`: Tiene `getActiveSession()`, `getById()`, `updateStatus()`, etc. Falta queries de conteo por fecha, ordenaciÃ³n de sesiones cerradas.
- `ExerciseSetDao.kt`: Tiene `getSetsForSessionExercise()` que retorna `weightKg`, `reps`, `rir`. Falta queries de agregaciÃ³n por sesiÃ³n/mÃ³dulo. `getLastWeightForExercise()` existe (excluye deload desde HU-14).
- `SessionExerciseDao.kt`: Tiene `getSessionExercisesForProgression()` y `updateProgressionClassification()`. Falta query de conteo de clasificaciones por ejercicio en rango de fechas.
- `ProfileDao.kt`: `getProfile()` retorna `Flow<ProfileEntity?>` que incluye `weeklyFrequency`. Disponible.
- `RotationStateDao.kt`: `getRotationState()` retorna `microcycleCount` y `microcyclePosition`. Disponible.
- `MuscleZoneDao.kt`: `getAll()` retorna `Flow<List<MuscleZoneEntity>>` con `muscleGroup`. Disponible.
- `ExerciseMuscleZoneEntity.kt`: Tabla JOIN con `exerciseId` + `muscleZoneId`. No hay `ExerciseMuscleZoneDao` â€” la tabla se accede via `ExerciseDao.insertMuscleZone()` y `insertAllMuscleZones()`. Para lecturas analÃ­ticas, se necesita un query JOIN directo en `ExerciseSetDao` o en `MetricsRepositoryImpl`.
- `TensionDatabase.kt`: version=6, 16 entities. No requiere nuevo entity ni migration â€” HU-15 es lectura pura.
- `DatabaseModule.kt`: Ya provee los 15 DAOs. No se necesita nuevo DAO â€” las queries se agregan a DAOs existentes.
- `RepositoryModule.kt`: Binds 4 repositorios (`ProfileRepository`, `ExerciseRepository`, `PlanRepository`, `SessionRepository`). Se agrega el 5to: `MetricsRepository`.
- `SessionRepository.kt`: 18 mÃ©todos. No se modifica â€” HU-15 usa su propio repositorio.

**AnÃ¡lisis de dependencias:**

- HU-15 depende de: HU-01 (profile.weekly_frequency para adherencia), HU-05 (session + session_exercise â€” datos base), HU-06 (exercise_set â€” datos de series), HU-09 (rotation_state.microcycle_count â€” agrupaciÃ³n temporal), HU-10 (progression_classification â€” fuente de Tasa de ProgresiÃ³n), HU-14 (session.deload_id â€” sesiones de deload participan en microciclos normalmente).
- HU-15 alimenta: HU-17 (alertas â€” los KPIs de HU-15 son los que disparan alertas de tasa baja, RIR fuera de rango, adherencia baja, tonelaje en caÃ­da; HU-17 necesita las mismas queries/reglas para calcular los datos de la alerta en H2).
- HU-15 NO modifica componentes de otras HUs â€” es lectura pura.

**Impacto en performance:**

- Todas las queries son de LECTURA sobre datos cerrados (sesiones COMPLETED/INCOMPLETE).
- `countClassificationsByExercise`: GROUP BY con COUNT sobre session_exercise filtrado por date range. Con Ã­ndices en `exercise_id` y `session_id`, O(n) donde n = sesiones del ejercicio.
- `getRirValuesBySessionIds`: JOIN exercise_set â†’ session_exercise filtrado por session IDs. Con IN clause. O(sets Ã— sessions).
- `getTonnageBySessionIds`: JOIN con SUM(weight_kg * reps) GROUP BY muscle_group. O(sets Ã— sessions Ã— exercises).
- Peor caso estimado: 20 microciclos Ã— 6 sesiones Ã— 8 ejercicios Ã— 4 sets = 3,840 filas de exercise_set total. Consultas < 50ms en dispositivo moderno.
- El grÃ¡fico Canvas de G2 renderiza mÃ¡ximo 12 lÃ­neas Ã— 20 puntos = 240 draw calls. Trivial.

### Notas TÃ©cnicas

**Nota 1 â€” La agrupaciÃ³n por microciclo asume sesiones consecutivas de 6.**

Si la rotaciÃ³n se ha reiniciado manualmente o hay sesiones corruptas, la agrupaciÃ³n podrÃ­a desalinearse. Sin embargo, el sistema no permite reiniciar la rotaciÃ³n (la tabla `rotation_state` es de fila Ãºnica inmutable excepto por `advanceRotation()`). Las sesiones IN_PROGRESS se excluyen del conteo. Las sesiones INCOMPLETE sÃ­ cuentan como cierre vÃ¡lido (ya avanzan la rotaciÃ³n â€” CA-09.05).

**Nota 2 â€” Las sesiones de deload sÃ­ se incluyen en cÃ¡lculos de tonelaje pero se excluyen de Tasa de ProgresiÃ³n y Velocidad de Carga.**

Un microciclo de deload tiene tonelaje reducido (cargas al 60%). Esto es correcto â€” la "EvoluciÃ³n temporal" en G2 deberÃ­a mostrar la caÃ­da de tonelaje durante el deload y la recuperaciÃ³n post-deload. El ejecutante debe poder visualizar este patrÃ³n. HU-17 (alertas de tonelaje) verificarÃ¡ si la caÃ­da es por "descarga planificada" antes de emitir alerta. En la Tasa de ProgresiÃ³n, las sesiones de deload no deberÃ­an penalizar al ejercicio â€” durante deload, `resolveNewProgressionState()` retorna IN_DELOAD sin cambiar el estado, y la `classification` se sigue asignando normalmente pero con cargas reducidas artificialmente (posiblemente REGRESSION comparado con pre-deload). **SoluciÃ³n: excluir sesiones con `session.deload_id IS NOT NULL` del cÃ¡lculo de Tasa de ProgresiÃ³n y Velocidad de Carga** â€” estas mÃ©tricas deben reflejar el rendimiento real, no el perÃ­odo de recuperaciÃ³n deliberada.

**Nota 3 â€” El grÃ¡fico de evoluciÃ³n temporal (G2) es un Canvas composable custom, no una librerÃ­a externa.**

Se evita dependencia externa para fase MVP. El componente recibe `List<TonnageSnapshot>` (microcycleNumber, Map&lt;group, tonnage&gt;) y dibuja:
- Eje X: microciclos (Label Small)
- Eje Y: tonelaje en Kg (Label Small, auto-scaled)
- LÃ­neas: una por grupo muscular, colores diferenciados segÃºn Â§G2 EspecVis (Primary #8B1A1A, Secondary #6B4F4F, Tertiary #5C6B4F + variantes)
- Leyenda inferior: Label Small + punto de color + nombre grupo

**Nota 4 â€” No hay tabla nueva ni migraciÃ³n de base de datos.**

HU-15 es 100% lectura sobre datos existentes. No se crea ninguna entidad Room nueva, no se modifica ninguna tabla, no se requiere migration. El Ãºnico cambio en la capa de datos son queries adicionales en DAOs existentes.

**Nota 5 â€” Para Velocidad de Carga, el "peso inicial" es el AVG(weight_kg) de las series de la primera sesiÃ³n del ejercicio en el perÃ­odo.**

No el peso de la primera serie. Se usa el promedio para suavizar variaciones intra-sesiÃ³n (warming up, fatigue drops). El "peso actual" es el AVG(weight_kg) de las series de la Ãºltima sesiÃ³n del ejercicio. Ambos queries usan el mismo rango de fechas que la Tasa de ProgresiÃ³n para consistencia.

**Nota 6 â€” Los accesos F3 (toque en ejercicio en G1) ya estÃ¡n implementados.**

`NavigationRoutes.EXERCISE_HISTORY = "exercise-history/{exerciseId}"` ya existe. La navegaciÃ³n G1â†’F3 usa `navController.navigate("exercise-history/$exerciseId")`. El composable `ExerciseHistoryScreen` ya estÃ¡ registrado en `TensionNavHost`.

**Nota 7 â€” La DistribuciÃ³n de Volumen (CA-15.10) se calcula por mÃ³dulo dentro del microciclo.**

CA-15.10 dice explÃ­citamente "porcentaje de series totales de cada zona muscular respecto al total de series **del mÃ³dulo**". El Wireframe G2 confirma: "DistribuciÃ³n de series por zona muscular vs. total del mÃ³dulo (...etc por mÃ³dulo...)". La distribuciÃ³n se calcula POR MÃ“DULO: dentro de cada mÃ³dulo (A, B, C) se cuentan las series por zona muscular del microciclo seleccionado y se calcula el porcentaje respecto al total de series de ese mÃ³dulo. G2 muestra 3 sub-secciones (una por mÃ³dulo) con las zonas musculares que le corresponden. Esto evita comparaciones cross-mÃ³dulo sin sentido (ej: Pecho de A vs. CuÃ¡driceps de C) y permite al ejecutante evaluar equilibrio dentro de cada segmento corporal. `VolumeDistributionRule.calculate(setsByZone, totalSets)` se invoca una vez por mÃ³dulo con los sets de las sesiones de ese mÃ³dulo en el microciclo.

**Nota 8 â€” Query de Tasa de ProgresiÃ³n excluye sesiones de deload.**

El query debe incluir el filtro `AND s.deload_id IS NULL` para que las clasificaciones durante sesiones de deload no contaminen el cÃ¡lculo de la tasa de rendimiento real del ejecutante.

### VerificaciÃ³n Cruzada de CAs

| CA | Estado | Mecanismo | Implementado en |
|---|---|---|---|
| CA-15.01 | ðŸ”¨ Por implementar | `ProgressionRateRule.calculate(positiveCount, totalCount)` â†’ porcentaje | HU-15 (Rule + UseCase) |
| CA-15.02 | ðŸ”¨ Por implementar | Dropdown en G1 (4/8/12 semanas). Defecto 4. Recalcula al cambiar | HU-15 (MetricsScreen + ViewModel) |
| CA-15.03 | ðŸ”¨ Por implementar | `LoadVelocityRule.calculate(current, initial, sessions)` â†’ Kg/sesiÃ³n | HU-15 (Rule + UseCase) |
| CA-15.04 | ðŸ”¨ Por implementar | Si `current == initial` â†’ velocidad = 0. Edge case en `LoadVelocityRule` | HU-15 (Rule) |
| CA-15.05 | ðŸ”¨ Por implementar | Guard: `if (isBodyweight)` â†’ excluir de Velocidad de Carga. Mostrar "N/A" | HU-15 (UseCase + UI) |
| CA-15.06 | ðŸ”¨ Por implementar | G1 Secciones 3+4: lista por ejercicio con % y Kg/sesiÃ³n | HU-15 (MetricsScreen) |
| CA-15.07 | ðŸ”¨ Por implementar | `TonnageRule.calculateForMuscleGroup(sets)` â†’ SUM(weight Ã— reps) agrupado por muscle_group | HU-15 (Rule + UseCase) |
| CA-15.08 | ðŸ”¨ Por implementar | JOIN exercise_muscle_zone â†’ muscle_zone. Usa `muscle_zone.muscle_group` como fuente de verdad | HU-15 (DAO query) |
| CA-15.09 | ðŸ”¨ Por implementar | Tonelaje se contabiliza al 100% en CADA grupo del ejercicio multi-zona | HU-15 (TonnageRule) |
| CA-15.10 | ðŸ”¨ Por implementar | `VolumeDistributionRule.calculate(setsByZone, totalSets)` â†’ porcentaje por zona | HU-15 (Rule + UseCase) |
| CA-15.11 | ðŸ”¨ Por implementar | AgrupaciÃ³n por microciclo: bloques de 6 sesiones cerradas consecutivas. Selector en G2 | HU-15 (MetricsRepository) |
| CA-15.12 | ðŸ”¨ Por implementar | G2: barras tonelaje + distribuciÃ³n % + referencia al microciclo seleccionado | HU-15 (VolumeScreen) |
| CA-15.13 | ðŸ”¨ Por implementar | `AvgRirRule.calculate(rirValues)` â†’ promedio aritmÃ©tico 1 decimal | HU-15 (Rule + UseCase) |
| CA-15.14 | ðŸ”¨ Por implementar | Dropdown en G1 (2/4/6 Ãºltimas sesiones del mÃ³dulo). Defecto 2 | HU-15 (MetricsScreen + ViewModel) |
| CA-15.15 | ðŸ”¨ Por implementar | Badges coloreados: 2-3=ðŸŸ¢ (verde), <1.5=ðŸ”´ (rojo/riesgo), >3.5=ðŸŸ¡ (Ã¡mbar). Referencia textual | HU-15 (MetricsScreen) |
| CA-15.16 | ðŸ”¨ Por implementar | `AdherenceRule.calculate(completed, planned)` â†’ porcentaje capped 100% | HU-15 (Rule + UseCase) |
| CA-15.17 | ðŸ”¨ Por implementar | Denominador: `profile.weekly_frequency` (4, 5 o 6) via `ProfileDao.getProfile()` | HU-15 (UseCase) |
| CA-15.18 | ðŸ”¨ Por implementar | Conteo incluye COMPLETED + INCOMPLETE. Excluye IN_PROGRESS | HU-15 (DAO query) |
| CA-15.19 | ðŸ”¨ Por implementar | G1 Secciones 1+2: Adherencia card + RIR por mÃ³dulo card con badges | HU-15 (MetricsScreen) |
| CA-15.20 | ðŸ”¨ Por implementar | `GetMuscleGroupTrendUseCase`: tonelaje + tasa progresiÃ³n Ãºltimos 4-6 microciclos | HU-15 (UseCase) |
| CA-15.21 | ðŸ”¨ Por implementar | `TrendClassificationRule.classify(values)` â†’ ASCENDING/STABLE/DECLINING (pendiente lineal) | HU-15 (Rule) |
| CA-15.22 | ðŸ”¨ Por implementar | Defecto: 4-6 Ãºltimos microciclos. Priorizando recientes | HU-15 (UseCase) |
| CA-15.23 | ðŸ”¨ Por implementar | Guard: `if (microcycleCount < 4)` â†’ InsufficientData(remaining). Mostrar "Faltan N microciclos" | HU-15 (TrendViewModel + TrendScreen) |
| CA-15.24 | ðŸ”¨ Por implementar | G3: lista de 12 grupos con tendencia desglosada | HU-15 (TrendScreen) |
| CA-15.25 | ðŸ”¨ Por implementar | G2 EvoluciÃ³n: tonelaje por grupo Ã— microciclo en grÃ¡fico multilÃ­nea Canvas | HU-15 (TonnageChartComposable) |
| CA-15.26 | ðŸ”¨ Por implementar | GrÃ¡fico permite visualizar tendencias ascendente/estable/caÃ­da por grupo | HU-15 (TonnageChartComposable) |
| CA-15.27 | ðŸ”¨ Por implementar | Desglose por 12 grupos: Pecho, Espalda, Abdomen, Hombro, TrÃ­ceps, BÃ­ceps, CuÃ¡driceps, Isquiotibiales, GlÃºteos, Aductores, Abductores, Gemelos | HU-15 (VolumeScreen + TrendScreen) |
| CA-15.28 | ðŸ”¨ Por implementar | Guard: `if (microcycleCount < 2)` â†’ "Se necesitan al menos 2 microciclos" | HU-15 (VolumeViewModel + VolumeScreen) |

### Referencias y ValidaciÃ³n

**DocumentaciÃ³n consultada:**

- Manifiesto de Dominio SistÃ©mico Â§7 â€” KPIs 1-6 (Tasa de ProgresiÃ³n, Tonelaje, RIR Promedio, Adherencia, Velocidad de Carga, DistribuciÃ³n de Volumen)
- Manifiesto de Dominio SistÃ©mico Â§7.B â€” Umbrales de Tolerancia (alertas de tasa baja, RIR fuera de rango, adherencia baja, caÃ­da de tonelaje)
- Modelo de Datos Â§3.2 (muscle_zone â€” 15 zonas, 12 grupos), Â§3.5 (exercise_muscle_zone), Â§3.8 (profile.weekly_frequency), Â§3.10 (session.date, session.status), Â§3.11 (session_exercise.progression_classification), Â§3.12 (exercise_set.weight_kg, reps, rir), Â§3.14 (rotation_state.microcycle_count)
- ADR-06 â€” Motor de reglas Kotlin puro
- Arquitectura TÃ©cnica Â§5.2 â€” Naming: `MetricsScreen`, `MetricsViewModel`, `ProgressionRateRule`, etc.
- Wireframes G1 â€” Panel de MÃ©tricas (4 secciones + 2 accesos rÃ¡pidos + Bottom Navigation)
- Wireframes G2 â€” Volumen por Grupo Muscular (selector microciclo + barras + distribuciÃ³n + evoluciÃ³n temporal)
- Wireframes G3 â€” Tendencia de ProgresiÃ³n (lista 12 grupos + clasificaciÃ³n + estado insuficiente)
- EspecificaciÃ³n Visual Â§G1 â€” CenterAlignedTopAppBar, Filled Card Secondary Container, ExposedDropdownMenuBox, ListItem M3, badges coloreados
- EspecificaciÃ³n Visual Â§G2 â€” ArrowBack, Selector microciclo con IconButtons, barras horizontales, Canvas multilÃ­nea, colores Primary/Secondary/Tertiary
- EspecificaciÃ³n Visual Â§G3 â€” ListItem M3 56dp, colores verde/Ã¡mbar/rojo para tendencias, emojis ðŸ“ˆðŸ“ŠðŸ“‰
- Mapa de NavegaciÃ³n Â§G â€” G1â†’G2, G1â†’G3, G1â†’F3, G2â†G1, G3â†G1
- Requerimientos RF42, RF44, RF45, RF46, RF47, RF48, RF49, RF52

**Historias relacionadas:**

- HU-01: Establece `profile.weekly_frequency` â€” denominador del Ãndice de Adherencia (CA-15.17).
- HU-05: Crea sesiones y session_exercises â€” datos base para todos los KPIs.
- HU-06: Registra exercise_sets (weight_kg, reps, rir) â€” datos atÃ³micos de tonelaje, RIR, progresiÃ³n de carga.
- HU-09: Gestiona rotaciÃ³n y cierre de sesiÃ³n. `rotation_state.microcycle_count` es el acumulador de microciclos usado para agrupaciÃ³n temporal.
- HU-10: Asigna `progression_classification` en session_exercise al cierre â€” fuente directa de Tasa de ProgresiÃ³n.
- HU-14: Define sesiones de deload (`session.deload_id`). Las sesiones de deload participan en el conteo de microciclos pero se excluyen de Tasa de ProgresiÃ³n y Velocidad de Carga (Nota 2).
- HU-17 (futuro): Sistema de Alertas â€” usa los mismos KPIs (tasa < 40%, RIR fuera de rango, adherencia < 60%, tonelaje en caÃ­da) para generar alertas automÃ¡ticas. Los Use Cases y Rules de HU-15 serÃ¡n reutilizados por HU-17.

**Validado por:** esteban.colorado | **Fecha:** 2026-02-18 | **Enfoque:** Exploratorio

---

## Refinamiento TÃ©cnico (Desarrollador)

<!-- â•â•â• DEV REFINEMENT â•â•â• -->
<!-- Generado: 2026-02-18 -->
<!-- Base: AnÃ¡lisis ArquitectÃ³nico completo (18 decisiones, 10 hitos, 8 notas) -->
<!-- Fuente: 29 archivos fuente verificados, 6 docs arquitectura, 5 docs negocio, 18 HUs -->

<!--
Archivos fuente consultados y verificados contra claims del arquitecto:
- SessionDao.kt (104 lÃ­neas) â€” insert, getActiveSession, getById, getActiveSessionWithModuleVersion, updateStatus, getModuleVersionIdBySessionId, getDeloadIdBySessionId, countDeloadSessions, hasSessionAfterDeload, getSessionSummaryInfo
- ExerciseSetDao.kt (76 lÃ­neas) â€” insert, getNextSetNumber, getLastWeightForExercise (excluye deload HU-14), getPreDeloadAvgWeight, getSetsForSessionExercise, getLastHistoricalSets
- SessionExerciseDao.kt (229 lÃ­neas) â€” 6 DTOs, insertAll, getBySessionId, getBySessionIdWithDetails, getExerciseInfoForSet, getSessionExerciseForSubstitution, getExerciseIdsForSession, getSessionExercisesForProgression, updateProgressionClassification, updateExerciseId, getExercisesForSummary
- ProfileDao.kt (22 lÃ­neas) â€” getProfile Flow<ProfileEntity?> con weeklyFrequency
- MuscleZoneDao.kt (19 lÃ­neas) â€” getAll Flow<List<MuscleZoneEntity>>, insertAll
- ExerciseDao.kt (152 lÃ­neas) â€” ExerciseWithDetails DTO, getAll, getById, getByIdOnce, insertMuscleZone, insertAllMuscleZones
- ModuleVersionDao.kt (44 lÃ­neas) â€” getAll, getById, getByModuleCodeAndVersion
- RotationStateDao.kt (21 lÃ­neas) â€” getRotationState Flow<RotationStateEntity?> con microcycleCount, microcyclePosition
- SessionEntity.kt (42 lÃ­neas) â€” id, moduleVersionId, deloadId?, date, status
- ExerciseSetEntity.kt (44 lÃ­neas) â€” id, sessionExerciseId, setNumber, weightKg, reps, rir
- SessionExerciseEntity.kt (55 lÃ­neas) â€” id, sessionId, exerciseId, originalExerciseId?, progressionClassification?
- ProfileEntity.kt (23 lÃ­neas) â€” weeklyFrequency: Int (4-6)
- MuscleZoneEntity.kt (23 lÃ­neas) â€” name, muscleGroup (index on muscle_group)
- ExerciseMuscleZoneEntity.kt (35 lÃ­neas) â€” composite PK(exerciseId, muscleZoneId), sin DAO propio
- ExerciseEntity.kt (61 lÃ­neas) â€” name, moduleCode, isBodyweight, isIsometric
- RotationStateEntity.kt (27 lÃ­neas) â€” microcyclePosition, currentVersionModuleA/B/C, microcycleCount
- ModuleVersionEntity.kt (35 lÃ­neas) â€” moduleCode, versionNumber
- ModuleEntity.kt (20 lÃ­neas) â€” code (PK String), name, loadIncrementKg
- SessionRepositoryImpl.kt (664 lÃ­neas) â€” constructor L51-65 (12 DAOs + DB), 18+ mÃ©todos
- SessionRepository.kt (30 lÃ­neas) â€” interfaz con 18 mÃ©todos
- NavigationRoutes.kt (31 lÃ­neas) â€” METRICS = "metrics", EXERCISE_HISTORY = "exercise-history/{exerciseId}"
- TensionNavHost.kt (351 lÃ­neas) â€” L244-245: PlaceholderScreen para METRICS, L339-351: PlaceholderScreen composable privado
- BottomNavigationBar.kt (137 lÃ­neas) â€” 5 tabs, METRICS sin childRoutes/childRoutePrefixes
- DatabaseModule.kt (111 lÃ­neas) â€” 15 DAOs provistos, fallbackToDestructiveMigration()
- RepositoryModule.kt (45 lÃ­neas) â€” @Binds 4 repos (Profile, Exercise, Plan, Session)
- TensionDatabase.kt (71 lÃ­neas) â€” version=6, 16 entities
- domain/rules/ (8 archivos) â€” ProgressionClassificationRule(136L), DeloadNeedRule(17L), ModuleFatigueRule(12L), DoubleThresholdRule(33L), DeloadLoadRule(21L), CorrectiveActionRule(19L), ActionSignalRule(55L), PlateauCausalAnalysisRule(25L) â€” patrÃ³n: object singleton, funciones puras
- ExerciseHistoryScreen.kt (44 lÃ­neas) â€” stub placeholder "Coming Soon"

DocumentaciÃ³n de referencia consultada:
- docs/architecture/EspecificaciÃ³n Visual.md (Â§G1 L878-896, Â§G2 L898-915, Â§G3 L916-935, Â§4.3 tendencias L177-181)
- docs/architecture/Wireframes.md (G1 L1436-1529, G2 L1531-1623, G3 L1625-1676)
- docs/architecture/Mapa de NavegaciÃ³n.md (Â§G L73-79, conexiones L395-405, tabla consolidada L533-537)
- docs/architecture/Arquitectura TÃ©cnica.md (rutas L400-402, paquete ui.metrics L297, graph L456-459)
- docs/architecture/ADR.md (ADR-06 L191-218, ADR-05 L167-188, ADR-18 L525-549)
- docs/architecture/Modelo de Datos.md (Â§3.2 muscle_zone L64-100, Â§3.5 exercise_muscle_zone L224-248, Â§3.8 profile L342-372, Â§3.10 session L387-418, Â§3.11 session_exercise L420-462, Â§3.12 exercise_set L464-506, Â§3.14 rotation_state L520-560)
- docs/business_definition/Manifiesto de Dominio SistÃ©mico.md (Â§7.A KPIs L409-507, Â§7.B umbrales L509-521, R5 L347-370)
- docs/business_definition/Requerimientos.md (RF42 L57, RF44 L59, RF45 L60, RF46 L61, RF47 L62, RF48 L63, RF49 L64, RF52 L67)
- docs/stories/HU-01.md, HU-05.md, HU-06.md, HU-09.md, HU-10.md, HU-14.md

Basado en anÃ¡lisis arquitectÃ³nico:
HU-15 es una historia de LECTURA PURA â€” no modifica ningÃºn dato existente, no ejecuta lÃ³gica al cierre de sesiÃ³n, no produce efectos colaterales. 29 componentes nuevos + 7 modificados distribuidos en 10 fases. Su complejidad estÃ¡ en la derivaciÃ³n de datos y la presentaciÃ³n visual: 7 reglas puras + 8 use cases + 3 pantallas + 1 repositorio. No requiere migraciÃ³n de base de datos, nueva entidad Room, ni nuevas dependencias. Todas las mÃ©tricas se calculan on-demand al abrir las pantallas, no al cierre de sesiÃ³n.

Nivel de complejidad:
ALTA en superficie (29 componentes nuevos), MEDIA en lÃ³gica individual (cada regla es simple: 1-3 funciones puras). La complejidad real estÃ¡ en: (1) los 8+ queries SQL de agregaciÃ³n que cruzan 6 tablas, (2) la agrupaciÃ³n por microciclo derivada en Kotlin (bloques de 6 sesiones), (3) el Canvas composable para el grÃ¡fico multilÃ­nea en G2 (~60 draw calls). Riesgo principal: errores en los queries de agregaciÃ³n que produzcan KPIs incorrectos â€” cada query necesita test de integraciÃ³n con datos de ejemplo.

Riesgos tÃ©cnicos conocidos:

1. **Queries de agregaciÃ³n complejos:** Los queries de tonelaje, RIR promedio, y distribuciÃ³n cruzan 4-6 tablas (exercise_set â†’ session_exercise â†’ session â†’ module_version + exercise â†’ exercise_muscle_zone â†’ muscle_zone). Room no soporta window functions en todas las versiones de Android â†’ la agrupaciÃ³n por microciclo se hace en Kotlin.
2. **AgrupaciÃ³n por microciclo asume sesiones consecutivas de 6:** Si alguna sesiÃ³n se perdiÃ³ o estÃ¡ corrupta, la agrupaciÃ³n se desalinea. Sin embargo, el sistema no permite eliminar sesiones y `advanceRotation()` siempre avanza secuencialmente.
3. **Canvas composable custom:** El grÃ¡fico de evoluciÃ³n temporal en G2 requiere coordenadas calculadas manualmente (ejes, escalas, lÃ­neas). Edge case: todos los grupos con tonelaje 0 â†’ eje Y sin rango. SoluciÃ³n: mÃ­nimo 1 Kg como escalas.
4. **Sesiones de deload en cÃ¡lculos de rendimiento:** Las sesiones de deload (`session.deload_id IS NOT NULL`) deben EXCLUIRSE de Tasa de ProgresiÃ³n y Velocidad de Carga pero INCLUIRSE en Tonelaje y adherencia (decisiÃ³n del arquitecto, Nota 2).

Patrones y convenciones del equipo (establecidos en HU-01â€”HU-14):

- CÃ³digo fuente en inglÃ©s, UI en espaÃ±ol (Arquitectura TÃ©cnica Â§5.1)
- Naming: `{Nombre}Rule` para reglas (object singleton), `{Feature}Screen` para composables, `{Feature}ViewModel` para VMs, `{Feature}UiState` para estados
- Rules: `object` singleton con funciones puras, sin DI (ADR-06)
- DAO: `@Dao interface` con queries `@Query("""...""")`, DTOs como `data class` fuera de la interfaz
- Repository: interfaz en `domain/repository/`, implementaciÃ³n con `@Inject constructor` en `data/repository/`
- UseCase: `@Inject constructor` + `operator fun invoke()`
- `@HiltViewModel` + `SavedStateHandle` (si args de navegaciÃ³n) o `@Inject constructor` directo
- Tests: JUnit 4, helpers factories, sin mocks para reglas puras (ADR-18)
- Paquete UI: TODOS los archivos de G1, G2, G3 van en `ui/metrics/` (Arquitectura TÃ©cnica Â§3.2: `ui.metrics`)
- `BottomNavigationBar` usa `childRoutes` y `childRoutePrefixes` para mantener tab activo en rutas hijas
- `RepositoryModule` usa `@Binds` para vincular interfaz â†’ implementaciÃ³n

Dependencias nuevas a instalar:
Ninguna.
-->

### Fase 1: Reglas puras (7 rules) + tests

<!-- Basado en Hito #1 del AnÃ¡lisis ArquitectÃ³nico -->
<!-- AC: CA-15.01, CA-15.03, CA-15.04, CA-15.07, CA-15.09, CA-15.10, CA-15.13, CA-15.16, CA-15.21 -->

#### ðŸ“¦ Domain Layer â€” Rules

- [ ] **Crear `ProgressionRateRule`** (AC: 1)
  - [ ] Crear archivo: `domain/rules/ProgressionRateRule.kt`
  - [ ] `object ProgressionRateRule`
  - [ ] FunciÃ³n:
    ```kotlin
    fun calculate(positiveCount: Int, totalCount: Int): Double {
        if (totalCount == 0) return 0.0
        return (positiveCount.toDouble() / totalCount) * 100.0
    }
    ```
  - [ ] Constantes: ninguna (funciÃ³n pura sin umbrales â€” los umbrales son visuales en Â§G1)

- [ ] **Crear `LoadVelocityRule`** (AC: 3, 4, 5)
  - [ ] Crear archivo: `domain/rules/LoadVelocityRule.kt`
  - [ ] `object LoadVelocityRule`
  - [ ] FunciÃ³n:
    ```kotlin
    fun calculate(currentWeightKg: Double, initialWeightKg: Double, sessionCount: Int): Double {
        if (sessionCount <= 1) return 0.0
        return (currentWeightKg - initialWeightKg) / (sessionCount - 1)
    }
    ```
  - [ ] `sessionCount` es el nÃºmero TOTAL de sesiones (no intermedias) â€” el denominador es `sessionCount - 1` (sesiones intermedias)
  - [ ] Si `currentWeightKg == initialWeightKg` â†’ retorna 0.0 (CA-15.04)
  - [ ] Para bodyweight, el UseCase no invoca esta funciÃ³n (CA-15.05)

- [ ] **Crear `TonnageRule`** (AC: 7, 9)
  - [ ] Crear archivo: `domain/rules/TonnageRule.kt`
  - [ ] `object TonnageRule`
  - [ ] FunciÃ³n:
    ```kotlin
    fun calculateForMuscleGroup(
        sets: List<SetForTonnage>,
    ): Map<String, Double> {
        return sets.groupBy { it.muscleGroup }
            .mapValues { (_, groupSets) ->
                groupSets.sumOf { it.weightKg * it.reps }
            }
    }
    ```
  - [ ] DTO de entrada (mismo archivo o en `domain/model/`):
    ```kotlin
    data class SetForTonnage(
        val weightKg: Double,
        val reps: Int,
        val muscleGroup: String,
    )
    ```
  - [ ] CA-15.09: ejercicios multi-zona aparecen duplicados en `sets` â€” una entrada por cada `muscle_group` del ejercicio â†’ contabilizaciÃ³n 100% en cada grupo

- [ ] **Crear `VolumeDistributionRule`** (AC: 10)
  - [ ] Crear archivo: `domain/rules/VolumeDistributionRule.kt`
  - [ ] `object VolumeDistributionRule`
  - [ ] FunciÃ³n:
    ```kotlin
    fun calculate(setsByZone: Map<String, Int>, totalSets: Int): Map<String, Double> {
        if (totalSets == 0) return setsByZone.mapValues { 0.0 }
        return setsByZone.mapValues { (_, count) ->
            (count.toDouble() / totalSets) * 100.0
        }
    }
    ```
  - [ ] CA-15.10: se invoca POR MÃ“DULO â€” el UseCase filtra sets del mÃ³dulo y pasa `totalSets` = total de series del mÃ³dulo en el microciclo

- [ ] **Crear `AvgRirRule`** (AC: 13)
  - [ ] Crear archivo: `domain/rules/AvgRirRule.kt`
  - [ ] `object AvgRirRule`
  - [ ] FunciÃ³n:
    ```kotlin
    fun calculate(rirValues: List<Int>): Double {
        if (rirValues.isEmpty()) return 0.0
        return (rirValues.sum().toDouble() / rirValues.size)
            .let { (it * 10).roundToInt() / 10.0 }
    }
    ```
  - [ ] Redondeo a 1 decimal con `roundToInt()`
  - [ ] import: `kotlin.math.roundToInt`

- [ ] **Crear `AdherenceRule`** (AC: 16)
  - [ ] Crear archivo: `domain/rules/AdherenceRule.kt`
  - [ ] `object AdherenceRule`
  - [ ] FunciÃ³n:
    ```kotlin
    fun calculate(completedSessions: Int, plannedSessions: Int): Double {
        if (plannedSessions == 0) return 0.0
        val raw = (completedSessions.toDouble() / plannedSessions) * 100.0
        return raw.coerceAtMost(100.0)
    }
    ```
  - [ ] Capped a 100% (CA-15.16: si entrena mÃ¡s del objetivo, no supera 100%)

- [ ] **Crear `TrendClassificationRule`** (AC: 21)
  - [ ] Crear archivo: `domain/rules/TrendClassificationRule.kt`
  - [ ] `object TrendClassificationRule`
  - [ ] FunciÃ³n:
    ```kotlin
    fun classify(values: List<Double>): TrendDirection {
        if (values.size < 2) return TrendDirection.STABLE
        val n = values.size
        val xMean = (n - 1) / 2.0
        val yMean = values.average()
        var numerator = 0.0
        var denominator = 0.0
        for (i in values.indices) {
            val xDiff = i - xMean
            numerator += xDiff * (values[i] - yMean)
            denominator += xDiff * xDiff
        }
        if (denominator == 0.0) return TrendDirection.STABLE
        val slope = numerator / denominator
        val threshold = yMean * 0.05
        return when {
            slope > threshold -> TrendDirection.ASCENDING
            slope < -threshold -> TrendDirection.DECLINING
            else -> TrendDirection.STABLE
        }
    }
    ```
  - [ ] RegresiÃ³n lineal simple: `slope = Î£(xi - xÌ„)(yi - È³) / Î£(xi - xÌ„)Â²`
  - [ ] Umbral: Â±5% del valor medio (DecisiÃ³n 5 del arquitecto)
  - [ ] CA-15.20: se invoca DOS veces por grupo muscular (tonelaje + tasa progresiÃ³n promedio) â†’ la clasificaciÃ³n final combina ambas (la mÃ¡s conservadora prevalece)

#### ðŸ“¦ Domain Layer â€” Model

- [ ] **Crear `TrendDirection`**
  - [ ] Crear archivo: `domain/model/TrendDirection.kt`
  - [ ] `enum class TrendDirection { ASCENDING, STABLE, DECLINING }`

#### ðŸ“¦ Tests

- [ ] **Crear test `ProgressionRateRuleTest`**
  - [ ] Archivo: `test/.../domain/rules/ProgressionRateRuleTest.kt`
  - [ ] Casos: (3 positivos de 10 total) â†’ 30%, (0 de 0) â†’ 0%, (10 de 10) â†’ 100%, (1 de 2) â†’ 50%

- [ ] **Crear test `LoadVelocityRuleTest`**
  - [ ] Archivo: `test/.../domain/rules/LoadVelocityRuleTest.kt`
  - [ ] Casos: (60, 40, 5) â†’ 5.0, (50, 50, 3) â†’ 0.0 (CA-15.04), (60, 40, 1) â†’ 0.0 (solo 1 sesiÃ³n), (0, 0, 0) â†’ 0.0

- [ ] **Crear test `TonnageRuleTest`**
  - [ ] Archivo: `test/.../domain/rules/TonnageRuleTest.kt`
  - [ ] Casos: sets con 2 muscle groups â†’ mapa correcto, sets vacÃ­os â†’ mapa vacÃ­o, ejercicio multi-zona (CA-15.09) con duplicaciÃ³n en ambos grupos â†’ tonelaje completo en cada grupo

- [ ] **Crear test `VolumeDistributionRuleTest`**
  - [ ] Casos: {"Pecho":10, "Espalda":6} con total 16 â†’ {62.5%, 37.5%}, totalSets=0 â†’ 0% para todos

- [ ] **Crear test `AvgRirRuleTest`**
  - [ ] Casos: [2,3,2,3] â†’ 2.5, [1] â†’ 1.0, vacÃ­o â†’ 0.0, [2,3,2,4] â†’ 2.8 (redondeo 1 decimal)

- [ ] **Crear test `AdherenceRuleTest`**
  - [ ] Casos: (5,6) â†’ 83.3, (6,6) â†’ 100.0, (7,6) â†’ 100.0 (capped), (0,6) â†’ 0.0, (0,0) â†’ 0.0

- [ ] **Crear test `TrendClassificationRuleTest`**
  - [ ] Casos: [100,110,120,130] â†’ ASCENDING, [100,100,100,100] â†’ STABLE, [130,120,110,100] â†’ DECLINING, [100] â†’ STABLE (< 2 puntos), [100,101,99,100] â†’ STABLE (dentro del umbral 5%), lista vacÃ­a â†’ STABLE

### Fase 2: Domain models

<!-- Basado en Hito #3 del AnÃ¡lisis ArquitectÃ³nico -->
<!-- AC: mÃºltiples â€” modelos usados por todas las capas -->

#### ðŸ“¦ Domain Layer â€” Models

- [ ] **Crear `AdherenceData`**
  - [ ] Crear archivo: `domain/model/AdherenceData.kt`
  - [ ] `data class AdherenceData(val completedSessions: Int, val plannedSessions: Int, val percentage: Double)`

- [ ] **Crear `RirByModule`**
  - [ ] Crear archivo: `domain/model/RirByModule.kt`
  - [ ] `data class RirByModule(val moduleCode: String, val averageRir: Double, val interpretation: RirInterpretation)`
  - [ ] `enum class RirInterpretation { OPTIMAL, RISK_TOO_CLOSE, INSUFFICIENT_STIMULUS }`
  - [ ] InterpretaciÃ³n (CA-15.15): 2.0..3.0 = OPTIMAL, <1.5 = RISK_TOO_CLOSE, >3.5 = INSUFFICIENT_STIMULUS, else = OPTIMAL (caso intermedio 1.5-2.0 y 3.0-3.5)

- [ ] **Crear `ExerciseProgressionRate`**
  - [ ] Crear archivo: `domain/model/ExerciseProgressionRate.kt`
  - [ ] `data class ExerciseProgressionRate(val exerciseId: Long, val exerciseName: String, val rate: Double, val isBodyweight: Boolean)`

- [ ] **Crear `ExerciseLoadVelocity`**
  - [ ] Crear archivo: `domain/model/ExerciseLoadVelocity.kt`
  - [ ] `data class ExerciseLoadVelocity(val exerciseId: Long, val exerciseName: String, val velocity: Double, val isBodyweight: Boolean)`
  - [ ] Si `isBodyweight` â†’ velocity es N/A (UI muestra "N/A")

- [ ] **Crear `MuscleGroupTonnage`**
  - [ ] Crear archivo: `domain/model/MuscleGroupTonnage.kt`
  - [ ] `data class MuscleGroupTonnage(val muscleGroup: String, val tonnageKg: Double)`

- [ ] **Crear `MuscleGroupTrend`**
  - [ ] Crear archivo: `domain/model/MuscleGroupTrend.kt`
  - [ ] `data class MuscleGroupTrend(val muscleGroup: String, val direction: TrendDirection)`

- [ ] **Crear `TonnageSnapshot`**
  - [ ] Crear archivo: `domain/model/TonnageSnapshot.kt`
  - [ ] `data class TonnageSnapshot(val microcycleNumber: Int, val tonnageByGroup: Map<String, Double>)`

- [ ] **Crear DTOs analÃ­ticos** (usados por DAOs y MetricsRepository)
  - [ ] Crear archivo: `domain/model/ClassificationCount.kt`
  - [ ] `data class ClassificationCount(val exerciseId: Long, val exerciseName: String, val isBodyweight: Int, val positiveCount: Int, val totalCount: Int)`
  - [ ] Crear archivo: `domain/model/ExerciseSessionRange.kt`
  - [ ] `data class ExerciseSessionRange(val exerciseId: Long, val exerciseName: String, val isBodyweight: Int, val isIsometric: Int, val firstSessionId: Long, val lastSessionId: Long, val sessionCount: Int)`
  - [ ] Crear archivo: `domain/model/SetTonnageData.kt`
  - [ ] `data class SetTonnageData(val weightKg: Double, val reps: Int, val muscleGroup: String)`
  - [ ] Crear archivo: `domain/model/SetDistributionData.kt`
  - [ ] `data class SetDistributionData(val muscleZoneName: String, val moduleCode: String, val setCount: Int)`
  - [ ] Crear archivo: `domain/model/ClassificationCountByGroup.kt`
  - [ ] `data class ClassificationCountByGroup(val muscleGroup: String, val positiveCount: Int, val totalCount: Int)`
  - [ ] **Nota:** Estos DTOs se definen en `domain/model/` (no junto a los DAOs) para respetar la direcciÃ³n de dependencias ADR-05: Domain no importa de Data. Room mapea estos DTOs por alias de columna independientemente del paquete.

### Fase 3: DAO queries nuevos

<!-- Basado en Hito #2 del AnÃ¡lisis ArquitectÃ³nico -->
<!-- AC: CA-15.01, CA-15.07, CA-15.08, CA-15.10, CA-15.11, CA-15.13, CA-15.16, CA-15.18 -->

#### ðŸ“¦ Data Layer â€” DAOs

- [ ] **Modificar `SessionDao`** (AC: 11, 16, 18)
  - [ ] Agregar query `getClosedSessionsOrdered()`:
    ```kotlin
    @Query("""
        SELECT id, module_version_id, deload_id, date, status
        FROM session
        WHERE status IN ('COMPLETED', 'INCOMPLETE')
        ORDER BY date ASC, id ASC
    """)
    suspend fun getClosedSessionsOrdered(): List<SessionEntity>
    ```
  - [ ] Agregar query `countSessionsInWeek()`:
    ```kotlin
    @Query("""
        SELECT COUNT(*) FROM session
        WHERE status IN ('COMPLETED', 'INCOMPLETE')
          AND date >= :weekStartDate
          AND date <= :weekEndDate
    """)
    suspend fun countSessionsInWeek(weekStartDate: String, weekEndDate: String): Int
    ```
  - [ ] **Nota:** `weekStartDate` y `weekEndDate` en formato ISO 8601 (`"YYYY-MM-DD"`). La semana ISO lunes-domingo se calcula en Kotlin.
  - [ ] Agregar query `getSessionIdsByModuleInRange()` para RIR promedio:
    ```kotlin
    @Query("""
        SELECT s.id FROM session s
        INNER JOIN module_version mv ON s.module_version_id = mv.id
        WHERE mv.module_code = :moduleCode
          AND s.status IN ('COMPLETED', 'INCOMPLETE')
        ORDER BY s.date DESC, s.id DESC
        LIMIT :limit
    """)
    suspend fun getSessionIdsByModuleInRange(moduleCode: String, limit: Int): List<Long>
    ```
  - [ ] **Nota:** Este query NO filtra `deload_id IS NULL`. Las sesiones de deload tienen RIR artificialmente alto (~4-5 objetivo) por diseÃ±o del protocolo (R5). Si se incluyen, el RIR promedio se infla. Se agrega filtro:
    ```kotlin
    @Query("""
        SELECT s.id FROM session s
        INNER JOIN module_version mv ON s.module_version_id = mv.id
        WHERE mv.module_code = :moduleCode
          AND s.status IN ('COMPLETED', 'INCOMPLETE')
          AND s.deload_id IS NULL
        ORDER BY s.date DESC, s.id DESC
        LIMIT :limit
    """)
    suspend fun getSessionIdsByModuleInRange(moduleCode: String, limit: Int): List<Long>
    ```
  - [ ] **JustificaciÃ³n:** El RIR promedio debe reflejar intensidad real de entrenamiento, no el perÃ­odo de recuperaciÃ³n deliberada. Consistente con la exclusiÃ³n de deload en Tasa de ProgresiÃ³n y Velocidad de Carga.

- [ ] **Modificar `ExerciseSetDao`** (AC: 7, 13)
  - [ ] Agregar DTO para tonelaje con muscle group:
    ```kotlin
    data class SetTonnageData(
        val weightKg: Double,
        val reps: Int,
        val muscleGroup: String,
    )
    ```
  - [ ] Agregar query `getTonnageDataBySessionIds()`:
    ```kotlin
    @Query("""
        SELECT es.weight_kg AS weightKg, es.reps, mz.muscle_group AS muscleGroup
        FROM exercise_set es
        INNER JOIN session_exercise se ON es.session_exercise_id = se.id
        INNER JOIN exercise_muscle_zone emz ON se.exercise_id = emz.exercise_id
        INNER JOIN muscle_zone mz ON emz.muscle_zone_id = mz.id
        WHERE se.session_id IN (:sessionIds)
    """)
    suspend fun getTonnageDataBySessionIds(sessionIds: List<Long>): List<SetTonnageData>
    ```
  - [ ] **Nota:** Esta query produce DUPLICADOS intencionales para ejercicios multi-zona (CA-15.09) â€” una fila por muscle_group del ejercicio.
  - [ ] Agregar query `getRirValuesBySessionIds()`:
    ```kotlin
    @Query("""
        SELECT es.rir FROM exercise_set es
        INNER JOIN session_exercise se ON es.session_exercise_id = se.id
        WHERE se.session_id IN (:sessionIds)
    """)
    suspend fun getRirValuesBySessionIds(sessionIds: List<Long>): List<Int>
    ```
  - [ ] Agregar query `getAvgWeightByExerciseInSession()`:
    ```kotlin
    @Query("""
        SELECT AVG(es.weight_kg)
        FROM exercise_set es
        INNER JOIN session_exercise se ON es.session_exercise_id = se.id
        WHERE se.exercise_id = :exerciseId
          AND se.session_id = :sessionId
    """)
    suspend fun getAvgWeightByExerciseInSession(exerciseId: Long, sessionId: Long): Double?
    ```
  - [ ] Agregar DTO para distribuciÃ³n de volumen por zona muscular y mÃ³dulo:
    ```kotlin
    data class SetDistributionData(
        val muscleZoneName: String,
        val moduleCode: String,
        val setCount: Int,
    )
    ```
  - [ ] Agregar query `getSetDistributionBySessionIds()`:
    ```kotlin
    @Query("""
        SELECT mz.name AS muscleZoneName, mv.module_code AS moduleCode, COUNT(*) AS setCount
        FROM exercise_set es
        INNER JOIN session_exercise se ON es.session_exercise_id = se.id
        INNER JOIN session s ON se.session_id = s.id
        INNER JOIN module_version mv ON s.module_version_id = mv.id
        INNER JOIN exercise_muscle_zone emz ON se.exercise_id = emz.exercise_id
        INNER JOIN muscle_zone mz ON emz.muscle_zone_id = mz.id
        WHERE se.session_id IN (:sessionIds)
        GROUP BY mz.name, mv.module_code
    """)
    suspend fun getSetDistributionBySessionIds(sessionIds: List<Long>): List<SetDistributionData>
    ```
  - [ ] **Nota (CA-15.10 + RF49):** La distribuciÃ³n agrupa por `mz.name` (15 zonas musculares: Pecho Medio, Pecho Superior, Pecho Inferior, etc.) y NO por `mz.muscle_group` (12 grupos). RF49 dice explÃ­citamente "porcentaje de series totales de cada **zona muscular**". El MDS KPI 6 da como ejemplo detectar imbalance entre Pecho Medio (60%) vs Pecho Superior (15%) â€” esto requiere granularidad de zona, no de grupo.

- [ ] **Modificar `SessionExerciseDao`** (AC: 1, 3)
  - [ ] Agregar DTO para conteo de clasificaciones:
    ```kotlin
    // DTO definido en domain/model/ClassificationCount.kt (importado aquÃ­)
    ```
  - [ ] Agregar query `getClassificationCountsByPeriod()`:
    ```kotlin
    @Query("""
        SELECT
            se.exercise_id AS exerciseId,
            e.name AS exerciseName,
            e.is_bodyweight AS isBodyweight,
            SUM(CASE WHEN se.progression_classification = 'POSITIVE_PROGRESSION' THEN 1 ELSE 0 END) AS positiveCount,
            COUNT(se.progression_classification) AS totalCount
        FROM session_exercise se
        INNER JOIN session s ON se.session_id = s.id
        INNER JOIN exercise e ON se.exercise_id = e.id
        WHERE s.status IN ('COMPLETED', 'INCOMPLETE')
          AND s.deload_id IS NULL
          AND s.date >= :startDate
          AND se.progression_classification IS NOT NULL
        GROUP BY se.exercise_id
    """)
    suspend fun getClassificationCountsByPeriod(startDate: String): List<ClassificationCount>
    ```
  - [ ] **Nota:** Excluye sesiones de deload (`s.deload_id IS NULL`) y sesiones sin clasificaciÃ³n (`IS NOT NULL`) (Nota 2, Nota 8 del arquitecto)
  - [ ] Agregar DTO para velocidad de carga:
    ```kotlin
    // DTO definido en domain/model/ExerciseSessionRange.kt (importado aquÃ­)
    ```
  - [ ] Agregar query `getExerciseSessionRangeByPeriod()`:
    ```kotlin
    @Query("""
        SELECT
            se.exercise_id AS exerciseId,
            e.name AS exerciseName,
            e.is_bodyweight AS isBodyweight,
            e.is_isometric AS isIsometric,
            MIN(se.session_id) AS firstSessionId,
            MAX(se.session_id) AS lastSessionId,
            COUNT(DISTINCT se.session_id) AS sessionCount
        FROM session_exercise se
        INNER JOIN session s ON se.session_id = s.id
        INNER JOIN exercise e ON se.exercise_id = e.id
        WHERE s.status IN ('COMPLETED', 'INCOMPLETE')
          AND s.deload_id IS NULL
          AND s.date >= :startDate
        GROUP BY se.exercise_id
    """)
    suspend fun getExerciseSessionRangeByPeriod(startDate: String): List<ExerciseSessionRange>
    ```
  - [ ] Agregar DTO para clasificaciÃ³n por grupo muscular (para doble mÃ©trica de tendencia en G3):
    ```kotlin
    // DTO definido en domain/model/ClassificationCountByGroup.kt (importado aquÃ­)
    ```
  - [ ] Agregar query `getClassificationCountsBySessionIds()`:
    ```kotlin
    @Query("""
        SELECT
            mz.muscle_group AS muscleGroup,
            SUM(CASE WHEN se.progression_classification = 'POSITIVE_PROGRESSION' THEN 1 ELSE 0 END) AS positiveCount,
            COUNT(se.progression_classification) AS totalCount
        FROM session_exercise se
        INNER JOIN session s ON se.session_id = s.id
        INNER JOIN exercise_muscle_zone emz ON se.exercise_id = emz.exercise_id
        INNER JOIN muscle_zone mz ON emz.muscle_zone_id = mz.id
        WHERE se.session_id IN (:sessionIds)
          AND s.deload_id IS NULL
          AND se.progression_classification IS NOT NULL
        GROUP BY mz.muscle_group
    """)
    suspend fun getClassificationCountsBySessionIds(sessionIds: List<Long>): List<ClassificationCountByGroup>
    ```
  - [ ] **Nota:** Este query soporta la doble mÃ©trica de CA-15.20. Para cada microciclo, se agrupa el conteo de progresiÃ³n por muscle_group cruzando exercise_muscle_zone â†’ muscle_zone. Los ejercicios multi-zona aportan a cada grupo.

#### ðŸ“¦ Tests â€” DAO queries (tests instrumentados)

- [ ] **Crear test instrumentado para queries de SessionDao**
  - [ ] Archivo: `androidTest/.../data/local/dao/SessionDaoMetricsTest.kt`
  - [ ] Setup: crear DB en memoria con datos de ejemplo (3 mÃ³dulos, 12+ sesiones cerradas, mix COMPLETED/INCOMPLETE)
  - [ ] Casos: `getClosedSessionsOrdered()` retorna solo cerradas y ordenadas por fecha ASC, `countSessionsInWeek()` cuenta solo en rango, `getSessionIdsByModuleInRange()` limita por mÃ³dulo y excluye deload

- [ ] **Crear test instrumentado para queries de ExerciseSetDao**
  - [ ] Archivo: `androidTest/.../data/local/dao/ExerciseSetDaoMetricsTest.kt`
  - [ ] Setup: poblar exercise_set, session_exercise, session, exercise_muscle_zone, muscle_zone con datos de ejemplo
  - [ ] Casos: `getTonnageDataBySessionIds()` produce duplicados para ejercicios multi-zona, `getRirValuesBySessionIds()` retorna todos los rir de las sesiones indicadas, `getSetDistributionBySessionIds()` agrupa correctamente por module_code y muscle_group

- [ ] **Crear test instrumentado para queries de SessionExerciseDao**
  - [ ] Archivo: `androidTest/.../data/local/dao/SessionExerciseDaoMetricsTest.kt`
  - [ ] Casos: `getClassificationCountsByPeriod()` excluye deload y NULL classifications, `getExerciseSessionRangeByPeriod()` retorna rango correcto, `getClassificationCountsBySessionIds()` agrupa por muscle_group correctamente

### Fase 4: MetricsRepository (interfaz + implementaciÃ³n)

<!-- Basado en Hito #4 del AnÃ¡lisis ArquitectÃ³nico -->
<!-- AC: CA-15.11, CA-15.17, todos los bloques vÃ­a queries encapsulados -->

#### ðŸ“¦ Domain Layer â€” Repository Interface

- [ ] **Crear `MetricsRepository`**
  - [ ] Crear archivo: `domain/repository/MetricsRepository.kt`
  - [ ] Interfaz:
    ```kotlin
    interface MetricsRepository {
        // Bloque C â€” Adherencia
        suspend fun getSessionsCompletedInWeek(weekStartDate: String, weekEndDate: String): Int
        suspend fun getWeeklyFrequency(): Int

        // Bloque C â€” RIR
        suspend fun getRirValuesByModule(moduleCode: String, sessionLimit: Int): List<Int>

        // Bloque A â€” ProgresiÃ³n
        suspend fun getClassificationCounts(startDate: String): List<ClassificationCount>
        suspend fun getClassificationCountsBySessionIds(sessionIds: List<Long>): List<ClassificationCountByGroup>
        suspend fun getExerciseSessionRanges(startDate: String): List<ExerciseSessionRange>
        suspend fun getAvgWeightForExerciseInSession(exerciseId: Long, sessionId: Long): Double?

        // Bloque B â€” Volumen
        suspend fun getSessionIdsGroupedByMicrocycle(): Map<Int, List<Long>>
        suspend fun getTonnageDataBySessionIds(sessionIds: List<Long>): List<SetTonnageData>
        suspend fun getSetDistributionBySessionIds(sessionIds: List<Long>): List<SetDistributionData>

        // Bloque B/E â€” EvoluciÃ³n
        suspend fun getMicrocycleCount(): Int
    }
    ```
  - [ ] **Nota ADR-05:** Los DTOs del repositorio (`ClassificationCount`, `SetTonnageData`, `SetDistributionData`, `ExerciseSessionRange`, `ClassificationCountByGroup`) estÃ¡n definidos en `domain/model/`, no en `data/local/dao/`. Room mapea por alias de columna independientemente del paquete del DTO. Esto evita que la capa Domain importe de la capa Data.

#### ðŸ“¦ Data Layer â€” Repository Implementation

- [ ] **Crear `MetricsRepositoryImpl`**
  - [ ] Crear archivo: `data/repository/MetricsRepositoryImpl.kt`
  - [ ] `@Singleton class MetricsRepositoryImpl @Inject constructor(private val sessionDao: SessionDao, private val exerciseSetDao: ExerciseSetDao, private val sessionExerciseDao: SessionExerciseDao, private val profileDao: ProfileDao, private val rotationStateDao: RotationStateDao)` â€” **sin** `@Singleton` en la clase (el scope se define solo en `RepositoryModule` con `@Binds @Singleton`, consistente con `SessionRepositoryImpl`)
  - [ ] Implementar `getSessionsCompletedInWeek()`:
    ```kotlin
    override suspend fun getSessionsCompletedInWeek(weekStartDate: String, weekEndDate: String): Int =
        sessionDao.countSessionsInWeek(weekStartDate, weekEndDate)
    ```
  - [ ] Implementar `getWeeklyFrequency()`:
    ```kotlin
    override suspend fun getWeeklyFrequency(): Int {
        val profile = profileDao.getProfile().first()
        return profile?.weeklyFrequency ?: 6
    }
    ```
  - [ ] Implementar `getRirValuesByModule()`:
    ```kotlin
    override suspend fun getRirValuesByModule(moduleCode: String, sessionLimit: Int): List<Int> {
        val sessionIds = sessionDao.getSessionIdsByModuleInRange(moduleCode, sessionLimit)
        if (sessionIds.isEmpty()) return emptyList()
        return exerciseSetDao.getRirValuesBySessionIds(sessionIds)
    }
    ```
  - [ ] Implementar `getSessionIdsGroupedByMicrocycle()` (DecisiÃ³n 17 del arquitecto):
    ```kotlin
    override suspend fun getSessionIdsGroupedByMicrocycle(): Map<Int, List<Long>> {
        val sessions = sessionDao.getClosedSessionsOrdered()
        return sessions.chunked(6).mapIndexed { index, chunk ->
            (index + 1) to chunk.map { it.id }
        }.toMap()
    }
    ```
  - [ ] Implementar `getMicrocycleCount()`:
    ```kotlin
    override suspend fun getMicrocycleCount(): Int {
        val rotationState = rotationStateDao.getRotationState().first()
        return rotationState?.microcycleCount ?: 0
    }
    ```
  - [ ] Los demÃ¡s mÃ©todos delegan directamente al DAO correspondiente.
  - [ ] **Nota:** `getProfile().first()` usa `kotlinx.coroutines.flow.first` para convertir Flow a suspend.

### Fase 5: Use Cases (9)

<!-- Basado en Hito #5 del AnÃ¡lisis ArquitectÃ³nico -->
<!-- AC: todos los bloques A-E -->

#### ðŸ“¦ Domain Layer â€” Use Cases

- [ ] **Crear `GetMicrocycleMapUseCase`** (ADR-05: ViewModel no accede Repository)
  - [ ] Crear archivo: `domain/usecase/metrics/GetMicrocycleMapUseCase.kt`
  - [ ] `class GetMicrocycleMapUseCase @Inject constructor(private val metricsRepository: MetricsRepository)`
  - [ ] `suspend operator fun invoke(): Map<Int, List<Long>>`:
    ```kotlin
    return metricsRepository.getSessionIdsGroupedByMicrocycle()
    ```
  - [ ] **JustificaciÃ³n ADR-05:** VolumeViewModel y TrendViewModel necesitan el mapa de microciclos para: (1) determinar `totalMicrocycles` para el selector â—€â–¶ en G2, (2) contar microciclos completados para el guard de G3, (3) pasar el mapa a otros Use Cases que lo necesitan como parÃ¡metro. Sin este UseCase, los ViewModels importarÃ­an `MetricsRepository` directamente, violando la regla de dependencias UI â†’ ViewModel â†’ Domain â†’ Data (ADR-05). Este UseCase actÃºa como puente delgado que preserva la separaciÃ³n de capas.
- [ ] **Crear `GetAdherenceUseCase`** (AC: 16, 17, 18, 19)
  - [ ] Crear archivo: `domain/usecase/metrics/GetAdherenceUseCase.kt`
  - [ ] `class GetAdherenceUseCase @Inject constructor(private val metricsRepository: MetricsRepository)`
  - [ ] `suspend operator fun invoke(): AdherenceData`:
    ```kotlin
    val today = LocalDate.now()
    val weekStart = today.with(DayOfWeek.MONDAY).toString()
    val weekEnd = today.with(DayOfWeek.SUNDAY).toString()
    val completed = metricsRepository.getSessionsCompletedInWeek(weekStart, weekEnd)
    val planned = metricsRepository.getWeeklyFrequency()
    val percentage = AdherenceRule.calculate(completed, planned)
    return AdherenceData(completed, planned, percentage)
    ```
  - [ ] Semana ISO 8601 (lunes a domingo) calculada con `java.time.DayOfWeek`

- [ ] **Crear `GetAvgRirByModuleUseCase`** (AC: 13, 14, 15, 19)
  - [ ] Crear archivo: `domain/usecase/metrics/GetAvgRirByModuleUseCase.kt`
  - [ ] `class GetAvgRirByModuleUseCase @Inject constructor(private val metricsRepository: MetricsRepository)`
  - [ ] `suspend operator fun invoke(sessionLimit: Int = 2): List<RirByModule>`:
    ```kotlin
    return listOf("A", "B", "C").map { moduleCode ->
        val rirValues = metricsRepository.getRirValuesByModule(moduleCode, sessionLimit)
        val avg = AvgRirRule.calculate(rirValues)
        val interpretation = when {
            avg < 1.5 -> RirInterpretation.RISK_TOO_CLOSE
            avg > 3.5 -> RirInterpretation.INSUFFICIENT_STIMULUS
            else -> RirInterpretation.OPTIMAL
        }
        RirByModule(moduleCode, avg, interpretation)
    }
    ```

- [ ] **Crear `GetProgressionRateUseCase`** (AC: 1, 2, 5, 6)
  - [ ] Crear archivo: `domain/usecase/metrics/GetProgressionRateUseCase.kt`
  - [ ] `class GetProgressionRateUseCase @Inject constructor(private val metricsRepository: MetricsRepository)`
  - [ ] `suspend operator fun invoke(weeksBack: Int = 4): List<ExerciseProgressionRate>`:
    ```kotlin
    val startDate = LocalDate.now().minusWeeks(weeksBack.toLong()).toString()
    val counts = metricsRepository.getClassificationCounts(startDate)
    return counts.map { c ->
        ExerciseProgressionRate(
            exerciseId = c.exerciseId,
            exerciseName = c.exerciseName,
            rate = ProgressionRateRule.calculate(c.positiveCount, c.totalCount),
            isBodyweight = c.isBodyweight == 1,
        )
    }
    ```

- [ ] **Crear `GetLoadVelocityUseCase`** (AC: 3, 4, 5, 6)
  - [ ] Crear archivo: `domain/usecase/metrics/GetLoadVelocityUseCase.kt`
  - [ ] `class GetLoadVelocityUseCase @Inject constructor(private val metricsRepository: MetricsRepository)`
  - [ ] `suspend operator fun invoke(weeksBack: Int = 4): List<ExerciseLoadVelocity>`:
    ```kotlin
    val startDate = LocalDate.now().minusWeeks(weeksBack.toLong()).toString()
    val ranges = metricsRepository.getExerciseSessionRanges(startDate)
    return ranges.map { r ->
        if (r.isBodyweight == 1 || r.isIsometric == 1) {
            return@map ExerciseLoadVelocity(r.exerciseId, r.exerciseName, 0.0, isBodyweight = r.isBodyweight == 1)
        }
        val initialWeight = metricsRepository.getAvgWeightForExerciseInSession(r.exerciseId, r.firstSessionId) ?: 0.0
        val currentWeight = metricsRepository.getAvgWeightForExerciseInSession(r.exerciseId, r.lastSessionId) ?: 0.0
        val velocity = LoadVelocityRule.calculate(currentWeight, initialWeight, r.sessionCount)
        ExerciseLoadVelocity(r.exerciseId, r.exerciseName, velocity, isBodyweight = false)
    }
    ```
  - [ ] CA-15.05: bodyweight e isometric â†’ velocity N/A, se marca con `isBodyweight = true`

- [ ] **Crear `GetTonnageByMuscleGroupUseCase`** (AC: 7, 8, 9, 11, 12)
  - [ ] Crear archivo: `domain/usecase/metrics/GetTonnageByMuscleGroupUseCase.kt`
  - [ ] `class GetTonnageByMuscleGroupUseCase @Inject constructor(private val metricsRepository: MetricsRepository)`
  - [ ] `suspend operator fun invoke(sessionIds: List<Long>): List<MuscleGroupTonnage>`:
    ```kotlin
    if (sessionIds.isEmpty()) return emptyList()
    val tonnageData = metricsRepository.getTonnageDataBySessionIds(sessionIds)
    val sets = tonnageData.map { SetForTonnage(it.weightKg, it.reps, it.muscleGroup) }
    val tonnageMap = TonnageRule.calculateForMuscleGroup(sets)
    // Pad con los 12 grupos canÃ³nicos a 0.0 para que G2 siempre muestre 12 filas (Â§G2 EspecVis)
    val allGroups = listOf("Pecho", "Espalda", "Abdomen", "Hombro", "TrÃ­ceps", "BÃ­ceps",
        "CuÃ¡driceps", "Isquiotibiales", "GlÃºteos", "Aductores", "Abductores", "Gemelos")
    return allGroups.map { group -> MuscleGroupTonnage(group, tonnageMap[group] ?: 0.0) }
    ```
  - [ ] **Nota:** Recibe `sessionIds` directamente (obtenidos del microcycleMap por el ViewModel via `GetMicrocycleMapUseCase`) en lugar de llamar `getSessionIdsGroupedByMicrocycle()` internamente. Esto evita llamadas redundantes al repositorio y respeta ADR-05.

- [ ] **Crear `GetVolumeDistributionUseCase`** (AC: 10, 11, 12)
  - [ ] Crear archivo: `domain/usecase/metrics/GetVolumeDistributionUseCase.kt`
  - [ ] `class GetVolumeDistributionUseCase @Inject constructor(private val metricsRepository: MetricsRepository)`
  - [ ] `suspend operator fun invoke(sessionIds: List<Long>): Map<String, Map<String, Double>>`:
    ```kotlin
    if (sessionIds.isEmpty()) return emptyMap()
    val distribution = metricsRepository.getSetDistributionBySessionIds(sessionIds)
    // Group by module â†’ calculate distribution per module
    return distribution.groupBy { it.moduleCode }.mapValues { (_, moduleSets) ->
        val totalSets = moduleSets.sumOf { it.setCount }
        val setsByZone = moduleSets.associate { it.muscleZoneName to it.setCount }
        VolumeDistributionRule.calculate(setsByZone, totalSets)
    }
    ```
  - [ ] CA-15.10: distribuciÃ³n POR MÃ“DULO, no global (Nota 7 del arquitecto)

- [ ] **Crear `GetTonnageEvolutionUseCase`** (AC: 25, 26, 27, 28)
  - [ ] Crear archivo: `domain/usecase/metrics/GetTonnageEvolutionUseCase.kt`
  - [ ] `class GetTonnageEvolutionUseCase @Inject constructor(private val metricsRepository: MetricsRepository)`
  - [ ] `suspend operator fun invoke(microcycleMap: Map<Int, List<Long>>): List<TonnageSnapshot>`:
    ```kotlin
    return microcycleMap.map { (number, sessionIds) ->
        val tonnageData = metricsRepository.getTonnageDataBySessionIds(sessionIds)
        val sets = tonnageData.map { SetForTonnage(it.weightKg, it.reps, it.muscleGroup) }
        val tonnageMap = TonnageRule.calculateForMuscleGroup(sets)
        TonnageSnapshot(number, tonnageMap)
    }
    ```
  - [ ] **Nota:** Recibe el `microcycleMap` como parÃ¡metro (ya obtenido por `GetMicrocycleMapUseCase`) para evitar llamar `getSessionIdsGroupedByMicrocycle()` mÃºltiples veces.

- [ ] **Crear `GetMuscleGroupTrendUseCase`** (AC: 20, 21, 22, 23, 24)
  - [ ] Crear archivo: `domain/usecase/metrics/GetMuscleGroupTrendUseCase.kt`
  - [ ] `class GetMuscleGroupTrendUseCase @Inject constructor(private val metricsRepository: MetricsRepository)`
  - [ ] `suspend operator fun invoke(microcycleMap: Map<Int, List<Long>>): List<MuscleGroupTrend>`:
    ```kotlin
    val completedMicrocycles = microcycleMap.filterCompletedOnly()
    if (completedMicrocycles.size < 4) return emptyList() // CA-15.23

    val recentMicrocycles = completedMicrocycles.entries
        .sortedByDescending { it.key }
        .take(6)
        .sortedBy { it.key }

    // 1. Calculate tonnage per group per microcycle
    val tonnageSnapshots = recentMicrocycles.map { (number, sessionIds) ->
        val data = metricsRepository.getTonnageDataBySessionIds(sessionIds)
        val sets = data.map { SetForTonnage(it.weightKg, it.reps, it.muscleGroup) }
        number to TonnageRule.calculateForMuscleGroup(sets)
    }

    // 2. Calculate avg progression rate per group per microcycle (CA-15.20: dual metric)
    // Nota: se filtran microciclos de deload (donde counts retorna vacÃ­o)
    // para evitar inyectar 0% artificial que sesgarÃ­a la tendencia a DECLINING
    val progressionSnapshots = recentMicrocycles.mapNotNull { (number, sessionIds) ->
        val counts = metricsRepository.getClassificationCountsBySessionIds(sessionIds)
        if (counts.isEmpty()) return@mapNotNull null // Microciclo de deload: sin datos de progresiÃ³n real
        val ratesByGroup = counts.groupBy { it.muscleGroup }
            .mapValues { (_, groupCounts) ->
                val totalPositive = groupCounts.sumOf { it.positiveCount }
                val totalAll = groupCounts.sumOf { it.totalCount }
                ProgressionRateRule.calculate(totalPositive, totalAll)
            }
        number to ratesByGroup
    }

    // Get all muscle groups present
    val allGroups = tonnageSnapshots.flatMap { it.second.keys }.distinct()

    return allGroups.map { group ->
        // Tonnage trend
        val tonnageValues = tonnageSnapshots.map { it.second[group] ?: 0.0 }
        val tonnageTrend = TrendClassificationRule.classify(tonnageValues)

        // Progression rate trend (solo microciclos con datos reales, sin deload)
        val rateValues = progressionSnapshots.map { it.second[group] ?: 0.0 }
        val rateTrend = if (rateValues.size >= 2) {
            TrendClassificationRule.classify(rateValues)
        } else {
            TrendDirection.STABLE // Insuficientes microciclos no-deload para tendencia de tasa
        }

        // Combine: most conservative wins (DecisiÃ³n 5 del arquitecto)
        val combined = when {
            tonnageTrend == TrendDirection.DECLINING || rateTrend == TrendDirection.DECLINING -> TrendDirection.DECLINING
            tonnageTrend == TrendDirection.STABLE || rateTrend == TrendDirection.STABLE -> TrendDirection.STABLE
            else -> TrendDirection.ASCENDING
        }
        MuscleGroupTrend(group, combined)
    }
    ```
  - [ ] **Nota:** Recibe `microcycleMap` como parÃ¡metro (ya obtenido por `GetMicrocycleMapUseCase`) para respetar ADR-05.
  - [ ] **FunciÃ³n helper** `Map<Int, List<Long>>.filterCompletedOnly()`: filtra entries donde `sessionIds.size == 6` (microciclo completo).
  - [ ] **Nota sobre deload en tasa de progresiÃ³n (correcciÃ³n auditoria R2):** Los microciclos de deload pasan `filterCompletedOnly()` (tienen 6 sesiones) pero `getClassificationCountsBySessionIds()` filtra `AND s.deload_id IS NULL`, retornando vacÃ­o. En lugar de inyectar 0.0 (que sesgarÃ­a a DECLINING), se usa `mapNotNull` para excluir estos puntos del cÃ¡lculo de tendencia de tasa. El tonelaje SÃ incluye microciclos de deload (el dip del 60% es informativo).
  - [ ] **Nota sobre doble mÃ©trica (CA-15.20):** Se implementa la combinaciÃ³n completa: tonnage trend + progression rate trend por grupo muscular. La clasificaciÃ³n mÃ¡s conservadora prevalece: DECLINING > STABLE > ASCENDING.

### Fase 6: DI binding

<!-- Basado en Hito #6 del AnÃ¡lisis ArquitectÃ³nico -->

#### ðŸ“¦ DI Layer

- [ ] **Modificar `RepositoryModule`**
  - [ ] Agregar binding:
    ```kotlin
    @Binds
    @Singleton
    abstract fun bindMetricsRepository(
        impl: MetricsRepositoryImpl,
    ): MetricsRepository
    ```
  - [ ] Agregar imports: `MetricsRepository`, `MetricsRepositoryImpl`

### Fase 7: G1 â€” MetricsScreen + ViewModel

<!-- Basado en Hito #7 del AnÃ¡lisis ArquitectÃ³nico -->
<!-- AC: CA-15.02, CA-15.06, CA-15.14, CA-15.15, CA-15.19 -->

#### ðŸ“¦ UI Layer (estado)

- [ ] **Crear `MetricsUiState`**
  - [ ] Crear archivo: `ui/metrics/MetricsUiState.kt`
  - [ ] `sealed interface MetricsUiState`
  - [ ] `data object Loading : MetricsUiState`
  - [ ] `data class Content(val adherence: AdherenceData, val rirByModule: List<RirByModule>, val progressionRates: List<ExerciseProgressionRate>, val loadVelocities: List<ExerciseLoadVelocity>) : MetricsUiState`
  - [ ] `data class Error(val message: String) : MetricsUiState`

#### ðŸ“¦ UI Layer (ViewModel)

- [ ] **Crear `MetricsViewModel`**
  - [ ] Crear archivo: `ui/metrics/MetricsViewModel.kt`
  - [ ] `@HiltViewModel class MetricsViewModel @Inject constructor(private val getAdherenceUseCase: GetAdherenceUseCase, private val getAvgRirByModuleUseCase: GetAvgRirByModuleUseCase, private val getProgressionRateUseCase: GetProgressionRateUseCase, private val getLoadVelocityUseCase: GetLoadVelocityUseCase)`
  - [ ] `private val _uiState = MutableStateFlow<MetricsUiState>(MetricsUiState.Loading)`
  - [ ] `val uiState: StateFlow<MetricsUiState> = _uiState.asStateFlow()`
  - [ ] `private var progressionWeeks = 4` â€” perÃ­odo configurable (4/8/12)
  - [ ] `private var rirSessionLimit = 2` â€” perÃ­odo configurable (2/4/6)
  - [ ] `init { loadMetrics() }`
  - [ ] `private fun loadMetrics()`:
    ```kotlin
    viewModelScope.launch {
        try {
            val adherence = getAdherenceUseCase()
            val rir = getAvgRirByModuleUseCase(rirSessionLimit)
            val rates = getProgressionRateUseCase(progressionWeeks)
            val velocities = getLoadVelocityUseCase(progressionWeeks)
            _uiState.value = MetricsUiState.Content(adherence, rir, rates, velocities)
        } catch (e: Exception) {
            _uiState.value = MetricsUiState.Error(e.message ?: "Error al cargar mÃ©tricas")
        }
    }
    ```
  - [ ] `fun changeProgressionPeriod(weeks: Int)`:
    ```kotlin
    progressionWeeks = weeks
    loadMetrics()
    ```
  - [ ] `fun changeRirPeriod(sessionLimit: Int)`:
    ```kotlin
    rirSessionLimit = sessionLimit
    loadMetrics()
    ```

#### ðŸ“¦ UI Layer (composable)

- [ ] **Crear `MetricsScreen`** (AC: 6, 19)
  - [ ] Crear archivo: `ui/metrics/MetricsScreen.kt`
  - [ ] ParÃ¡metros: `onNavigateToVolume: () -> Unit`, `onNavigateToTrend: () -> Unit`, `onNavigateToExerciseHistory: (Long) -> Unit`
  - [ ] Scaffold con `CenterAlignedTopAppBar` sin navigationIcon (Â§G1): "MÃ©tricas"
  - [ ] Body: `LazyColumn` con 6 items:

    **Item 1 â€” Adherencia (SecciÃ³n 1):**
    - Filled Card (Secondary Container `#F0E0E0`, corner 12.dp)
    - "Adherencia semanal" Title Medium, On Secondary Container
    - Porcentaje: Headline Medium, Primary (`#8B1A1A`)
    - Desglose: Body Medium "{completedSessions} de {plannedSessions} sesiones esta semana"

    **Item 2 â€” RIR Promedio (SecciÃ³n 2):**
    - Filled Card (Surface Container High, corner 12.dp)
    - `ExposedDropdownMenuBox` con opciones "2 Ãºltimas sesiones" (defecto), "4 Ãºltimas sesiones", "6 Ãºltimas sesiones"
    - 3 filas (A, B, C): Row â€” Title Medium (mÃ³dulo) + Body Medium fontWeight Medium (valor RIR) + Badge interpretaciÃ³n
    - Badge Ã“ptimo (2.0-3.0): containerColor `#E8F5E9`, label `#1B5E20` ðŸŸ¢
    - Badge Riesgo (<1.5): containerColor `#FFDAD6`, label `#410002` ðŸ”´
    - Badge Insuficiente (>3.5): containerColor `#FFF8E1`, label `#5D4200` ðŸŸ¡
    - Referencia: Body Small "2-3 = Ã³ptimo, < 1.5 = riesgo, > 3.5 = insuficiente"

    **Item 3 â€” Tasa de ProgresiÃ³n (SecciÃ³n 3):**
    - Divider M3 (Outline Variant, margin vertical 16.dp) entre SecciÃ³n 2 y SecciÃ³n 3
    - `ExposedDropdownMenuBox`: "4 semanas" (defecto), "8 semanas", "12 semanas"
    - Lista de ejercicios: ListItem M3 56dp
    - headlineContent: Title Medium (nombre ejercicio)
    - trailingContent: Body Medium fontWeight Medium (porcentaje) + trend icon:
      - â‰¥ 60%: â†‘ verde `#2E7D32` (light) / `#81C784` (dark)
      - 40-59%: = Ã¡mbar `#8D6E00` (light) / `#FFD54F` (dark)
      - < 40%: â†“ rojo `#C62828` (light) / `#EF9A9A` (dark)
    - Clickable â†’ `onNavigateToExerciseHistory(exerciseId)`
    - Divider entre filas

    **Item 4 â€” Velocidad de Carga (SecciÃ³n 4):**
    - Divider M3 (Outline Variant, margin vertical 16.dp) entre SecciÃ³n 3 y SecciÃ³n 4
    - Lista de ejercicios: ListItem M3 56dp
    - headlineContent: Title Medium (nombre)
    - trailingContent: Body Medium ("+X.X Kg/sesiÃ³n" o "0 Kg/sesiÃ³n")
    - Bodyweight: trailing "N/A" On Surface Variant, fontStyle italic
    - Clickable â†’ `onNavigateToExerciseHistory(exerciseId)`
    - Divider entre filas

    **Item 5 â€” Quick link "Volumen por Grupo Muscular â†’":**
    - Divider M3 (Outline Variant, margin vertical 16.dp) entre SecciÃ³n 4 y quick links (Â§G1 EspecVis)
    - Text Button, color Primary, full width left-aligned â†’ `onNavigateToVolume()`

    **Item 6 â€” Quick link "Tendencia de ProgresiÃ³n â†’":**
    - Text Button, color Primary â†’ `onNavigateToTrend()`

### Fase 8: G2 â€” VolumeScreen + ViewModel

<!-- Basado en Hito #8 del AnÃ¡lisis ArquitectÃ³nico -->
<!-- AC: CA-15.07, CA-15.08, CA-15.09, CA-15.10, CA-15.11, CA-15.12, CA-15.25, CA-15.26, CA-15.27, CA-15.28 -->

#### ðŸ“¦ UI Layer (estado)

- [ ] **Crear `VolumeUiState`**
  - [ ] Crear archivo: `ui/metrics/VolumeUiState.kt`
  - [ ] `sealed interface VolumeUiState`
  - [ ] `data object Loading : VolumeUiState`
  - [ ] `data class Content(val tonnageByGroup: List<MuscleGroupTonnage>, val distributionByModule: Map<String, Map<String, Double>>, val evolution: List<TonnageSnapshot>, val selectedMicrocycle: Int, val totalMicrocycles: Int, val insufficientEvolution: Boolean) : VolumeUiState`
  - [ ] `data class Error(val message: String) : VolumeUiState`

#### ðŸ“¦ UI Layer (ViewModel)

- [ ] **Crear `VolumeViewModel`**
  - [ ] Crear archivo: `ui/metrics/VolumeViewModel.kt`
  - [ ] `@HiltViewModel class VolumeViewModel @Inject constructor(private val getMicrocycleMapUseCase: GetMicrocycleMapUseCase, private val getTonnageByMuscleGroupUseCase: GetTonnageByMuscleGroupUseCase, private val getVolumeDistributionUseCase: GetVolumeDistributionUseCase, private val getTonnageEvolutionUseCase: GetTonnageEvolutionUseCase)`
  - [ ] `private val _uiState = MutableStateFlow<VolumeUiState>(VolumeUiState.Loading)`
  - [ ] `val uiState: StateFlow<VolumeUiState> = _uiState.asStateFlow()`
  - [ ] `private var totalMicrocycles = 0`
  - [ ] `private var microcycleMap: Map<Int, List<Long>> = emptyMap()`
  - [ ] `init { loadVolume() }`
  - [ ] `private fun loadVolume()`:
    ```kotlin
    viewModelScope.launch {
        try {
            microcycleMap = getMicrocycleMapUseCase()
            totalMicrocycles = microcycleMap.size
            val selectedMicrocycle = totalMicrocycles.coerceAtLeast(1)
            val sessionIds = microcycleMap[selectedMicrocycle] ?: emptyList()
            val tonnage = getTonnageByMuscleGroupUseCase(sessionIds)
            val distribution = getVolumeDistributionUseCase(sessionIds)
            val evolution = getTonnageEvolutionUseCase(microcycleMap)
            _uiState.value = VolumeUiState.Content(
                tonnageByGroup = tonnage,
                distributionByModule = distribution,
                evolution = evolution,
                selectedMicrocycle = selectedMicrocycle,
                totalMicrocycles = totalMicrocycles,
                insufficientEvolution = totalMicrocycles < 2,
            )
        } catch (e: Exception) {
            _uiState.value = VolumeUiState.Error(e.message ?: "Error al cargar volumen")
        }
    }
    ```
  - [ ] **Nota ADR-05:** Se inyecta `GetMicrocycleMapUseCase` en lugar de `MetricsRepository`. El mapa se obtiene una vez y se pasa como parÃ¡metro a los otros use cases, evitando llamadas redundantes y respetando la regla de dependencias UI â†’ ViewModel â†’ Domain â†’ Data.
  - [ ] `fun selectMicrocycle(microcycleNumber: Int)`:
    ```kotlin
    viewModelScope.launch {
        val sessionIds = microcycleMap[microcycleNumber] ?: emptyList()
        val tonnage = getTonnageByMuscleGroupUseCase(sessionIds)
        val distribution = getVolumeDistributionUseCase(sessionIds)
        val current = (_uiState.value as? VolumeUiState.Content) ?: return@launch
        _uiState.value = current.copy(
            tonnageByGroup = tonnage,
            distributionByModule = distribution,
            selectedMicrocycle = microcycleNumber,
        )
    }
    ```

#### ðŸ“¦ UI Layer (composable)

- [ ] **Crear `VolumeScreen`** (AC: 12, 25, 26, 27, 28)
  - [ ] Crear archivo: `ui/metrics/VolumeScreen.kt`
  - [ ] ParÃ¡metros: `onNavigateBack: () -> Unit`
  - [ ] Scaffold con `CenterAlignedTopAppBar`: navigationIcon ArrowBack â†’ `onNavigateBack()`, title "Volumen por Grupo Muscular"
  - [ ] Body: `LazyColumn` con 4 secciones:

    **SecciÃ³n 1 â€” Selector de microciclo:**
    - Row centered: IconButton â—€ + Text "Microciclo {n}" Title Medium + IconButton â–¶
    - Disabled en extremos (first/last) con tint 38% opacity

    **SecciÃ³n 2 â€” Tonelaje por grupo muscular:**
    - Filled Card (Surface Container, corner 12.dp)
    - 12 filas: Row â€” Body Medium (nombre, ancho fijo 120.dp) + barra horizontal (Surface Variant background, Primary fill, height 16.dp, corner 4.dp, width proporcional a mÃ¡ximo) + Body Medium On Surface Variant ("{X,XXX} Kg" right-aligned)
    - Row spacing 8.dp

    **SecciÃ³n 3 â€” DistribuciÃ³n de volumen (%):**
    - Filled Card (Surface Container, corner 12.dp)
    - POR MÃ“DULO: Title Small "MÃ³dulo {code}" + filas por **zona muscular** (15 zonas: Pecho Medio, Pecho Superior, etc.) con barra Secondary (`#6B4F4F`) + Body Medium "{XX}%"
    - **Nota CA-15.10 + RF49:** Muestra zonas musculares (15), no grupos (12). Permite detectar imbalances intra-grupo (ej: Pecho Medio 60% vs Pecho Superior 15%).

    **SecciÃ³n 4 â€” EvoluciÃ³n temporal:**
    - Si `insufficientEvolution` â†’ Column centered: Body Large "Se necesitan al menos 2 microciclos para mostrar evoluciÃ³n comparativa." (CA-15.28)
    - Si suficiente â†’ Filled Card (Surface Container, corner 12.dp, height 200.dp) con `TonnageChartComposable`

- [ ] **Crear `TonnageChartComposable`** (AC: 25, 26)
  - [ ] Crear archivo: `ui/metrics/TonnageChartComposable.kt`
  - [ ] ParÃ¡metros: `snapshots: List<TonnageSnapshot>`, `modifier: Modifier`
  - [ ] Canvas composable con draw commands:
    - Eje X: nÃºmeros de microciclo (Label Small, On Surface Variant)
    - Eje Y: tonelaje en Kg (Label Small, auto-scaled, mÃ­nimo 1 Kg)
    - LÃ­neas: una por grupo muscular, colores diferenciados (Primary `#8B1A1A`, Secondary `#6B4F4F`, Tertiary `#5C6B4F` + variantes)
    - `drawLine()` conectando puntos de datos
    - `drawCircle()` en cada punto
    - Leyenda inferior: Row con Label Small + punto de color + nombre del grupo
  - [ ] Grid: lÃ­neas dashed (Outline Variant)
  - [ ] **Nota:** El Canvas renderiza mÃ¡ximo 12 lÃ­neas Ã— 20 puntos = 240 draw calls. Trivial para composiciÃ³n.

### Fase 9: G3 â€” TrendScreen + ViewModel

<!-- Basado en Hito #9 del AnÃ¡lisis ArquitectÃ³nico -->
<!-- AC: CA-15.20, CA-15.21, CA-15.22, CA-15.23, CA-15.24 -->

#### ðŸ“¦ UI Layer (estado)

- [ ] **Crear `TrendUiState`**
  - [ ] Crear archivo: `ui/metrics/TrendUiState.kt`
  - [ ] `sealed interface TrendUiState`
  - [ ] `data object Loading : TrendUiState`
  - [ ] `data class Content(val trends: List<MuscleGroupTrend>) : TrendUiState`
  - [ ] `data class InsufficientData(val remaining: Int) : TrendUiState`
  - [ ] `data class Error(val message: String) : TrendUiState`

#### ðŸ“¦ UI Layer (ViewModel)

- [ ] **Crear `TrendViewModel`**
  - [ ] Crear archivo: `ui/metrics/TrendViewModel.kt`
  - [ ] `@HiltViewModel class TrendViewModel @Inject constructor(private val getMicrocycleMapUseCase: GetMicrocycleMapUseCase, private val getMuscleGroupTrendUseCase: GetMuscleGroupTrendUseCase)`
  - [ ] `init { loadTrends() }`
  - [ ] `private fun loadTrends()`:
    ```kotlin
    viewModelScope.launch {
        try {
            val microcycleMap = getMicrocycleMapUseCase()
            val completedCount = microcycleMap.count { it.value.size == 6 }
            if (completedCount < 4) {
                _uiState.value = TrendUiState.InsufficientData(remaining = 4 - completedCount)
                return@launch
            }
            val trends = getMuscleGroupTrendUseCase(microcycleMap)
            _uiState.value = TrendUiState.Content(trends)
        } catch (e: Exception) {
            _uiState.value = TrendUiState.Error(e.message ?: "Error al cargar tendencias")
        }
    }
    ```

#### ðŸ“¦ UI Layer (composable)

- [ ] **Crear `TrendScreen`** (AC: 20, 21, 22, 23, 24)
  - [ ] Crear archivo: `ui/metrics/TrendScreen.kt`
  - [ ] ParÃ¡metros: `onNavigateBack: () -> Unit`
  - [ ] Scaffold con `CenterAlignedTopAppBar`: navigationIcon ArrowBack â†’ `onNavigateBack()`, title "Tendencia de ProgresiÃ³n"
  - [ ] Body:
    - Si `Content` â†’ Text "EvaluaciÃ³n: Ãºltimos 4-6 microciclos" Body Medium On Surface Variant + `LazyColumn` con 12 filas
    - Si `InsufficientData` â†’ Column centered: Body Large "Se necesitan al menos 4 microciclos completados. Faltan {remaining} microciclos." (CA-15.23)

    **Fila de grupo muscular:**
    - ListItem M3 56dp
    - headlineContent: Title Medium, On Surface (nombre grupo)
    - trailingContent: Row â€” Body Medium (clasificaciÃ³n en espaÃ±ol) + Ã­cono 16dp
    - **Mapeo TrendDirection â†’ texto display (espaÃ±ol, ADR-17):**
      - `ASCENDING` â†’ "Ascendente"
      - `STABLE` â†’ "Estable"
      - `DECLINING` â†’ "En declive"
    - Colores (EspecificaciÃ³n Visual Â§4.3):
      - Ascendente: verde `#2E7D32` (light) / `#81C784` (dark), Ã­cono ðŸ“ˆ
      - Estable: Ã¡mbar `#8D6E00` (light) / `#FFD54F` (dark), Ã­cono ðŸ“Š
      - En declive: rojo `#C62828` (light) / `#EF9A9A` (dark), Ã­cono ðŸ“‰
    - Divider M3 entre filas

### Fase 10: NavegaciÃ³n + integraciÃ³n

<!-- Basado en Hito #10 del AnÃ¡lisis ArquitectÃ³nico -->

#### ðŸ“¦ Navigation

- [ ] **Modificar `NavigationRoutes`**
  - [ ] Agregar:
    ```kotlin
    const val MUSCLE_VOLUME = "muscle-volume"
    const val PROGRESSION_TREND = "progression-trend"
    ```

- [ ] **Modificar `BottomNavigationBar`** â€” mantener MÃ©tricas activo en G2 y G3
  - [ ] Agregar `childRoutes` al tab METRICS:
    ```kotlin
    BottomNavItem(
        route = NavigationRoutes.METRICS,
        labelResId = R.string.nav_metrics,
        selectedIcon = Icons.Filled.BarChart,
        unselectedIcon = Icons.Outlined.BarChart,
        childRoutes = setOf(
            NavigationRoutes.MUSCLE_VOLUME,
            NavigationRoutes.PROGRESSION_TREND,
        ),
    ),
    ```

- [ ] **Modificar `TensionNavHost`** â€” reemplazar PlaceholderScreen y registrar G2, G3
  - [ ] Reemplazar placeholder L244-245:
    ```kotlin
    composable(NavigationRoutes.METRICS) {
        MetricsScreen(
            onNavigateToVolume = {
                navController.navigate(NavigationRoutes.MUSCLE_VOLUME)
            },
            onNavigateToTrend = {
                navController.navigate(NavigationRoutes.PROGRESSION_TREND)
            },
            onNavigateToExerciseHistory = { exerciseId ->
                navController.navigate(
                    NavigationRoutes.exerciseHistoryRoute(exerciseId),
                )
            },
        )
    }
    ```
  - [ ] Registrar G2 despuÃ©s del bloque METRICS:
    ```kotlin
    composable(NavigationRoutes.MUSCLE_VOLUME) {
        VolumeScreen(
            onNavigateBack = { navController.popBackStack() },
        )
    }
    ```
  - [ ] Registrar G3:
    ```kotlin
    composable(NavigationRoutes.PROGRESSION_TREND) {
        TrendScreen(
            onNavigateBack = { navController.popBackStack() },
        )
    }
    ```
  - [ ] **Nota:** `showBottomBar` NO necesita excluir `muscle-volume` ni `progression-trend` â€” ambas pantallas SÃ tienen Bottom Navigation (EspecificaciÃ³n Visual Â§G2 y Â§G3). Ya se muestran correctamente con la lÃ³gica actual.

### Fase N: QA y Deployment

- [ ] **Ejecutar Agente Peer Review** (MANUAL)
- [ ] **Resolver incidentes del Peer Review** (MANUAL, condicional)
- [ ] **Crear Pull Request** (MANUAL)
- [ ] **Ejecutar pipeline deployment DEV** (MANUAL)
- [ ] **DiseÃ±ar set de pruebas manuales** (MANUAL)
- [ ] **Ejecutar pruebas manuales** (MANUAL)

---

**Notas sobre vinculaciÃ³n con Criterios de AceptaciÃ³n:**

**CA-15.01 â€” Tasa de ProgresiÃ³n:**
â†’ Fase 1 (`ProgressionRateRule.calculate(positiveCount, totalCount)`) + Fase 3 (`getClassificationCountsByPeriod` con filtro deload+fecha) + Fase 5 (`GetProgressionRateUseCase`) + Fase 7 (G1 SecciÃ³n 3)

**CA-15.02 â€” PerÃ­odo configurable:**
â†’ Fase 7 (`ExposedDropdownMenuBox` con opciones 4/8/12 semanas, `MetricsViewModel.changeProgressionPeriod()`)

**CA-15.03 â€” Velocidad de Carga:**
â†’ Fase 1 (`LoadVelocityRule.calculate(current, initial, sessions)`) + Fase 3 (`getExerciseSessionRangeByPeriod` + `getAvgWeightByExerciseInSession`) + Fase 5 (`GetLoadVelocityUseCase`) + Fase 7 (G1 SecciÃ³n 4)

**CA-15.04 â€” Velocidad 0 sin incremento:**
â†’ Fase 1 (`LoadVelocityRule`: si `current == initial` â†’ 0.0)

**CA-15.05 â€” Bodyweight excluido de velocidad:**
â†’ Fase 5 (`GetLoadVelocityUseCase`: guard `if (isBodyweight || isIsometric)`) + Fase 7 (trailing "N/A" italic)

**CA-15.06 â€” PresentaciÃ³n KPIs rendimiento:**
â†’ Fase 7 (G1 Secciones 3+4: lista por ejercicio con % y Kg/sesiÃ³n)

**CA-15.07 â€” Tonelaje Acumulado:**
â†’ Fase 1 (`TonnageRule.calculateForMuscleGroup(sets)`) + Fase 3 (`getTonnageDataBySessionIds` con JOIN exercise_muscle_zone â†’ muscle_zone) + Fase 5 (`GetTonnageByMuscleGroupUseCase`) + Fase 8 (G2 barras)

**CA-15.08 â€” AgrupaciÃ³n por zona del Diccionario:**
â†’ Fase 3 (`muscle_zone.muscle_group` como GROUP BY en queries de tonelaje)

**CA-15.09 â€” Ejercicios multi-zona:**
â†’ Fase 3 (el JOIN produce duplicados intencionales) + Fase 1 (`TonnageRule` suma todo por grupo â†’ contabilizaciÃ³n 100% en cada grupo)

**CA-15.10 â€” DistribuciÃ³n por mÃ³dulo:**
â†’ Fase 1 (`VolumeDistributionRule`) + Fase 3 (`getSetDistributionBySessionIds` con GROUP BY `mz.name` â€” 15 zonas musculares, por mÃ³dulo) + Fase 5 (`GetVolumeDistributionUseCase`) + Fase 8 (G2 distribuciÃ³n por mÃ³dulo con zonas)

**CA-15.11 â€” CÃ¡lculo por microciclo:**
â†’ Fase 4 (`getSessionIdsGroupedByMicrocycle`: bloques de 6 sesiones, derivaciÃ³n Kotlin)

**CA-15.12 â€” PresentaciÃ³n KPIs volumen:**
â†’ Fase 8 (G2: barras tonelaje + distribuciÃ³n % + referencia microciclo)

**CA-15.13 â€” RIR Promedio:**
â†’ Fase 1 (`AvgRirRule.calculate(rirValues)`) + Fase 3 (`getRirValuesBySessionIds`) + Fase 5 (`GetAvgRirByModuleUseCase`) + Fase 7 (G1 SecciÃ³n 2)

**CA-15.14 â€” PerÃ­odo RIR:**
â†’ Fase 7 (`ExposedDropdownMenuBox` con opciones 2/4/6 sesiones, `MetricsViewModel.changeRirPeriod()`)

**CA-15.15 â€” InterpretaciÃ³n RIR:**
â†’ Fase 2 (`RirInterpretation` enum) + Fase 5 (clasificaciÃ³n en UseCase) + Fase 7 (badges coloreados + referencia textual)

**CA-15.16 â€” Adherencia:**
â†’ Fase 1 (`AdherenceRule.calculate(completed, planned)` capped 100%) + Fase 5 (`GetAdherenceUseCase` con semana ISO) + Fase 7 (G1 SecciÃ³n 1)

**CA-15.17 â€” Frecuencia del perfil:**
â†’ Fase 4 (`getWeeklyFrequency()` vÃ­a `ProfileDao.getProfile()`)

**CA-15.18 â€” COMPLETED + INCOMPLETE:**
â†’ Fase 3 (todos los queries usan `status IN ('COMPLETED', 'INCOMPLETE')`)

**CA-15.19 â€” PresentaciÃ³n intensidad/adherencia:**
â†’ Fase 7 (G1 Secciones 1+2)

**CA-15.20 â€” Tendencia por grupo:**
â†’ Fase 1 (`TrendClassificationRule.classify(values)`) + Fase 5 (`GetMuscleGroupTrendUseCase`) + Fase 9 (G3 lista)

**CA-15.21 â€” ClasificaciÃ³n tendencia:**
â†’ Fase 1 (ASCENDING/STABLE/DECLINING con pendiente lineal Â±5%)

**CA-15.22 â€” Rango microciclos:**
â†’ Fase 5 (`GetMuscleGroupTrendUseCase`: Ãºltimos 4-6 microciclos)

**CA-15.23 â€” Datos insuficientes tendencia:**
â†’ Fase 9 (`TrendUiState.InsufficientData(remaining = 4 - count)`)

**CA-15.24 â€” PresentaciÃ³n por grupo:**
â†’ Fase 9 (G3: lista de 12 grupos con tendencia desglosada)

**CA-15.25 â€” EvoluciÃ³n tonelaje:**
â†’ Fase 5 (`GetTonnageEvolutionUseCase`) + Fase 8 (G2 grÃ¡fico Canvas)

**CA-15.26 â€” IdentificaciÃ³n tendencias tonelaje:**
â†’ Fase 8 (`TonnageChartComposable`: lÃ­neas permiten visualizar ascendente/estable/caÃ­da)

**CA-15.27 â€” Desglose 12 grupos:**
â†’ Fase 8 (G2: 12 filas en barras) + Fase 9 (G3: 12 filas)

**CA-15.28 â€” Datos insuficientes evoluciÃ³n:**
â†’ Fase 8 (`VolumeUiState.Content.insufficientEvolution` â†’ mensaje "Se necesitan al menos 2 microciclos")

---

### AuditorÃ­a del Refinamiento

<!-- Ronda 1: Ejecutada 2026-02-18 â€” Self-audit del desarrollador -->
<!-- Ronda 2: Ejecutada 2026-02-18 â€” AuditorÃ­a cruzada profunda contra documentaciÃ³n completa + 18 HUs + 29 archivos fuente -->
<!-- Alcance R2: 6 docs arquitectura + 5 docs negocio + 14 HUs dependientes + 4 HUs downstream + 29 archivos fuente -->
<!-- Verificaciones R2: 76 checks (SQL columns, JOINs, ADR compliance, RF coverage, KPI formulas, nav routes, patterns, CAs) -->

#### Hallazgos corregidos (Ronda 1): 4

| # | Severidad | Hallazgo | CorrecciÃ³n aplicada |
| --- | --- | --- | --- |
| R1-H1 | **HIGH** | `GetMuscleGroupTrendUseCase` solo usaba tonelaje, violando CA-15.20 que exige anÃ¡lisis de AMBAS mÃ©tricas (tonelaje + tasa de progresiÃ³n). Un grupo con tonelaje ascendente pero ejercicios estancados se clasificaba incorrectamente como ASCENDING. | Implementada doble mÃ©trica completa: `getClassificationCountsBySessionIds()` (nuevo query en SessionExerciseDao) + combinaciÃ³n conservadora (DECLINING > STABLE > ASCENDING). Nuevo DTO `ClassificationCountByGroup` que agrupa por muscle_group vÃ­a JOIN exercise_muscle_zone â†’ muscle_zone. |
| R1-H2 | **HIGH** | Inconsistencia entre `rotation_state.microcycleCount` (solo completados) y `getSessionIdsGroupedByMicrocycle()` (incluye parcial). VolumeViewModel usaba la primera como `totalMicrocycles` pero el map contiene una entry extra parcial â†’ selector â—€â–¶ inaccesible para microciclo parcial. TrendViewModel usaba guard con completed count pero analizaba con map que incluye parcial â†’ tonelaje artificialmente bajo en Ãºltimo punto. | Fuente de verdad unificada: `totalMicrocycles = map.size` en VolumeViewModel. TrendViewModel usa `filterCompletedOnly()` (entries con .size == 6) para tendencia. `getMicrocycleCount()` ya no se usa como guard en ViewModels. |
| R1-H3 | **HIGH** | Fase 3 no incluÃ­a tests instrumentados para los 7 queries DAO nuevos, pese a que el Hito #2 del arquitecto lo exige. Los queries cruzan 4-6 tablas con JOINs complejos â€” son la parte mÃ¡s propensa a errores. | Agregados 3 archivos de test instrumentado en Fase 3: `SessionDaoMetricsTest`, `ExerciseSetDaoMetricsTest`, `SessionExerciseDaoMetricsTest` con setup de DB en memoria y datos de ejemplo. |
| R1-M1 | **MEDIUM** | `getSessionIdsByModuleInRange()` para RIR promedio NO filtraba `deload_id IS NULL`. Las sesiones de deload tienen RIR objetivo ~4-5 (R5), inflando artificialmente el promedio y generando falsos positivos de INSUFFICIENT_STIMULUS. | Agregado filtro `AND s.deload_id IS NULL` al query. Consistente con la exclusiÃ³n de deload en Tasa de ProgresiÃ³n y Velocidad de Carga. |

#### Hallazgos corregidos (Ronda 2): 7

| # | Severidad | Hallazgo | CorrecciÃ³n aplicada |
| --- | --- | --- | --- |
| R2-H1 | **HIGH** | ViolaciÃ³n ADR-05: `VolumeViewModel` y `TrendViewModel` inyectaban `MetricsRepository` directamente para obtener la agrupaciÃ³n de microciclos. ADR-05 establece UI â†’ ViewModel â†’ Domain (UseCases) â†’ Data (Repository). | Creado `GetMicrocycleMapUseCase` que encapsula `getSessionIdsGroupedByMicrocycle()`. Ambos ViewModels ahora inyectan este UseCase en lugar de `MetricsRepository`. `GetTonnageByMuscleGroupUseCase`, `GetVolumeDistributionUseCase`, `GetTonnageEvolutionUseCase` y `GetMuscleGroupTrendUseCase` reciben el mapa como parÃ¡metro para evitar llamadas redundantes. |
| R2-H2 | **HIGH** | DistribuciÃ³n de Volumen (CA-15.10, RF49, MDS KPI 6) agrupaba por `mz.muscle_group` (12 grupos) en lugar de `mz.name` (15 zonas musculares). RF49 dice "porcentaje de series totales de cada **zona muscular**". El MDS da como ejemplo detectar imbalance entre Pecho Medio vs Pecho Superior â€” imposible con agrupaciÃ³n por grupo. | `getSetDistributionBySessionIds()` ahora usa `GROUP BY mz.name` (15 zonas). DTO `SetDistributionData.muscleGroup` renombrado a `muscleZoneName`. VolumeScreen G2 actualizado para mostrar 15 zonas por mÃ³dulo. |
| R2-H3 | **HIGH** | `GetTonnageByMuscleGroupUseCase` retornaba solo grupos con datos. La EspecificaciÃ³n Visual Â§G2 exige "12 filas (una por grupo muscular)" incondicionalmente. Grupos sin series en el microciclo seleccionado quedaban ausentes del resultado. | Agregado padding con los 12 grupos canÃ³nicos a 0.0: `allGroups.map { group -> MuscleGroupTonnage(group, tonnageMap[group] ?: 0.0) }`. G2 siempre muestra 12 filas. |
| R2-H4 | **HIGH** | `MetricsRepository` (interfaz en `domain/repository/`) importaba DTOs definidos junto a DAOs (`data/local/dao/`): `ClassificationCount`, `SetTonnageData`, `SetDistributionData`, `ExerciseSessionRange`, `ClassificationCountByGroup`. ViolaciÃ³n de la direcciÃ³n de dependencias Domain â†’ Data. | DTOs movidos a `domain/model/`. Room mapea por alias de columna independientemente del paquete del DTO. La interfaz `MetricsRepository` ya no importa nada de `data/`. |
| R2-M1 | **MEDIUM** | Microciclos de deload inyectaban 0% artificial en la tendencia de tasa de progresiÃ³n. Un microciclo de deload pasa `filterCompletedOnly()` (6 sesiones) pero `getClassificationCountsBySessionIds()` filtra `s.deload_id IS NULL` â†’ retorna vacÃ­o â†’ `?: 0.0` generaba un punto de datos falso que sesgaba `classify()` hacia DECLINING. | `GetMuscleGroupTrendUseCase` usa `mapNotNull` en `progressionSnapshots`: si `counts.isEmpty()` (microciclo de deload), el punto se excluye del cÃ¡lculo de tendencia de tasa. Si quedan < 2 puntos de tasa no-deload, la tendencia de tasa se clasifica como STABLE. El tonelaje SÃ incluye deload (el dip del 60% es informativo). |
| R2-M2 | **MEDIUM** | Faltaban Dividers entre secciones en MetricsScreen G1. La EspecificaciÃ³n Visual Â§G1 define explÃ­citamente `Separador (Divider M3)` con `Outline Variant Â· Margin vertical 16 dp` entre SecciÃ³n 4 y quick links. El Wireframe G1 muestra `---` entre todas las secciones. | Agregados Dividers M3 explÃ­citos: entre SecciÃ³n 2â†”3, SecciÃ³n 3â†”4, y SecciÃ³n 4â†”quick links. |
| R2-M3 | **MEDIUM** | `@Singleton` en `MetricsRepositoryImpl` inconsistente con patrÃ³n existente (`SessionRepositoryImpl` no tiene `@Singleton` en clase â€” el scope se define solo en `RepositoryModule` con `@Binds @Singleton`). | Removido `@Singleton` de la clase. Scope definido exclusivamente en `RepositoryModule`. |

#### Hallazgos corregidos (Ronda 2) â€” Menores: 4

| # | Severidad | Hallazgo | CorrecciÃ³n aplicada |
| --- | --- | --- | --- |
| R2-M4 | **MEDIUM** | `TrendDirection` enum no tenÃ­a mapeo explÃ­cito a texto display en espaÃ±ol. Â§G3 define "Ascendente", "Estable", "En declive" pero el refinamiento solo decÃ­a `Body Medium (clasificaciÃ³n)` sin especificar la conversiÃ³n. | Agregado mapeo explÃ­cito: `ASCENDING â†’ "Ascendente"`, `STABLE â†’ "Estable"`, `DECLINING â†’ "En declive"` en `TrendScreen`. |
| R2-M5 | **MEDIUM** | Colores hex para trend icons en G1 SecciÃ³n 3 (Tasa de ProgresiÃ³n) no estaban especificados. Solo decÃ­a "verde/Ã¡mbar/rojo" sin referenciar Â§4.3. | Agregados hex exactos: verde `#2E7D32`/`#81C784`, Ã¡mbar `#8D6E00`/`#FFD54F`, rojo `#C62828`/`#EF9A9A` para light/dark. |
| R2-M6 | **MEDIUM** | `SetWithMuscleGroups` referenciado en tabla de componentes (fila 29) y hitos pero renombrado a `SetForTonnage` en implementaciÃ³n. AmbigÃ¼edad en deliverables. | Tabla de componentes y hitos actualizados para usar `SetForTonnage` consistentemente. |
| R2-M7 | **MEDIUM** | `MicrocycleVolume` definido en Fase 2 pero nunca referenciado por ningÃºn UseCase ni ViewModel. CÃ³digo muerto. | Removido de Fase 2 y de listas de componentes. |

#### Hallazgos aceptados (sin correcciÃ³n necesaria): 10

| Severidad | Hallazgo | JustificaciÃ³n |
| --- | --- | --- |
| MEDIUM | `VolumeUiState` usa `Content(insufficientEvolution: Boolean)` en lugar del `InsufficientEvolution` sealed variant del arquitecto | DecisiÃ³n de diseÃ±o mejorada: permite mostrar tonelaje y distribuciÃ³n del microciclo actual incluso cuando no hay datos suficientes para evoluciÃ³n temporal. |
| MEDIUM | Velocidad de Carga: denominador usa `sessionCount - 1` (sesiones intermedias) vs MDS fÃ³rmula que dice "NÃºmero de sesiones" (total). | InterpretaciÃ³n correcta: RF48, CA-15.03 y texto MDS dicen "sesiones intermedias". La fÃ³rmula del MDS tiene label impreciso. Rate-of-change requiere intervalos = N-1. |
| MEDIUM | Umbral 5% para TrendClassificationRule no estÃ¡ documentado en negocio. | DecisiÃ³n tÃ©cnica razonable. Ni el MDS ni RF42 definen algoritmo ni umbral. El 5% evita ruido estadÃ­stico. Se documenta como decisiÃ³n de diseÃ±o. |
| MEDIUM | G2 DistribuciÃ³n sub-headers "MÃ³dulo {code}" no estÃ¡n en Â§G2 EspecificaciÃ³n Visual. | Wireframe G2 dice "...etc por mÃ³dulo..." confirmando la intenciÃ³n. El sub-header Title Small es implementaciÃ³n visual razonable sin contradicciÃ³n. |
| MEDIUM | No hay Compose UI tests para G1, G2, G3 (ADR-18 menciona Compose UI Tests). | Fase N incluye QA manual. Los 7 tests unitarios (rules) + 3 instrumentados (DAOs) cubren lÃ³gica de negocio. UI tests se pueden agregar iterativamente. |
| LOW | MIN/MAX de session_id en `getExerciseSessionRangeByPeriod()` asume correlaciÃ³n id-fecha | Correcto dado IDs autoincrement y creaciÃ³n secuencial. El query ya filtra por `date >= :startDate`. |
| LOW | `changeProgressionPeriod()` y `changeRirPeriod()` recargan todos los KPIs | Trade-off simplicidad > optimizaciÃ³n. Costo total < 50ms. No perceptible. |
| LOW | RIR 1.5-2.0 y 3.0-3.5 clasificados como OPTIMAL por catch-all `else` | Zonas de transiciÃ³n legÃ­timas. Consistente con MDS donde 3 bandas son exhaustivas. HU-17 alerta solo en extremos (<1.5, >3.5). |
| LOW | DTO mapping redundante `SetTonnageData â†’ SetForTonnage` (campos idÃ©nticos) | SeparaciÃ³n semÃ¡ntica intencional: uno es DTO de datos, otro es input de regla. El costo de mapping (1 `.map`) es trivial. |
| INFO | ExclusiÃ³n de isomÃ©tricos de Velocidad de Carga va mÃ¡s allÃ¡ del texto de CA-15.05 | Correcto: isomÃ©tricos no usan peso variable. Protege contra hipotÃ©ticos ejercicios isomÃ©tricos con peso futuro. |

#### Verificaciones cruzadas completadas (Ronda 2)

| Ãrea | Checks | Resultado |
|------|---------|-----------|
| SQL column names vs @ColumnInfo | 14 queries Ã— 3-7 columnas cada uno | âœ… 100% match |
| JOIN paths vs FK constraints | 6 paths (exercise_setâ†’session_exerciseâ†’sessionâ†’module_version, session_exerciseâ†’exerciseâ†’exercise_muscle_zoneâ†’muscle_zone) | âœ… Todos vÃ¡lidos |
| DAO method conflicts | 10 nuevos mÃ©todos vs 30+ existentes | âœ… Sin conflictos |
| Navigation route conflicts | 2 nuevas rutas vs 19 existentes | âœ… Sin conflictos |
| session.status values consistency | 5 HUs que definen/usan status | âœ… 'IN_PROGRESS', 'COMPLETED', 'INCOMPLETE' consistente |
| progression_classification values | HU-05 CHECK + HU-10 enum | âœ… 'POSITIVE_PROGRESSION' exacto |
| BottomNavigationBar childRoutes | Tab METRICS vs tabs de otros HUs | âœ… Sin solapamiento |
| TensionNavHost PlaceholderScreen | LÃ­neas 246-247 del cÃ³digo actual | âœ… UbicaciÃ³n correcta para reemplazo |
| DatabaseModule DAOs provistos | 15 DAOs necesarios | âœ… Todos disponibles |
| MDS KPIs 1-6 implementados | 6 KPIs vs 6 bloques del refinamiento | âœ… Completa cobertura (con fix de distribuciÃ³n por zona) |
| RFs cubiertos | RF42, RF44-49, RF52 | âœ… 8/8 RFs trazados |
| 12 muscle_groups canonical | Modelo de Datos Â§3.2 | âœ… 15 zonas â†’ 12 grupos confirmados |
| HU-07 substitution field | se.exercise_id (correcto para mÃ©tricas) | âœ… Atribuye datos al ejercicio ejecutado |
| HU-14 deload exclusion | 3 mÃ©tricas excluyen + 2 incluyen | âœ… Consistente con R5 y Nota 2 |
| HU-09 advanceRotation timing | microcycleCount + 1 al cerrar sesiÃ³n 6 | âœ… Consistente con chunking |
| HU-10 classification timing | Al cierre de sesiÃ³n (no al registro de set) | âœ… Solo COMPLETED/INCOMPLETE tienen clasificaciÃ³n |
| ADR-06 rules pattern | object singletons, funciones puras | âœ… 7 nuevas rules siguen patrÃ³n de 8 existentes |
| ADR-05 dependency direction | UI â†’ ViewModel â†’ UseCase â†’ Repository â†’ DAO | âœ… Corregido con GetMicrocycleMapUseCase |
| HU-17 downstream compatibility | Rules/UseCases reutilizables para alertas | âœ… Mismos umbrales, mismas rules |

#### Estado final del refinamiento

- **10 fases de implementaciÃ³n** (1-10 + N)
- **28/28 CAs** trazados con mecanismo de implementaciÃ³n
- **30 componentes nuevos + 7 modificados** (incluye `GetMicrocycleMapUseCase` + DTOs analÃ­ticos en domain/model)
- **3 archivos de test instrumentado** + **7 archivos de test unitario**
- **11 hallazgos corregidos** (R1: 4, R2: 7) + **4 menores corregidos** (R2) + **10 aceptados con justificaciÃ³n**
- **0 hallazgos pendientes**
