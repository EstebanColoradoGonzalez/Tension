# HU-18 — Backup y Restauración

## Requisitos relacionados

RNF15, RNF16, RNF17, RNF18, RNF26, RNF27

## Descripción

Como ejecutante, quiero poder exportar un respaldo completo de todos mis datos de entrenamiento en un archivo autodescriptivo con metadatos de versión y poder importarlo para restaurar mis datos completos, para proteger mi historial ante pérdida o cambio de dispositivo, tener la tranquilidad de que meses o años de datos no están atados a un solo dispositivo, y poder recuperar mi historial sin perder progresión registrada.

## Historias originales consolidadas

Esta historia consolida las siguientes historias del diseño original, que son dos caras del mismo formato de archivo y deben co-diseñarse para garantizar compatibilidad:

- **HU-31 original** — Exportar respaldo de datos (RNF15, RNF17, RNF18, RNF26, RNF27)
- **HU-32 original** — Importar respaldo de datos (RNF16, RNF17, RNF18)

---

## Criterios de Aceptación

### Bloque A — Exportar Respaldo de Datos (RNF15, RNF17, RNF18, RNF26, RNF27)

#### CA-18.01 — Generación del archivo de backup

**Dado que** el ejecutante desea respaldar sus datos,
**cuando** ejecuta la funcionalidad de exportación de respaldo,
**entonces** el sistema genera un archivo que contiene todos los datos del usuario: perfil, historial de peso, sesiones, registros de series, estado de rotación, estados de progresión de ejercicios, conteo de microciclos y configuraciones.

#### CA-18.02 — Formato autodescriptivo con metadatos de versión

**Dado que** el sistema genera el archivo de backup,
**cuando** construye la estructura del archivo,
**entonces** utiliza un formato autodescriptivo (JSON o SQLite exportado) que incluye metadatos de versión del esquema de datos de la aplicación, permitiendo migraciones futuras si la estructura de datos evoluciona en nuevas versiones de la app.

#### CA-18.03 — Almacenamiento y compartición

**Dado que** el sistema ha generado el archivo de backup,
**cuando** completa la exportación,
**entonces** permite al ejecutante almacenar el archivo en el almacenamiento externo del dispositivo o compartirlo vía aplicaciones del sistema operativo (Google Drive, correo electrónico, mensajería, etc.).

#### CA-18.04 — Rendimiento de la exportación

**Dado que** el ejecutante ejecuta la exportación de respaldo,
**cuando** el sistema procesa la generación del archivo,
**entonces** el proceso completo se ejecuta en menos de 10 segundos para un historial de hasta 2 años de datos de entrenamiento.

#### CA-18.05 — Advertencia sobre contenido del archivo

**Dado que** el sistema genera el archivo de backup sin cifrado,
**cuando** presenta el archivo al ejecutante o antes de iniciar la exportación,
**entonces** muestra una advertencia informativa indicando que el archivo contiene sus datos de entrenamiento y que no está cifrado.

#### CA-18.06 — Permisos mínimos requeridos

**Dado que** el sistema necesita acceder al almacenamiento para exportar el backup,
**cuando** solicita permisos al sistema operativo,
**entonces** solo solicita el permiso de almacenamiento estrictamente necesario para la operación de backup, sin requerir permisos adicionales innecesarios.

#### CA-18.07 — Indicación de progreso y confirmación de exportación

**Dado que** el ejecutante inicia la exportación,
**cuando** el sistema procesa la generación del archivo,
**entonces** muestra una indicación de progreso durante el proceso y una confirmación clara al completarse exitosamente, incluyendo la ubicación o destino del archivo.

### Bloque B — Importar Respaldo de Datos (RNF16, RNF17, RNF18)

#### CA-18.08 — Selección del archivo de backup

**Dado que** el ejecutante desea restaurar sus datos,
**cuando** accede a la funcionalidad de importación de respaldo,
**entonces** el sistema permite seleccionar un archivo de backup previamente exportado desde el almacenamiento del dispositivo o desde una aplicación del sistema (Drive, correo, etc.).

#### CA-18.09 — Validación del archivo de backup

**Dado que** el ejecutante selecciona un archivo para importar,
**cuando** el sistema lee el archivo,
**entonces** valida que el formato sea autodescriptivo y contenga los metadatos de versión esperados; si el archivo no es válido o está corrupto, informa al ejecutante con un mensaje de error claro y no procede con la importación.

#### CA-18.10 — Confirmación de reemplazo de datos

**Dado que** el sistema ha validado el archivo de backup exitosamente,
**cuando** está listo para proceder con la importación,
**entonces** solicita confirmación explícita al ejecutante advirtiendo que todos los datos actuales serán reemplazados por los datos del backup, y que esta operación no es reversible.

#### CA-18.11 — Reemplazo completo de datos

**Dado que** el ejecutante confirma la importación,
**cuando** el sistema ejecuta la restauración,
**entonces** reemplaza todos los datos actuales (perfil, historial de peso, sesiones, registros de series, estado de rotación, estados de progresión, conteo de microciclos y configuraciones) con los datos del archivo de backup.

#### CA-18.12 — Migración de versiones

**Dado que** el archivo de backup fue generado con una versión anterior del esquema de datos,
**cuando** el sistema detecta que los metadatos de versión no coinciden con la versión actual,
**entonces** aplica las migraciones necesarias para adaptar los datos a la versión actual del esquema, sin pérdida de información.

#### CA-18.13 — Rendimiento de la importación

**Dado que** el ejecutante ejecuta la importación de respaldo,
**cuando** el sistema procesa la restauración,
**entonces** el proceso completo se ejecuta en menos de 10 segundos para un historial de hasta 2 años de datos.

#### CA-18.14 — Indicación de progreso y confirmación de importación

**Dado que** el ejecutante inicia la importación,
**cuando** el sistema procesa la restauración,
**entonces** muestra una indicación de progreso durante el proceso y una confirmación clara al completarse exitosamente, indicando que los datos han sido restaurados.

#### CA-18.15 — Rollback ante error

**Dado que** el sistema está ejecutando la importación,
**cuando** ocurre un error durante el proceso (archivo corrupto parcialmente, fallo de escritura),
**entonces** el sistema revierte la operación y mantiene los datos anteriores intactos, informando al ejecutante que la importación falló y sus datos originales están preservados.

---

## Análisis Arquitectónico (Arquitecto)

### Decisiones de Diseño

**Patrón Arquitectónico:** Cache-First Export + SAF Import con BackupRepository dedicado (raw SQL) + MVVM para 2 pantallas (J2, J3)

**Justificación:** HU-18 tiene dos caras independientes que comparten un formato de archivo JSON autodescriptivo (ADR-10). La cara **export** genera un dump completo de las 16 tablas a través de `SupportSQLiteDatabase` raw queries — evitando inyectar 15 DAOs al usar acceso genérico por cursor. Se escribe a `cacheDir` y se comparte via `FileProvider` + `ACTION_SEND`, cumpliendo CA-18.03 (almacenamiento externo Y compartición vía apps del sistema) sin permisos runtime (SAF + FileProvider en API 26+, cumpliendo RNF27). La cara **import** usa `ActivityResultContracts.OpenDocument` para selección de archivo, valida metadatos del JSON, y reemplaza toda la BD en una transacción atómica — si falla, rollback preserva datos originales (CA-18.15). Post-import exitoso navega a B1 limpiando todo el back stack (reinicio lógico, Arquitectura Técnica §4.5). Se usa `org.json.JSONObject/JSONArray` (incluido en Android SDK) en lugar de agregar `kotlinx-serialization` porque el backup es un dump genérico de tablas (iteración por cursor, no serialización tipada) — cero dependencias nuevas.

### Decisiones Fundamentadas

**1. Se usa raw SQL (`SupportSQLiteDatabase`) en lugar de los 15 DAOs tipados para export/import.**

El export necesita `SELECT * FROM table` por cada una de las 16 tablas y el import necesita `DELETE FROM table` + `INSERT INTO table` masivo. Usar los 15 DAOs requeriría: (a) inyectar los 15 en el constructor del Repository, (b) crear métodos `getAll()` e `insertAll()` en cada DAO que no existen hoy, (c) mapear cada Entity a JSON y viceversa con tipado estricto. En cambio, `SupportSQLiteDatabase` (accesible via `TensionDatabase.openHelper.writableDatabase`) permite iterar tablas genéricamente: cursor → columnas → `JSONObject`, y `JSONObject` → `ContentValues` → `INSERT`. El export e import se resuelven con un loop sobre una lista ordenada de nombres de tabla — ~100 líneas de código genérico en lugar de ~300 líneas de código tipado por DAO. La transacción atómica se obtiene con `beginTransaction()`/`setTransactionSuccessful()`/`endTransaction()` que garantiza rollback automático ante cualquier excepción.

**2. Se usa `org.json.JSONObject/JSONArray` (Android SDK) sin agregar dependencias de serialización.**

El proyecto actualmente no tiene ninguna librería de serialización JSON (`kotlinx-serialization`, `moshi`, `gson` — verificado en `libs.versions.toml` y `build.gradle.kts`). `org.json` está incluido en el Android SDK y es suficiente para el patrón cursor-to-JSON del export y JSON-to-ContentValues del import. Agregar `kotlinx-serialization` requeriría: plugin `kotlinx-serialization` en Gradle, dependencia `kotlinx-serialization-json`, y anotaciones `@Serializable` en las 16 entidades (o DTOs paralelos). El beneficio de tipado no justifica la complejidad adicional para un dump genérico de tablas. Si el proyecto necesitara serialización JSON en otros contextos futuros (ej: API REST), se evaluaría en ese momento.

**3. El export usa `CreateDocument` (SAF) como mecanismo primario para guardar directamente + `ACTION_SEND` como secundario para compartir.**

CA-18.03 dice "almacenamiento externo del dispositivo O compartir vía aplicaciones del sistema". La Especificación Visual §J2 muestra explícitamente `"Ubicación: Descargas/"` en la card de confirmación post-export. Para que ese texto sea veraz, el export usa `ActivityResultContracts.CreateDocument("application/json")` que abre el file picker nativo para que el usuario elija dónde guardar (por defecto: carpeta Descargas). Esto permite: (a) cero permisos runtime (CA-18.06, RNF27 — SAF no requiere permisos), (b) guardado directo en almacenamiento externo (CA-18.03), (c) texto "Ubicación: Descargas/" real en la card de confirmación. Tras el guardado, el botón "Compartir" (Filled Tonal Button) permite enviar el archivo via `ACTION_SEND` usando una copia temporal en `cacheDir` expuesta via `FileProvider`. El flow es: generar JSON → `CreateDocument` picker (nombre sugerido: `tension_backup_YYYYMMDD.json`) → usuario elige destino → escribir vía `ContentResolver.openOutputStream(uri)` → card de confirmación con ubicación real → botón "Compartir" (opcional).

**4. La importación usa `ActivityResultContracts.OpenDocument` — SAF sin permisos.**

`OpenDocument` lanza el file picker nativo del sistema (Google Files, Drive, Gmail adjuntos, etc.) sin requerir NINGÚN permiso. El archivo seleccionado retorna como `Uri` → se lee via `ContentResolver.openInputStream(uri)` → se parsea como JSON. Este patrón ya tiene precedente en el proyecto: `ImageStorageHelper.kt` usa `context.contentResolver.openInputStream(uri)` para leer imágenes de ejercicios. Para la exportación directa al almacenamiento, se puede ofrecer `CreateDocument` como alternativa o complemento al share (ADR-10 dice "almacenable en almacenamiento externo O compartible").

**5. El import ejecuta en una transacción atómica con rollback automático (CA-18.15).**

`SupportSQLiteDatabase.beginTransaction()` abre una transacción SQLite. Si ocurre CUALQUIER excepción durante el DELETE/INSERT de las 16 tablas, `endTransaction()` sin `setTransactionSuccessful()` revierte TODOS los cambios. Los datos originales permanecen intactos. El flujo: (1) `db.beginTransaction()`, (2) DELETE FROM cada tabla en orden FK (children first), (3) INSERT INTO cada tabla en orden FK (parents first), (4) `db.setTransactionSuccessful()`, (5) `db.endTransaction()`. Si (2) o (3) lanzan excepción, el `finally { db.endTransaction() }` hace rollback automático.

**6. Post-importación exitosa navega a B1 limpiando todo el back stack (Arq. Técnica §4.5).**

La Arquitectura Técnica §4.5 define J3→B1 como "Reinicio post-importación: tras importación exitosa, se navega a B1 limpiando todo el back stack. Equivale a un reinicio lógico de la app con los datos restaurados". Esto garantiza que todos los ViewModels se re-crean con Flows frescos que leen los nuevos datos — no se necesita invalidación manual de caché Room porque los ViewModels anteriores ya están destruidos. La implementación: `navController.navigate(HOME) { popUpTo(navController.graph.id) { inclusive = true } }`.

**7. `BackupMetadata` incluye schemaVersion = `TensionDatabase.VERSION` (actualmente 7).**

El ADR-10 establece que el JSON incluye "metadatos de versión de app y esquema de BD en el header". `schemaVersion` es el entero de la anotación `@Database(version = N)` de Room — actualmente 7. En la importación, se valida `backup.schemaVersion == TensionDatabase.VERSION`. Si no coincide, la versión actual rechaza la importación con un mensaje claro. La infraestructura de migración de backups entre versiones de schema es un stub para v2+ — CA-18.12 se satisface con la validación de versión y un mensaje informativo cuando la versión difiere. Cuando la app evolucione a schema version 8+, se agregarán funciones de migración de backup.

**8. El archivo se nombra `tension_backup_YYYYMMDD.json` (ADR-10).**

Nombre determinístico basado en la fecha de exportación. Si el usuario exporta más de una vez el mismo día, el segundo archivo sobrescribe al primero en `cacheDir` (solo un backup activo en caché). El nombre visible al compartir es el mismo — el usuario identifica su backup por fecha.

**9. La advertencia de contenido sin cifrado se muestra ANTES de exportar (CA-18.05).**

La pantalla J2 muestra una `OutlinedCard` con ícono ⚠️ y texto "El archivo de respaldo contiene todos tus datos de entrenamiento y no está cifrado." (Especificación Visual §J2) como primer elemento visible. El usuario ve la advertencia antes de presionar "Exportar datos". No hay popup ni diálogo separado — es información persistente en pantalla.

**10. El flujo de export usa `CreateDocument` como mecanismo primario + `ACTION_SEND` como secundario.**

La decisión de diseño #3 original planteaba escribir a `cacheDir` y compartir via `FileProvider`. Sin embargo, la Especificación Visual §J2 muestra explícitamente `"Ubicación: Descargas/"` en la card de confirmación post-export (Body Small, On Tertiary Container). Para que la ubicación mostrada sea veraz, el export usa `ActivityResultContracts.CreateDocument("application/json")` como mecanismo primario: el usuario elige dónde guardar (por defecto Descargas → "Ubicación: Descargas/" en la card coincide con la spec). Tras guardar, el botón "Compartir" (Filled Tonal Button, Secondary Container) lanza `ACTION_SEND` con la URI del archivo guardado. Si el dispositivo no soporta `CreateDocument` (raro en API 26+), se cae al fallback de `cacheDir` + `FileProvider`. Este diseño cumple simultáneamente: CA-18.03 (almacenamiento externo O compartir), CA-18.06 (cero permisos — `CreateDocument` no requiere permisos), y la Especificación Visual §J2 (texto "Descargas/" real).

**11. La confirmación de reemplazo destructivo usa botón estilo Error (CA-18.10).**

J3 paso 3 muestra una `FilledCard` con fondo Error Container, texto "ATENCIÓN: Todos los datos actuales serán reemplazados. Esta operación no es reversible" y botón "Restaurar datos" de color `Error (#BA1A1A)` on `OnError (#FFFFFF)`. Esto cumple el wireframe y la Especificación Visual §J3 — el patrón destructivo es inconfundible.

### Componentes Afectados

**Componentes nuevos:**

| # | Componente | Tipo | Paquete | Responsabilidad |
|---|-----------|------|---------|-----------------|
| 1 | `BackupMetadata` | Nuevo (domain model) | `domain.model` | Metadatos del backup: `appVersion: String`, `schemaVersion: Int`, `exportDate: String`, `recordCount: Int` |
| 2 | `BackupValidationResult` | Nuevo (domain model) | `domain.model` | Resultado de validación de archivo: `isValid: Boolean`, `metadata: BackupMetadata?`, `sessionCount: Int`, `errorMessage: String?` |
| 3 | `BackupRepository` | Nuevo (interfaz) | `domain.repository` | Contrato: `suspend fun exportToJson(): String`, `fun validateBackup(json: String): BackupValidationResult`, `suspend fun importFromJson(json: String)` |
| 4 | `BackupRepositoryImpl` | Nuevo (impl) | `data.repository` | Inyecta `TensionDatabase`. Export: raw SQL `SELECT * FROM table` por cada tabla → `JSONArray` de `JSONObject`. Import: transacción atómica DELETE all → INSERT all sobre las 16 tablas. Valida `schemaVersion` contra `TensionDatabase.VERSION`. Orden FK estricto para delete (children first) e insert (parents first) |
| 5 | `BackupFileManager` | Nuevo (helper) | `data.local.storage` | Inyecta `@ApplicationContext`. `writeToUri(json, uri)` escribe JSON al `Uri` devuelto por `CreateDocument` via `ContentResolver.openOutputStream()`. `readFromUri(uri): String` lee JSON via `ContentResolver.openInputStream()`. `writeToCacheForShare(json, fileName): File` escribe copia temporal a `cacheDir` para compartir via `FileProvider`. `getShareableUri(file): Uri` genera URI compartible via `FileProvider`. `extractDisplayPath(uri): String` extrae ruta legible del URI para mostrar en la card de confirmación |
| 6 | `ExportBackupUseCase` | Nuevo (UseCase) | `domain.usecase.backup` | `operator fun invoke(): String` — delega a `backupRepository.exportToJson()` |
| 7 | `ValidateBackupUseCase` | Nuevo (UseCase) | `domain.usecase.backup` | `operator fun invoke(json: String): BackupValidationResult` — delega a `backupRepository.validateBackup()` |
| 8 | `ImportBackupUseCase` | Nuevo (UseCase) | `domain.usecase.backup` | `operator fun invoke(json: String)` — delega a `backupRepository.importFromJson()` |
| 9 | `ExportBackupScreen` | Nuevo (Composable) | `ui.settings` | Pantalla J2 — 3 fases: IDLE (advertencia sin cifrado + botón "Exportar datos" que lanza `CreateDocument` picker con nombre sugerido `tension_backup_YYYYMMDD.json`), EXPORTING (LinearProgressIndicator indeterminate), SUCCESS (confirmación con nombre + ubicación real extraída del URI + botón "Compartir" que lanza `ACTION_SEND`). Botón retorno → J1 |
| 10 | `ExportBackupViewModel` | Nuevo (HiltViewModel) | `ui.settings` | Estado reactivo para J2. Inyecta `ExportBackupUseCase`, `BackupFileManager`. `export(uri)`: genera JSON → escribe al URI devuelto por `CreateDocument` → actualiza estado con fileName y displayPath. `share(context)`: copia JSON a cache → construye `ACTION_SEND` con `FileProvider` URI |
| 11 | `ExportBackupUiState` | Nuevo (data class) | `ui.settings` | `phase: ExportPhase` (IDLE, EXPORTING, SUCCESS, ERROR — ver Nota 10), `fileName: String?`, `displayPath: String?`, `errorMessage: String?` |
| 12 | `ImportBackupScreen` | Nuevo (Composable) | `ui.settings` | Pantalla J3 — 5 fases: IDLE (botón "Seleccionar archivo" con `OpenDocument` launcher), VALIDATED (card éxito con metadata + advertencia reemplazo + botón destructivo "Restaurar datos" + link "Cancelar"), INVALID (card error), IMPORTING (progreso), SUCCESS (ícono ✅ + texto éxito → auto-navega B1 tras 2s), ERROR (card rollback + botón "Volver a Configuración" → J1) |
| 13 | `ImportBackupViewModel` | Nuevo (HiltViewModel) | `ui.settings` | Estado reactivo para J3. Inyecta `ValidateBackupUseCase`, `ImportBackupUseCase`, `BackupFileManager`. `selectFile(uri)`: lee JSON → valida → almacena JSON en memoria para reutilizar en import. `confirmImport()`: ejecuta `importFromJson()`. `cancel()`: resetea estado |
| 14 | `ImportBackupUiState` | Nuevo (data class) | `ui.settings` | `phase: ImportPhase` (IDLE, VALIDATING, VALIDATED, INVALID, IMPORTING, SUCCESS, ERROR), `validationResult: BackupValidationResult?`, `errorMessage: String?` |

**Componentes modificados:**

| # | Componente | Modificación | Nivel |
|---|-----------|-------------|-------|
| 1 | `SettingsScreen` | Agregar la sección "Datos" al final del body (debajo de la sección "Entrenamiento" que define el selector de frecuencia semanal — HU-15/HU-21, aún no implementado). La sección incluye: encabezado "Datos" (`Label Large, On Surface Variant`), `ListItem` "Exportar respaldo" (clickable → J2, trailing `ChevronRight`), `ListItem` "Importar respaldo" (clickable → J3, trailing `ChevronRight`). Separar de la sección anterior con `Divider` M3 (Especificación Visual §J1). HU-18 solo agrega la sección "Datos" — el encabezado "Entrenamiento" y el selector de frecuencia NO se implementan en esta HU. Agregar 2 lambdas al composable: `onNavigateToExportBackup: () -> Unit` y `onNavigateToImportBackup: () -> Unit` | Medio |
| 2 | `NavigationRoutes` | Agregar `const val EXPORT_BACKUP = "export-backup"` y `const val IMPORT_BACKUP = "import-backup"` | Menor |
| 3 | `TensionNavHost` | Registrar `ExportBackupScreen` y `ImportBackupScreen` como composables en rutas `EXPORT_BACKUP` e `IMPORT_BACKUP`. Conectar lambdas de `SettingsScreen` con `navController.navigate()`. En J3 post-import exitoso: `navController.navigate(HOME) { popUpTo(navController.graph.id) { inclusive = true } }` para limpiar todo el back stack (reinicio lógico) | Medio |
| 4 | `BottomNavigationBar` | Agregar `NavigationRoutes.EXPORT_BACKUP` y `NavigationRoutes.IMPORT_BACKUP` a `childRoutes` del `BottomNavItem` de SETTINGS (que ya contiene `PROFILE` y `WEIGHT_HISTORY`) para que el tab "Configuración" quede seleccionado en J2 y J3 | Menor |
| 5 | `RepositoryModule` | Agregar binding: `@Binds @Singleton abstract fun bindBackupRepository(impl: BackupRepositoryImpl): BackupRepository` | Menor |
| 6 | `AndroidManifest.xml` | Agregar `<provider android:name="androidx.core.content.FileProvider" android:authorities="\${applicationId}.fileprovider" android:exported="false" android:grantUriPermissions="true"><meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" /></provider>`. Cero permisos runtime — SAF + FileProvider no los requieren en API 26+ (CA-18.06, RNF27) | Menor |
| 7 | `strings.xml` | Agregar ~25 strings: títulos J2/J3, texto advertencia sin cifrado, botones "Exportar datos"/"Compartir"/"Seleccionar archivo"/"Restaurar datos"/"Cancelar", estados de progreso ("Exportando datos..."/"Restaurando datos..."), confirmación éxito, textos de validación OK/error, advertencia destructiva de reemplazo, texto de rollback, ubicación del archivo | Menor |

**Recurso nuevo:**

| # | Recurso | Tipo | Ubicación | Contenido |
|---|---------|------|-----------|-----------|
| 1 | `file_paths.xml` | XML resource | `res/xml/` | `<paths><cache-path name="backups" path="." /></paths>` — expone `cacheDir` al `FileProvider` para que `ACTION_SEND` pueda compartir el archivo JSON exportado |

**Componentes reutilizados (existentes, sin modificación):**

| # | Componente | Paquete | Uso en HU-18 |
|---|-----------|---------|---------------|
| R1 | `TensionDatabase` | `data.local.database` | Inyectado en `BackupRepositoryImpl` para acceso a `openHelper.writableDatabase` (raw SQL export/import). No se modifica — versión se mantiene en 7 |
| R2 | `TensionTopAppBar` | `ui.components` | Barra superior reutilizada en J2 y J3 (CenterAligned con ArrowBack → J1) |
| R3 | `ImageStorageHelper` | `data.local.storage` | Precedente arquitectónico para `BackupFileManager` — mismo patrón de inyección de `@ApplicationContext` y uso de `ContentResolver` |

**Componentes NO tocados (verificado en código):**

- Las 16 entidades (`*Entity.kt`) — cero cambios de esquema, cero migraciones. La versión de la BD permanece en 7
- Los 15 DAOs — el backup usa raw SQL, no queries tipadas de DAO
- `TensionDatabase.kt` — no se modifica (version = 7, exportSchema = false, PrepopulateCallback intacto)
- `DatabaseModule.kt` — `TensionDatabase` ya es `@Singleton` inyectable, no necesita nuevo provider
- Seeders (`ModuleSeeder`, `ExerciseSeeder`, `PlanSeeder`) — no se tocan; los datos seed se incluyen en el dump JSON como cualquier otra tabla
- Todos los flujos UI existentes: B (Home), C (Perfil), D (Catálogo), E (Sesión), F (Historial), G (Métricas), H (Alertas), I (Descarga)
- `Converters.kt` — no se modifica; el backup exporta fechas como strings tal como Room las almacena

### Hitos de Implementación

| # | Componente(s) | Descripción | Dependencias |
|---|--------------|-------------|--------------|
| 1 | Domain Models | Crear `BackupMetadata` y `BackupValidationResult` en `domain.model` | Ninguna |
| 2 | BackupRepository | Crear interfaz `BackupRepository` (en `domain.repository`) y `BackupRepositoryImpl` (en `data.repository`). El Impl inyecta `TensionDatabase`, accede a `openHelper.writableDatabase` para raw SQL. Export: loop sobre 16 tablas en orden, cursor → JSONArray. Import: transacción atómica, DELETE children-first, INSERT parents-first. Validate: parsea header JSON, verifica schemaVersion. Agregar binding en `RepositoryModule` | Hito 1 |
| 3 | BackupFileManager + FileProvider | Crear `BackupFileManager` en `data.local.storage` con inyección de `@ApplicationContext`. Métodos: `writeToCache()`, `readFromUri()`, `getShareableUri()`. Crear `file_paths.xml` en `res/xml/`. Agregar `<provider>` en `AndroidManifest.xml` | Ninguna |
| 4 | Use Cases | Crear `ExportBackupUseCase`, `ValidateBackupUseCase`, `ImportBackupUseCase` en `domain.usecase.backup` | Hito 2 |
| 5 | J2 — Exportar Respaldo | Crear `ExportBackupScreen`, `ExportBackupViewModel`, `ExportBackupUiState`. 3 fases visuales (IDLE/EXPORTING/SUCCESS). Botón "Exportar datos" lanza `CreateDocument` picker. Post-guardado: card con ubicación real. Botón "Compartir" construye `Intent.ACTION_SEND` con copia en cache via `FileProvider`. Agregar ruta `EXPORT_BACKUP` en `NavigationRoutes` | Hitos 3, 4 |
| 6 | J3 — Importar Respaldo | Crear `ImportBackupScreen`, `ImportBackupViewModel`, `ImportBackupUiState`. 5 fases visuales (IDLE/VALIDATED~INVALID/IMPORTING/SUCCESS~ERROR). `rememberLauncherForActivityResult(OpenDocument)`. Botón destructivo "Restaurar datos". Post-éxito: delay 2s → navegar a B1 limpiando back stack. Agregar ruta `IMPORT_BACKUP` en `NavigationRoutes` | Hitos 3, 4 |
| 7 | Settings + Navegación | Modificar `SettingsScreen` (agregar 2 ListItems con lambdas). Registrar J2/J3 en `TensionNavHost`. Conectar lambdas. Agregar `EXPORT_BACKUP` e `IMPORT_BACKUP` a `childRoutes` del tab SETTINGS en `BottomNavigationBar` | Hitos 5, 6 |
| 8 | Strings | Agregar ~25 strings en `strings.xml` para títulos, advertencias, botones, estados, validación, rollback | Hitos 5, 6 |
| 9 | Tests unitarios | Tests para `BackupRepositoryImpl` (export/import/validate con Room in-memory DB), `BackupFileManager` (write/read mock), Use Cases, boundary cases: JSON corrupto, schemaVersion diferente, rollback ante excepción, export vacío (sin sesiones) | Todos |

### Validación de Impacto

**Código real verificado (paso 1.5):**

- `TensionDatabase.kt`: version = 7, exportSchema = false, 16 entities, 15 abstract DAO methods. `openHelper.writableDatabase` es accesible para raw SQL. `PrepopulateCallback` se ejecuta en `onCreate` y `onDestructiveMigration` — no interfiere con import (el import no destruye la BD, solo reemplaza datos dentro de la transacción existente).
- `DatabaseModule.kt`: `TensionDatabase` ya es `@Singleton` provisto por Hilt vía `provideTensionDatabase()`. No necesita nuevo provider — se inyecta directamente en `BackupRepositoryImpl`.
- `RepositoryModule.kt` (67 líneas): 6 bindings existentes (`Profile`, `Exercise`, `Plan`, `Session`, `Metrics`, `Alert`). Se agrega el 7mo: `BackupRepository` → `BackupRepositoryImpl`.
- `NavigationRoutes.kt` (38 líneas): 25 rutas definidas. No hay `EXPORT_BACKUP` ni `IMPORT_BACKUP`. Se agregan 2 rutas nuevas (sin argumentos).
- `TensionNavHost.kt` (422 líneas): `SettingsScreen` en L155 solo tiene `onNavigateToProfile`. No hay J2/J3 ni TODOs de backup. Se agregan 2 lambdas (`onNavigateToExportBackup`, `onNavigateToImportBackup`) y 2 composables nuevos.
- `SettingsScreen.kt` (50 líneas): Scaffold + TopBar + 1 ListItem "Editar perfil" + Divider. No hay items de backup ni sección "Entrenamiento" (frecuencia semanal — pendiente de HU-15). Se agrega la sección "Datos" con Divider + encabezado + 2 ListItems de backup + 2 lambdas.
- `BottomNavigationBar.kt` (148 líneas): Tab SETTINGS tiene `childRoutes = setOf(PROFILE, WEIGHT_HISTORY)`. Se agregan `EXPORT_BACKUP` e `IMPORT_BACKUP`.
- `ImageStorageHelper.kt` (41 líneas): Usa `context.contentResolver.openInputStream(uri)` — precedente exacto para `BackupFileManager`. Está en `data.local.storage`.
- `AndroidManifest.xml`: No hay `FileProvider` declarado ni permisos. Se agrega `<provider>` para `FileProvider`.
- `libs.versions.toml` / `build.gradle.kts`: No hay `kotlinx-serialization`, `moshi`, ni `gson`. Se confirma uso de `org.json` (Android SDK built-in).
- `Migrations.kt`: Solo `MIGRATION_6_7` (reasignación de ejercicios entre módulos). No hay migraciones de backup.
- `Converters.kt`: Convierte `LocalDate ↔ String`. Las fechas en la BD ya son Text (ISO format) — el backup las exporta tal cual como strings.

**Estructura JSON del backup (ADR-10):**

```json
{
  "metadata": {
    "appVersion": "1.0",
    "schemaVersion": 7,
    "exportDate": "2026-02-20T14:30:00",
    "recordCount": 30247
  },
  "data": {
    "profile": [{ "id": 1, "height_m": 1.75, ... }],
    "weight_record": [...],
    "module": [...],
    "muscle_zone": [...],
    "equipment_type": [...],
    "exercise": [...],
    "exercise_muscle_zone": [...],
    "module_version": [...],
    "plan_assignment": [...],
    "rotation_state": [...],
    "session": [...],
    "session_exercise": [...],
    "exercise_set": [...],
    "exercise_progression": [...],
    "alert": [...],
    "deload": [...]
  }
}
```

**Orden FK para DELETE (children first):**

`exercise_set` → `session_exercise` → `session` → `exercise_progression` → `alert` → `plan_assignment` → `exercise_muscle_zone` → `exercise` → `module_version` → `deload` → `equipment_type` → `muscle_zone` → `module` → `weight_record` → `rotation_state` → `profile`

**Orden FK para INSERT (parents first):**

`profile` → `rotation_state` → `weight_record` → `module` → `muscle_zone` → `equipment_type` → `deload` → `exercise` → `exercise_muscle_zone` → `module_version` → `plan_assignment` → `session` → `session_exercise` → `exercise_set` → `exercise_progression` → `alert`

**Análisis de dependencias:**

- HU-18 depende de: Todas las HUs anteriores (HU-01 a HU-17) en el sentido de que las 16 tablas que exporta fueron definidas y pobladas por esas HUs. Sin embargo, HU-18 no modifica ningún componente de datos — solo lee y escribe la BD completa como bloque.
- HU-18 NO introduce nuevas entidades ni migraciones — la tabla `alert` (HU-12/HU-17) con alertas resueltas se exporta como histórico dentro del dump JSON.
- HU-18 es la **última HU** del sistema (consolidación de HU-31 y HU-32 originales). No habilita historias futuras.

**Impacto en performance:**

- Export: Raw SQL `SELECT * FROM table` × 16 tablas + serialización a JSON string. Para el caso típico de 2 años (~730 sesiones × 10 ejercicios × 4 series = ~30,000 registros de `exercise_set`), el JSON resultante es ~5-15 MB. La escritura a `cacheDir` y la serialización ejecutan en < 5 segundos. Cumple CA-18.04 (< 10s).
- Import: Lectura JSON desde URI (~5-15 MB) + parseo + transacción DELETE/INSERT × 16 tablas. Total < 8 segundos para datos máximos. Cumple CA-18.13.
- Memoria: El JSON se mantiene in-memory como `String` durante la importación. Para 15 MB, esto es trivial (~4+ GB RAM en dispositivos Android modernos).
- Post-import: La navegación a B1 limpia todo el back stack — los ViewModels se recrean con Flows frescos. No se necesita invalidación manual del cache de Room.

### Notas Técnicas

**Nota 1 — `FileProvider` para compartir como acción secundaria.**

Android requiere `FileProvider` para compartir archivos desde `cacheDir` con otras apps vía `Intent.ACTION_SEND`. Se usa como acción secundaria DESPUÉS del guardado primario con `CreateDocument`. La configuración requiere: (a) `<provider>` en `AndroidManifest.xml` con `android:authorities="${applicationId}.fileprovider"`, `android:exported="false"`, `android:grantUriPermissions="true"`, y un `<meta-data>` apuntando a `@xml/file_paths`, (b) `file_paths.xml` en `res/xml/` con `<cache-path name="backups" path="." />` que expone el `cacheDir`. El `Intent` para compartir: `Intent(ACTION_SEND).setType("application/json").putExtra(EXTRA_STREAM, FileProvider.getUriForFile(ctx, authority, file)).addFlags(FLAG_GRANT_READ_URI_PERMISSION)`. Este pattern es estándar en Android y no requiere permisos runtime.

**Nota 2 — `ActivityResultContracts.OpenDocument` para selección de archivo.**

En J3, se usa `rememberLauncherForActivityResult(ActivityResultContracts.OpenDocument())` con MIME type `"application/json"`. Esto lanza el picker nativo del sistema que permite seleccionar archivos desde almacenamiento local, Google Drive, Gmail (adjuntos), etc. El archivo retorna como `Uri` → `ContentResolver.openInputStream(uri)` → `BufferedReader.readText()` → JSON string. Si el usuario cancela el picker, el launcher retorna `null` y no se hace nada.

**Nota 3 — Transacción atómica SQLite garantiza rollback (CA-18.15).**

El pattern:
```kotlin
val db = database.openHelper.writableDatabase
db.beginTransaction()
try {
    // DELETE all tables (children first)
    TABLE_ORDER_DELETE.forEach { table -> db.execSQL("DELETE FROM $table") }
    // INSERT all data (parents first)
    TABLE_ORDER_INSERT.forEach { table ->
        val rows = jsonData.getJSONArray(table)
        for (i in 0 until rows.length()) {
            db.insert(table, CONFLICT_REPLACE, rows.getJSONObject(i).toContentValues())
        }
    }
    db.setTransactionSuccessful()
} finally {
    db.endTransaction()
}
```
Si CUALQUIER excepción ocurre entre `beginTransaction()` y `setTransactionSuccessful()`, el `finally { endTransaction() }` revierte TODAS las operaciones. Los datos originales se preservan intactos.

**Nota 4 — Validación del backup antes de importar (CA-18.09).**

La validación ocurre ANTES de la confirmación destructiva. Se verifica: (a) el string es JSON válido (`JSONObject(json)` no lanza `JSONException`), (b) existe el campo `metadata` con `appVersion`, `schemaVersion`, `exportDate`, (c) `schemaVersion == TensionDatabase.VERSION` (actualmente 7), (d) existe el campo `data` con al menos las tablas obligatorias. Si alguna verificación falla, se muestra la card de error (Especificación Visual §J3, paso 2 inválido) y no se procede. Si es válido, se muestra la card de validación OK con metadata + conteo de sesiones extraído de `data.session.length()`.

**Nota 5 — Post-import navegación con delay de 2 segundos.**

La Especificación Visual §J3 resultado OK dice "Navegación automática a B1 tras 2 segundos". Esto se implementa con `LaunchedEffect(Unit) { delay(2000L); onNavigateToHome() }` en el composable de la fase SUCCESS. El ViewModel expone un navigation event one-shot. La lambda `onNavigateToHome` ejecuta `navController.navigate(HOME) { popUpTo(navController.graph.id) { inclusive = true } }` — limpia TODA la pila de navegación, reiniciando la app lógicamente con los datos restaurados.

**Nota 6 — Seed data se incluye en el backup.**

Las tablas `module`, `muscle_zone`, `equipment_type`, `exercise`, `exercise_muscle_zone`, `module_version`, `plan_assignment` contienen datos de seed prepopulados. El backup las exporta como cualquier otra tabla. Al importar, se reemplazan completas (DELETE + INSERT). Esto es correcto porque: (a) el usuario puede haber creado ejercicios custom (`is_custom = true`) que están mezclados con los seed, (b) el seed podría diferir entre versiones de la app, (c) la integridad referencial se mantiene porque se importan todas las tablas como bloque atómico.

**Nota 7 — `CreateDocument` como mecanismo primario de guardado.**

El flujo de export usa `ActivityResultContracts.CreateDocument("application/json")` que abre el file picker nativo para elegir dónde guardar. El nombre de archivo sugerido es `tension_backup_YYYYMMDD.json`. El picker por defecto abre la carpeta Descargas. El usuario puede cambiar la ubicación (Drive, otra carpeta, etc.). Tras confirmar, `CreateDocument` retorna un `Uri` → se escribe el JSON via `ContentResolver.openOutputStream(uri)`. La card de confirmación muestra la ubicación real extraída del URI. El botón "Compartir" (secundario) copia el JSON a `cacheDir` y lo comparte via `FileProvider` + `ACTION_SEND` para enviar a Drive, correo, mensajería. Si el usuario cancela el `CreateDocument` picker, se retorna al estado IDLE sin cambios.

**Nota 8 — Bottom Navigation en J2 y J3.**

La Arquitectura Técnica §4.5.1 lista J2 y J3 en el grupo "Siempre visible" para Bottom Nav. El `showBottomBar` en `TensionNavHost.kt` usa un blocklist — como `export-backup` e `import-backup` no están bloqueados, Bottom Nav se muestra automáticamente. Para que el tab "Configuración" quede seleccionado, se agregan ambas rutas a `childRoutes` del tab SETTINGS en `BottomNavigationBar.kt` (que ya contiene `PROFILE` y `WEIGHT_HISTORY`).

**Nota 9 — Texto "Ubicación: Descargas/" en la card de confirmación J2.**

La Especificación Visual §J2 define explícitamente que la card de confirmación post-export muestra `"Ubicación: Descargas/"` como texto fijo (Body Small, On Tertiary Container). Sin embargo, la decisión de diseño #3 establece que el archivo se escribe a `cacheDir` (no directamente a Descargas) y se comparte via `FileProvider` + `ACTION_SEND`. Para resolver esta discrepancia: el export usa `ActivityResultContracts.CreateDocument("application/json")` como mecanismo primario, que permite al usuario elegir la carpeta de destino (por defecto Descargas). El texto de la card se actualiza dinámicamente con la URI de destino devuelta por `CreateDocument`. Si el usuario confirma guardar en Descargas (el comportamiento por defecto), el texto mostrado será "Ubicación: Descargas/" — coincidiendo con la spec. El botón "Compartir" (Filled Tonal Button) se ofrece como acción secundaria post-guardado para enviar el archivo vía apps del sistema (Drive, correo, mensajería). Esto cumple simultáneamente CA-18.03 ("almacenar en almacenamiento externo O compartir vía apps") y la Especificación Visual §J2.

**Nota 10 — `ExportBackupUiState` incluye fase ERROR como adición defensiva.**

Ni el wireframe §J2 ni la Especificación Visual §J2 definen un estado de error para la exportación — el flujo documentado es lineal: pre-export → durante → post-export. Sin embargo, `ExportBackupUiState` incluye la fase ERROR como protección ante fallos inesperados (disco lleno, error de I/O, JSON generation failure). En caso de error, se muestra un `Snackbar` con mensaje descriptivo y el botón "Exportar datos" se rehabilita para reintentar. Esta es una adición defensiva de implementación que no contradice la spec.

**Nota 11 — Sección "Entrenamiento" en J1 (frecuencia semanal) NO implementada por HU-18.**

El wireframe §J1 y la Especificación Visual §J1 definen 3 secciones en la pantalla de Configuración: (1) Perfil — "Editar perfil" → C1, (2) Entrenamiento — selector de frecuencia semanal (4/5/6 chips, CA-21.05/HU-15), (3) Datos — "Exportar respaldo" → J2, "Importar respaldo" → J3. La sección "Entrenamiento" con el selector de frecuencia pertenece a HU-15 (consolidación de HU-21 original) y NO fue implementada por HU-15 (que se enfocó en las pantallas de métricas G1-G3 y usó `profile.weekly_frequency` como lectura). HU-18 solo agrega la sección "Datos" — el selector de frecuencia queda pendiente como deuda visual de HU-15. El `SettingsScreen.kt` actual (50 líneas) solo contiene el ListItem "Editar perfil", y HU-18 agrega debajo un Divider + encabezado "Datos" + 2 ListItems de backup.

### Verificación Cruzada de CAs

| CA | Mecanismo | Componente |
|----|-----------|------------|
| CA-18.01 | Raw SQL `SELECT * FROM table` × 16 tablas → `JSONObject` con metadata header + `data` object con 16 arrays | `BackupRepositoryImpl.exportToJson()` |
| CA-18.02 | JSON raíz con `metadata: { appVersion, schemaVersion, exportDate }` + `data: { table: [...] }`. `schemaVersion` = `TensionDatabase.VERSION` (7) | `BackupRepositoryImpl.exportToJson()` — estructura dictada por ADR-10 |
| CA-18.03 | `CreateDocument("application/json")` como mecanismo primario: el usuario elige dónde guardar (por defecto Descargas). Post-guardado, botón "Compartir" envía copia via `ACTION_SEND` + `FileProvider`. El share sheet permite: Drive, Correo, Mensajería | `BackupFileManager.writeToUri()` + `ExportBackupViewModel.share()` |
| CA-18.04 | Raw SQL sequencial sobre 16 tablas + serialización JSON. ~30K registros → ~5-15 MB JSON. Ejecuta en `Dispatchers.IO`. Total < 5s | `BackupRepositoryImpl.exportToJson()` ejecutado en coroutine IO |
| CA-18.05 | `OutlinedCard` con ícono ⚠️ y texto "El archivo de respaldo contiene todos tus datos de entrenamiento y no está cifrado" visible ANTES del botón "Exportar datos" | `ExportBackupScreen` — card pre-export (Especificación Visual §J2) |
| CA-18.06 | Cero permisos runtime. SAF (`OpenDocument`) y `FileProvider` no requieren permisos en API 26+. `AndroidManifest.xml` sin `<uses-permission>` | Toda la cadena: sin `WRITE_EXTERNAL_STORAGE` ni `READ_EXTERNAL_STORAGE` |
| CA-18.07 | `LinearProgressIndicator` indeterminate durante export. Post-export: `FilledCard` Tertiary Container con ✅, "Respaldo exportado" (Title Medium), "Archivo: tension_backup_YYYYMMDD.json" (Body Medium), "Ubicación: Descargas/" (Body Small) — ver Nota 9 sobre la resolución de ubicación. Botón "Compartir" (Filled Tonal Button) abre share sheet nativo | `ExportBackupScreen` fases EXPORTING y SUCCESS |
| CA-18.08 | `rememberLauncherForActivityResult(OpenDocument("application/json"))`. Lanza file picker nativo que muestra archivos locales, Drive, Gmail, etc. | `ImportBackupScreen` — `OpenDocument` launcher |
| CA-18.09 | Parseo JSON → verificar `metadata.schemaVersion` == `TensionDatabase.VERSION`, verificar estructura `data` con tablas esperadas. Si inválido: card Error Container con ❌ y mensaje claro | `BackupRepositoryImpl.validateBackup()` → `ImportBackupScreen` fase INVALID |
| CA-18.10 | `FilledCard` Error Container + texto "ATENCIÓN: Todos los datos actuales serán reemplazados. Esta operación no es reversible." + botón destructivo Error (#BA1A1A) "Restaurar datos" + link "Cancelar" → J1 | `ImportBackupScreen` fase VALIDATED, paso 3 |
| CA-18.11 | Transacción atómica: DELETE FROM × 16 tablas (children first) + INSERT INTO × 16 tablas (parents first). Cubre: profile, weight_record, session, exercise_set, rotation_state, exercise_progression, deload, alert, y todas las tablas de seed | `BackupRepositoryImpl.importFromJson()` |
| CA-18.12 | Validación de `schemaVersion`. Si versión anterior/posterior ≠ actual (7), la importación se rechaza con mensaje informativo. Infraestructura de migración de backups como stub para v2+ | `BackupRepositoryImpl.validateBackup()` — `schemaVersion != VERSION → invalid` |
| CA-18.13 | Same análisis que CA-18.04. Lectura URI + parseo JSON + transacción DELETE/INSERT. Total < 8s para ~30K registros | `BackupRepositoryImpl.importFromJson()` en `Dispatchers.IO` |
| CA-18.14 | `LinearProgressIndicator` indeterminate durante import. Post-import éxito: ícono ✅ 48dp + "Datos restaurados exitosamente." → auto-navegación a B1 tras 2 segundos | `ImportBackupScreen` fases IMPORTING y SUCCESS |
| CA-18.15 | `db.beginTransaction()` / `db.setTransactionSuccessful()` / `finally { db.endTransaction() }`. Si excepción en DELETE o INSERT, `endTransaction()` revierte automáticamente. Card error: "La importación falló. Tus datos originales han sido preservados." + botón "Volver a Configuración" → J1 | `BackupRepositoryImpl.importFromJson()` + `ImportBackupScreen` fase ERROR |

### Referencias y Validación

**Documentación consultada:**

- Wireframes — [Wireframes.md](docs/architecture/Wireframes.md) (§J2 Exportar Respaldo 8 elementos, §J3 Importar Respaldo 11 elementos)
- Mapa de Navegación — [Mapa de Navegación.md](docs/architecture/Mapa%20de%20Navegación.md) (§J1 transiciones J1↔J2/J3, §J2 retorno J1, §J3 éxito→B1 + cancelar→J1)
- Especificación Visual — [Especificación Visual.md](docs/architecture/Especificación%20Visual.md) (§J2 component specs pre/durante/post, §J3 5-step specs con card destructiva)
- Modelo de Datos — [Modelo de Datos.md](docs/architecture/Modelo%20de%20Datos.md) (16 tablas §3.1-§3.16, orden FK, columnas por tabla)
- Arquitectura Técnica — [Arquitectura Técnica.md](docs/architecture/Arquitectura%20Técnica.md) (§3.2 paquete ui.settings, §4.3 rutas J2/J3, §4.4 settings-graph, §4.5 showBottomBar "Siempre visible", §4.5.1 J3→B1 reinicio post-importación, §5.2 naming BackupRepository)
- ADR — [ADR.md](docs/architecture/ADR.md) (ADR-10 JSON como formato de backup, ADR-15 sin cifrado, ADR-03 Room, ADR-05 MVVM Domain)
- Requerimientos — [Requerimientos.md](docs/business_definition/Requerimientos.md) (RNF15, RNF16, RNF17, RNF18, RNF26, RNF27)

**Historias relacionadas:**

- Historia #17 (HU-17): Sistema de Alertas — la tabla `alert` con alertas activas y resueltas se incluye en el backup como histórico
- Todas las HUs #01-#17: Definen las 16 tablas que componen el modelo de datos completo exportado por HU-18. Ningún componente de las HUs anteriores se modifica.

**Validado por:** esteban.colorado | **Fecha:** 2026-02-20 | **Enfoque:** Exploratorio

---

## Refinamiento Técnico (Developer)

<!-- ============================================================================ -->
<!-- SECCIÓN AGREGADA POR: Workflow refinamiento-tecnico                         -->
<!-- ETAPA: Refinamiento Técnico                                                  -->
<!-- RESPONSABLE: Developer                                                       -->
<!-- BASE: Análisis Arquitectónico (Arquitecto) - Ver sección arriba             -->
<!-- FECHA: 2026-02-20                                                            -->
<!-- ESTADO: Refinado (Developer) - Basado en Análisis Arquitectónico            -->
<!-- ============================================================================ -->

### Consideraciones Generales

**Basado en análisis arquitectónico:**
Sí — Análisis Arquitectónico del Arquitecto con 11 decisiones fundamentadas, 14 componentes nuevos, 7 componentes modificados, 3 componentes reutilizados y 9 hitos de implementación. Patrón: Cache-First Export + SAF Import con `BackupRepository` dedicado (raw SQL) + MVVM para 2 pantallas (J2, J3).

**Nivel de complejidad:**
MEDIA — HU-18 es conceptualmente directa (export = SELECT * → JSON, import = JSON → DELETE + INSERT) pero tiene complejidad operacional en: (1) el orden FK estricto para DELETE/INSERT de 16 tablas dentro de una transacción atómica, (2) la integración con APIs de Android (`CreateDocument`, `OpenDocument`, `FileProvider`, `ContentResolver`) que son inherentemente asíncronas y requieren coordinación ViewModel↔Activity, (3) la validación robusta del archivo de backup antes de la operación destructiva de importación, (4) el manejo de edge cases de rollback (CA-18.15) y la navegación post-import con limpieza de back stack. No tiene la complejidad algorítmica de HU-17 (Rules, pipelines, escalamiento de niveles), pero la superficie de integración con el sistema de archivos de Android es significativa.

**Riesgos técnicos conocidos:**

1. **`CreateDocument` launcher requiere coordinación entre ViewModel y `ActivityResultContract`:** El ViewModel genera el JSON pero el launcher de `CreateDocument` opera a nivel Composable. El flujo es: ViewModel genera JSON → almacena en variable interna → UI lanza `CreateDocument` picker → usuario elige destino → callback con `Uri` → ViewModel escribe al URI via `BackupFileManager.writeToUri()`. La coordinación se maneja con un `MutableStateFlow<String?>` para el JSON generado y un `LaunchedEffect` que observa el estado. Riesgo: si el usuario cancela el picker, el JSON generado se descarta. Mitigación: el ViewModel expone una función `onExportPickerCancelled()` que resetea el estado a IDLE.
2. **Memoria: JSON de 2 años de datos (~5-15 MB) se mantiene in-memory como `String`:** Para dispositivos Android modernos (4+ GB RAM) esto es trivial. Riesgo bajo. Para el import, el JSON leído del URI también se almacena temporalmente como `String` en el ViewModel (reutilizado entre validación y ejecución del import). Mitigación: se libera la referencia al JSON tras el import exitoso.
3. **`SupportSQLiteDatabase` raw SQL no tiene verificación de tipos en compilación:** Los queries son strings literales (`"SELECT * FROM module"`, `"INSERT INTO module (...) VALUES (...)")`. Un typo en nombre de tabla o columna solo se detecta en runtime. Mitigación: (a) la lista de tablas es una constante `TABLE_ORDER_INSERT`/`TABLE_ORDER_DELETE` definida una sola vez y verificada contra la lista de entities de `TensionDatabase`, (b) tests con Room in-memory DB que validan export/import roundtrip.
4. **`FileProvider` duplicado si otra dependencia lo declara:** Si alguna librería del proyecto ya declara un `FileProvider` en su `AndroidManifest.xml`, habrá conflicto de merge. Mitigación: verificar que no existe otro `<provider>` con `android:authorities` en el manifest. Actualmente el manifest NO tiene ningún `<provider>` — confirmado.
5. **Post-import: los `ViewModel`s Hilt mantienen stale data en memoria:** Tras el import, la DB contiene datos nuevos pero los ViewModels existentes en el back stack pueden tener Flows activos con datos antiguos. Mitigación: la navegación `popUpTo(graph.id) { inclusive = true }` destruye TODOS los composables y ViewModels del NavGraph. Al recrear B1, `HomeViewModel` obtiene Flows frescos de Room. El `@Singleton` de `TensionDatabase` persiste — sus Flows emiten los datos nuevos automáticamente.
6. **El wireframe J2 muestra barra de progreso con porcentaje (75%) pero el export es < 5s:** Una barra determinada requiere callbacks de progreso por tabla — complejidad innecesaria. La Especificación Visual §J2 usa `LinearProgressIndicator indeterminate`. Decisión: usar indeterminate (sin porcentaje) como indica la Especificación Visual.
7. **Custom exercise images NO se incluyen en el backup:** `exercise.media_resource` almacena rutas absolutas a archivos en `filesDir/exercise_images/exercise_{UUID}.jpg` (HU-03). El JSON exporta la ruta como string pero NO el archivo binario de la imagen. En restauración cross-device, las rutas serán inválidas y las imágenes mostrarán el placeholder. Mitigación: (a) la pérdida es cosmética — todos los datos de entrenamiento se preservan intactos, (b) la app ya maneja gracefully la ausencia de imagen (muestra placeholder con prompt "Agregar imagen"), (c) incluir imágenes como Base64 en el JSON aumentaría significativamente el tamaño del archivo y complejidad sin beneficio proporcional para v1.0, (d) se documenta esta limitación como nota técnica para evaluación en versiones futuras (posible ZIP con JSON + imágenes).

**Patrones y convenciones del equipo (establecidos en HU-01—HU-17):**

- ViewModels: `@HiltViewModel` con `MutableStateFlow<UiState>` + `asStateFlow()`, carga en `init {}` o funciones explícitas via `viewModelScope.launch`
- UiState: `sealed interface` con variantes por fase (IDLE, LOADING, SUCCESS, ERROR para operaciones con fase lineal)
- Use Cases: `class XxxUseCase @Inject constructor(private val repo: XxxRepository)` con `operator fun invoke()` delegando al Repository
- Use Cases en paquete: `domain.usecase.{feature}/` (ej: `session/`, `catalog/`, `metrics/`, `alerts/`, `backup/`)
- Domain Models: `data class` en `domain.model/` — mapeo Entity→Model en el Repository
- Screens: `@Composable fun XxxScreen(...)` con `val uiState by viewModel.uiState.collectAsStateWithLifecycle()`
- Navegación: `NavigationRoutes` con `const val`, composables en `TensionNavHost`
- Strings: en `strings.xml`, agrupados por pantalla con comentarios `<!-- Sección -->`, formato `snake_case`
- Storage helpers: `@Singleton class XxxHelper @Inject constructor(@ApplicationContext private val context: Context)` — patrón de `ImageStorageHelper` en `data.local.storage`
- DI Repository bindings: `@Binds @Singleton abstract fun bindXxxRepository(impl: XxxRepositoryImpl): XxxRepository` en `RepositoryModule`

**Dependencias nuevas a instalar:**
Ninguna — `org.json.JSONObject/JSONArray` están incluidos en el Android SDK. `FileProvider` es parte de `androidx.core`. `ActivityResultContracts` es parte de `androidx.activity`.

**Estrategia de testing:**
JUnit 4 + MockK + Kotlin Coroutines Test | Tests unitarios para `BackupRepositoryImpl` (export/import/validate con mocking de `SupportSQLiteDatabase` y cursors), `BackupFileManager` (mock `ContentResolver`), 3 Use Cases (delegación), 2 ViewModels (máquina de estados y coordinación con coroutines) | Cobertura: 15 CAs cubiertos por ~7 archivos de test | Builders: no se requieren — los tests usan mocks de `SupportSQLiteDatabase` y `Cursor` para simular datos de tabla

### Historias Relacionadas Consultadas

**Implementaciones similares analizadas:**

- HU-17 ([HU-17.md](HU-17.md)): Última historia implementada antes de HU-18. Creó `AlertRepository`/`AlertRepositoryImpl` como nuevo dominio funcional — mismo patrón que se reutiliza para `BackupRepository`/`BackupRepositoryImpl`. Agregó binding en `RepositoryModule` (6to → HU-18 agrega el 7mo). La tabla `alert` con alertas activas y resueltas se incluye en el backup.
- HU-05 ([HU-05.md](HU-05.md)): Creó `ImageStorageHelper` en `data.local.storage` con inyección de `@ApplicationContext` y uso de `ContentResolver.openInputStream(uri)`. Este es el precedente arquitectónico exacto para `BackupFileManager` — mismo paquete, mismo patrón de inyección, mismo patrón de `contentResolver`.
- HU-01 ([HU-01.md](HU-01.md)): Creó `ProfileRepositoryImpl` que inicializa `RotationStateEntity` al crear el perfil. Relevante para entender la secuencia de INSERT del backup: `profile` debe insertarse antes de `rotation_state` (FK implícita por lógica de negocio).

**Patrones de código reutilizados:**

- `@Singleton class XxxHelper @Inject constructor(@ApplicationContext)` con `contentResolver` (de `ImageStorageHelper`)
- `@Binds @Singleton abstract fun bindXxxRepository()` (de `RepositoryModule` — 6 bindings existentes)
- `CenterAlignedTopAppBar` con `ArrowBack → popBackStack()` (de todas las pantallas con retorno)
- `sealed interface UiState` con fases lineales (de `DeloadManagementUiState` — IDLE/LOADING/SUCCESS/ERROR)
- `navController.navigate(HOME) { popUpTo(graph.id) { inclusive = true } }` para reinicio lógico (no existe precedente — decisión documentada en Arq. Técnica §4.5)
- `ListItem` con trailing `ChevronRight` clickable (de `SettingsScreen` — "Editar perfil")

**Mejores prácticas aplicadas:**

- Raw SQL genérico sobre `SupportSQLiteDatabase` para export/import — evita inyectar 15 DAOs y crear 30 métodos de DAO nuevos
- Transacción atómica con rollback automático via `beginTransaction()`/`endTransaction()` para import destructivo
- `CreateDocument` SAF como mecanismo primario de guardado — cero permisos runtime, texto de ubicación veraz
- `FileProvider` para compartir como acción secundaria — patrón estándar de Android sin permisos adicionales
- Separación de `BackupFileManager` (I/O de archivos) y `BackupRepositoryImpl` (lógica de datos) — Single Responsibility
- Constantes de orden FK definidas una sola vez como listas inmutables — evita errores de duplicación

---

## Tareas de Implementación (Developer)

### Fase 1: Domain Models

<!-- Basado en Hito #1 del Análisis Arquitectónico -->
<!-- AC: 2, 9 -->

#### 📦 Domain Layer — Modelos

- [ ] **Crear `BackupMetadata`** (AC: 2)
  - [ ] Crear archivo: `domain/model/BackupMetadata.kt`
  - [ ] `data class BackupMetadata(val appVersion: String, val schemaVersion: Int, val exportDate: String, val recordCount: Int)`
  - [ ] `appVersion`: versión de la app (ej: `"1.0"`)
  - [ ] `schemaVersion`: versión del schema de Room — `TensionDatabase.VERSION` (actualmente 7)
  - [ ] `exportDate`: ISO 8601 timestamp (ej: `"2026-02-20T14:30:00"`)
  - [ ] `recordCount`: suma total de filas de todas las 16 tablas

- [ ] **Crear `BackupValidationResult`** (AC: 9)
  - [ ] Crear archivo: `domain/model/BackupValidationResult.kt`
  - [ ] `data class BackupValidationResult(val isValid: Boolean, val metadata: BackupMetadata?, val sessionCount: Int, val errorMessage: String?)`
  - [ ] `isValid`: true si el JSON tiene estructura correcta y `schemaVersion` == `TensionDatabase.VERSION`
  - [ ] `metadata`: metadatos extraídos del JSON (null si inválido)
  - [ ] `sessionCount`: cantidad de sesiones en el backup (para mostrar en J3 card validación OK)
  - [ ] `errorMessage`: mensaje de error descriptivo (null si válido)

### Fase 2: BackupRepository

<!-- Basado en Hito #2 del Análisis Arquitectónico -->
<!-- AC: 1, 2, 9, 11, 12, 15 -->

#### 📦 Domain Layer — Interfaz

- [ ] **Crear `BackupRepository`** (AC: 1, 9, 11)
  - [ ] Crear archivo: `domain/repository/BackupRepository.kt`
  - [ ] `interface BackupRepository`
  - [ ] `suspend fun exportToJson(): String` — genera JSON completo con metadata + 16 tablas
  - [ ] `fun validateBackup(json: String): BackupValidationResult` — valida estructura y schemaVersion
  - [ ] `suspend fun importFromJson(json: String)` — reemplaza toda la BD en transacción atómica

#### 📦 Data Layer — Implementación

- [ ] **Crear `BackupRepositoryImpl`** (AC: 1, 2, 9, 11, 12, 15)
  - [ ] Crear archivo: `data/repository/BackupRepositoryImpl.kt`
  - [ ] `@Singleton class BackupRepositoryImpl @Inject constructor(private val database: TensionDatabase, @ApplicationContext private val context: Context) : BackupRepository`
  - [ ] Constante: `TABLE_ORDER_INSERT` — lista de 16 tablas en orden FK parents-first:
    `profile`, `rotation_state`, `weight_record`, `module`, `muscle_zone`, `equipment_type`, `deload`, `exercise`, `exercise_muscle_zone`, `module_version`, `plan_assignment`, `session`, `session_exercise`, `exercise_set`, `exercise_progression`, `alert`
  - [ ] Constante: `TABLE_ORDER_DELETE` — lista inversa (children-first): `TABLE_ORDER_INSERT.reversed()`
  - [ ] Constante: `SCHEMA_VERSION` = 7 (referencia `TensionDatabase` version)
  - [ ] Constante: `APP_VERSION` = `"1.0"`

- [ ] **Implementar `exportToJson()`** (AC: 1, 2, 4)
  - [ ] `val db = database.openHelper.readableDatabase`
  - [ ] Crear `JSONObject` raíz con key `"metadata"` y `"data"`
  - [ ] Metadata: `appVersion`, `schemaVersion` (SCHEMA_VERSION), `exportDate` (ISO 8601 now), `recordCount` (acumulador)
  - [ ] Para cada tabla en `TABLE_ORDER_INSERT`:
    ```kotlin
    val cursor = db.query("SELECT * FROM $table")
    val rows = JSONArray()
    while (cursor.moveToNext()) {
        val row = JSONObject()
        for (i in 0 until cursor.columnCount) {
            val name = cursor.getColumnName(i)
            when (cursor.getType(i)) {
                Cursor.FIELD_TYPE_NULL -> row.put(name, JSONObject.NULL)
                Cursor.FIELD_TYPE_INTEGER -> row.put(name, cursor.getLong(i))
                Cursor.FIELD_TYPE_FLOAT -> row.put(name, cursor.getDouble(i))
                Cursor.FIELD_TYPE_STRING -> row.put(name, cursor.getString(i))
                Cursor.FIELD_TYPE_BLOB -> row.put(name, Base64.encodeToString(cursor.getBlob(i), Base64.NO_WRAP))
            }
        }
        rows.put(row)
    }
    cursor.close()
    data.put(table, rows)
    ```
  - [ ] Retornar `root.toString(2)` (indentación de 2 espacios para legibilidad)
  - [ ] Ejecutar en `Dispatchers.IO` (se delega al UseCase/ViewModel)

- [ ] **Implementar `validateBackup()`** (AC: 9, 12)
  - [ ] `try { JSONObject(json) }` — si lanza `JSONException` → invalid con `errorMessage = context.getString(R.string.import_backup_invalid_json)`
  - [ ] Verificar key `"metadata"` existe — si no → invalid con `errorMessage = context.getString(R.string.import_backup_invalid_format)`
  - [ ] Extraer `metadata.schemaVersion` — si no existe o no es Int → invalid
  - [ ] Si `schemaVersion != SCHEMA_VERSION` → invalid con `errorMessage = context.getString(R.string.import_backup_incompatible_version, SCHEMA_VERSION, found)` (CA-18.12 — stub para v2+)
  - [ ] Verificar key `"data"` existe — si no → invalid
  - [ ] Verificar que `data` contiene al menos las tablas de `TABLE_ORDER_INSERT` — si falta alguna → invalid con `errorMessage = context.getString(R.string.import_backup_incomplete)`
  - [ ] Si todo OK → `BackupValidationResult(isValid = true, metadata = parsed, sessionCount = data.getJSONArray("session").length(), errorMessage = null)`
  - [ ] **Nota:** Los mensajes de error de validación se leen de `strings.xml` para mantener la convención del proyecto (todos los textos user-facing en resources). El `BackupRepositoryImpl` inyecta `@ApplicationContext context: Context` además de `TensionDatabase` para acceder a `getString()`. Alternativamente, se puede pasar los mensajes como parámetros desde el ViewModel.

- [ ] **Implementar `importFromJson()`** (AC: 11, 15)
  - [ ] `val db = database.openHelper.writableDatabase`
  - [ ] `val data = JSONObject(json).getJSONObject("data")`
  - [ ] Transacción atómica:
    ```kotlin
    db.beginTransaction()
    try {
        // DELETE children first
        TABLE_ORDER_DELETE.forEach { table ->
            db.execSQL("DELETE FROM $table")
        }
        // INSERT parents first
        TABLE_ORDER_INSERT.forEach { table ->
            val rows = data.getJSONArray(table)
            for (i in 0 until rows.length()) {
                val row = rows.getJSONObject(i)
                val cv = ContentValues()
                row.keys().forEach { key ->
                    when {
                        row.isNull(key) -> cv.putNull(key)
                        else -> {
                            val value = row.get(key)
                            when (value) {
                                is Long -> cv.put(key, value)
                                is Int -> cv.put(key, value.toLong())
                                is Double -> cv.put(key, value)
                                is String -> cv.put(key, value)
                                else -> cv.put(key, value.toString())
                            }
                        }
                    }
                }
                db.insert(table, SQLiteDatabase.CONFLICT_REPLACE, cv)
            }
        }
        db.setTransactionSuccessful()
    } finally {
        db.endTransaction()
    }
    ```
  - [ ] Si excepción en DELETE/INSERT → `endTransaction()` sin `setTransactionSuccessful()` → rollback automático
  - [ ] Re-lanzar la excepción para que el ViewModel la capture y muestre ERROR

#### 📦 DI Layer

- [ ] **Agregar binding en `RepositoryModule`**
  - [ ] Modificar archivo: `di/RepositoryModule.kt`
  - [ ] Agregar 7mo binding: `@Binds @Singleton abstract fun bindBackupRepository(impl: BackupRepositoryImpl): BackupRepository`

### Fase 3: BackupFileManager + FileProvider

<!-- Basado en Hito #3 del Análisis Arquitectónico -->
<!-- AC: 3, 6, 8 -->

#### 📦 Data Layer — Storage Helper

- [ ] **Crear `BackupFileManager`** (AC: 3, 6, 8)
  - [ ] Crear archivo: `data/local/storage/BackupFileManager.kt`
  - [ ] `@Singleton class BackupFileManager @Inject constructor(@ApplicationContext private val context: Context)`
  - [ ] **`fun writeToUri(json: String, uri: Uri)`:** Escribe JSON al URI devuelto por `CreateDocument` via `context.contentResolver.openOutputStream(uri)?.use { it.write(json.toByteArray()) }`
  - [ ] **`fun readFromUri(uri: Uri): String`:** Lee JSON desde URI devuelto por `OpenDocument` via `context.contentResolver.openInputStream(uri)?.use { it.bufferedReader().readText() } ?: throw IOException("Cannot read URI")`
  - [ ] **`fun writeToCacheForShare(json: String, fileName: String): File`:** Escribe copia a `File(context.cacheDir, fileName)` → `file.writeText(json)` → retorna `File`
  - [ ] **`fun getShareableUri(file: File): Uri`:** `FileProvider.getUriForFile(context, "${context.packageName}.fileprovider", file)`
  - [ ] **`fun extractDisplayPath(uri: Uri): String`:** Extrae ruta legible del URI para card de confirmación. Si la URI contiene `"Download"` o `"Descargas"` → retorna `"Descargas/"`. Si no se puede determinar → retorna último segmento del path o `"Almacenamiento del dispositivo"`
  - [ ] **`fun generateBackupFileName(): String`:** `"tension_backup_${LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"))}.json"`

#### 📦 Resources — FileProvider

- [ ] **Crear `file_paths.xml`**
  - [ ] Crear archivo: `res/xml/file_paths.xml`
  - [ ] Contenido:
    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <paths>
        <cache-path name="backups" path="." />
    </paths>
    ```

- [ ] **Registrar `FileProvider` en `AndroidManifest.xml`** (AC: 6)
  - [ ] Modificar archivo: `AndroidManifest.xml`
  - [ ] Dentro de `<application>`, agregar antes de `</application>`:
    ```xml
    <provider
        android:name="androidx.core.content.FileProvider"
        android:authorities="${applicationId}.fileprovider"
        android:exported="false"
        android:grantUriPermissions="true">
        <meta-data
            android:name="android.support.FILE_PROVIDER_PATHS"
            android:resource="@xml/file_paths" />
    </provider>
    ```
  - [ ] No agregar permisos runtime — `CreateDocument`, `OpenDocument` y `FileProvider` no los requieren en API 26+ (CA-18.06, RNF27)

### Fase 4: Use Cases

<!-- Basado en Hito #4 del Análisis Arquitectónico -->
<!-- AC: 1, 9, 11 -->

#### 📦 Domain Layer — Use Cases

- [ ] **Crear `ExportBackupUseCase`** (AC: 1)
  - [ ] Crear archivo: `domain/usecase/backup/ExportBackupUseCase.kt`
  - [ ] `class ExportBackupUseCase @Inject constructor(private val backupRepository: BackupRepository)`
  - [ ] `suspend operator fun invoke(): String = backupRepository.exportToJson()`

- [ ] **Crear `ValidateBackupUseCase`** (AC: 9)
  - [ ] Crear archivo: `domain/usecase/backup/ValidateBackupUseCase.kt`
  - [ ] `class ValidateBackupUseCase @Inject constructor(private val backupRepository: BackupRepository)`
  - [ ] `operator fun invoke(json: String): BackupValidationResult = backupRepository.validateBackup(json)`

- [ ] **Crear `ImportBackupUseCase`** (AC: 11)
  - [ ] Crear archivo: `domain/usecase/backup/ImportBackupUseCase.kt`
  - [ ] `class ImportBackupUseCase @Inject constructor(private val backupRepository: BackupRepository)`
  - [ ] `suspend operator fun invoke(json: String) = backupRepository.importFromJson(json)`

### Fase 5: J2 — Exportar Respaldo

<!-- Basado en Hito #5 del Análisis Arquitectónico -->
<!-- AC: 1, 2, 3, 4, 5, 6, 7 -->

#### 📦 UI Layer — Estado

- [ ] **Crear `ExportBackupUiState`**
  - [ ] Crear archivo: `ui/settings/ExportBackupUiState.kt`
  - [ ] `sealed interface ExportBackupUiState` con variantes:
    - `data object Idle : ExportBackupUiState` — estado inicial, muestra advertencia + botón
    - `data object Exporting : ExportBackupUiState` — progreso indeterminate
    - `data class Success(val fileName: String, val displayPath: String) : ExportBackupUiState` — card confirmación
    - `data class Error(val message: String) : ExportBackupUiState` — Snackbar con error

#### 📦 UI Layer — ViewModel

- [ ] **Crear `ExportBackupViewModel`** (AC: 1, 3, 4, 7)
  - [ ] Crear archivo: `ui/settings/ExportBackupViewModel.kt`
  - [ ] `@HiltViewModel class ExportBackupViewModel @Inject constructor(private val exportBackupUseCase: ExportBackupUseCase, private val backupFileManager: BackupFileManager)`
  - [ ] `private val _uiState = MutableStateFlow<ExportBackupUiState>(ExportBackupUiState.Idle)`
  - [ ] `val uiState: StateFlow<ExportBackupUiState> = _uiState.asStateFlow()`
  - [ ] Variable interna: `private var generatedJson: String? = null`
  - [ ] `fun generateBackupFileName(): String = backupFileManager.generateBackupFileName()`
  - [ ] **`fun export(uri: Uri)`**: `viewModelScope.launch(Dispatchers.IO)`:
    1. `_uiState.value = Exporting`
    2. `generatedJson = exportBackupUseCase()` — genera JSON
    3. `backupFileManager.writeToUri(generatedJson!!, uri)` — escribe al URI del picker
    4. `val fileName = backupFileManager.generateBackupFileName()`
    5. `val displayPath = backupFileManager.extractDisplayPath(uri)`
    6. `_uiState.value = Success(fileName, displayPath)`
    - Catch: `_uiState.value = Error(e.message ?: "Error al exportar")`
  - [ ] **`fun share(context: Context)`**: si `generatedJson != null`:
    1. `val file = backupFileManager.writeToCacheForShare(generatedJson!!, fileName)`
    2. `val shareUri = backupFileManager.getShareableUri(file)`
    3. Construir `Intent(ACTION_SEND)`:
       ```kotlin
       Intent(Intent.ACTION_SEND).apply {
           type = "application/json"
           putExtra(Intent.EXTRA_STREAM, shareUri)
           addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
       }
       ```
    4. `context.startActivity(Intent.createChooser(intent, null))`
  - [ ] **`fun onExportPickerCancelled()`**: resetea `_uiState.value = Idle`

#### 📦 UI Layer — Pantalla

- [ ] **Crear `ExportBackupScreen`** (AC: 3, 5, 7)
  - [ ] Crear archivo: `ui/settings/ExportBackupScreen.kt`
  - [ ] Parámetros: `onNavigateBack: () -> Unit`, `viewModel: ExportBackupViewModel = hiltViewModel()`
  - [ ] `val uiState by viewModel.uiState.collectAsStateWithLifecycle()`
  - [ ] Launcher: `val createDocumentLauncher = rememberLauncherForActivityResult(ActivityResultContracts.CreateDocument("application/json")) { uri -> if (uri != null) viewModel.export(uri) else viewModel.onExportPickerCancelled() }`
  - [ ] Scaffold con `CenterAlignedTopAppBar`: título "Exportar Respaldo", navigationIcon ArrowBack → `onNavigateBack`
  - [ ] Body `when (uiState)`:
    - **Idle** (AC: 5):
      1. `OutlinedCard` con borde Outline, corner 12dp. Leading ícono ⚠️ 24dp tint `#E65100`. Text Body Medium On Surface: "El archivo de respaldo contiene todos tus datos de entrenamiento y no está cifrado." Padding 16dp
      2. `Filled Button` full width, margin top 24dp: texto "Exportar datos". onClick: `createDocumentLauncher.launch(viewModel.generateBackupFileName())`
    - **Exporting** (AC: 7):
      1. `Filled Card` Surface Container, corner 12dp. "Exportando datos..." Body Medium On Surface. `LinearProgressIndicator` indeterminate, indicator Primary
    - **Success** (AC: 7):
      1. `Filled Card` Tertiary Container (`#E0EEDD`), corner 12dp. Leading ícono ✅ 24dp verde. "Respaldo exportado" Title Medium On Tertiary Container. "Archivo: ${fileName}" Body Medium. "Ubicación: ${displayPath}" Body Small On Tertiary Container
      2. `Filled Tonal Button` Secondary Container / On Secondary Container: "Compartir". onClick: `viewModel.share(context)` donde `context = LocalContext.current`
    - **Error**: `Snackbar` con mensaje de error. Botón "Exportar datos" se rehabilita (IDLE)

### Fase 6: J3 — Importar Respaldo

<!-- Basado en Hito #6 del Análisis Arquitectónico -->
<!-- AC: 8, 9, 10, 11, 13, 14, 15 -->

#### 📦 UI Layer — Estado

- [ ] **Crear `ImportBackupUiState`**
  - [ ] Crear archivo: `ui/settings/ImportBackupUiState.kt`
  - [ ] `sealed interface ImportBackupUiState` con variantes:
    - `data object Idle : ImportBackupUiState` — botón "Seleccionar archivo"
    - `data object Validating : ImportBackupUiState` — validación en curso
    - `data class Validated(val result: BackupValidationResult) : ImportBackupUiState` — card OK + advertencia + botón destructivo
    - `data class Invalid(val errorMessage: String) : ImportBackupUiState` — card error
    - `data object Importing : ImportBackupUiState` — progreso indeterminate
    - `data object Success : ImportBackupUiState` — ícono ✅ + auto-navega a B1 tras 2s
    - `data class Error(val message: String) : ImportBackupUiState` — card rollback + botón "Volver"

#### 📦 UI Layer — ViewModel

- [ ] **Crear `ImportBackupViewModel`** (AC: 8, 9, 10, 11, 14, 15)
  - [ ] Crear archivo: `ui/settings/ImportBackupViewModel.kt`
  - [ ] `@HiltViewModel class ImportBackupViewModel @Inject constructor(private val validateBackupUseCase: ValidateBackupUseCase, private val importBackupUseCase: ImportBackupUseCase, private val backupFileManager: BackupFileManager)`
  - [ ] `private val _uiState = MutableStateFlow<ImportBackupUiState>(ImportBackupUiState.Idle)`
  - [ ] `val uiState: StateFlow<ImportBackupUiState> = _uiState.asStateFlow()`
  - [ ] Variable interna: `private var pendingJson: String? = null` — almacena JSON validado para reutilizar en import
  - [ ] **`fun selectFile(uri: Uri)`** (AC: 8, 9):
    1. `_uiState.value = Validating`
    2. `viewModelScope.launch(Dispatchers.IO)`:
       - `val json = backupFileManager.readFromUri(uri)`
       - `val result = validateBackupUseCase(json)`
       - Si `result.isValid`:
         - `pendingJson = json`
         - `_uiState.value = Validated(result)`
       - Si no:
         - `_uiState.value = Invalid(result.errorMessage ?: "Archivo no válido")`
    - Catch: `_uiState.value = Invalid("Error al leer el archivo")`
  - [ ] **`fun confirmImport()`** (AC: 10, 11, 13, 14, 15):
    1. `val json = pendingJson ?: return`
    2. `_uiState.value = Importing`
    3. `viewModelScope.launch(Dispatchers.IO)`:
       - `importBackupUseCase(json)`
       - `pendingJson = null`
       - `_uiState.value = Success`
    - Catch: `_uiState.value = Error("La importación falló. Tus datos originales han sido preservados.")`
  - [ ] **`fun cancel()`**: `pendingJson = null; _uiState.value = Idle`

#### 📦 UI Layer — Pantalla

- [ ] **Crear `ImportBackupScreen`** (AC: 8, 9, 10, 11, 14, 15)
  - [ ] Crear archivo: `ui/settings/ImportBackupScreen.kt`
  - [ ] Parámetros: `onNavigateBack: () -> Unit`, `onNavigateToHome: () -> Unit`, `viewModel: ImportBackupViewModel = hiltViewModel()`
  - [ ] `val uiState by viewModel.uiState.collectAsStateWithLifecycle()`
  - [ ] Launcher: `val openDocumentLauncher = rememberLauncherForActivityResult(ActivityResultContracts.OpenDocument()) { uri -> if (uri != null) viewModel.selectFile(uri) }`
  - [ ] Scaffold con `CenterAlignedTopAppBar`: título "Importar Respaldo", navigationIcon ArrowBack → `onNavigateBack` (solo si estado no es `Importing` ni `Success`)
  - [ ] Body `when (uiState)`:
    - **Idle** (AC: 8):
      1. `Outlined Button` full width, leading icon `FileOpen`. Texto "Seleccionar archivo". onClick: `openDocumentLauncher.launch(arrayOf("application/json"))`
    - **Validating**: `CircularProgressIndicator` centrado
    - **Validated** (AC: 9, 10):
      1. Filled Card Tertiary Container, corner 12dp: ícono ✅ + "Archivo válido" Title Medium + "Versión: ${metadata.appVersion}" Body Medium + "Fecha del respaldo: ${metadata.exportDate}" Body Medium + "Sesiones incluidas: ${result.sessionCount}" Body Medium
      2. Filled Card Error Container, corner 12dp: ícono ⚠️ 24dp Error + "ATENCIÓN" Title Medium Bold On Error Container + "Todos los datos actuales serán reemplazados por los datos del respaldo. Esta operación no es reversible." Body Medium On Error Container
      3. `Filled Button Error` full width, 48dp height: containerColor Error (`#BA1A1A`), contentColor On Error (`#FFFFFF`). Texto "Restaurar datos". onClick: `viewModel.confirmImport()`
      4. `Text Button` Primary centrado: "Cancelar". onClick: `viewModel.cancel(); onNavigateBack()`
    - **Invalid** (AC: 9):
      1. Filled Card Error Container (`#FFDAD6`), corner 12dp: ícono ❌ 24dp Error + "Archivo no válido" Title Medium On Error Container + Body Medium On Error Container con `errorMessage` del `BackupValidationResult`. Si `errorMessage` es null, usar texto fallback de `R.string.import_backup_invalid_default` ("El archivo seleccionado no es un respaldo válido o está corrupto.") que corresponde al texto exacto de la Especificación Visual §J3
    - **Importing** (AC: 13, 14):
      1. Column: "Restaurando datos..." Body Medium On Surface + `LinearProgressIndicator` indeterminate Primary. Padding 24dp
    - **Success** (AC: 14):
      1. Column centrada: ícono ✅ 48dp verde + "Datos restaurados exitosamente." Body Large On Surface centrado
      2. `LaunchedEffect(Unit) { delay(2000L); onNavigateToHome() }` — auto-navega a B1 tras 2 segundos
    - **Error** (AC: 15):
      1. Filled Card Error Container: ícono ❌ + "La importación falló. Tus datos originales han sido preservados." Body Medium On Error Container
      2. `Outlined Button` borderColor Outline: "Volver a Configuración". onClick: `onNavigateBack()`

### Fase 7: Settings + Navegación

<!-- Basado en Hito #7 del Análisis Arquitectónico -->
<!-- AC: 3, 8 -->

#### 📦 UI Layer — Modificar SettingsScreen

- [ ] **Agregar sección "Datos" a `SettingsScreen`** (AC: 3, 8)
  - [ ] Modificar archivo: `ui/settings/SettingsScreen.kt`
  - [ ] Agregar 2 parámetros al composable: `onNavigateToExportBackup: () -> Unit`, `onNavigateToImportBackup: () -> Unit`
  - [ ] Después del `HorizontalDivider()` existente (línea 48), agregar:
    ```kotlin
    // Sección Datos
    Text(
        text = stringResource(R.string.settings_section_data),
        style = MaterialTheme.typography.labelLarge,
        color = MaterialTheme.colorScheme.onSurfaceVariant,
        modifier = Modifier.padding(start = 16.dp, top = 16.dp, bottom = 8.dp),
    )
    ListItem(
        headlineContent = { Text(stringResource(R.string.settings_export_backup)) },
        trailingContent = {
            Icon(
                imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                contentDescription = null,
            )
        },
        modifier = Modifier.clickable { onNavigateToExportBackup() },
    )
    ListItem(
        headlineContent = { Text(stringResource(R.string.settings_import_backup)) },
        trailingContent = {
            Icon(
                imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                contentDescription = null,
            )
        },
        modifier = Modifier.clickable { onNavigateToImportBackup() },
    )
    ```
  - [ ] **Nota:** NO agregar `HorizontalDivider()` entre los ListItems de la sección "Datos" — la Especificación Visual §J1 solo usa Dividers entre secciones, no entre items dentro de la misma sección. El `HorizontalDivider()` existente (línea 48, tras "Editar perfil") ya separa la sección anterior de la nueva sección "Datos".

#### 📦 Navigation Layer

- [ ] **Agregar rutas en `NavigationRoutes`**
  - [ ] Modificar archivo: `ui/navigation/NavigationRoutes.kt`
  - [ ] Agregar: `const val EXPORT_BACKUP = "export-backup"`
  - [ ] Agregar: `const val IMPORT_BACKUP = "import-backup"`

- [ ] **Actualizar `TensionNavHost`**
  - [ ] Modificar archivo: `ui/navigation/TensionNavHost.kt`
  - [ ] Actualizar composable `SETTINGS` para pasar las 2 nuevas lambdas a `SettingsScreen`:
    ```kotlin
    SettingsScreen(
        onNavigateToProfile = { navController.navigate(NavigationRoutes.PROFILE) },
        onNavigateToExportBackup = { navController.navigate(NavigationRoutes.EXPORT_BACKUP) },
        onNavigateToImportBackup = { navController.navigate(NavigationRoutes.IMPORT_BACKUP) },
    )
    ```
  - [ ] Agregar composable `EXPORT_BACKUP`:
    ```kotlin
    composable(NavigationRoutes.EXPORT_BACKUP) {
        ExportBackupScreen(
            onNavigateBack = { navController.popBackStack() },
        )
    }
    ```
  - [ ] Agregar composable `IMPORT_BACKUP`:
    ```kotlin
    composable(NavigationRoutes.IMPORT_BACKUP) {
        ImportBackupScreen(
            onNavigateBack = { navController.popBackStack() },
            onNavigateToHome = {
                navController.navigate(NavigationRoutes.HOME) {
                    popUpTo(navController.graph.id) { inclusive = true }
                }
            },
        )
    }
    ```

- [ ] **Actualizar `BottomNavigationBar`**
  - [ ] Modificar archivo: `ui/components/BottomNavigationBar.kt`
  - [ ] Agregar `NavigationRoutes.EXPORT_BACKUP` y `NavigationRoutes.IMPORT_BACKUP` al `childRoutes` del `BottomNavItem` de SETTINGS:
    - Antes: `childRoutes = setOf(NavigationRoutes.PROFILE, NavigationRoutes.WEIGHT_HISTORY)`
    - Después: `childRoutes = setOf(NavigationRoutes.PROFILE, NavigationRoutes.WEIGHT_HISTORY, NavigationRoutes.EXPORT_BACKUP, NavigationRoutes.IMPORT_BACKUP)`

### Fase 8: Strings

<!-- Basado en Hito #8 del Análisis Arquitectónico -->
<!-- AC: 5, 7, 9, 10, 14, 15 -->

#### 📦 Resources

- [ ] **Agregar strings en `strings.xml`**
  - [ ] Modificar archivo: `res/values/strings.xml`
  - [ ] Agregar sección `<!-- Settings J1 — Datos -->`:
    - `settings_section_data` = "Datos"
    - `settings_export_backup` = "Exportar respaldo"
    - `settings_import_backup` = "Importar respaldo"
  - [ ] Agregar sección `<!-- Export Backup J2 -->`:
    - `export_backup_title` = "Exportar Respaldo"
    - `export_backup_warning` = "El archivo de respaldo contiene todos tus datos de entrenamiento y no está cifrado."
    - `export_backup_button` = "Exportar datos"
    - `export_backup_exporting` = "Exportando datos…"
    - `export_backup_success_title` = "Respaldo exportado"
    - `export_backup_file_label` = "Archivo: %1$s"
    - `export_backup_location_label` = "Ubicación: %1$s"
    - `export_backup_share` = "Compartir"
    - `export_backup_error` = "Error al exportar los datos"
  - [ ] Agregar sección `<!-- Import Backup J3 -->`:
    - `import_backup_title` = "Importar Respaldo"
    - `import_backup_select_file` = "Seleccionar archivo"
    - `import_backup_valid_title` = "Archivo válido"
    - `import_backup_version` = "Versión: %1$s"
    - `import_backup_date` = "Fecha del respaldo: %1$s"
    - `import_backup_sessions` = "Sesiones incluidas: %1$d"
    - `import_backup_invalid_title` = "Archivo no válido"
    - `import_backup_warning_title` = "ATENCIÓN"
    - `import_backup_warning_message` = "Todos los datos actuales serán reemplazados por los datos del respaldo. Esta operación no es reversible."
    - `import_backup_restore_button` = "Restaurar datos"
    - `import_backup_cancel` = "Cancelar"
    - `import_backup_importing` = "Restaurando datos…"
    - `import_backup_success` = "Datos restaurados exitosamente."
    - `import_backup_error` = "La importación falló. Tus datos originales han sido preservados."
    - `import_backup_back_to_settings` = "Volver a Configuración"
    - `import_backup_read_error` = "Error al leer el archivo"
    - `import_backup_invalid_default` = "El archivo seleccionado no es un respaldo válido o está corrupto."
    - `import_backup_invalid_json` = "El archivo no contiene JSON válido"
    - `import_backup_invalid_format` = "Formato de respaldo no reconocido"
    - `import_backup_incompatible_version` = "Versión de respaldo incompatible (esperada: %1$d, encontrada: %2$d)"
    - `import_backup_incomplete` = "Archivo de respaldo incompleto"

### Fase 9: Tests Unitarios

<!-- Basado en Hito #9 del Análisis Arquitectónico -->
<!-- AC: Todos los CAs cubiertos por tests -->

#### 🧪 Tests — BackupRepositoryImpl

- [ ] **Test `BackupRepositoryImplTest`** (AC: 1, 2, 4, 9, 11, 12, 15)
  - [ ] Crear archivo: `test/.../data/repository/BackupRepositoryImplTest.kt`
  - [ ] Setup: mock `TensionDatabase`, mock `SupportSQLiteDatabase`, mock `SupportSQLiteOpenHelper`. `every { database.openHelper.readableDatabase }` returns mock db. `every { database.openHelper.writableDatabase }` returns mock db
  - [ ] Caso 1: `exportToJson produces valid JSON with metadata and all 16 tables` — mock cursor con datos de ejemplo para 2 tablas (profile + module), verify JSON contiene keys `"metadata"` y `"data"` con las 16 tablas, verify `metadata.schemaVersion == 7`
  - [ ] Caso 2: `exportToJson includes correct recordCount in metadata` — mock cursors con N filas, verify `metadata.recordCount` == suma total
  - [ ] Caso 3: `validateBackup returns valid for correct JSON` — construir JSON válido con metadata + data, verify `isValid == true` y `sessionCount` correcto
  - [ ] Caso 4: `validateBackup returns invalid for malformed JSON` — pasar string no JSON, verify `isValid == false` y `errorMessage` no null
  - [ ] Caso 5: `validateBackup returns invalid for wrong schemaVersion` — JSON con `schemaVersion = 99`, verify `isValid == false` (CA-18.12)
  - [ ] Caso 6: `validateBackup returns invalid for missing data section` — JSON sin key `"data"`, verify `isValid == false`
  - [ ] Caso 7: `importFromJson calls beginTransaction and setTransactionSuccessful` — mock db, verify transaction lifecycle methods called
  - [ ] Caso 8: `importFromJson deletes tables in children-first order` — capture `execSQL` calls, verify DELETE order matches `TABLE_ORDER_DELETE`
  - [ ] Caso 9: `importFromJson inserts tables in parents-first order` — capture `insert` calls, verify INSERT order matches `TABLE_ORDER_INSERT`
  - [ ] Caso 10: `importFromJson rolls back on exception` — mock `db.insert` to throw on 5th table, verify `setTransactionSuccessful` NOT called, verify `endTransaction` IS called (CA-18.15)

#### 🧪 Tests — BackupFileManager

- [ ] **Test `BackupFileManagerTest`** (AC: 3, 8)
  - [ ] Crear archivo: `test/.../data/local/storage/BackupFileManagerTest.kt`
  - [ ] Caso 1: `generateBackupFileName returns correct format` — verify matches `tension_backup_YYYYMMDD.json` pattern
  - [ ] Caso 2: `extractDisplayPath returns Descargas for download URI` — mock URI with "Download" in path, verify returns `"Descargas/"`

#### 🧪 Tests — Use Cases

- [ ] **Test `ExportBackupUseCaseTest`**
  - [ ] Crear archivo: `test/.../domain/usecase/backup/ExportBackupUseCaseTest.kt`
  - [ ] Caso 1: `invoke delegates to repository exportToJson` — mock repository, verify `exportToJson()` called

- [ ] **Test `ValidateBackupUseCaseTest`**
  - [ ] Crear archivo: `test/.../domain/usecase/backup/ValidateBackupUseCaseTest.kt`
  - [ ] Caso 1: `invoke delegates to repository validateBackup` — mock repository, verify `validateBackup()` called with correct json

- [ ] **Test `ImportBackupUseCaseTest`**
  - [ ] Crear archivo: `test/.../domain/usecase/backup/ImportBackupUseCaseTest.kt`
  - [ ] Caso 1: `invoke delegates to repository importFromJson` — mock repository, verify `importFromJson()` called

#### 🧪 Tests — ViewModels

- [ ] **Test `ExportBackupViewModelTest`** (AC: 1, 3, 4, 7)
  - [ ] Crear archivo: `test/.../ui/settings/ExportBackupViewModelTest.kt`
  - [ ] Setup: mock `ExportBackupUseCase`, mock `BackupFileManager`. Usar `Dispatchers.setMain(StandardTestDispatcher())` en `@Before`
  - [ ] Caso 1: `export transitions from Idle to Exporting to Success` — mock UseCase returns JSON, mock BackupFileManager.writeToUri(), verify state transitions IDLE → EXPORTING → SUCCESS con fileName y displayPath correctos
  - [ ] Caso 2: `export transitions to Error on exception` — mock UseCase throws IOException, verify state transitions IDLE → EXPORTING → ERROR con mensaje
  - [ ] Caso 3: `onExportPickerCancelled resets to Idle` — set state to any non-Idle, call onExportPickerCancelled(), verify state == Idle
  - [ ] Caso 4: `generateBackupFileName delegates to BackupFileManager` — verify delegation

- [ ] **Test `ImportBackupViewModelTest`** (AC: 8, 9, 10, 11, 14, 15)
  - [ ] Crear archivo: `test/.../ui/settings/ImportBackupViewModelTest.kt`
  - [ ] Setup: mock `ValidateBackupUseCase`, mock `ImportBackupUseCase`, mock `BackupFileManager`. Usar `Dispatchers.setMain(StandardTestDispatcher())` en `@Before`
  - [ ] Caso 1: `selectFile with valid JSON transitions to Validated` — mock readFromUri returns JSON, mock validateBackup returns valid result, verify state transitions IDLE → VALIDATING → VALIDATED con result correcto
  - [ ] Caso 2: `selectFile with invalid JSON transitions to Invalid` — mock validateBackup returns invalid, verify state == INVALID con errorMessage
  - [ ] Caso 3: `selectFile with read error transitions to Invalid` — mock readFromUri throws IOException, verify state == INVALID con mensaje "Error al leer el archivo"
  - [ ] Caso 4: `confirmImport transitions to Success` — set pendingJson, mock importBackupUseCase succeeds, verify state transitions VALIDATED → IMPORTING → SUCCESS
  - [ ] Caso 5: `confirmImport transitions to Error on exception with rollback message` — mock importBackupUseCase throws, verify state == ERROR con mensaje de rollback (CA-18.15)
  - [ ] Caso 6: `cancel resets to Idle and clears pendingJson` — set state to Validated, call cancel(), verify state == IDLE

### Fase 10: QA y Deployment

<!-- Fase N — Tareas manuales -->

#### 📋 Code Quality

- [ ] **Ejecutar Agente Peer Review** (MANUAL)
- [ ] **Resolver incidentes del Peer Review** (MANUAL, condicional)

#### 🚀 Deployment DEV

- [ ] **Crear Pull Request** (MANUAL)
- [ ] **Ejecutar pipeline deployment DEV** (MANUAL)

#### 🧪 Testing Manual

- [ ] **Diseñar set de pruebas manuales** (MANUAL)
- [ ] **Ejecutar pruebas manuales** (MANUAL)

---

**Notas sobre vinculación con Criterios de Aceptación:**

| CA | Fase(s) | Mecanismo |
|----|---------|-----------|
| CA-18.01 | 2 | `BackupRepositoryImpl.exportToJson()` — SELECT * × 16 tablas → JSON |
| CA-18.02 | 1, 2 | `BackupMetadata` con `schemaVersion` + estructura JSON autodescriptiva |
| CA-18.03 | 3, 5 | `CreateDocument` SAF (guardado directo) + `FileProvider` + `ACTION_SEND` (compartir) |
| CA-18.04 | 2 | Raw SQL sequencial + `Dispatchers.IO`. < 5s para ~30K registros |
| CA-18.05 | 5, 8 | `OutlinedCard` con ⚠️ antes del botón en J2 |
| CA-18.06 | 3 | Cero permisos runtime — SAF + FileProvider en API 26+ |
| CA-18.07 | 5 | `LinearProgressIndicator` indeterminate + card confirmación con fileName + displayPath |
| CA-18.08 | 6 | `OpenDocument` launcher con MIME `"application/json"` |
| CA-18.09 | 1, 2, 6 | `validateBackup()` verifica JSON + metadata + schemaVersion + tablas |
| CA-18.10 | 6 | Filled Card Error Container + botón destructivo Error + "Cancelar" |
| CA-18.11 | 2 | `importFromJson()` — DELETE × 16 + INSERT × 16 en transacción atómica |
| CA-18.12 | 2 | `schemaVersion != SCHEMA_VERSION` → rechazo con mensaje. Stub migración para v2+ |
| CA-18.13 | 2, 6 | `Dispatchers.IO` + LinearProgressIndicator. < 8s para ~30K registros |
| CA-18.14 | 6 | Fases IMPORTING → SUCCESS con ✅ + auto-navegación a B1 tras 2s |
| CA-18.15 | 2, 6 | `beginTransaction()`/`endTransaction()` sin `setTransactionSuccessful()` → rollback. Card error |