# HU-15.5 — Migración a división Pull / Push / Legs

## Requisitos relacionados

RF04, RF05, RF08

## Descripción

Como ejecutante, necesito que el sistema reorganice internamente la distribución de grupos musculares por módulo — pasando de la división anterior (A = Pecho, Espalda, Abdomen; B = Hombro, Tríceps, Bíceps) a la división fisiológicamente optimizada para hipertrofia **Pull / Push / Legs** (A = Espalda, Bíceps, Abdomen; B = Pecho, Hombro, Tríceps) — y que corrija la clasificación del ejercicio "Elevación de hombros con mancuernas" de Hombro a Espalda Media, para que mi plan de entrenamiento refleje correctamente los patrones biomecánicos de jalón y empuje, y los datos históricos ya registrados se preserven íntegros y correctamente asociados bajo la nueva estructura.

## Contexto y justificación del cambio

### Motivación fisiológica

La división anterior agrupaba Pecho + Espalda + Abdomen en un mismo día (Módulo A) y Hombro + Tríceps + Bíceps en otro (Módulo B). Sin embargo, esta agrupación no respeta los patrones de movimiento biomecánicos:

- **Jalones (Pull):** Los movimientos de tracción — como remos y jalones dorsales — reclutan sinérgicamente el bíceps. Entrenar espalda y bíceps juntos aprovecha esta sinergia y reduce la fatiga residual cruzada entre módulos.
- **Empujones (Push):** Los movimientos de empuje — como press de banca y press de hombro — reclutan sinérgicamente el tríceps. Entrenar pecho, hombro y tríceps juntos aprovecha esta sinergia.
- **Abdomen con Pull:** El módulo de jalones (Espalda + Bíceps) trabaja 2 grupos musculares principales frente a los 3 del módulo de empujones (Pecho + Hombro + Tríceps). Agregar Abdomen al módulo A equilibra la carga de trabajo.

### Corrección de zona muscular

El ejercicio "Elevación de hombros con mancuernas" (*dumbbell shrugs*) trabaja el trapecio, que anatómicamente pertenece a la espalda, no al hombro. La zona muscular correcta es **Espalda Media**, no Hombro.

### Impacto sobre datos existentes

El ejecutante tiene 15 sesiones de datos históricos registrados bajo la estructura anterior. Esta migración **no invalida** esos datos: cada registro de serie está vinculado al `exercise_id` (no al módulo) y al `session_id`. La reasignación del `module_code` de los ejercicios afectados actualiza la pertenencia del ejercicio, pero no altera los datos crudos de series ya registradas. Las métricas históricas (tonelaje, tasas de progresión) se recalculan automáticamente porque se derivan del ejercicio, no del módulo.

---

## Criterios de Aceptación

### Bloque A — Migración de la tabla `module` (metadatos)

#### CA-15.5.01 — Actualización de nombre y grupo muscular del Módulo A

**Dado que** el Módulo A tenía `name = "Módulo A — Superior"` y `group_description = "Pecho, Espalda, Abdomen"`,
**cuando** se ejecuta la migración,
**entonces** el Módulo A queda con `name = "Módulo A — Superior (Pull + Abs)"` y `group_description = "Espalda, Bíceps, Abdomen"`.

#### CA-15.5.02 — Actualización de nombre y grupo muscular del Módulo B

**Dado que** el Módulo B tenía `name = "Módulo B — Superior"` y `group_description = "Hombro, Tríceps, Bíceps"`,
**cuando** se ejecuta la migración,
**entonces** el Módulo B queda con `name = "Módulo B — Superior (Push)"` y `group_description = "Pecho, Hombro, Tríceps"`.

#### CA-15.5.03 — Módulo C inalterado

**Dado que** el Módulo C ya estaba correctamente asignado,
**cuando** se ejecuta la migración,
**entonces** el Módulo C conserva `name = "Módulo C — Inferior"` y `group_description = "Cuádriceps, Isquiotibiales, Glúteos, Aductores, Abductores, Gemelos"` sin cambios.

---

### Bloque B — Migración de la tabla `exercise` (reasignación de módulo)

#### CA-15.5.04 — Ejercicios de Pecho migran de A a B

**Dado que** los ejercicios de Pecho (IDs 1-7: Press de banca, Press de mancuerna, Press de banca inclinada, Flexiones, Cruce en polea alta, Apertura de pecho sentado, Apertura de pecho inclinado) pertenecían al Módulo A,
**cuando** se ejecuta la migración,
**entonces** los 7 ejercicios de Pecho tienen `module_code = "B"`.

#### CA-15.5.05 — Ejercicios de Bíceps migran de B a A

**Dado que** los ejercicios de Bíceps (IDs 16-20: Curl de bíceps Mancuerna, Curl de bíceps Polea, Curl de martillo cruzado, Curl de martillo, Curl de Contracción) pertenecían al Módulo B,
**cuando** se ejecuta la migración,
**entonces** los 5 ejercicios de Bíceps tienen `module_code = "A"`.

#### CA-15.5.06 — Elevación de hombros con mancuernas migra de B a A

**Dado que** el ejercicio "Elevación de hombros con mancuernas" (ID 26) pertenecía al Módulo B,
**cuando** se ejecuta la migración,
**entonces** el ejercicio tiene `module_code = "A"`.

#### CA-15.5.07 — Ejercicios de Hombro (excepto Elevación de hombros) permanecen en B

**Dado que** los ejercicios de Hombro restantes (IDs 24, 25, 27, 28, 29: Elevación frontal, Elevación lateral, Press de elevación sentado, Remo vertical, Remo vertical con cable) pertenecían al Módulo B,
**cuando** se ejecuta la migración,
**entonces** los 5 ejercicios de Hombro conservan `module_code = "B"`.

#### CA-15.5.08 — Ejercicios de Tríceps permanecen en B

**Dado que** los ejercicios de Tríceps (IDs 21-23: Dominada de tríceps banco, Extensión de tríceps por encima de la cabeza, Flexión de tríceps con cuerda) pertenecían al Módulo B,
**cuando** se ejecuta la migración,
**entonces** los 3 ejercicios de Tríceps conservan `module_code = "B"`.

#### CA-15.5.09 — Ejercicios de Espalda y Abdomen permanecen en A

**Dado que** los ejercicios de Espalda (IDs 8-10: Remo con Inclinación, Remo con un solo brazo doblado, Tiro de dorsales) y Abdomen (IDs 11-15: Abdominales, Escalador, Giro Ruso, Plancha, Plancha Lateral) pertenecían al Módulo A,
**cuando** se ejecuta la migración,
**entonces** los 8 ejercicios conservan `module_code = "A"`.

#### CA-15.5.10 — Ejercicios del Módulo C inalterados

**Dado que** los 14 ejercicios del Módulo C (IDs 30-43) ya estaban correctamente asignados,
**cuando** se ejecuta la migración,
**entonces** los 14 ejercicios conservan `module_code = "C"`.

#### CA-15.5.11 — Conteo final de ejercicios por módulo

**Dado que** la migración ha completado las reasignaciones,
**cuando** se verifica el conteo,
**entonces** el Módulo A tiene 14 ejercicios (4 Espalda + 5 Bíceps + 5 Abdomen), el Módulo B tiene 15 ejercicios (7 Pecho + 5 Hombro + 3 Tríceps) y el Módulo C tiene 14 ejercicios (inalterado). Total: 43 ejercicios.

---

### Bloque C — Corrección de zona muscular de "Elevación de hombros con mancuernas"

#### CA-15.5.12 — Cambio de zona muscular de Hombro a Espalda Media

**Dado que** el ejercicio "Elevación de hombros con mancuernas" (ID 26) tenía asignada la zona muscular Hombro (muscle_zone_id = 7),
**cuando** se ejecuta la migración,
**entonces** la fila correspondiente en `exercise_muscle_zone` se actualiza a `muscle_zone_id = 4` (Espalda Media).

#### CA-15.5.13 — Recálculo de KPIs post-migración

**Dado que** el cambio de zona muscular afecta la distribución de volumen por grupo muscular,
**cuando** el ejecutante consulta las métricas de analítica después de la migración,
**entonces** el tonelaje y distribución de volumen del grupo muscular "Hombro" disminuye al perder las series de Elevación de hombros, y el grupo muscular "Espalda" aumenta al ganarlas. Los cálculos reflejan la corrección retroactivamente.

---

### Bloque D — Migración de la tabla `plan_assignment` (recomposición de versiones)

#### CA-15.5.14 — Eliminación de asignaciones antiguas de Módulos A y B

**Dado que** las asignaciones del plan de entrenamiento para los Módulos A y B ya no corresponden a la nueva estructura,
**cuando** se ejecuta la migración,
**entonces** se eliminan las 66 filas de `plan_assignment` correspondientes a `module_version_id` IN (1, 2, 3, 4, 5, 6).

#### CA-15.5.15 — Inserción de nuevas asignaciones del Módulo A (Pull + Abs)

**Dado que** el nuevo Módulo A agrupa Espalda, Bíceps y Abdomen,
**cuando** se ejecuta la migración,
**entonces** se insertan las siguientes 33 filas de `plan_assignment` (3 versiones × 11 ejercicios):

**A-V1:** Tiro de dorsales (10), Remo con Inclinación (8), Remo con un solo brazo doblado (9), Curl de bíceps Mancuerna (16), Curl de martillo cruzado (18), Curl de bíceps Polea (17), Curl de martillo (19), Abdominales (11), Escalador (12), Giro Ruso (13), Plancha (14).

**A-V2:** Tiro de dorsales (10), Remo con Inclinación (8), Remo con un solo brazo doblado (9), Elevación de hombros (26), Curl de bíceps Mancuerna (16), Curl de martillo cruzado (18), Curl de bíceps Polea (17), Curl de Contracción (20), Abdominales (11), Plancha (14), Plancha Lateral (15).

**A-V3:** Tiro de dorsales (10), Remo con Inclinación (8), Remo con un solo brazo doblado (9), Elevación de hombros (26), Curl de bíceps Mancuerna (16), Curl de martillo (19), Curl de bíceps Polea (17), Curl de Contracción (20), Abdominales (11), Giro Ruso (13), Plancha (14).

#### CA-15.5.16 — Inserción de nuevas asignaciones del Módulo B (Push)

**Dado que** el nuevo Módulo B agrupa Pecho, Hombro y Tríceps,
**cuando** se ejecuta la migración,
**entonces** se insertan las siguientes 33 filas de `plan_assignment` (3 versiones × 11 ejercicios):

**B-V1:** Press de banca (1), Press de banca inclinada (3), Apertura de pecho sentado (6), Flexiones (4, fallo técnico), Press de elevación sentado (27), Elevación frontal (24), Elevación lateral (25), Remo vertical (28), Dominada de tríceps banco (21), Extensión de tríceps cabeza (22), Flexión de tríceps cuerda (23).

**B-V2:** Press de banca (1), Apertura de pecho inclinado (7), Apertura de pecho sentado (6), Cruce en polea alta (5), Press de elevación sentado (27), Elevación lateral (25), Remo vertical con cable (29), Press de mancuerna (2), Dominada de tríceps banco (21), Extensión de tríceps cabeza (22), Flexión de tríceps cuerda (23).

**B-V3:** Press de banca (1), Press de banca inclinada (3), Apertura de pecho sentado (6), Cruce en polea alta (5), Press de elevación sentado (27), Elevación frontal (24), Remo vertical (28), Press de mancuerna (2), Dominada de tríceps banco (21), Extensión de tríceps cabeza (22), Flexión de tríceps cuerda (23).

#### CA-15.5.17 — Asignaciones del Módulo C inalteradas

**Dado que** el Módulo C no cambió su composición,
**cuando** se ejecuta la migración,
**entonces** las 27 filas de `plan_assignment` de `module_version_id` IN (7, 8, 9) permanecen sin cambios.

#### CA-15.5.18 — Conteo total de asignaciones post-migración

**Dado que** la migración ha completado la recomposición,
**cuando** se verifica el conteo,
**entonces** `plan_assignment` tiene exactamente 93 filas: 33 (A) + 33 (B) + 27 (C).

---

### Bloque E — Actualización de seeders para instalaciones nuevas

#### CA-15.5.19 — ModuleSeeder actualizado

**Dado que** el seeder de módulos contenía los nombres y descripciones anteriores,
**cuando** se actualiza el seeder,
**entonces** `ModuleSeeder.kt` inserta:
- `("A", "Módulo A — Superior (Pull + Abs)", "Espalda, Bíceps, Abdomen", 2.5)`
- `("B", "Módulo B — Superior (Push)", "Pecho, Hombro, Tríceps", 2.5)`
- `("C", "Módulo C — Inferior", ...)` sin cambios.

#### CA-15.5.20 — ExerciseSeeder actualizado (module_code)

**Dado que** el seeder de ejercicios asignaba los ejercicios a los módulos anteriores,
**cuando** se actualiza el seeder,
**entonces** los ejercicios de Pecho (IDs 1-7) se insertan con `moduleCode = "B"`, los ejercicios de Bíceps (IDs 16-20) y Elevación de hombros (ID 26) se insertan con `moduleCode = "A"`, y los demás ejercicios conservan su módulo original.

#### CA-15.5.21 — ExerciseSeeder actualizado (muscle_zone)

**Dado que** el seeder asignaba "Elevación de hombros con mancuernas" (ID 26) a la zona muscular Hombro (zone_id = 7),
**cuando** se actualiza el seeder,
**entonces** la asignación se cambia a Espalda Media (zone_id = 4): `emz(db, 26, 4)`.

#### CA-15.5.22 — PlanSeeder actualizado

**Dado que** el seeder del plan contenía las asignaciones de versiones anteriores para Módulos A y B,
**cuando** se actualiza el seeder,
**entonces** `PlanSeeder.kt` refleja las nuevas 33 + 33 asignaciones de A y B según los CA-15.5.15 y CA-15.5.16, y las 27 asignaciones de C permanecen iguales.

---

### Bloque F — Migración de base de datos Room

#### CA-15.5.23 — Incremento de versión de la base de datos

**Dado que** la base de datos actual está en versión N,
**cuando** se implementa la migración,
**entonces** la versión de la base de datos se incrementa a N+1 y se registra una `Migration(N, N+1)` en el `DatabaseModule`.

#### CA-15.5.24 — Migración SQL ejecutada secuencialmente

**Dado que** la migración requiere cambios en 4 tablas (`module`, `exercise`, `exercise_muscle_zone`, `plan_assignment`),
**cuando** se ejecuta la `Migration(N, N+1)`,
**entonces** los statements SQL se ejecutan en el siguiente orden dentro de una transacción:
1. UPDATE `module` (2 filas: A y B)
2. UPDATE `exercise` (13 filas: 7 Pecho de A→B, 5 Bíceps de B→A, 1 Elevación hombros de B→A)
3. UPDATE `exercise_muscle_zone` (1 fila: ejercicio 26 de zone 7→4)
4. DELETE `plan_assignment` WHERE `module_version_id` IN (1, 2, 3, 4, 5, 6)
5. INSERT 66 filas nuevas en `plan_assignment`

#### CA-15.5.25 — Preservación de datos históricos

**Dado que** el ejecutante tiene sesiones, series y alertas registradas bajo la estructura anterior,
**cuando** se ejecuta la migración,
**entonces** ninguna fila de las tablas `session`, `exercise_set`, `session_exercise` ni `alert` es modificada ni eliminada. Los datos históricos se preservan íntegros.

#### CA-15.5.26 — Estado de rotación preservado

**Dado que** el `profile` almacena la posición actual en la rotación cíclica (`current_module_position`) y las versiones por módulo (`module_a_version_index`, `module_b_version_index`, `module_c_version_index`),
**cuando** se ejecuta la migración,
**entonces** el estado de rotación se preserva sin cambios. La próxima sesión del ejecutante usará el módulo y versión que corresponda según la rotación existente.

---

### Bloque G — Validación de integridad post-migración

#### CA-15.5.27 — Test unitario: conteo de ejercicios por módulo

**Dado que** la migración ha sido aplicada,
**cuando** se ejecuta `SELECT module_code, COUNT(*) FROM exercise GROUP BY module_code`,
**entonces** retorna: A = 14, B = 15, C = 14.

#### CA-15.5.28 — Test unitario: conteo de asignaciones por versión

**Dado que** la migración ha sido aplicada,
**cuando** se ejecuta `SELECT module_version_id, COUNT(*) FROM plan_assignment GROUP BY module_version_id`,
**entonces** retorna: 1 = 11, 2 = 11, 3 = 11, 4 = 11, 5 = 11, 6 = 11, 7 = 9, 8 = 9, 9 = 9.

#### CA-15.5.29 — Test unitario: zona muscular de Elevación de hombros

**Dado que** la migración ha sido aplicada,
**cuando** se consulta `SELECT mz.name FROM exercise_muscle_zone emz JOIN muscle_zone mz ON emz.muscle_zone_id = mz.id WHERE emz.exercise_id = 26`,
**entonces** retorna "Espalda Media".

#### CA-15.5.30 — Test unitario: integridad referencial de plan_assignment

**Dado que** la migración ha recompuesto las asignaciones del plan,
**cuando** se ejecuta la validación cruzada `SELECT pa.* FROM plan_assignment pa JOIN module_version mv ON pa.module_version_id = mv.id JOIN exercise e ON pa.exercise_id = e.id WHERE mv.module_code != e.module_code`,
**entonces** retorna 0 filas (todos los ejercicios asignados pertenecen al módulo correcto de su versión).

---

## Análisis Arquitectónico (Arquitecto)

### Decisiones de Diseño

**Patrón Arquitectónico:** Room Database Migration (data-only) con sincronización de Seed Data

**Justificación:** HU-15.5 es una operación 100% en la capa de datos. No hay cambios de esquema DDL (tablas, columnas, índices) — solo manipulación de datos existentes (UPDATE, DELETE, INSERT) dentro de una `Migration(6, 7)` de Room. El código productivo fuera de `data/local/` no se toca. Los seeders se actualizan en paralelo para que instalaciones nuevas arranquen con la estructura correcta. Es la migración más limpia posible: sin nuevos componentes de dominio, sin cambios de UI, sin nuevas dependencias.

### Decisiones Fundamentadas

**1. Se crea `Migrations.kt` como archivo dedicado en `data.local.database` para alojar `MIGRATION_6_7`.**

Actualmente la app NO tiene ninguna migración registrada — usa exclusivamente `fallbackToDestructiveMigration()`. Este es el primer migration del proyecto. Se crea un `object Migrations` que contiene `val MIGRATION_6_7: Migration` como propiedad. Ubicado junto a `TensionDatabase.kt` y `Converters.kt` en el paquete `data.local.database`, siguiendo la convención de naming del proyecto (`PascalCase` para objetos, Arquitectura Técnica §5.2). Si futuras HUs requieren migraciones adicionales, se agregan al mismo objeto (`MIGRATION_7_8`, etc.).

**2. `.addMigrations()` se registra ANTES de `.fallbackToDestructiveMigration()` en el builder de Room.**

El orden en la cadena del builder de Room importa: si `Migration(6, 7)` está registrada, Room la ejecuta para usuarios que actualizan (preservando datos). Si por alguna razón futura la versión salta más allá de 7 sin migration cubierta, el fallback destructivo actúa como red de seguridad (recrea BD con seeders actualizados vía `PrepopulateCallback`). La cadena queda:

```kotlin
Room.databaseBuilder(context, TensionDatabase::class.java, "tension_database")
    .addCallback(PrepopulateCallback())
    .addMigrations(Migrations.MIGRATION_6_7)
    .fallbackToDestructiveMigration()
    .build()
```

**3. Room envuelve la migración en una transacción — no se necesita manejo manual de transacciones.**

Room ejecuta el método `migrate()` dentro de una transacción implícita. Si cualquier statement SQL falla, Room revierte toda la migración y aplica el fallback destructivo (que recrea la BD y ejecuta los seeders actualizados via `PrepopulateCallback.onDestructiveMigration()`). Por tanto, el cuerpo de `migrate()` contiene llamadas `database.execSQL()` planas sin `beginTransaction()/setTransactionSuccessful()/endTransaction()`. Esto simplifica el código y evita transacciones anidadas.

**4. `PRAGMA foreign_keys` está desactivado durante migraciones de Room — no hay riesgo de orden de operaciones.**

Room desactiva automáticamente la verificación de FK antes de ejecutar migraciones y la verifica después con `PRAGMA foreign_key_check`. Esto elimina cualquier riesgo de violación temporal de integridad referencial durante la ejecución secuencial del SQL (ej: reasignar `module_code = 'B'` a ejercicios de Pecho cuando el módulo B aún tiene la descripción anterior). Los 7 bloques de SQL del CA-15.5.24 se ejecutan secuencialmente sin importar el orden relativo entre UPDATEs de `module` y UPDATEs de `exercise`.

**5. `exercise_progression` se preserva sin modificaciones — `load_increment_kg` es idéntico entre A y B.**

Los 13 ejercicios reasignados se mueven entre módulos A (`load_increment_kg = 2.5`) y B (`load_increment_kg = 2.5`), que tienen el mismo incremento. Las cargas prescritas (`prescribed_load_kg`) y contadores de meseta (`sessions_without_progression`) siguen siendo válidos. El `DoubleThresholdRule` consulta `module.load_increment_kg` dinámicamente al cierre de sesión — no hay valor cacheado que quede obsoleto.

**6. Alertas existentes con `module_code` preservadas — HU-17 (alertas) no está implementada.**

`AlertEntity` tiene columna `module_code` (FK a `module`). Alertas existentes que referenciaran módulos A o B podrían tener metadata semánticamente obsoleta. Sin embargo: (1) La migración NO modifica `alert` (CA-15.5.25 correcto). (2) HU-17 (sistema de alertas) aún no está implementada — no existen alertas en la BD del ejecutante. (3) Si las hubiera, los valores de FK (`"A"`, `"B"`) siguen siendo claves válidas — solo cambió la descripción del módulo, no su código. No hay acción requerida.

**7. No se necesita `exportSchema = true` ni `MigrationTestHelper` para esta migración.**

El proyecto tiene `exportSchema = false` en `@Database`. Habilitar schema export requeriría cambios en `build.gradle.kts` y generación de archivos JSON. Para una migración de datos pura (sin DDL), `MigrationTestHelper` no aporta valor: su propósito es validar cambios estructurales de esquema. Los 4 tests de integridad del Bloque G se implementan como tests instrumentados estándar que ejecutan queries de verificación post-migración sobre una BD real.

**8. Hallazgo en CA-15.5.26: nombres de columna y tabla incorrectos en la redacción del PO.**

CA-15.5.26 dice: *"Dado que el `profile` almacena la posición actual en la rotación cíclica (`current_module_position`) y las versiones por módulo (`module_a_version_index`, `module_b_version_index`, `module_c_version_index`)..."*. Verificación contra código real:

- El estado de rotación NO está en `profile` — está en la tabla **`rotation_state`** (entidad separada, `RotationStateEntity`, fila única con `id = 1`).
- Los nombres de columna correctos son: `microcycle_position` (no `current_module_position`), `current_version_module_a` (no `module_a_version_index`), `current_version_module_b`, `current_version_module_c`, `microcycle_count`.

El **intent** del CA es correcto: el estado de rotación se preserva porque la migración SQL NO toca la tabla `rotation_state`. El cumplimiento es automático. Pero la redacción debe corregirse para evitar confusión durante la implementación.

### Componentes Afectados

**Componentes nuevos:**

| # | Componente | Tipo | Paquete | Responsabilidad |
|---|-----------|------|---------|-----------------|
| 1 | `Migrations` | Nuevo (object) | `data.local.database` | Declara `val MIGRATION_6_7: Migration` con los 7 bloques de SQL (2 UPDATEs module, 2 UPDATEs exercise, 1 UPDATE exercise_muscle_zone, 1 DELETE plan_assignment, 66 INSERTs plan_assignment) |

**Componentes modificados:**

| # | Componente | Modificación | Nivel |
|---|-----------|-------------|-------|
| 1 | `TensionDatabase` | Cambiar `version = 6` → `version = 7` | Menor |
| 2 | `DatabaseModule` | Agregar `.addMigrations(Migrations.MIGRATION_6_7)` ANTES de `.fallbackToDestructiveMigration()` | Menor |
| 3 | `ModuleSeeder` | Actualizar `name` y `group_description` de módulos A y B (2 líneas) | Menor |
| 4 | `ExerciseSeeder` | Cambiar `module_code` de 13 ejercicios (13 líneas) + cambiar `muscle_zone_id` del ejercicio 26 de `emz(db, 26, 7)` → `emz(db, 26, 4)` (1 línea) | Medio |
| 5 | `PlanSeeder` | Reemplazar las 66 llamadas `pa()` de módulos A y B con las 66 nuevas según CA-15.5.15 y CA-15.5.16. Las 27 de C no cambian | Mayor |

**Componentes NO tocados (verificado en código):**

- `RotationStateEntity` / `RotationStateDao` — no se modifica tabla ni datos
- `ProfileEntity` / `ProfileDao` — no contiene estado de rotación
- `SessionEntity` / `SessionExerciseEntity` / `ExerciseSetEntity` — datos transaccionales preservados
- `ExerciseProgressionEntity` / `ExerciseProgressionDao` — cargas prescritas y contadores válidos
- `AlertEntity` / `DeloadEntity` — FK válidas, sin datos afectados
- Toda la capa `domain/` — no hay nuevos modelos, rules ni use cases
- Toda la capa `ui/` — no hay cambios visuales ni de navegación
- `RepositoryModule` — no hay nuevo repository
- Ningún DAO recibe queries nuevos
- Ningún Repository recibe métodos nuevos

### Hitos de Implementación

| # | Componente(s) | Descripción | Dependencias |
|---|--------------|-------------|--------------|
| 1 | `ModuleSeeder` | Actualizar `name` y `group_description` de A y B (2 líneas) | Ninguna |
| 2 | `ExerciseSeeder` | Cambiar `module_code` de 13 ejercicios + cambiar zona muscular de ejercicio 26 | Ninguna |
| 3 | `PlanSeeder` | Reemplazar 66 llamadas `pa()` de A+B con las nuevas asignaciones | Ninguna |
| 4 | `Migrations` | Crear `object Migrations` en `data.local.database` con `MIGRATION_6_7` conteniendo los 7 bloques SQL del CA-15.5.24 | Ninguna |
| 5 | `TensionDatabase` + `DatabaseModule` | Incrementar version a 7 + registrar migración con `.addMigrations(Migrations.MIGRATION_6_7)` | Hito 4 |
| 6 | Tests instrumentados (Bloque G) | 4 tests verificando: conteo por módulo (CA-15.5.27), conteo por versión (CA-15.5.28), zona muscular de ID 26 (CA-15.5.29), integridad referencial plan_assignment (CA-15.5.30) | Hitos 4, 5 |

### Validación de Impacto

**Código real verificado (paso 1.5):**

- `TensionDatabase.kt`: Actualmente `version = 6`, 16 entities. No hay migrations registradas. Se incrementa a 7.
- `DatabaseModule.kt`: Usa `.addCallback(PrepopulateCallback()).fallbackToDestructiveMigration()`. Se inserta `.addMigrations(Migrations.MIGRATION_6_7)` entre callback y fallback.
- `PrepopulateCallback.kt`: Invoca `PrepopulateFacade.populate(db)` en `onCreate()` y `onDestructiveMigration()`. No requiere cambio — los seeders actualizados se usan automáticamente para instalaciones nuevas y para fallbacks destructivos.
- `PrepopulateFacade.kt`: Ejecuta `ModuleSeeder.seed()` → `ExerciseSeeder.seed()` → `PlanSeeder.seed()` en transacción. No requiere cambio.
- `ModuleSeeder.kt`: 2 líneas a cambiar — `insertModule(db, "A", ...)` y `insertModule(db, "B", ...)`.
- `ExerciseSeeder.kt`: 13 líneas de `ex()` a cambiar (`module_code`). 1 línea de `emz()` a cambiar (ejercicio 26). Comentarios de sección a actualizar.
- `PlanSeeder.kt`: 66 líneas de `pa()` a reemplazar (secciones A-V1/V2/V3 y B-V1/V2/V3). Sección C inalterada.
- `ModuleVersionEntity.kt`: IDs 1-3 = A, IDs 4-6 = B, IDs 7-9 = C. No cambian. Las versiones de `module_version` quedan bajo el mismo `module_code` — solo cambió qué ejercicios incluyen.
- `PlanAssignmentEntity.kt`: PK compuesta (`module_version_id`, `exercise_id`). FK a `module_version` (RESTRICT) y `exercise` (RESTRICT). El DELETE/INSERT del SQL cumple la lógica de FK correctamente.
- `ExerciseEntity.kt`: FK a `module(code)` con ON DELETE RESTRICT. Los UPDATEs de `module_code` referencian códigos que ya existen ("A", "B") — no hay riesgo de violación FK.
- `ExerciseMuscleZoneEntity.kt`: PK compuesta (`exercise_id`, `muscle_zone_id`). FK a `exercise` y `muscle_zone`. La actualización de zone 7→4 para ejercicio 26 referencia IDs válidos.
- `RotationStateEntity.kt`: Tabla independiente, fila única. La migración no la toca. Preservación automática.
- `SessionEntity.kt`: FK a `module_version(id)`. Las sesiones históricas apuntan a `module_version_id` (ej: 1 para A-V1). Dado que `module_version` no se modifica (solo cambian las `plan_assignment` bajo ella), las sesiones históricas siguen siendo válidas e interpretables.
- `AlertEntity.kt`: Tiene `module_code` como FK. No hay alertas en la BD actualmente (HU-17 no implementada). No se toca.
- `ExerciseProgressionEntity.kt`: FK a `exercise(id)`. `prescribed_load_kg` y `sessions_without_progression` siguen válidos. No se toca.

**Análisis de dependencias:**

- HU-15.5 depende de: HU-01 (creó perfil y la BD con seeders), HU-04 (definió la estructura original del plan), HU-15 (implementó métricas que se recalculan automáticamente post-migración).
- HU-15.5 NO modifica componentes de domain ni UI — es una operación exclusiva de la capa `data.local`.
- HU-15.5 habilita: HU-16, HU-17, HU-18 — que operarán sobre la estructura Pull/Push/Legs correcta.

**Impacto en datos históricos del ejecutante:**

- `session` (15 sesiones): Preservadas. Cada sesión referencia `module_version_id` — la FK sigue válida porque `module_version` no cambia.
- `session_exercise`: Preservadas. Cada registro referencia `exercise_id` — el ejercicio sigue existiendo (solo cambió su `module_code`).
- `exercise_set`: Preservadas. Cada serie referencia `session_exercise_id` — la cadena relacional es estable.
- `exercise_progression`: Preservadas. `prescribed_load_kg` sigue siendo correcto (`load_increment_kg` de A y B son ambos 2.5).
- KPIs de HU-15: Se recalculan automáticamente porque derivan de `exercise_id` (no de `module_code`). El tonelaje por grupo muscular del ejercicio 26 se reclasificará de "Hombro" a "Espalda" retroactivamente porque `exercise_muscle_zone` se actualiza.

### Notas Técnicas

**Nota 1 — Sesión `IN_PROGRESS` al momento de la actualización de la app.**

Si el ejecutante tiene una sesión activa cuando actualiza la app, Room ejecuta la migración antes del primer acceso a la BD. La sesión en progreso tiene `session_exercise` ya creados con `exercise_id` previamente asignados — esos ejercicios siguen existiendo (solo cambió su `module_code`). La sesión se puede continuar y cerrar normalmente. Los ejercicios de la sesión podrían pertenecer ahora a un módulo diferente del `module_version` de la sesión (ej: ejercicio de Pecho ID=1 ahora pertenece a B pero la sesión era de A-V1), pero esto no genera error funcional: el cierre de sesión evalúa progresión por `exercise_id`, no por `module_code`. La próxima sesión post-migración ya usará la estructura correcta.

**Nota 2 — Consistencia entre Seeders y Migration SQL.**

Los seeders y la Migration SQL deben producir exactamente el mismo estado final para módulos A y B. Los seeders se ejecutan en instalaciones nuevas (`onCreate`) o tras destructive migration (`onDestructiveMigration`). La `MIGRATION_6_7` se ejecuta en actualizaciones de usuarios existentes. Ambos caminos deben converger al mismo catálogo de ejercicios y plan de entrenamiento. La verificación cruzada se hace comparando los IDs y module_codes de ambos artefactos — contrastados con los CA-15.5.15/16.

**Nota 3 — `plan_assignment` usa PK compuesta (`module_version_id`, `exercise_id`) — los INSERTs no necesitan ID explícito.**

A diferencia de tablas con `id AUTOINCREMENT`, `plan_assignment` no tiene columna `id`. El DELETE + INSERT del SQL no depende de auto-incremento — las PKs se definen explícitamente en cada INSERT. No hay riesgo de conflicto de IDs.

### Verificación Cruzada de CAs

| CA | Estado | Mecanismo | Implementado en |
|---|---|---|---|
| CA-15.5.01 | Por implementar | `UPDATE module SET name = '...', group_description = '...' WHERE code = 'A'` | Migration SQL + ModuleSeeder |
| CA-15.5.02 | Por implementar | `UPDATE module SET name = '...', group_description = '...' WHERE code = 'B'` | Migration SQL + ModuleSeeder |
| CA-15.5.03 | Automático | C no se toca en migration ni seeders | No requiere acción |
| CA-15.5.04 | Por implementar | `UPDATE exercise SET module_code = 'B' WHERE id IN (1,2,3,4,5,6,7)` | Migration SQL + ExerciseSeeder |
| CA-15.5.05 | Por implementar | `UPDATE exercise SET module_code = 'A' WHERE id IN (16,17,18,19,20)` | Migration SQL + ExerciseSeeder |
| CA-15.5.06 | Por implementar | `UPDATE exercise SET module_code = 'A' WHERE id IN (..., 26)` | Migration SQL + ExerciseSeeder |
| CA-15.5.07 | Automático | IDs 24,25,27,28,29 ya tienen `module_code = 'B'` | No requiere acción |
| CA-15.5.08 | Automático | IDs 21,22,23 ya tienen `module_code = 'B'` | No requiere acción |
| CA-15.5.09 | Automático | IDs 8-15 ya tienen `module_code = 'A'` | No requiere acción |
| CA-15.5.10 | Automático | IDs 30-43 ya tienen `module_code = 'C'` | No requiere acción |
| CA-15.5.11 | Por verificar | Test: `SELECT module_code, COUNT(*) FROM exercise GROUP BY module_code` → A=14, B=15, C=14 | Test instrumentado |
| CA-15.5.12 | Por implementar | `UPDATE exercise_muscle_zone SET muscle_zone_id = 4 WHERE exercise_id = 26` | Migration SQL + ExerciseSeeder |
| CA-15.5.13 | Automático | KPIs de HU-15 se derivan de `exercise_muscle_zone` vía JOINs — recálculo retroactivo | Sin acción adicional |
| CA-15.5.14 | Por implementar | `DELETE FROM plan_assignment WHERE module_version_id IN (1,2,3,4,5,6)` | Migration SQL |
| CA-15.5.15 | Por implementar | 33 INSERTs para A-V1/V2/V3 | Migration SQL + PlanSeeder |
| CA-15.5.16 | Por implementar | 33 INSERTs para B-V1/V2/V3 | Migration SQL + PlanSeeder |
| CA-15.5.17 | Automático | IDs 7,8,9 no se tocan | No requiere acción |
| CA-15.5.18 | Por verificar | Test: conteo por module_version_id → 11×6 + 9×3 = 93 | Test instrumentado |
| CA-15.5.19 | Por implementar | `ModuleSeeder.kt` actualizado | ModuleSeeder |
| CA-15.5.20 | Por implementar | `ExerciseSeeder.kt` — 13 ejercicios con module_code actualizado | ExerciseSeeder |
| CA-15.5.21 | Por implementar | `ExerciseSeeder.kt` — `emz(db, 26, 4)` | ExerciseSeeder |
| CA-15.5.22 | Por implementar | `PlanSeeder.kt` — 66 nuevas llamadas `pa()` | PlanSeeder |
| CA-15.5.23 | Por implementar | `TensionDatabase` → `version = 7` + `DatabaseModule` → `.addMigrations(MIGRATION_6_7)` | TensionDatabase + DatabaseModule |
| CA-15.5.24 | Por implementar | SQL secuencial en `Migrations.MIGRATION_6_7.migrate()` | Migrations |
| CA-15.5.25 | Automático | Migration SQL no toca `session`, `exercise_set`, `session_exercise`, `alert` | Sin acción requerida |
| CA-15.5.26 | Automático (con corrección de redacción) | La tabla `rotation_state` no se toca. **Nota:** CA dice `profile` pero la tabla real es `rotation_state` con columnas `microcycle_position`, `current_version_module_a/b/c`, `microcycle_count` | Sin acción en código — corregir redacción del CA |
| CA-15.5.27 | Por implementar | Test instrumentado: conteo ejercicios por módulo | Test |
| CA-15.5.28 | Por implementar | Test instrumentado: conteo asignaciones por versión | Test |
| CA-15.5.29 | Por implementar | Test instrumentado: zona muscular de ejercicio 26 | Test |
| CA-15.5.30 | Por implementar | Test instrumentado: integridad referencial plan_assignment | Test |

### Referencias y Validación

**Documentación consultada:**

- Modelo de Datos — [Modelo de Datos.md](docs/architecture/Modelo%20de%20Datos.md) (§3.1 module, §3.4 exercise, §3.5 exercise_muscle_zone, §3.7 plan_assignment, §3.14 rotation_state)
- Arquitectura Técnica — [Arquitectura Técnica.md](docs/architecture/Arquitectura%20Técnica.md) (§3.2 árbol de paquetes, §5.2 naming conventions)
- ADR — [ADR.md](docs/architecture/ADR.md) (ADR-03 Room como ORM — habilita `Migration` objects y RNF19, ADR-11 Prepopulación de datos — patrón Facade + Seeders, ADR-06 motor de reglas Kotlin puro, ADR-08 estructura de paquetes)
- Manifiesto de Dominio Sistémico — [Manifiesto de Dominio Sistémico.md](docs/business_definition/Manifiesto%20de%20Dominio%20Sistémico.md) (§4 módulos, §5 reglas R1-R7, §7 KPIs)
- Diccionario de Ejercicios — [Diccionario de Ejercicios.md](docs/business_definition/Diccionario%20de%20Ejercicios.md) (asignación actualizada de ejercicios por módulo)
- Plan de Entrenamiento — [Plan de Entrenamiento.md](docs/business_definition/Plan%20de%20Entrenamiento.md) (versiones V1/V2/V3 actualizadas)

**Historias relacionadas:**

- Historia #1 (HU-01): Creó perfil con seeders iniciales — los seeders se actualizan para reflejar nueva estructura
- Historia #4 (HU-04): Definió estructura original del plan y seeders — se recomponen completamente las versiones A y B
- Historia #9 (HU-09): Cierre de sesión y rotación — `rotation_state` preservado, el ciclo A→B→C→A→B→C no cambia
- Historia #10 (HU-10): Progresión y clasificación — `exercise_progression` preservada, `load_increment_kg` idéntico entre A y B
- Historia #14 (HU-14): Deload — `deload` preservado, versiones congeladas siguen referenciando IDs de `module_version` válidos
- Historia #15 (HU-15): KPIs y métricas — se recalculan retroactivamente porque derivan de `exercise_id` y `exercise_muscle_zone`, no de `module_code`

**Validado por:** esteban.colorado | **Fecha:** 2026-02-18 | **Enfoque:** Exploratorio

---

## Notas de implementación

### Estrategia de migración

Dado que la aplicación usa `fallbackToDestructiveMigration()`, existen dos opciones:

1. **Migración explícita (recomendada):** Crear `Migration(6, 7)` con los SQL statements del CA-15.5.24 y registrarla con `.addMigrations(MIGRATION_6_7)` antes del fallback. Esto preserva los datos del ejecutante sin requerir reinstalación.

2. **Destructiva (solo aceptable en desarrollo):** Incrementar la versión sin migration, dejando que Room destruya y recree la BD con los seeders actualizados. Esto pierde todos los datos históricos y solo es aceptable si el ejecutante acepta perder su historial.

### Orden de ejecución de la implementación

1. Actualizar los 3 seeders (`ModuleSeeder`, `ExerciseSeeder`, `PlanSeeder`) con los valores nuevos.
2. Crear la `Migration(6, 7)` con los SQL statements.
3. Incrementar `version` en `TensionDatabase` de 6 a 7.
4. Registrar la migración en `DatabaseModule` con `.addMigrations(...)` antes del `.fallbackToDestructiveMigration()`.
5. Ejecutar los tests de integridad del Bloque G.

### Ejercicios reasignados — tabla de referencia

| exercise_id | Nombre | Módulo anterior | Módulo nuevo | Zona muscular anterior | Zona muscular nueva |
|-------------|--------|----------------|-------------|----------------------|-------------------|
| 1 | Press de banca | A | **B** | Pecho Medio | Pecho Medio |
| 2 | Press de mancuerna | A | **B** | Pecho Medio | Pecho Medio |
| 3 | Press de banca inclinada | A | **B** | Pecho Superior | Pecho Superior |
| 4 | Flexiones | A | **B** | Pecho Inferior | Pecho Inferior |
| 5 | Cruce en polea alta | A | **B** | Pecho Inferior | Pecho Inferior |
| 6 | Apertura de pecho sentado | A | **B** | Pecho Medio | Pecho Medio |
| 7 | Apertura de pecho inclinado | A | **B** | Pecho Superior | Pecho Superior |
| 16 | Curl de bíceps (Mancuerna) | B | **A** | Bíceps | Bíceps |
| 17 | Curl de bíceps (Polea) | B | **A** | Bíceps | Bíceps |
| 18 | Curl de martillo cruzado | B | **A** | Bíceps | Bíceps |
| 19 | Curl de martillo | B | **A** | Bíceps | Bíceps |
| 20 | Curl de Contracción | B | **A** | Bíceps | Bíceps |
| 26 | Elevación de hombros con mancuernas | B | **A** | **Hombro** | **Espalda Media** |

### SQL de la migración

```sql
-- 1. Actualizar module
UPDATE module SET name = 'Módulo A — Superior (Pull + Abs)', group_description = 'Espalda, Bíceps, Abdomen' WHERE code = 'A';
UPDATE module SET name = 'Módulo B — Superior (Push)', group_description = 'Pecho, Hombro, Tríceps' WHERE code = 'B';

-- 2. Reasignar ejercicios de Pecho (A → B)
UPDATE exercise SET module_code = 'B' WHERE id IN (1, 2, 3, 4, 5, 6, 7);

-- 3. Reasignar ejercicios de Bíceps + Elevación de hombros (B → A)
UPDATE exercise SET module_code = 'A' WHERE id IN (16, 17, 18, 19, 20, 26);

-- 4. Corregir zona muscular de Elevación de hombros (Hombro → Espalda Media)
UPDATE exercise_muscle_zone SET muscle_zone_id = 4 WHERE exercise_id = 26;

-- 5. Eliminar asignaciones del plan para módulos A y B
DELETE FROM plan_assignment WHERE module_version_id IN (1, 2, 3, 4, 5, 6);

-- 6. Insertar nuevas asignaciones del Módulo A (Pull + Abs)
-- A-V1 (11 ejercicios)
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 10, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 8, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 9, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 16, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 18, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 17, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 19, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 11, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 12, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 13, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 14, 4, '30-45_SEC');

-- A-V2 (11 ejercicios)
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 10, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 8, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 9, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 26, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 16, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 18, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 17, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 20, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 11, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 14, 4, '30-45_SEC');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 15, 4, '30-45_SEC');

-- A-V3 (11 ejercicios)
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 10, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 8, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 9, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 26, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 16, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 19, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 17, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 20, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 11, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 13, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 14, 4, '30-45_SEC');

-- 7. Insertar nuevas asignaciones del Módulo B (Push)
-- B-V1 (11 ejercicios)
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 1, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 3, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 6, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 4, 4, 'TO_TECHNICAL_FAILURE');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 27, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 24, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 25, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 28, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 21, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 22, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 23, 4, '8-12');

-- B-V2 (11 ejercicios)
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 1, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 7, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 6, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 5, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 27, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 25, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 29, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 2, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 21, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 22, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 23, 4, '8-12');

-- B-V3 (11 ejercicios)
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 1, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 3, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 6, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 5, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 27, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 24, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 28, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 2, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 21, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 22, 4, '8-12');
INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 23, 4, '8-12');
```
---

## Refinamiento Técnico (Developer)

<!-- ============================================================================ -->
<!-- SECCIÓN AGREGADA POR: Workflow refinamiento-tecnico                         -->
<!-- ETAPA: Refinamiento Técnico                                                  -->
<!-- RESPONSABLE: Developer                                                       -->
<!-- BASE: Análisis Arquitectónico (Arquitecto) - Ver sección arriba             -->
<!-- FECHA: 2026-02-19                                                            -->
<!-- ESTADO: Refinado (Developer) - Basado en Análisis Arquitectónico            -->
<!-- ============================================================================ -->

### Consideraciones Generales

**Basado en análisis arquitectónico:**
Sí — Análisis Arquitectónico del Arquitecto con 8 decisiones fundamentadas, 1 componente nuevo (`Migrations`), 5 componentes modificados, y 6 hitos de implementación. Patrón: Room Database Migration (data-only) con sincronización de Seed Data.

**Nivel de complejidad:**
BAJA — HU-15.5 es una operación 100% en la capa de datos. No hay cambios de esquema DDL, no hay componentes de dominio, no hay cambios de UI, no hay nuevas dependencias. El componente nuevo (`Migrations`) es un `object` con una única propiedad `val MIGRATION_6_7`. Los cambios en seeders son actualizaciones de valores literales. El SQL de la migración son 7 bloques de statements planos (UPDATE, DELETE, INSERT) sin lógica condicional. La complejidad real está en la verificación de correctitud: asegurar que los 66 INSERTs de `plan_assignment` coincidan exactamente con el Plan de Entrenamiento actualizado.

**Riesgos técnicos conocidos:**

1. **Inconsistencia Seeder ↔ Migration SQL:** Los seeders y la `MIGRATION_6_7` deben producir exactamente el mismo estado final. Si un INSERT difiere entre ambos, instalaciones nuevas y actualizaciones tendrán catálogos distintos. Mitigación: los 66 INSERTs del SQL están copiados literalmente del Plan de Entrenamiento, contrastados contra los CAs 15.5.15/16, contrastados contra el Diccionario de Ejercicios, y verificados contra los seeders. El test instrumentado CA-15.5.30 (integridad referencial) detectaría inconsistencias.
2. **Sesión `IN_PROGRESS` al momento de la actualización:** Room ejecuta la migración antes del primer acceso a la BD. Una sesión activa con ejercicios ya asignados sigue siendo válida — los `exercise_id` no cambian, solo su `module_code`. El cierre de sesión evalúa progresión por `exercise_id`, no por `module_code`. Riesgo aceptado (Nota 1 del arquitecto).
3. **`fallbackToDestructiveMigration()` como red de seguridad:** Si la migración falla (error en SQL), Room destruye la BD y ejecuta los seeders actualizados via `PrepopulateCallback.onDestructiveMigration()`. Esto preserva la estructura correcta del plan, pero pierde los datos históricos del ejecutante. El riesgo es mitigado porque el SQL fue verificado contra las entities y los tests instrumentados validan la migración antes del release.
4. **Imágenes de ejercicios (assets) vinculadas a `module_code`:** La función `rememberExerciseBitmap()` en `ExerciseDetailScreen.kt` (HU-03, D2) construye la ruta de assets como `exercises/module-${moduleCode.lowercase()}/$mediaResource.png`. Al cambiar `module_code` de 13 ejercicios, la app buscaría los PNGs en directorios incorrectos (los 7 PNGs de Pecho en `module-b/` cuando físicamente están en `module-a/`, y los 6 de Bíceps + Elevación hombros en `module-a/` cuando están en `module-b/`). Mitigación: Fase 2.5 mueve los 13 archivos PNG a los directorios que corresponden a su nuevo `module_code`.

**Patrones y convenciones del equipo (establecidos en HU-01—HU-14):**

- Seeders: `object XxxSeeder` con funciones `seed(db)` usando `ContentValues` + `db.insert()` con `SQLiteDatabase.CONFLICT_REPLACE`
- Helpers de seeders: funciones privadas abreviadas (`ex()`, `emz()`, `pa()`, `mv()`, `insertModule()`) para legibilidad
- Comentarios de sección: `// ===== Module X =====` y `// Module X (N exercises, IDs X-Y)` en seeders
- `TensionDatabase`: `@Database(version = N, exportSchema = false)` — sin schema export
- `DatabaseModule`: builder chain: `.addCallback(PrepopulateCallback()).fallbackToDestructiveMigration().build()`
- `PrepopulateFacade`: maneja transacción con `beginTransaction()/setTransactionSuccessful()/endTransaction()`
- Tests instrumentados: JUnit 4 con `@RunWith(AndroidJUnit4::class)`, BD en memoria via `Room.inMemoryDatabaseBuilder()`

**Dependencias nuevas a instalar:**
Ninguna.

**Estrategia de testing:**
JUnit 4 + AndroidX Test (Room inMemoryDatabaseBuilder) | Tests instrumentados para validación de migración post-apply | Cobertura: 4 tests del Bloque G (conteo por módulo, conteo por versión, zona muscular, integridad referencial) | Builders: no se requieren — los tests usan queries SQL directos sobre la BD migrada

### Historias Relacionadas Consultadas

**Implementaciones similares analizadas:**

- HU-03 ([HU-03.md](HU-03.md)): Creó los seeders (`ModuleSeeder`, `ExerciseSeeder`, `PlanSeeder`), el patrón `PrepopulateCallback → PrepopulateFacade → Seeders`, y las pantallas D1/D2 del Diccionario de Ejercicios — D2 carga imágenes vía `rememberExerciseBitmap()` usando `moduleCode` para construir la ruta de assets. Este es el patrón que se actualiza y la pantalla cuyas imágenes se ven afectadas por la reasignación de `module_code`.
- HU-04 ([HU-04.md](HU-04.md)): Definió la estructura original del plan (`PlanSeeder`) con las versiones A/B/C. Las secciones A y B se recomponen completamente.
- HU-05 ([HU-05.md](HU-05.md)): E1 (sesión activa) y B1 (próxima sesión) muestran `module.name` y listas de ejercicios derivadas de `plan_assignment` — ambos cambian visualmente post-migración. Funcionalidad preservada vía Room Flows reactivos.
- HU-09 ([HU-09.md](HU-09.md)): `rotation_state` no se toca — el ciclo A→B→C sigue igual.
- HU-10 ([HU-10.md](HU-10.md)): `exercise_progression` no se toca — `load_increment_kg` de A y B son ambos 2.5.
- HU-14 ([HU-14.md](HU-14.md)): `deload` no se toca — versiones congeladas siguen referenciando IDs de `module_version` válidos.
- HU-15 ([HU-15.md](HU-15.md)): Implementó métricas que se recalculan automáticamente post-migración porque derivan de `exercise_id` y JOINs a `exercise_muscle_zone`, no de `module_code`.
- HU-01 ([HU-01.md](HU-01.md)): Creó el perfil, la BD (`TensionDatabase`), y la infraestructura de Hilt. Los seeders fueron creados en HU-03.

**Patrones de código reutilizados:**

- Patrón de seeders con helpers abreviados (`ex()`, `emz()`, `pa()`) de `ExerciseSeeder.kt` y `PlanSeeder.kt`
- Patrón de `ContentValues` + `db.insert()` + `SQLiteDatabase.CONFLICT_REPLACE` de `ModuleSeeder.kt`
- Chain builder de Room en `DatabaseModule.kt` (`.addCallback().fallbackToDestructiveMigration().build()`)

**Mejores prácticas aplicadas:**

- Migration SQL verificado contra entities reales (`ModuleEntity`, `ExerciseEntity`, `PlanAssignmentEntity`, `ExerciseMuscleZoneEntity`) para confirmar nombres de columna exactos
- Separación de `Migrations.kt` como objeto dedicado (Decisión 1 del arquitecto) para facilitar futuras migraciones
- `addMigrations()` antes de `fallbackToDestructiveMigration()` en builder chain (Decisión 2 del arquitecto) — preserva datos del usuario existente
- No se envuelve `migrate()` en transacción manual — Room lo hace automáticamente (Decisión 3 del arquitecto)

---

## Tareas de Implementación (Developer)

### Fase 1: Actualización de ModuleSeeder

<!-- Basado en Hito #1 del Análisis Arquitectónico -->
<!-- AC: CA-15.5.01, CA-15.5.02, CA-15.5.03, CA-15.5.19 -->

#### 📦 Data Layer — Seeder

- [ ] **Modificar `ModuleSeeder`** (AC: 1, 2, 3, 19)
  - [ ] Modificar archivo: `data/local/seed/ModuleSeeder.kt`
  - [ ] Cambiar línea de Módulo A:
    ```kotlin
    // ANTES:
    insertModule(db, "A", "Módulo A \u2014 Superior", "Pecho, Espalda, Abdomen", 2.5)
    // DESPUÉS:
    insertModule(db, "A", "Módulo A \u2014 Superior (Pull + Abs)", "Espalda, Bíceps, Abdomen", 2.5)
    ```
  - [ ] Cambiar línea de Módulo B:
    ```kotlin
    // ANTES:
    insertModule(db, "B", "Módulo B \u2014 Superior", "Hombro, Tríceps, Bíceps", 2.5)
    // DESPUÉS:
    insertModule(db, "B", "Módulo B \u2014 Superior (Push)", "Pecho, Hombro, Tríceps", 2.5)
    ```
  - [ ] Verificar que Módulo C NO se modifica (CA-15.5.03)
  - [ ] Verificar que `load_increment_kg` permanece 2.5 para A y B, 5.0 para C

#### 📦 Verificación

- [ ] Casos: `seedModules()` produce exactamente los 3 módulos con los nuevos `name` y `group_description`

### Fase 2: Actualización de ExerciseSeeder

<!-- Basado en Hito #2 del Análisis Arquitectónico -->
<!-- AC: CA-15.5.04, CA-15.5.05, CA-15.5.06, CA-15.5.07, CA-15.5.08, CA-15.5.09, CA-15.5.10, CA-15.5.11, CA-15.5.20, CA-15.5.21 -->

#### 📦 Data Layer — Seeder

- [ ] **Modificar `ExerciseSeeder.seedExercises()`** (AC: 4, 5, 6, 7, 8, 9, 10, 11, 20)
  - [ ] Modificar archivo: `data/local/seed/ExerciseSeeder.kt`
  - [ ] **Módulo A** — Comentario de sección: cambiar `// Module A (15 exercises, IDs 1-15)` → `// Module A — Pull + Abs (14 exercises, IDs 8-15, 16-20, 26)`
  - [ ] Reasignar ejercicios de Pecho (IDs 1-7) de `"A"` → `"B"`:
    ```kotlin
    ex(db, 1, "Press de banca", "B", 1, media = "press_de_banca_maquina")
    ex(db, 2, "Press de mancuerna", "B", 2, media = "press_de_mancuerna_mancuernas")
    ex(db, 3, "Press de banca inclinada", "B", 1, media = "press_de_banca_inclinada_maquina")
    ex(db, 4, "Flexiones", "B", 4, bw = 1, fail = 1, media = "flexiones_cuerpo")
    ex(db, 5, "Cruce en polea alta", "B", 1, media = "cruce_en_polea_alta_maquina")
    ex(db, 6, "Apertura de pecho sentado", "B", 1, media = "apertura_de_pecho_sentado_maquina")
    ex(db, 7, "Apertura de pecho inclinado", "B", 1, media = "apertura_de_pecho_inclinado_maquina")
    ```
  - [ ] **Módulo B** — Comentario de sección: cambiar `// Module B (14 exercises, IDs 16-29)` → `// Module B — Push (15 exercises, IDs 1-7, 21-25, 27-29)`
  - [ ] Reasignar ejercicios de Bíceps (IDs 16-20) de `"B"` → `"A"`:
    ```kotlin
    ex(db, 16, "Curl de bíceps", "A", 5, media = "curl_de_biceps_mancuerna")
    ex(db, 17, "Curl de bíceps", "A", 6, media = "curl_de_biceps_polea")
    ex(db, 18, "Curl de martillo cruzado", "A", 5, media = "curl_de_martillo_cruzado_mancuerna")
    ex(db, 19, "Curl de martillo", "A", 5, media = "curl_de_martillo_mancuerna")
    ex(db, 20, "Curl de Contracción", "A", 5, media = "curl_de_contraccion_mancuerna")
    ```
  - [ ] Reasignar Elevación de hombros (ID 26) de `"B"` → `"A"`:
    ```kotlin
    ex(db, 26, "Elevación de hombros con mancuernas", "A", 5, media = "elevacion_de_hombros_con_mancuernas_mancuerna")
    ```
  - [ ] Verificar que ejercicios de Espalda (IDs 8-10), Abdomen (IDs 11-15), Tríceps (IDs 21-23), Hombro restantes (IDs 24, 25, 27-29) y Módulo C (IDs 30-43) NO cambian de `module_code`
  - [ ] Reorganizar el orden de las llamadas `ex()` para agrupar por módulo lógico (A: IDs 8-20+26, B: IDs 1-7+21-29, C: IDs 30-43)
  - [ ] Conteo final: A = 14 (3 Espalda + 5 Abdomen + 5 Bíceps + 1 Elevación hombros = 14), B = 15 (7 Pecho + 3 Tríceps + 5 Hombro = 15), C = 14

- [ ] **Modificar `ExerciseSeeder.seedExerciseMuscleZones()`** (AC: 12, 21)
  - [ ] Modificar archivo: `data/local/seed/ExerciseSeeder.kt`
  - [ ] Cambiar zona muscular del ejercicio 26:
    ```kotlin
    // ANTES:
    emz(db, 26, 7)  // Elevación de hombros con mancuernas → Hombro
    // DESPUÉS:
    emz(db, 26, 4)  // Elevación de hombros con mancuernas → Espalda Media
    ```
  - [ ] Reorganizar los comentarios de sección de las zonas musculares para reflejar la nueva agrupación por módulo
  - [ ] Verificar que todas las demás zonas musculares NO cambian

### Fase 2.5: Reorganización de assets de imágenes

<!-- Impacto identificado en auditoría: HU-03 D2 usa moduleCode para construir ruta de assets -->
<!-- No vinculado a un Hito del Arquitecto — descubierto durante validación cruzada con código UI -->

#### 📦 Assets — Imágenes de ejercicios

- [ ] **Mover 7 PNGs de Pecho de `module-a/` a `module-b/`** (ejercicios IDs 1-7, ahora `module_code = "B"`)
  - [ ] Mover `assets/exercises/module-a/press_de_banca_maquina.png` → `assets/exercises/module-b/press_de_banca_maquina.png`
  - [ ] Mover `assets/exercises/module-a/press_de_mancuerna_mancuernas.png` → `assets/exercises/module-b/press_de_mancuerna_mancuernas.png`
  - [ ] Mover `assets/exercises/module-a/press_de_banca_inclinada_maquina.png` → `assets/exercises/module-b/press_de_banca_inclinada_maquina.png`
  - [ ] Mover `assets/exercises/module-a/flexiones_cuerpo.png` → `assets/exercises/module-b/flexiones_cuerpo.png`
  - [ ] Mover `assets/exercises/module-a/cruce_en_polea_alta_maquina.png` → `assets/exercises/module-b/cruce_en_polea_alta_maquina.png`
  - [ ] Mover `assets/exercises/module-a/apertura_de_pecho_sentado_maquina.png` → `assets/exercises/module-b/apertura_de_pecho_sentado_maquina.png`
  - [ ] Mover `assets/exercises/module-a/apertura_de_pecho_inclinado_maquina.png` → `assets/exercises/module-b/apertura_de_pecho_inclinado_maquina.png`

- [ ] **Mover 6 PNGs de Bíceps + Elevación hombros de `module-b/` a `module-a/`** (ejercicios IDs 16-20 + 26, ahora `module_code = "A"`)
  - [ ] Mover `assets/exercises/module-b/curl_de_biceps_mancuerna.png` → `assets/exercises/module-a/curl_de_biceps_mancuerna.png`
  - [ ] Mover `assets/exercises/module-b/curl_de_biceps_polea.png` → `assets/exercises/module-a/curl_de_biceps_polea.png`
  - [ ] Mover `assets/exercises/module-b/curl_de_martillo_cruzado_mancuerna.png` → `assets/exercises/module-a/curl_de_martillo_cruzado_mancuerna.png`
  - [ ] Mover `assets/exercises/module-b/curl_de_martillo_mancuerna.png` → `assets/exercises/module-a/curl_de_martillo_mancuerna.png`
  - [ ] Mover `assets/exercises/module-b/curl_de_contraccion_mancuerna.png` → `assets/exercises/module-a/curl_de_contraccion_mancuerna.png`
  - [ ] Mover `assets/exercises/module-b/elevacion_de_hombros_con_mancuernas_mancuerna.png` → `assets/exercises/module-a/elevacion_de_hombros_con_mancuernas_mancuerna.png`

- [ ] **Verificar conteo post-reorganización:**
  - [ ] `module-a/`: 14 PNGs (3 Espalda + 5 Abdomen + 5 Bíceps + 1 Elevación hombros) — antes era 15 (se restaron 7 Pecho, se sumaron 6 Bíceps+Elevación)
  - [ ] `module-b/`: 15 PNGs (7 Pecho + 3 Tríceps + 5 Hombro) — antes era 14 (se sumaron 7 Pecho, se restaron 6 Bíceps+Elevación)
  - [ ] `module-c/`: 14 PNGs (sin cambios)

**Nota:** Los movimientos deben hacerse en un paso temporal intermedio (via directorio temp) para evitar conflictos de nombres si ambos directorios contienen archivos con el mismo nombre. En este caso no hay colisiones (los nombres de Pecho vs Bíceps son distintos), pero se recomienda mover primero los 7 de `module-a/` → `module-b/` y luego los 6 de `module-b/` → `module-a/`.

### Fase 3: Actualización de PlanSeeder

<!-- Basado en Hito #3 del Análisis Arquitectónico -->
<!-- AC: CA-15.5.14, CA-15.5.15, CA-15.5.16, CA-15.5.17, CA-15.5.18, CA-15.5.22 -->

#### 📦 Data Layer — Seeder

- [ ] **Modificar `PlanSeeder.seedPlanAssignments()`** (AC: 14, 15, 16, 17, 18, 22)
  - [ ] Modificar archivo: `data/local/seed/PlanSeeder.kt`
  - [ ] Reemplazar las 33 llamadas `pa()` de **Módulo A** (sección `// ===== Module A =====`) con:
    ```kotlin
    // ===== Module A — Pull + Abs =====
    // A-V1 (moduleVersionId = 1) — 11 exercises
    pa(db, 1, 10, R8_12);  pa(db, 1, 8, R8_12);   pa(db, 1, 9, R8_12)
    pa(db, 1, 16, R8_12);  pa(db, 1, 18, R8_12);  pa(db, 1, 17, R8_12)
    pa(db, 1, 19, R8_12);  pa(db, 1, 11, R8_12);  pa(db, 1, 12, R8_12)
    pa(db, 1, 13, R8_12);  pa(db, 1, 14, R30_45)

    // A-V2 (moduleVersionId = 2) — 11 exercises
    pa(db, 2, 10, R8_12);  pa(db, 2, 8, R8_12);   pa(db, 2, 9, R8_12)
    pa(db, 2, 26, R8_12);  pa(db, 2, 16, R8_12);  pa(db, 2, 18, R8_12)
    pa(db, 2, 17, R8_12);  pa(db, 2, 20, R8_12);  pa(db, 2, 11, R8_12)
    pa(db, 2, 14, R30_45); pa(db, 2, 15, R30_45)

    // A-V3 (moduleVersionId = 3) — 11 exercises
    pa(db, 3, 10, R8_12);  pa(db, 3, 8, R8_12);   pa(db, 3, 9, R8_12)
    pa(db, 3, 26, R8_12);  pa(db, 3, 16, R8_12);  pa(db, 3, 19, R8_12)
    pa(db, 3, 17, R8_12);  pa(db, 3, 20, R8_12);  pa(db, 3, 11, R8_12)
    pa(db, 3, 13, R8_12);  pa(db, 3, 14, R30_45)
    ```
  - [ ] Reemplazar las 33 llamadas `pa()` de **Módulo B** (sección `// ===== Module B =====`) con:
    ```kotlin
    // ===== Module B — Push =====
    // B-V1 (moduleVersionId = 4) — 11 exercises
    pa(db, 4, 1, R8_12);   pa(db, 4, 3, R8_12);   pa(db, 4, 6, R8_12)
    pa(db, 4, 4, FAILURE);  pa(db, 4, 27, R8_12);  pa(db, 4, 24, R8_12)
    pa(db, 4, 25, R8_12);  pa(db, 4, 28, R8_12);  pa(db, 4, 21, R8_12)
    pa(db, 4, 22, R8_12);  pa(db, 4, 23, R8_12)

    // B-V2 (moduleVersionId = 5) — 11 exercises
    pa(db, 5, 1, R8_12);   pa(db, 5, 7, R8_12);   pa(db, 5, 6, R8_12)
    pa(db, 5, 5, R8_12);   pa(db, 5, 27, R8_12);  pa(db, 5, 25, R8_12)
    pa(db, 5, 29, R8_12);  pa(db, 5, 2, R8_12);   pa(db, 5, 21, R8_12)
    pa(db, 5, 22, R8_12);  pa(db, 5, 23, R8_12)

    // B-V3 (moduleVersionId = 6) — 11 exercises
    pa(db, 6, 1, R8_12);   pa(db, 6, 3, R8_12);   pa(db, 6, 6, R8_12)
    pa(db, 6, 5, R8_12);   pa(db, 6, 27, R8_12);  pa(db, 6, 24, R8_12)
    pa(db, 6, 28, R8_12);  pa(db, 6, 2, R8_12);   pa(db, 6, 21, R8_12)
    pa(db, 6, 22, R8_12);  pa(db, 6, 23, R8_12)
    ```
  - [ ] Verificar que sección `// ===== Module C =====` NO se modifica (CA-15.5.17)
  - [ ] **Verificación cruzada:** Contar 33 + 33 + 27 = 93 llamadas `pa()` total (CA-15.5.18)

#### 📦 Verificación cruzada contra Plan de Entrenamiento

- [ ] A-V1: Comparar IDs `{10, 8, 9, 16, 18, 17, 19, 11, 12, 13, 14}` contra Plan de Entrenamiento §A-V1
- [ ] A-V2: Comparar IDs `{10, 8, 9, 26, 16, 18, 17, 20, 11, 14, 15}` contra Plan de Entrenamiento §A-V2
- [ ] A-V3: Comparar IDs `{10, 8, 9, 26, 16, 19, 17, 20, 11, 13, 14}` contra Plan de Entrenamiento §A-V3
- [ ] B-V1: Comparar IDs `{1, 3, 6, 4, 27, 24, 25, 28, 21, 22, 23}` contra Plan de Entrenamiento §B-V1, confirmar que ID 4 usa `FAILURE`
- [ ] B-V2: Comparar IDs `{1, 7, 6, 5, 27, 25, 29, 2, 21, 22, 23}` contra Plan de Entrenamiento §B-V2
- [ ] B-V3: Comparar IDs `{1, 3, 6, 5, 27, 24, 28, 2, 21, 22, 23}` contra Plan de Entrenamiento §B-V3

### Fase 4: Crear Migrations

<!-- Basado en Hito #4 del Análisis Arquitectónico -->
<!-- AC: CA-15.5.24 -->

#### 📦 Data Layer — Database

- [ ] **Crear `Migrations`** (AC: 24)
  - [ ] Crear archivo: `data/local/database/Migrations.kt`
  - [ ] Paquete: `com.estebancoloradogonzalez.tension.data.local.database`
  - [ ] Implementación completa:
    ```kotlin
    package com.estebancoloradogonzalez.tension.data.local.database

    import androidx.room.migration.Migration
    import androidx.sqlite.db.SupportSQLiteDatabase

    object Migrations {

        val MIGRATION_6_7 = object : Migration(6, 7) {
            override fun migrate(db: SupportSQLiteDatabase) {
                // 1. Actualizar metadatos de módulos A y B
                db.execSQL("UPDATE module SET name = 'Módulo A — Superior (Pull + Abs)', group_description = 'Espalda, Bíceps, Abdomen' WHERE code = 'A'")
                db.execSQL("UPDATE module SET name = 'Módulo B — Superior (Push)', group_description = 'Pecho, Hombro, Tríceps' WHERE code = 'B'")

                // 2. Reasignar ejercicios de Pecho (A → B)
                db.execSQL("UPDATE exercise SET module_code = 'B' WHERE id IN (1, 2, 3, 4, 5, 6, 7)")

                // 3. Reasignar ejercicios de Bíceps + Elevación de hombros (B → A)
                db.execSQL("UPDATE exercise SET module_code = 'A' WHERE id IN (16, 17, 18, 19, 20, 26)")

                // 4. Corregir zona muscular de Elevación de hombros (Hombro → Espalda Media)
                db.execSQL("UPDATE exercise_muscle_zone SET muscle_zone_id = 4 WHERE exercise_id = 26")

                // 5. Eliminar asignaciones del plan para módulos A y B
                db.execSQL("DELETE FROM plan_assignment WHERE module_version_id IN (1, 2, 3, 4, 5, 6)")

                // 6. Insertar nuevas asignaciones del Módulo A (Pull + Abs)
                // A-V1
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 10, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 8, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 9, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 16, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 18, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 17, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 19, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 11, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 12, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 13, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (1, 14, 4, '30-45_SEC')")

                // A-V2
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 10, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 8, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 9, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 26, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 16, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 18, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 17, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 20, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 11, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 14, 4, '30-45_SEC')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (2, 15, 4, '30-45_SEC')")

                // A-V3
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 10, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 8, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 9, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 26, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 16, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 19, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 17, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 20, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 11, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 13, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (3, 14, 4, '30-45_SEC')")

                // 7. Insertar nuevas asignaciones del Módulo B (Push)
                // B-V1
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 1, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 3, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 6, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 4, 4, 'TO_TECHNICAL_FAILURE')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 27, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 24, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 25, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 28, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 21, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 22, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (4, 23, 4, '8-12')")

                // B-V2
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 1, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 7, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 6, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 5, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 27, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 25, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 29, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 2, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 21, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 22, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (5, 23, 4, '8-12')")

                // B-V3
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 1, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 3, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 6, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 5, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 27, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 24, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 28, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 2, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 21, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 22, 4, '8-12')")
                db.execSQL("INSERT INTO plan_assignment (module_version_id, exercise_id, sets, reps) VALUES (6, 23, 4, '8-12')")
            }
        }
    }
    ```
  - [ ] **Verificación:** El SQL fue contrastado línea a línea contra:
    - Entities: `ModuleEntity` (columnas `code`, `name`, `group_description`), `ExerciseEntity` (columna `module_code`), `ExerciseMuscleZoneEntity` (columnas `exercise_id`, `muscle_zone_id`), `PlanAssignmentEntity` (columnas `module_version_id`, `exercise_id`, `sets`, `reps`)
    - Plan de Entrenamiento actualizado (módulos A-V1/V2/V3 y B-V1/V2/V3)
    - CAs 15.5.01, 15.5.02, 15.5.04, 15.5.05, 15.5.06, 15.5.12, 15.5.14, 15.5.15, 15.5.16
  - [ ] Conteo: 2 UPDATEs module + 2 UPDATEs exercise + 1 UPDATE exercise_muscle_zone + 1 DELETE + 66 INSERTs = 72 execSQL calls

### Fase 5: Registrar migración en TensionDatabase y DatabaseModule

<!-- Basado en Hito #5 del Análisis Arquitectónico -->
<!-- AC: CA-15.5.23 -->

#### 📦 Data Layer — Database

- [ ] **Modificar `TensionDatabase`** (AC: 23)
  - [ ] Modificar archivo: `data/local/database/TensionDatabase.kt`
  - [ ] Cambiar versión de la base de datos:
    ```kotlin
    // ANTES:
    @Database(
        entities = [...],
        version = 6,
        exportSchema = false,
    )
    // DESPUÉS:
    @Database(
        entities = [...],
        version = 7,
        exportSchema = false,
    )
    ```

#### 📦 DI Layer

- [ ] **Modificar `DatabaseModule`** (AC: 23)
  - [ ] Modificar archivo: `di/DatabaseModule.kt`
  - [ ] Agregar import: `com.estebancoloradogonzalez.tension.data.local.database.Migrations`
  - [ ] Insertar `.addMigrations(Migrations.MIGRATION_6_7)` ANTES de `.fallbackToDestructiveMigration()`:
    ```kotlin
    // ANTES:
    return Room.databaseBuilder(
        context,
        TensionDatabase::class.java,
        "tension_database",
    )
        .addCallback(PrepopulateCallback())
        .fallbackToDestructiveMigration()
        .build()

    // DESPUÉS:
    return Room.databaseBuilder(
        context,
        TensionDatabase::class.java,
        "tension_database",
    )
        .addCallback(PrepopulateCallback())
        .addMigrations(Migrations.MIGRATION_6_7)
        .fallbackToDestructiveMigration()
        .build()
    ```
  - [ ] **Nota Decisión 2 del arquitecto:** El orden importa — si `Migration(6, 7)` está registrada, Room la ejecuta (preserva datos). Si la versión salta más allá de 7 sin migration, el fallback destructivo recrea BD con seeders actualizados.

### Fase 6: Tests instrumentados (Bloque G)

<!-- Basado en Hito #6 del Análisis Arquitectónico -->
<!-- AC: CA-15.5.25, CA-15.5.26, CA-15.5.27, CA-15.5.28, CA-15.5.29, CA-15.5.30 -->

#### 📦 Tests instrumentados

- [ ] **Crear `MigrationV6ToV7Test`** (AC: 25, 26, 27, 28, 29, 30)
  - [ ] Crear archivo: `androidTest/java/com/estebancoloradogonzalez/tension/MigrationV6ToV7Test.kt`
  - [ ] `@RunWith(AndroidJUnit4::class) class MigrationV6ToV7Test`
  - [ ] Setup: crear BD en memoria vía `Room.inMemoryDatabaseBuilder()` con version 7 y `addMigrations(Migrations.MIGRATION_6_7)`. Dado que la BD en memoria se crea desde cero con los seeders actualizados (vía `PrepopulateCallback`), los tests validan el ESTADO FINAL correcto independientemente de si llegó por migration o por seeder. Esto es equivalente a validar que ambos caminos convergen.
  - [ ] **Alternativa de setup:** Si se necesita validar la migration misma (no solo el estado final), usar `SupportSQLiteOpenHelper` con version 6 → insertar datos de seeders V6 manualmente → ejecutar `Migrations.MIGRATION_6_7.migrate(db)` → validar estado post-migración. Este enfoque es más riguroso pero requiere más setup.
  - [ ] **Test 1 — Conteo de ejercicios por módulo** (CA-15.5.27):
    ```kotlin
    @Test
    fun migration_exerciseCountByModule_isCorrect() {
        val cursor = db.query("SELECT module_code, COUNT(*) AS cnt FROM exercise GROUP BY module_code ORDER BY module_code")
        val results = mutableMapOf<String, Int>()
        while (cursor.moveToNext()) {
            results[cursor.getString(0)] = cursor.getInt(1)
        }
        cursor.close()
        assertEquals(14, results["A"])
        assertEquals(15, results["B"])
        assertEquals(14, results["C"])
    }
    ```
  - [ ] **Test 2 — Conteo de asignaciones por versión** (CA-15.5.28):
    ```kotlin
    @Test
    fun migration_assignmentCountByVersion_isCorrect() {
        val cursor = db.query("SELECT module_version_id, COUNT(*) AS cnt FROM plan_assignment GROUP BY module_version_id ORDER BY module_version_id")
        val results = mutableMapOf<Int, Int>()
        while (cursor.moveToNext()) {
            results[cursor.getInt(0)] = cursor.getInt(1)
        }
        cursor.close()
        // A-V1=11, A-V2=11, A-V3=11, B-V1=11, B-V2=11, B-V3=11, C-V1=9, C-V2=9, C-V3=9
        for (versionId in 1..6) assertEquals(11, results[versionId], "module_version_id=$versionId")
        for (versionId in 7..9) assertEquals(9, results[versionId], "module_version_id=$versionId")
        assertEquals(93, results.values.sum()) // Total
    }
    ```
  - [ ] **Test 3 — Zona muscular de Elevación de hombros** (CA-15.5.29):
    ```kotlin
    @Test
    fun migration_exercise26MuscleZone_isEspaldaMedia() {
        val cursor = db.query("""
            SELECT mz.name FROM exercise_muscle_zone emz
            JOIN muscle_zone mz ON emz.muscle_zone_id = mz.id
            WHERE emz.exercise_id = 26
        """)
        assertTrue(cursor.moveToFirst())
        assertEquals("Espalda Media", cursor.getString(0))
        cursor.close()
    }
    ```
  - [ ] **Test 4 — Integridad referencial de plan_assignment** (CA-15.5.30):
    ```kotlin
    @Test
    fun migration_planAssignmentReferentialIntegrity_isValid() {
        val cursor = db.query("""
            SELECT pa.module_version_id, pa.exercise_id
            FROM plan_assignment pa
            JOIN module_version mv ON pa.module_version_id = mv.id
            JOIN exercise e ON pa.exercise_id = e.id
            WHERE mv.module_code != e.module_code
        """)
        assertEquals(0, cursor.count, "Exercises assigned to wrong module version")
        cursor.close()
    }
    ```
  - [ ] **Test 5 — Datos históricos no tocados** (CA-15.5.25, CA-15.5.26):
    ```kotlin
    @Test
    fun migration_historicalTablesPreserved_noModification() {
        // Verificar que las tablas transaccionales existen y no fueron alteradas
        // (En BD en memoria no hay datos históricos, pero validamos que no hay
        // DROP/ALTER en estas tablas verificando que la estructura existe)
        val tables = listOf("session", "session_exercise", "exercise_set", "alert", "rotation_state")
        for (table in tables) {
            val cursor = db.query("SELECT COUNT(*) FROM $table")
            assertTrue(cursor.moveToFirst())
            cursor.close()
        }
    }
    ```

### Fase N: QA y Deployment

#### 📦 Code Quality

- [ ] **Ejecutar Agente Peer Review**
- [ ] **Resolver incidentes del Peer Review** (condicional)

#### 📦 Deployment DEV

- [ ] **Crear Pull Request**
- [ ] **Ejecutar pipeline deployment DEV**

#### 📦 Testing Manual

- [ ] **Diseñar set de pruebas manuales**
  - [ ] Escenario 1: Instalación limpia (desinstalar app → instalar) — verificar que la pantalla de inicio de sesión muestra los módulos correctos y el plan de entrenamiento contiene los ejercicios nuevos
  - [ ] Escenario 2: Actualización in-place (mantener BD existente → instalar actualización) — verificar que las sesiones históricas se preservan y que la próxima sesión usa la estructura correcta
  - [ ] Escenario 3: Verificar métricas post-migración — abrir pantalla de analítica (HU-15) y verificar que el tonelaje de "Elevación de hombros" aparece bajo "Espalda" en lugar de "Hombro"
  - [ ] Escenario 4: Abrir una sesión para cada módulo (A, B, C) y verificar que los ejercicios presentados corresponden a la nueva composición Pull/Push/Legs
- [ ] **Ejecutar pruebas manuales**

---

### Verificación cruzada de CAs

**CA-15.5.01 → CA-15.5.02:** Fase 1 (ModuleSeeder) + Fase 4 (Migration SQL UPDATEs module)
**CA-15.5.03:** Automático — C no se toca en ninguna fase
**CA-15.5.04 → CA-15.5.06:** Fase 2 (ExerciseSeeder) + Fase 2.5 (mover PNGs) + Fase 4 (Migration SQL UPDATEs exercise)
**CA-15.5.07 → CA-15.5.10:** Automáticos — ejercicios ya tienen module_code correcto
**CA-15.5.11:** Fase 6 (Test 1)
**CA-15.5.12:** Fase 2 (ExerciseSeeder emz) + Fase 4 (Migration SQL UPDATE exercise_muscle_zone)
**CA-15.5.13:** Automático — KPIs de HU-15 se recalculan vía JOINs a exercise_muscle_zone
**CA-15.5.14:** Fase 4 (Migration SQL DELETE plan_assignment)
**CA-15.5.15 → CA-15.5.16:** Fase 3 (PlanSeeder) + Fase 4 (Migration SQL 66 INSERTs)
**CA-15.5.17:** Automático — módulo C no se toca
**CA-15.5.18:** Fase 6 (Test 2)
**CA-15.5.19:** Fase 1 (ModuleSeeder)
**CA-15.5.20 → CA-15.5.21:** Fase 2 (ExerciseSeeder)
**CA-15.5.22:** Fase 3 (PlanSeeder)
**CA-15.5.23:** Fase 5 (TensionDatabase version + DatabaseModule addMigrations)
**CA-15.5.24:** Fase 4 (Migrations SQL completo)
**CA-15.5.25 → CA-15.5.26:** Automáticos — migration SQL no toca session/exercise_set/session_exercise/alert/rotation_state + Fase 6 (Test 5)
**CA-15.5.27:** Fase 6 (Test 1)
**CA-15.5.28:** Fase 6 (Test 2)
**CA-15.5.29:** Fase 6 (Test 3)
**CA-15.5.30:** Fase 6 (Test 4)