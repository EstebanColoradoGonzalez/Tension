# HU-12 ‚Äî Motor de Detecci√≥n: Regresi√≥n, Meseta y Necesidad de Descarga

## Requisitos relacionados

RF29, RF30, RF34, RF35, RF36, RF37, RNF05

## Descripci√≥n

Como ejecutante, quiero que el sistema detecte autom√°ticamente regresiones en mis ejercicios, identifique fatiga acumulada del m√≥dulo, diagnostique mesetas con an√°lisis causal, me recomiende acciones correctivas escalonadas y se√±ale cuando un m√≥dulo completo necesita descarga, para tener un diagn√≥stico integral y objetivo de mi estado de entrenamiento que me permita tomar decisiones informadas antes de que la acumulaci√≥n de fatiga comprometa mi progreso.

## Historias originales consolidadas

Esta historia consolida las siguientes historias del dise√±o original, que forman una cadena de decisi√≥n inseparable (detectar ‚Üí diagnosticar ‚Üí prescribir ‚Üí escalar):

- **HU-12 original** ‚Äî Detectar regresi√≥n y fatiga acumulada (RF29, RF30)
- **HU-14 original** ‚Äî Detectar y alertar meseta en ejercicios (RF34, RF35)
- **HU-15 original** ‚Äî Recomendar acciones correctivas escalonadas ante meseta (RF36)
- **HU-16 original** ‚Äî Detectar necesidad de descarga por m√≥dulo (RF37)

---

## Criterios de Aceptaci√≥n

### Bloque A ‚Äî Detecci√≥n de Regresi√≥n (RF29)

#### CA-12.01 ‚Äî Detecci√≥n de regresi√≥n por ca√≠da de repeticiones

**Dado que** el sistema compara un ejercicio contra su √∫ltimo registro hist√≥rico al cerrar una sesi√≥n,
**cuando** detecta que el peso utilizado es igual al de la sesi√≥n anterior pero las repeticiones cayeron en ‚â• 2 de las 4 series,
**entonces** clasifica al ejercicio con "Regresi√≥n" para esta sesi√≥n.

#### CA-12.02 ‚Äî Detecci√≥n de regresi√≥n por aumento de RIR

**Dado que** el sistema compara un ejercicio contra su √∫ltimo registro hist√≥rico al cerrar una sesi√≥n,
**cuando** detecta que la carga es la misma, las repeticiones son similares a la sesi√≥n anterior, pero el RIR promedio subi√≥ en ‚â• 1.5 puntos,
**entonces** clasifica al ejercicio con "Regresi√≥n" para esta sesi√≥n, interpretando que el ejecutante necesit√≥ m√°s esfuerzo percibido para mantener el mismo rendimiento.

#### CA-12.03 ‚Äî Regresi√≥n por ca√≠da de carga

**Dado que** el sistema compara un ejercicio contra su √∫ltimo registro hist√≥rico,
**cuando** detecta que el peso utilizado es menor al de la sesi√≥n anterior,
**entonces** clasifica al ejercicio con "Regresi√≥n" para esta sesi√≥n.

### Bloque B ‚Äî Detecci√≥n de Fatiga Acumulada del M√≥dulo (RF30)

#### CA-12.04 ‚Äî Detecci√≥n de fatiga acumulada del m√≥dulo

**Dado que** el sistema ha clasificado la progresi√≥n de todos los ejercicios registrados en la sesi√≥n,
**cuando** identifica regresi√≥n simult√°nea en ‚â• 50% de los ejercicios de esa sesi√≥n,
**entonces** detecta y registra "Fatiga acumulada del m√≥dulo" para el m√≥dulo de la sesi√≥n.

#### CA-12.05 ‚Äî Umbral del 50% calculado sobre ejercicios registrados

**Dado que** una sesi√≥n se cierra como Incompleta con menos ejercicios registrados que los prescritos,
**cuando** el sistema eval√∫a fatiga acumulada,
**entonces** calcula el umbral del 50% sobre los ejercicios que efectivamente tienen registros en la sesi√≥n, no sobre el total de ejercicios prescritos.

#### CA-12.06 ‚Äî Registro de las detecciones

**Dado que** el sistema detecta regresi√≥n en un ejercicio o fatiga acumulada en un m√≥dulo,
**cuando** completa el an√°lisis post-sesi√≥n,
**entonces** persiste las detecciones vinculadas a la sesi√≥n para su uso en reglas de decisi√≥n posteriores (mesetas, alertas de descarga, KPIs).

### Bloque C ‚Äî Detecci√≥n de Meseta (RF34, RF35)

#### CA-12.07 ‚Äî Detecci√≥n de meseta por 3 sesiones sin progresi√≥n

**Dado que** el sistema eval√∫a la progresi√≥n de un ejercicio al cerrar una sesi√≥n,
**cuando** detecta que el ejercicio no ha registrado progresi√≥n positiva (ni aumento de carga ni aumento de repeticiones) durante 3 sesiones consecutivas del mismo ejercicio,
**entonces** marca el ejercicio con estado "En Meseta".

#### CA-12.08 ‚Äî Sesiones consecutivas del mismo ejercicio

**Dado que** el sistema eval√∫a si un ejercicio est√° en meseta,
**cuando** cuenta las sesiones consecutivas sin progresi√≥n,
**entonces** solo cuenta sesiones que incluyen ese ejercicio espec√≠fico, sin importar cu√°ntas sesiones de otros m√≥dulos hayan ocurrido entre ellas; la consecutividad es del ejercicio, no del calendario.

#### CA-12.09 ‚Äî Alerta de meseta al ejecutante

**Dado que** un ejercicio entra en estado de "En Meseta",
**cuando** el sistema completa la detecci√≥n,
**entonces** emite una alerta visible al ejecutante indicando el nombre del ejercicio en meseta y que lleva 3 sesiones sin progresi√≥n.

#### CA-12.10 ‚Äî An√°lisis causal: RIR bajo indica l√≠mite de carga

**Dado que** un ejercicio entra en meseta,
**cuando** el sistema analiza los datos de las √∫ltimas 3 sesiones y el RIR promedio es consistentemente bajo (0-1),
**entonces** la alerta incluye el an√°lisis causal: "El ejecutante est√° entrenando cerca del fallo t√©cnico ‚Äî posible l√≠mite de carga con este peso. El cuerpo no tiene reserva suficiente para progresar."

#### CA-12.11 ‚Äî An√°lisis causal: RIR alto indica carga conservadora

**Dado que** un ejercicio entra en meseta,
**cuando** el sistema analiza los datos de las √∫ltimas 3 sesiones y el RIR promedio es alto (3+),
**entonces** la alerta incluye el an√°lisis causal: "El ejecutante mantiene reserva alta ‚Äî posible carga conservadora. El est√≠mulo puede ser insuficiente para generar adaptaci√≥n."

#### CA-12.12 ‚Äî An√°lisis causal: estancamiento grupal indica fatiga sist√©mica

**Dado que** un ejercicio entra en meseta,
**cuando** el sistema detecta que otros ejercicios del mismo grupo muscular tambi√©n est√°n estancados o en meseta,
**entonces** la alerta incluye el an√°lisis causal: "M√∫ltiples ejercicios del mismo grupo muscular estancados ‚Äî posible fatiga sist√©mica del grupo muscular."

#### CA-12.13 ‚Äî Se√±ales visuales diferenciadas

**Dado que** el sistema emite una alerta de meseta,
**cuando** el ejecutante visualiza la alerta,
**entonces** la alerta es visualmente distinguible mediante colores e iconograf√≠a espec√≠fica para meseta, diferenci√°ndose de las se√±ales de progresi√≥n positiva y regresi√≥n, sin depender √∫nicamente del texto.

#### CA-12.14 ‚Äî Actualizaci√≥n del estado del ejercicio

**Dado que** un ejercicio entra en meseta,
**cuando** el sistema actualiza el estado persistente de progresi√≥n,
**entonces** el estado del ejercicio cambia de "En Progresi√≥n" a "En Meseta" y permanece as√≠ hasta que se registre progresi√≥n positiva o se active una descarga.

### Bloque D ‚Äî Acciones Correctivas Escalonadas ante Meseta (RF36)

#### CA-12.15 ‚Äî Recomendaci√≥n en sesi√≥n 4 sin progreso

**Dado que** un ejercicio lleva 4 sesiones consecutivas sin progresi√≥n positiva (1 sesi√≥n m√°s all√° de la detecci√≥n de meseta),
**cuando** el sistema emite la recomendaci√≥n,
**entonces** recomienda al ejecutante: aplicar un microincremento de carga (la menor carga posible disponible) o intentar extender las repeticiones dentro del rango (buscar llegar a 12 reps antes de subir carga), presentando ambas opciones como alternativas.

#### CA-12.16 ‚Äî Recomendaci√≥n en sesi√≥n 6 sin progreso

**Dado que** un ejercicio lleva 6 sesiones consecutivas sin progresi√≥n positiva,
**cuando** el sistema emite la recomendaci√≥n,
**entonces** recomienda al ejecutante: rotar a otra versi√≥n del m√≥dulo para cambiar el patr√≥n de est√≠mulo muscular, indicando que la versi√≥n actual puede haber agotado su efecto adaptativo para ese ejercicio.

#### CA-12.17 ‚Äî Escalonamiento acumulativo

**Dado que** un ejercicio alcanza la sesi√≥n 6 sin progreso,
**cuando** el sistema presenta la recomendaci√≥n,
**entonces** muestra la recomendaci√≥n de sesi√≥n 6 (rotar versi√≥n) como complemento a la de sesi√≥n 4 (microincremento o extensi√≥n de reps), indicando que ambas estrategias pueden combinarse.

#### CA-12.18 ‚Äî Recomendaciones informativas, no bloqueantes

**Dado que** el sistema emite una recomendaci√≥n correctiva,
**cuando** el ejecutante visualiza la recomendaci√≥n,
**entonces** la recomendaci√≥n es informativa: el ejecutante puede seguirla o ignorarla. El sistema no impide iniciar ni completar una sesi√≥n por existir una recomendaci√≥n pendiente.

#### CA-12.19 ‚Äî Vinculaci√≥n con la alerta de meseta

**Dado que** un ejercicio est√° en meseta y el sistema ha emitido una alerta,
**cuando** el sistema emite las recomendaciones correctivas,
**entonces** las presenta asociadas a la alerta de meseta del ejercicio, permitiendo al ejecutante ver el diagn√≥stico (an√°lisis causal) y la prescripci√≥n (acci√≥n correctiva) de forma conjunta.

### Bloque E ‚Äî Detecci√≥n de Necesidad de Descarga por M√≥dulo (RF37)

#### CA-12.20 ‚Äî Detecci√≥n por meseta/regresi√≥n simult√°nea

**Dado que** el sistema eval√∫a el estado de los ejercicios de un m√≥dulo al cerrar una sesi√≥n,
**cuando** detecta que ‚â• 50% de los ejercicios del m√≥dulo est√°n simult√°neamente en estado de "En Meseta" o clasificados con "Regresi√≥n" en la sesi√≥n actual,
**entonces** marca el m√≥dulo como "Requiere descarga" y emite una se√±al al ejecutante.

#### CA-12.21 ‚Äî Detecci√≥n por fatiga acumulada del m√≥dulo

**Dado que** el sistema ha detectado fatiga acumulada del m√≥dulo en la sesi√≥n actual (regresi√≥n simult√°nea en ‚â• 50% de los ejercicios ‚Äî CA-12.04),
**cuando** completa el an√°lisis post-sesi√≥n,
**entonces** marca el m√≥dulo como "Requiere descarga" y emite una se√±al al ejecutante, independientemente del estado de meseta de los ejercicios individuales.

#### CA-12.22 ‚Äî C√°lculo del umbral del 50%

**Dado que** el sistema eval√∫a si un m√≥dulo requiere descarga,
**cuando** calcula el porcentaje de ejercicios en meseta/regresi√≥n,
**entonces** lo calcula sobre el total de ejercicios prescritos para la versi√≥n del m√≥dulo actualmente en ejecuci√≥n (11 para A, 11 para B, 9 para C).

#### CA-12.23 ‚Äî Se√±al informativa, no bloqueante

**Dado que** el sistema detecta que un m√≥dulo requiere descarga,
**cuando** emite la se√±al al ejecutante,
**entonces** la se√±al es informativa y recomienda activar el modo de descarga (HU-14), pero no impide al ejecutante continuar entrenando con la carga normal si as√≠ lo decide.

#### CA-12.24 ‚Äî Registro de la detecci√≥n

**Dado que** el sistema detecta que un m√≥dulo requiere descarga,
**cuando** completa la evaluaci√≥n,
**entonces** persiste la detecci√≥n con la fecha y el m√≥dulo afectado, disponible para consulta en el historial.

---

## An√°lisis Arquitect√≥nico (Arquitecto)

### Decisiones de Dise√±o

**Patr√≥n Arquitect√≥nico:** Extensi√≥n del pipeline de cierre de sesi√≥n (HU-10/HU-11) + reglas puras en `domain/rules/` (ADR-06) + nueva capa de persistencia de alertas.

**Justificaci√≥n:** HU-12 sigue la cadena establecida por HU-10 y HU-11: l√≥gica de backend sin pantalla propia, ejecutada dentro de la transacci√≥n de `closeSession()`, con funciones puras en `domain/rules/` testeables sin emulador. HU-12 agrega una dimensi√≥n nueva: la evaluaci√≥n a **nivel de m√≥dulo** (post-loop), que opera DESPU√âS de que el loop per-ejercicio actualice todos los estados. Adem√°s, establece la **infraestructura de alertas** (`AlertEntity` + `AlertDao`) que HU-17 (Sistema de Alertas) reutilizar√°.

**1. HU-12 es l√≥gica pura de backend ‚Äî no tiene pantalla propia.**

Mapa de Navegaci√≥n: E5 (HU-13) consume se√±ales de regresi√≥n/descarga, H1/H2 (HU-17) consume alertas de meseta, B1 muestra badge de alertas activas. HU-12 produce datos, no los visualiza. Todo ocurre dentro de la transacci√≥n de `closeSession()`.

**2. Siete de los 24 CAs ya est√°n cubiertos por HU-10 ‚Üí HU-12 no los reimplementa.**

| CA ya cubierto | Mecanismo existente (HU-10) |
|---|---|
| CA-12.01 (regresi√≥n por reps) | `classifyStandard()` ‚Üí `totalReps < previous ‚Üí REGRESSION` |
| CA-12.02 (regresi√≥n por RIR) | `classifyStandard()` ‚Üí `rirRise >= 1.5 ‚Üí REGRESSION` |
| CA-12.03 (regresi√≥n por carga) | `classifyStandard()` ‚Üí `weightLower ‚Üí REGRESSION` |
| CA-12.07 (meseta a 3 sesiones) | `resolveNewProgressionState()` ‚Üí `counter >= 3 ‚Üí IN_PLATEAU` |
| CA-12.08 (consecutividad por ejercicio) | Dise√±o inherente ‚Äî `sessionsWithoutProgression` solo se incrementa cuando ESE ejercicio se eval√∫a |
| CA-12.14 (actualizaci√≥n de estado) | `resolveNewProgressionState()` ‚Üí `status = IN_PLATEAU` |
| CA-12.18 (no bloqueante) | Las alertas y recomendaciones son informativas por dise√±o ‚Äî no alteran ning√∫n flujo |

**Nota sobre CA-12.01:** El MDS R4 define regresi√≥n como "reps caen en ‚â• 2 de las 4 series" (criterio per-serie). HU-10 implementa un criterio agregado (`totalReps < previous ‚Üí REGRESSION`). Ambos convergen en la pr√°ctica: si las repeticiones totales bajan, al menos algunas series individuales bajaron. El edge case (series individuales cambian pero total se mantiene) es un patr√≥n at√≠pico de entrenamiento real. Se mantiene el enfoque agregado como suficiente para el MVP.

**3. Cuatro reglas puras nuevas en `domain/rules/` (ADR-06).**

Cada regla es un `object` Kotlin con funciones puras, sin dependencias Android, testeable con JUnit:

| Regla | MDS | Invocaci√≥n | Responsabilidad |
|---|---|---|---|
| `ModuleFatigueRule` | R4 (m√≥dulo) | Write-time (cierre de sesi√≥n) | Detectar fatiga acumulada del m√≥dulo (‚â•50% regresiones en sesi√≥n) |
| `DeloadNeedRule` | R3 ¬ß3·µÉ intervenci√≥n + R4 | Write-time (cierre de sesi√≥n) | Detectar si m√≥dulo requiere descarga |
| `PlateauCausalAnalysisRule` | R3 (an√°lisis) | Read-time (detalle de alerta) | Analizar causa de meseta (RIR bajo/alto, estancamiento grupal) |
| `CorrectiveActionRule` | R3 ¬ß1·µÉ/2·µÉ intervenci√≥n | Read-time (detalle de alerta) | Recomendar acciones correctivas escalonadas (sesi√≥n 4/6) |

**4. HU-12 establece la infraestructura de alertas que HU-17 reutiliza.**

El Modelo de Datos ¬ß3.16 define la tabla `alert` con 7 tipos. HU-12 crea `AlertEntity` + `AlertDao` (la infraestructura completa) pero solo escribe 2 tipos: `PLATEAU` y `MODULE_REQUIRES_DELOAD`. HU-17 agregar√° los otros 5 tipos (`LOW_PROGRESSION_RATE`, `RIR_OUT_OF_RANGE`, `LOW_ADHERENCE`, `TONNAGE_DROP`, `MODULE_INACTIVITY`) y construir√° las pantallas H1/H2. Esto sigue el principio de extensi√≥n incremental: HU-12 introduce la tabla y los primeros consumidores; HU-17 ampl√≠a.

**5. Separaci√≥n de responsabilidades WRITE-TIME vs READ-TIME.**

- **Write-time** (cierre de sesi√≥n): Detecci√≥n de condiciones + creaci√≥n/resoluci√≥n de alertas en tabla `alert`. Datos persistidos: tipo, nivel, entidad afectada, mensaje, estado activo/resuelto.
- **Read-time** (detalle de alerta en H2): An√°lisis causal y recomendaciones correctivas. Computados din√°micamente desde datos crudos (series, sesiones).
- **Justificaci√≥n:** El Modelo de Datos ¬ß3.16 es expl√≠cito: *"Los datos que dispararon la alerta y las recomendaciones escalonadas no se almacenan ‚Äî se recalculan din√°micamente en la capa de aplicaci√≥n a partir de las series, sesiones y la l√≥gica del motor de reglas. Dado que las sesiones cerradas son inmutables, el rec√°lculo siempre produce el mismo resultado."*

**6. El an√°lisis causal (CA-12.10-12.12) recibe datos pre-computados.**

`PlateauCausalAnalysisRule.analyze()` recibe: (a) lista de avgRIR de las √∫ltimas 3 sesiones del ejercicio, (b) flag de estancamiento grupal. La obtenci√≥n de estos datos (queries hist√≥ricas + JOINs de `exercise_muscle_zone`) la hace el Repository/UseCase que sirve H2 ‚Äî no la regla. La regla solo clasifica.

**7. Las recomendaciones correctivas (CA-12.15-12.17) se derivan del contador existente.**

`exercise_progression.sessions_without_progression` ya se mantiene por HU-10. `CorrectiveActionRule.recommend(counter)` aplica umbrales: `‚â• 4` ‚Üí microincremento/extensi√≥n de reps, `‚â• 6` ‚Üí rotar versi√≥n (acumulativo, CA-12.17). No requiere persistencia adicional ‚Äî la informaci√≥n se computa al renderizar H2.

**8. Deduplicaci√≥n y resoluci√≥n autom√°tica de alertas.**

- **Deduplicaci√≥n:** Antes de insertar un `PLATEAU` alert, verificar que no exista uno activo para el mismo `exercise_id`. Antes de insertar `MODULE_REQUIRES_DELOAD`, verificar que no exista uno activo para el mismo `module_code`.
- **Resoluci√≥n autom√°tica (CA-12.14 impl√≠cito):** Cuando un ejercicio sale de `IN_PLATEAU` (progresi√≥n positiva ‚Üí `IN_PROGRESSION`, counter reset a 0), la alerta PLATEAU se resuelve (`is_active = 0`, `resolved_at = hoy`). Cuando el m√≥dulo ya no cumple el umbral de descarga, la alerta MODULE_REQUIRES_DELOAD se resuelve.

**9. El umbral del 50% tiene denominadores diferentes seg√∫n el contexto.**

| Detecci√≥n | Denominador | CA |
|---|---|---|
| Fatiga acumulada del m√≥dulo | Ejercicios **con registros** en la sesi√≥n (no prescritos totales) | CA-12.05 |
| Necesidad de descarga | Total de ejercicios **prescritos** para la versi√≥n del m√≥dulo | CA-12.22 |

**10. `moduleVersionId` se obtiene de la tabla `session` y se pasa como par√°metro.**

`ActiveSessionInfo` no incluye `moduleVersionId` ‚Äî solo `moduleCode` y `versionNumber`. Para las queries de deload need (CA-12.22), se necesita `moduleVersionId`. Se obtiene directamente de `session.module_version_id` mediante una nueva query en `SessionDao` y se pasa como par√°metro a `evaluateProgression()`.

**11. Los mensajes de alerta son gen√©ricos; el nombre de ejercicio/m√≥dulo se resuelve por JOIN.**

`alert.message` almacena texto descriptivo gen√©rico ("3 sesiones sin progresi√≥n", "‚â•50% ejercicios en meseta/regresi√≥n"). Los nombres se obtienen al leer la alerta v√≠a FKs (`exercise_id` ‚Üí `exercise.name`, `module_code` ‚Üí `module.name`). Esto evita denormalizaci√≥n y mantiene los mensajes actualizables.

**12. Guardia de descarga: la detecci√≥n de m√≥dulo-nivel se omite durante sesiones de descarga.**

Si la sesi√≥n que se cierra pertenece a un ciclo de descarga activo (`session.deload_id != null`), el paso 6 (detecci√≥n de fatiga/deload del m√≥dulo) se omite completamente. Justificaci√≥n: durante la descarga, la carga se reduce al 60% ‚Äî las regresiones en ese contexto son esperadas y no representan fatiga real. Emitir una alerta `MODULE_REQUIRES_DELOAD` durante una descarga que ya est√° en curso ser√≠a parad√≥jico. La guardia usa `session.deload_id` que ya existe en `SessionEntity`. El paso 5d (alertas per-ejercicio de meseta) tambi√©n se omite durante descarga porque `resolveNewProgressionState()` de HU-10 ya tiene guardia `IN_DELOAD`: no modifica estado ni contador durante descarga.

**13. E5 (HU-13) deriva "Considerar descarga" combinando clasificaci√≥n y alertas.**

CA-13.05 espera una se√±al "Considerar descarga" por ejercicio en el resumen post-sesi√≥n (E5). La ruta de derivaci√≥n es: E5 muestra "Considerar descarga" cuando `session_exercise.progression_classification == 'REGRESSION'` en la sesi√≥n actual **Y** existe una alerta activa `MODULE_REQUIRES_DELOAD` para el m√≥dulo del ejercicio. Si solo hay regresi√≥n aislada sin alerta de m√≥dulo, E5 muestra "‚Üì Regresi√≥n" pero no "Considerar descarga". La implementaci√≥n de esta l√≥gica de derivaci√≥n es responsabilidad de HU-13, pero HU-12 provee los datos subyacentes.

**Componentes Afectados:**

**Componentes nuevos:**

| # | Componente | Capa | Responsabilidad |
|---|---|---|---|
| 1 | `AlertEntity` | Data (entity) | Entity Room para tabla `alert` (Modelo de Datos ¬ß3.16) |
| 2 | `AlertDao` | Data (DAO) | Insert, query activas, resolve, existsActive, countActive |
| 3 | `ModuleFatigueRule` | Domain (rules) | R4 m√≥dulo: `detectFatigue(regressionCount, exercisesWithRecords) ‚Üí Boolean` |
| 4 | `DeloadNeedRule` | Domain (rules) | R3 ¬ß3·µÉ intervenci√≥n + R4: `needsDeload(affectedCount, totalCount, fatigueDetected) ‚Üí Boolean` |
| 5 | `PlateauCausalAnalysisRule` | Domain (rules) | R3 an√°lisis: `analyze(avgRirs, isGroupStagnant) ‚Üí PlateauCause` |
| 6 | `CorrectiveActionRule` | Domain (rules) | R3 ¬ß1·µÉ/2·µÉ intervenci√≥n: `recommend(sessionsWithoutProgression) ‚Üí List<CorrectiveAction>` |
| 7 | `PlateauCause` | Domain (model) | Enum: `LOW_RIR_LIMIT`, `HIGH_RIR_CONSERVATIVE`, `GROUP_STAGNATION`, `MIXED` |
| 8 | `CorrectiveAction` | Domain (model) | Enum: `MICRO_INCREMENT_OR_EXTEND_REPS`, `ROTATE_VERSION` |

**Componentes modificados:**

| # | Componente | Cambio | Nivel |
|---|---|---|---|
| 1 | `TensionDatabase` | Agregar `AlertEntity` a entities, agregar `alertDao()`, version 4 ‚Üí 5, migraci√≥n | Mayor |
| 2 | `DatabaseModule` | Agregar `provideAlertDao()` | Menor |
| 3 | `SessionRepositoryImpl` | Inyectar `AlertDao`; extender `evaluateProgression()` con gesti√≥n de alertas post-loop + guardia de descarga | Mayor |
| 4 | `SessionDao` | Agregar queries `getModuleVersionIdBySessionId()`, `getDeloadIdBySessionId()` | Menor |
| 5 | `PlanAssignmentDao` | Agregar queries: `countExercisesForModuleVersion()`, `countAffectedForDeload()` | Menor |

**Componentes nuevos ‚Äî Especificaciones:**

#### `ModuleFatigueRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

object ModuleFatigueRule {

    const val FATIGUE_THRESHOLD = 0.50

    fun detectFatigue(regressionCount: Int, exercisesWithRecords: Int): Boolean {
        if (exercisesWithRecords == 0) return false
        return regressionCount.toDouble() / exercisesWithRecords >= FATIGUE_THRESHOLD
    }
}
```

#### `DeloadNeedRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

object DeloadNeedRule {

    const val DELOAD_THRESHOLD = 0.50

    fun needsDeload(
        affectedCount: Int,
        totalCount: Int,
        fatigueDetected: Boolean,
    ): Boolean {
        if (fatigueDetected) return true // CA-12.21
        if (totalCount == 0) return false
        return affectedCount.toDouble() / totalCount >= DELOAD_THRESHOLD // CA-12.20
    }
}
```

#### `PlateauCausalAnalysisRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

import com.estebancoloradogonzalez.tension.domain.model.PlateauCause

object PlateauCausalAnalysisRule {

    const val LOW_RIR_THRESHOLD = 1.0
    const val HIGH_RIR_THRESHOLD = 3.0

    fun analyze(
        lastSessionsAvgRir: List<Double>,
        isGroupStagnant: Boolean,
    ): PlateauCause {
        if (isGroupStagnant) return PlateauCause.GROUP_STAGNATION // CA-12.12
        if (lastSessionsAvgRir.isEmpty()) return PlateauCause.MIXED
        val overallAvg = lastSessionsAvgRir.average()
        return when {
            overallAvg <= LOW_RIR_THRESHOLD -> PlateauCause.LOW_RIR_LIMIT // CA-12.10
            overallAvg >= HIGH_RIR_THRESHOLD -> PlateauCause.HIGH_RIR_CONSERVATIVE // CA-12.11
            else -> PlateauCause.MIXED
        }
    }
}
```

#### `CorrectiveActionRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

import com.estebancoloradogonzalez.tension.domain.model.CorrectiveAction

object CorrectiveActionRule {

    const val MICRO_INCREMENT_THRESHOLD = 4
    const val ROTATE_VERSION_THRESHOLD = 6

    fun recommend(sessionsWithoutProgression: Int): List<CorrectiveAction> {
        if (sessionsWithoutProgression < MICRO_INCREMENT_THRESHOLD) return emptyList()
        val actions = mutableListOf(CorrectiveAction.MICRO_INCREMENT_OR_EXTEND_REPS) // CA-12.15
        if (sessionsWithoutProgression >= ROTATE_VERSION_THRESHOLD) {
            actions.add(CorrectiveAction.ROTATE_VERSION) // CA-12.16, CA-12.17
        }
        return actions
    }
}
```

#### `PlateauCause.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.model

enum class PlateauCause {
    LOW_RIR_LIMIT,         // CA-12.10: RIR 0-1, entrenando cerca del fallo
    HIGH_RIR_CONSERVATIVE, // CA-12.11: RIR 3+, carga conservadora
    GROUP_STAGNATION,      // CA-12.12: m√∫ltiples ejercicios del grupo muscular estancados
    MIXED,                 // Ning√∫n patr√≥n claro dominante
}
```

#### `CorrectiveAction.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.model

enum class CorrectiveAction {
    MICRO_INCREMENT_OR_EXTEND_REPS, // CA-12.15: sesi√≥n 4+, microincremento o extensi√≥n de reps
    ROTATE_VERSION,                 // CA-12.16: sesi√≥n 6+, rotar a otra versi√≥n del m√≥dulo
}
```

#### `AlertEntity.kt`

```kotlin
package com.estebancoloradogonzalez.tension.data.local.entity

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "alert",
    foreignKeys = [
        ForeignKey(
            entity = ExerciseEntity::class,
            parentColumns = ["id"],
            childColumns = ["exercise_id"],
            onDelete = ForeignKey.RESTRICT,
        ),
        ForeignKey(
            entity = ModuleEntity::class,
            parentColumns = ["code"],
            childColumns = ["module_code"],
            onDelete = ForeignKey.RESTRICT,
        ),
    ],
    indices = [
        Index(value = ["is_active"]),
        Index(value = ["type"]),
        Index(value = ["exercise_id"]),
        Index(value = ["module_code"]),
    ],
)
data class AlertEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,

    @ColumnInfo(name = "type")
    val type: String,

    @ColumnInfo(name = "level")
    val level: String,

    @ColumnInfo(name = "exercise_id")
    val exerciseId: Long? = null,

    @ColumnInfo(name = "module_code")
    val moduleCode: String? = null,

    @ColumnInfo(name = "muscle_group")
    val muscleGroup: String? = null,

    @ColumnInfo(name = "message")
    val message: String,

    @ColumnInfo(name = "is_active", defaultValue = "1")
    val isActive: Int = 1,

    @ColumnInfo(name = "created_at")
    val createdAt: String,

    @ColumnInfo(name = "resolved_at")
    val resolvedAt: String? = null,
)
```

#### `AlertDao.kt`

```kotlin
package com.estebancoloradogonzalez.tension.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.Query
import com.estebancoloradogonzalez.tension.data.local.entity.AlertEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface AlertDao {

    @Insert
    suspend fun insert(alert: AlertEntity): Long

    @Query(
        """
        SELECT EXISTS(
            SELECT 1 FROM alert
            WHERE exercise_id = :exerciseId AND type = :type AND is_active = 1
        )
        """,
    )
    suspend fun existsActiveByExercise(exerciseId: Long, type: String): Boolean

    @Query(
        """
        SELECT EXISTS(
            SELECT 1 FROM alert
            WHERE module_code = :moduleCode AND type = :type AND is_active = 1
        )
        """,
    )
    suspend fun existsActiveByModule(moduleCode: String, type: String): Boolean

    @Query(
        """
        UPDATE alert
        SET is_active = 0, resolved_at = :resolvedAt
        WHERE exercise_id = :exerciseId AND type = :type AND is_active = 1
        """,
    )
    suspend fun resolveByExerciseAndType(exerciseId: Long, type: String, resolvedAt: String)

    @Query(
        """
        UPDATE alert
        SET is_active = 0, resolved_at = :resolvedAt
        WHERE module_code = :moduleCode AND type = :type AND is_active = 1
        """,
    )
    suspend fun resolveByModuleAndType(moduleCode: String, type: String, resolvedAt: String)

    @Query("SELECT COUNT(*) FROM alert WHERE is_active = 1")
    fun countActive(): Flow<Int>

    @Query("SELECT * FROM alert WHERE is_active = 1 ORDER BY level ASC, created_at DESC")
    fun getActiveAlerts(): Flow<List<AlertEntity>>
}
```

**Componentes modificados ‚Äî Especificaciones:**

#### Modificaci√≥n #1 ‚Äî `SessionExerciseForProgression` (agregar `moduleCode`)

El DTO ya tiene `moduleCode: String` desde HU-10. No se requiere modificaci√≥n adicional.

#### Modificaci√≥n #2 ‚Äî `SessionDao` (queries nuevas)

```kotlin
@Query("SELECT module_version_id FROM session WHERE id = :sessionId")
suspend fun getModuleVersionIdBySessionId(sessionId: Long): Long

@Query("SELECT deload_id FROM session WHERE id = :sessionId")
suspend fun getDeloadIdBySessionId(sessionId: Long): Long?
```

#### Modificaci√≥n #3 ‚Äî `PlanAssignmentDao` (queries nuevas)

```kotlin
@Query("SELECT COUNT(*) FROM plan_assignment WHERE module_version_id = :moduleVersionId")
suspend fun countExercisesForModuleVersion(moduleVersionId: Long): Int

@Query(
    """
    SELECT COUNT(DISTINCT pa.exercise_id)
    FROM plan_assignment pa
    LEFT JOIN exercise_progression ep ON pa.exercise_id = ep.exercise_id
    LEFT JOIN session_exercise se ON pa.exercise_id = se.exercise_id
        AND se.session_id = :sessionId
    WHERE pa.module_version_id = :moduleVersionId
    AND (ep.status = 'IN_PLATEAU' OR se.progression_classification = 'REGRESSION')
    """,
)
suspend fun countAffectedForDeload(moduleVersionId: Long, sessionId: Long): Int
```

#### Modificaci√≥n #4 ‚Äî `evaluateProgression()` en `SessionRepositoryImpl`

Cambio de firma: `private suspend fun evaluateProgression(sessionId: Long)` ‚Üí `private suspend fun evaluateProgression(sessionId: Long, moduleVersionId: Long, isDeloadSession: Boolean)`

Extensi√≥n del loop existente (despu√©s de HU-11, antes del `exerciseProgressionDao.update()`):

```kotlin
private suspend fun evaluateProgression(
    sessionId: Long,
    moduleVersionId: Long,
    isDeloadSession: Boolean,
) {
    val exercises = sessionExerciseDao.getSessionExercisesForProgression(sessionId)
    val today = LocalDate.now().toString()

    // HU-12: Accumulators for module-level analysis
    var regressionCount = 0
    var exercisesWithRecords = 0

    for (exercise in exercises) {
        // === Existing HU-10 code: fetch sets, build currentData/previousData, classify ===
        // === Existing HU-11 code: prescribe load ===

        // HU-12 Step 5c: Collect classification for module-level analysis (CA-12.04, CA-12.05)
        if (classification != null) {
            exercisesWithRecords++
            if (classification == ProgressionClassification.REGRESSION) regressionCount++
        }

        // HU-12 Step 5d: Plateau alert management (CA-12.09, CA-12.06)
        // Guarded by deload: IN_DELOAD guard in resolveNewProgressionState() prevents
        // status/counter changes during deload, so no plateau transitions occur.
        val previousStatus = currentProgression.status
        if (previousStatus != "IN_PLATEAU" && newStatus == "IN_PLATEAU") {
            if (!alertDao.existsActiveByExercise(exercise.exerciseId, "PLATEAU")) {
                alertDao.insert(
                    AlertEntity(
                        type = "PLATEAU",
                        level = "HIGH_ALERT",
                        exerciseId = exercise.exerciseId,
                        message = "3 sesiones sin progresi√≥n",
                        isActive = 1,
                        createdAt = today,
                    ),
                )
            }
        } else if (previousStatus == "IN_PLATEAU" && newStatus != "IN_PLATEAU") {
            alertDao.resolveByExerciseAndType(exercise.exerciseId, "PLATEAU", today)
        }

        exerciseProgressionDao.update(
            currentProgression.copy(
                status = newStatus,
                sessionsWithoutProgression = newCounter,
                prescribedLoadKg = prescribedLoadKg,
            ),
        )
    }

    // HU-12 Step 6: Module-level detection (post-loop)
    // DELOAD GUARD: Skip module-level detection during deload sessions (Decision 12)
    if (isDeloadSession) return

    val moduleCode = exercises.firstOrNull()?.moduleCode ?: return

    // CA-12.04, CA-12.05: Module fatigue detection
    val fatigueDetected = ModuleFatigueRule.detectFatigue(regressionCount, exercisesWithRecords)

    // CA-12.20, CA-12.21, CA-12.22: Deload need detection
    val totalExercises = planAssignmentDao.countExercisesForModuleVersion(moduleVersionId)
    val affectedCount = planAssignmentDao.countAffectedForDeload(moduleVersionId, sessionId)
    val deloadNeeded = DeloadNeedRule.needsDeload(affectedCount, totalExercises, fatigueDetected)

    if (deloadNeeded) {
        // CA-12.20, CA-12.21, CA-12.23, CA-12.24
        if (!alertDao.existsActiveByModule(moduleCode, "MODULE_REQUIRES_DELOAD")) {
            alertDao.insert(
                AlertEntity(
                    type = "MODULE_REQUIRES_DELOAD",
                    level = "HIGH_ALERT",
                    moduleCode = moduleCode,
                    message = "‚â•50% ejercicios en meseta/regresi√≥n",
                    isActive = 1,
                    createdAt = today,
                ),
            )
        }
    } else {
        alertDao.resolveByModuleAndType(moduleCode, "MODULE_REQUIRES_DELOAD", today)
    }
}
```

Cambio en `closeSession()` que invoca `evaluateProgression()`:

```kotlin
// Before (HU-10):
evaluateProgression(sessionId)

// After (HU-12):
val moduleVersionId = sessionDao.getModuleVersionIdBySessionId(sessionId)
val deloadId = sessionDao.getDeloadIdBySessionId(sessionId)
evaluateProgression(sessionId, moduleVersionId, isDeloadSession = deloadId != null)
```

#### Modificaci√≥n #5 ‚Äî `TensionDatabase` (versi√≥n + entity + DAO)

```kotlin
// entities: agregar AlertEntity::class
// version: 4 ‚Üí 5
// agregar: abstract fun alertDao(): AlertDao
```

#### Modificaci√≥n #6 ‚Äî `DatabaseModule` (provider)

```kotlin
@Provides
fun provideAlertDao(database: TensionDatabase): AlertDao {
    return database.alertDao()
}
```

**Hitos de Implementaci√≥n:**

| # | Entregable | Archivos | CAs |
|---|---|---|---|
| 1 | Infraestructura de alertas ‚Äî `AlertEntity` + `AlertDao` + migraci√≥n DB v4‚Üív5 + DI | `AlertEntity.kt`, `AlertDao.kt`, `TensionDatabase.kt`, `DatabaseModule.kt` | CA-12.06, CA-12.24 |
| 2 | Reglas write-time ‚Äî `ModuleFatigueRule` + `DeloadNeedRule` + tests unitarios | `ModuleFatigueRule.kt`, `DeloadNeedRule.kt`, `ModuleFatigueRuleTest.kt`, `DeloadNeedRuleTest.kt` | CA-12.04, CA-12.05, CA-12.20, CA-12.21, CA-12.22 |
| 3 | Reglas read-time ‚Äî `PlateauCausalAnalysisRule` + `CorrectiveActionRule` + enums + tests | `PlateauCausalAnalysisRule.kt`, `CorrectiveActionRule.kt`, `PlateauCause.kt`, `CorrectiveAction.kt`, `PlateauCausalAnalysisRuleTest.kt`, `CorrectiveActionRuleTest.kt` | CA-12.10, CA-12.11, CA-12.12, CA-12.15, CA-12.16, CA-12.17 |
| 4 | Queries de agregaci√≥n ‚Äî `SessionDao`, `PlanAssignmentDao` | `SessionDao.kt`, `PlanAssignmentDao.kt` | CA-12.22, Decisi√≥n 12 (deload guard) |
| 5 | Integraci√≥n ‚Äî extender `evaluateProgression()` con alertas per-ejercicio + detecci√≥n m√≥dulo-nivel | `SessionRepositoryImpl.kt` | CA-12.09, CA-12.13, CA-12.19, CA-12.23 |

### Validaci√≥n de Impacto

**C√≥digo real verificado (paso 1.5):**

- `ProgressionClassificationRule.kt`: `classify()` ya implementa CA-12.01 (regresi√≥n por reps), CA-12.02 (por RIR), CA-12.03 (por carga) mediante `classifyStandard()`, `classifyBodyweight()`, `classifyIsometric()`. `resolveNewProgressionState()` ya implementa CA-12.07 (meseta a 3) y CA-12.14 (actualizaci√≥n de estado) con constante `PLATEAU_THRESHOLD = 3`.
- `DoubleThresholdRule.kt`: No afectado por HU-12. Funciona independientemente.
- `ExerciseProgressionEntity.kt`: Campo `sessionsWithoutProgression` ya existe y se mantiene por HU-10. HU-12 lo consume sin modificar (read-time para recomendaciones correctivas).
- `SessionRepositoryImpl.evaluateProgression()`: El loop actual genera `classification` (per-ejercicio), `newStatus` y `newCounter` ‚Äî exactamente los datos que HU-12 consume para acumuladores de m√≥dulo y alertas de meseta.
- `SessionExerciseDao.getSessionExercisesForProgression()`: Devuelve `SessionExerciseForProgression` con `moduleCode`, `isBodyweight`, `isIsometric`. Suficiente para el loop HU-12.
- `SessionDao`: `ActiveSessionInfo` NO tiene `moduleVersionId`. Se agrega `getModuleVersionIdBySessionId()` para obtenerlo.
- `TensionDatabase`: Versi√≥n actual = 4. `fallbackToDestructiveMigration()` configurado. No existe `AlertEntity` ni `alertDao()`.
- `DatabaseModule`: No tiene `provideAlertDao()`.
- `PlanAssignmentDao`: No tiene queries de conteo por module_version.

**An√°lisis de dependencias:**

- HU-12 depende de: HU-10 (clasificaci√≥n, estados, contadores), HU-11 (carga prescrita ‚Äî no modificada).
- HU-12 alimenta: HU-13 (E5 ‚Äî se√±ales de regresi√≥n/descarga), HU-14 (protocolo de descarga ‚Äî lee `MODULE_REQUIRES_DELOAD`), HU-17 (H1/H2 ‚Äî lee alertas activas, an√°lisis causal, acciones correctivas).

**Impacto en performance:**

- 4 reglas puras: operaciones O(1) o O(n) con n ‚â§ 11 ejercicios. Despreciable.
- 2 INSERTs condicionales + 2 UPDATEs condicionales en `alert`: m√°ximo 2 alertas por sesi√≥n. Despreciable.
- `countAffectedForDeload`: JOIN triple sobre m√°ximo 11 filas. Despreciable.
- Todo dentro de `database.withTransaction {}`: atomicidad garantizada.

### Notas T√©cnicas

**Nota 1 ‚Äî CA-12.06 (registro de detecciones) se resuelve por la tabla `alert`.**

Los CAs de registro (CA-12.06, CA-12.24) son cubiertos por la inserci√≥n de alertas en la tabla `alert`. La alerta persiste la detecci√≥n vinculada a la sesi√≥n (fecha de creaci√≥n), al ejercicio o m√≥dulo afectado, y queda disponible para consulta futura. No se requiere una tabla de "detecciones" separada.

**Nota 2 ‚Äî CA-12.09 y CA-12.13 (se√±ales visuales) son responsabilidad de HU-17 (H1/H2).**

HU-12 produce los datos (alertas en tabla `alert`); HU-17 los consume y aplica las se√±ales visuales diferenciadas (colores, iconograf√≠a, RNF05). La alerta `PLATEAU` tiene `level = "HIGH_ALERT"`, que H1 renderizar√° con el estilo visual correspondiente. CA-12.13 se cubre transitivamente: HU-12 provee el tipo + nivel, HU-17 aplica la diferenciaci√≥n visual.

**Nota 3 ‚Äî CA-12.19 (vinculaci√≥n alerta + recomendaci√≥n) se resuelve en H2.**

La pantalla H2 (Detalle de Alerta) de HU-17 leer√° la alerta PLATEAU, computar√° el an√°lisis causal via `PlateauCausalAnalysisRule` y las acciones correctivas via `CorrectiveActionRule`, y los presentar√° juntos. HU-12 provee ambas reglas + la alerta persistida; HU-17 orquesta la presentaci√≥n conjunta.

**Nota 4 ‚Äî Resoluci√≥n autom√°tica de `MODULE_REQUIRES_DELOAD` tiene dos v√≠as.**

V√≠a 1 (HU-12): Si en una sesi√≥n posterior el m√≥dulo ya no cumple el umbral ‚â•50%, la alerta se resuelve autom√°ticamente en `evaluateProgression()`. V√≠a 2 (HU-14): Cuando el ejecutante activa el protocolo de descarga, HU-14 resolver√° expl√≠citamente la alerta como parte del flujo de activaci√≥n. Ambas v√≠as son complementarias.

**Nota 5 ‚Äî La detecci√≥n de estancamiento grupal (CA-12.12) requiere query de `exercise_muscle_zone`.**

Para determinar si hay estancamiento grupal, el consumidor read-time (H2 en HU-17) necesitar√°: (a) obtener las zonas musculares del ejercicio en meseta, (b) consultar si otros ejercicios del mismo `muscle_group` tambi√©n est√°n en `IN_PLATEAU` o `REGRESSION`. Esta query la implementar√° el Repository que sirve H2. La regla `PlateauCausalAnalysisRule` recibe el resultado como boolean `isGroupStagnant`.

**Nota 6 ‚Äî Se√±ales visuales diferenciadas (CA-12.13, RNF05) y orden de prioridad.**

`alert.level` distingue severidades: `CRISIS` > `HIGH_ALERT` > `MEDIUM_ALERT`. Las alertas de HU-12 son todas `HIGH_ALERT`. La diferenciaci√≥n por color/icono seg√∫n `level` es responsabilidad de HU-17 (H1/H2). HU-12 solo garantiza que el campo `level` est√© correctamente asignado.

**Nota 7 ‚Äî La alerta de fatiga acumulada del m√≥dulo (CA-12.04) no tiene tipo propio.**

La fatiga acumulada del m√≥dulo se detecta (CA-12.04) y se usa como input para `DeloadNeedRule` (CA-12.21). Si hay fatiga ‚Üí autom√°ticamente se marca `MODULE_REQUIRES_DELOAD`. No se crea una alerta separada de tipo "FATIGA" porque el Modelo de Datos ¬ß3.16 no define ese tipo, y funcionalmente es un escalamiento directo a "requiere descarga".

**Nota 8 ‚Äî Guardia de descarga: sesiones de deload no generan alertas de m√≥dulo (Auditor√≠a).**

Durante la descarga, las cargas se reducen al 60% (MDS R5), lo que produce regresiones naturales en los datos crudos. Si no se guarda esta distinci√≥n, `ModuleFatigueRule` detectar√≠a fatiga falsa y `DeloadNeedRule` emitir√≠a `MODULE_REQUIRES_DELOAD` durante una descarga activa ‚Äî resultado parad√≥jico. La guardia se implementa con `session.deload_id != null` para omitir el paso 6. A nivel per-ejercicio (paso 5d), `resolveNewProgressionState()` de HU-10 ya tiene una guardia `IN_DELOAD` que impide transiciones de estado/contador, por lo que no se generar√°n alertas PLATEAU falsas durante descarga.

**Nota 9 ‚Äî Los nombres de reglas HU-10 anticip√≥ no aplican en la estructura consolidada (Auditor√≠a).**

HU-10 Nota T√©cnica 2 anticip√≥ `RegressionDetectionRule` y `PlateauDetectionRule` como futuros archivos en `domain/rules/`. En la estructura consolidada de HU-12, la detecci√≥n de regresi√≥n ya est√° resuelta por `ProgressionClassificationRule.classify()` (HU-10), y el an√°lisis de meseta se divide en dos responsabilidades distintas (`PlateauCausalAnalysisRule` para an√°lisis causal, `CorrectiveActionRule` para acciones correctivas). La fatiga de m√≥dulo y necesidad de descarga se resuelven con `ModuleFatigueRule` y `DeloadNeedRule`. No se crean reglas con los nombres originalmente anticipados.

**Nota 10 ‚Äî RF29 define regresi√≥n per-serie pero la implementaci√≥n usa criterio agregado (Auditor√≠a).**

RF29 establece: "las repeticiones caen en ‚â• 2 de las 4 series". HU-10 implementa un criterio agregado (`totalReps < previous ‚Üí REGRESSION`). CA-12.01 hereda este criterio por reutilizaci√≥n. Discrepancia aceptable para MVP: si totalReps baja, al menos 1 serie baj√≥; el edge case donde series individuales cambian pero el total se mantiene es at√≠pico en entrenamiento real. Un refinamiento futuro podr√≠a agregar l√≥gica per-serie, pero no es necesario para la primera iteraci√≥n.

### Referencias y Validaci√≥n

**Documentaci√≥n consultada:**

- Manifiesto de Dominio Sist√©mico ¬ß6-A ‚Äî Reglas R3 (Detecci√≥n de Meseta), R4 (Regresi√≥n y Fatiga Acumulada)
- Modelo de Datos ¬ß3.13 (`exercise_progression`), ¬ß3.11 (`session_exercise`), ¬ß3.16 (`alert`), ¬ß3.15 (`deload`)
- ADR-06 ‚Äî Motor de reglas Kotlin puro en `domain/rules/`
- Arquitectura T√©cnica ¬ß5.2 ‚Äî Naming `{Nombre}Rule`
- Wireframes E5, B1, H1, H2
- Mapa de Navegaci√≥n ¬ß4 ‚Äî HU-12 outputs en E5/H1/H2
- Requerimientos ‚Äî RF29, RF30, RF34, RF35, RF36, RF37, RNF05

**Historias relacionadas:**

- HU-10: Establece `evaluateProgression()`, `ProgressionClassificationRule`, estados de progresi√≥n, contadores ‚Äî todo reutilizado por HU-12
- HU-11: Establece prescripci√≥n de carga en el mismo loop ‚Äî no afectada por HU-12
- HU-13: Consume se√±ales de regresi√≥n/descarga en E5
- HU-14: Consume alerta `MODULE_REQUIRES_DELOAD` para activar protocolo de descarga
- HU-17: Consume toda la infraestructura de alertas (`AlertEntity`, `AlertDao`) y las reglas read-time

### Verificaci√≥n Cruzada de CAs

| CA | Estado | Mecanismo | Implementado en |
|---|---|---|---|
| CA-12.01 | ‚úÖ Ya cubierto | `ProgressionClassificationRule.classifyStandard()` ‚Üí `REGRESSION` por reps | HU-10 |
| CA-12.02 | ‚úÖ Ya cubierto | `ProgressionClassificationRule.classifyStandard()` ‚Üí `REGRESSION` por RIR | HU-10 |
| CA-12.03 | ‚úÖ Ya cubierto | `ProgressionClassificationRule.classifyStandard()` ‚Üí `REGRESSION` por carga | HU-10 |
| CA-12.04 | üî® Por implementar | `ModuleFatigueRule.detectFatigue()` ‚Äî acumuladores post-loop | HU-12 (Rule + Repository) |
| CA-12.05 | üî® Por implementar | Denominador = `exercisesWithRecords` (no prescritos) | HU-12 (Rule) |
| CA-12.06 | üî® Por implementar | `alertDao.insert()` ‚Äî alerta PLATEAU o MODULE_REQUIRES_DELOAD | HU-12 (Repository) |
| CA-12.07 | ‚úÖ Ya cubierto | `resolveNewProgressionState()` ‚Üí `counter >= 3 ‚Üí IN_PLATEAU` | HU-10 |
| CA-12.08 | ‚úÖ Ya cubierto | Dise√±o inherente ‚Äî `sessionsWithoutProgression` del ejercicio | HU-10 |
| CA-12.09 | üî® Por implementar | Insert alerta PLATEAU al transicionar a `IN_PLATEAU` | HU-12 (Repository) |
| CA-12.10 | üî® Por implementar | `PlateauCausalAnalysisRule.analyze()` ‚Üí `LOW_RIR_LIMIT` | HU-12 (Rule) |
| CA-12.11 | üî® Por implementar | `PlateauCausalAnalysisRule.analyze()` ‚Üí `HIGH_RIR_CONSERVATIVE` | HU-12 (Rule) |
| CA-12.12 | üî® Por implementar | `PlateauCausalAnalysisRule.analyze()` ‚Üí `GROUP_STAGNATION` | HU-12 (Rule) |
| CA-12.13 | üî® Parcial HU-12 + HU-17 | `alert.level = "HIGH_ALERT"` (HU-12) + renderizado visual (HU-17) | HU-12 (Rule) + HU-17 (UI) |
| CA-12.14 | ‚úÖ Ya cubierto | `resolveNewProgressionState()` ‚Üí `status = IN_PLATEAU` | HU-10 |
| CA-12.15 | üî® Por implementar | `CorrectiveActionRule.recommend(4+)` ‚Üí `MICRO_INCREMENT_OR_EXTEND_REPS` | HU-12 (Rule) |
| CA-12.16 | üî® Por implementar | `CorrectiveActionRule.recommend(6+)` ‚Üí `ROTATE_VERSION` | HU-12 (Rule) |
| CA-12.17 | üî® Por implementar | Retorno acumulativo de `recommend()` ‚Äî ambas acciones si ‚â•6 | HU-12 (Rule) |
| CA-12.18 | ‚úÖ Ya cubierto | Dise√±o inherente ‚Äî alertas y recomendaciones no alteran flujos | ‚Äî |
| CA-12.19 | üî® Parcial HU-12 + HU-17 | Reglas proveen datos; H2 los presenta juntos | HU-12 (Rules) + HU-17 (UI) |
| CA-12.20 | üî® Por implementar | `DeloadNeedRule.needsDeload()` ‚Äî umbral ‚â•50% meseta/regresi√≥n | HU-12 (Rule + Repository) |
| CA-12.21 | üî® Por implementar | `DeloadNeedRule.needsDeload(fatigueDetected = true)` ‚Üí `true` | HU-12 (Rule) |
| CA-12.22 | üî® Por implementar | `countExercisesForModuleVersion()` ‚Äî denominador sobre prescritos | HU-12 (DAO) |
| CA-12.23 | üî® Por implementar | `alert.type = "MODULE_REQUIRES_DELOAD"` ‚Äî se√±al informativa | HU-12 (Repository) |
| CA-12.24 | üî® Por implementar | `alertDao.insert()` con `moduleCode`, `createdAt` | HU-12 (Repository) |

**Validado por:** esteban.colorado | **Fecha:** 2026-02-16 | **Enfoque:** Exploratorio

### Auditor√≠a Post-An√°lisis

**Fecha:** 2026-02-16

**Documentaci√≥n auditada:** MDS ¬ß6-A (R1-R7), Modelo de Datos (¬ß3.10-3.16), ADR (01-18), Arquitectura T√©cnica (¬ß2.5, ¬ß5.2), Requerimientos (RF29-RF37, RNF05, RNF29, RNF30), Mapa de Historias de Usuario, 18 HUs (HU-01 a HU-18).

**C√≥digo auditado:** `ProgressionClassificationRule.kt`, `DoubleThresholdRule.kt`, `SessionRepositoryImpl.kt` (`evaluateProgression()`, `closeSession()`), `SessionDao.kt`, `SessionExerciseDao.kt`, `PlanAssignmentDao.kt`, `ExerciseProgressionDao.kt`, `ExerciseProgressionEntity.kt`, `SessionEntity.kt`, `ModuleEntity.kt`, `TensionDatabase.kt`, `DatabaseModule.kt`.

**Hallazgos y correcciones aplicadas:**

| # | Severidad | Hallazgo | Correcci√≥n |
| --- | --- | --- | --- |
| 1 | CR√çTICO | Sesiones de descarga (`session.deload_id != null`) producir√≠an falsos positivos en `ModuleFatigueRule`/`DeloadNeedRule` porque las cargas al 60% generan regresiones esperadas | Agregada Decisi√≥n 12 (guardia de descarga), `isDeloadSession` como par√°metro de `evaluateProgression()`, `getDeloadIdBySessionId()` en `SessionDao`, `if (isDeloadSession) return` antes del paso 6 |
| 2 | MEDIO | CA-13.05 (E5 "Considerar descarga") no tiene ruta de derivaci√≥n documentada desde HU-12 | Agregada Decisi√≥n 13 con la ruta de derivaci√≥n: `REGRESSION` + alerta activa `MODULE_REQUIRES_DELOAD`. Responsabilidad de implementaci√≥n de HU-13 |
| 3 | BAJO | HU-10 anticip√≥ nombres `RegressionDetectionRule` y `PlateauDetectionRule` que no se crearon | Agregada Nota 9 documentando la divergencia y justificaci√≥n |
| 4 | BAJO | RF29 define regresi√≥n per-serie pero HU-10/HU-12 usan criterio agregado | Agregada Nota 10 documentando la discrepancia aceptable para MVP |
| 5 | VERIFICADO | Modelo de Datos ¬ß3.16 `alert.level` CHECK values (`CRISIS`, `HIGH_ALERT`, `MEDIUM_ALERT`) alineados con el an√°lisis | Sin correcci√≥n ‚Äî ya correcto |
| 6 | VERIFICADO | ADR-06 naming `{Nombre}Rule` alineado con las 4 reglas propuestas | Sin correcci√≥n ‚Äî ya correcto |
| 7 | VERIFICADO | `SessionEntity.deloadId` nullable ya existe en el c√≥digo ‚Äî disponible para guardia | Sin correcci√≥n ‚Äî dato confirmado |
| 8 | VERIFICADO | `exercise_progression.sessions_without_progression` no tiene tope (sigue incrementando a 4, 5, 6...) compatible con `CorrectiveActionRule` thresholds | Sin correcci√≥n ‚Äî ya correcto |
---

## Refinamiento T√©cnico (Developer)

<!-- ============================================================================ -->
<!-- SECCI√ìN AGREGADA POR: Workflow refinamiento-tecnico                         -->
<!-- ETAPA: Refinamiento T√©cnico                                                  -->
<!-- RESPONSABLE: Developer                                                       -->
<!-- BASE: An√°lisis Arquitect√≥nico (Arquitecto) - Ver secci√≥n arriba             -->
<!-- FECHA: 2026-02-16                                                            -->
<!-- ESTADO: Refinado (Developer) - Basado en An√°lisis Arquitect√≥nico             -->
<!-- ============================================================================ -->

### Consideraciones Generales

**Basado en an√°lisis arquitect√≥nico:**
An√°lisis Arquitect√≥nico de HU-12 con 13 decisiones de dise√±o, 5 hitos de implementaci√≥n, 13 componentes (8 nuevos + 5 modificados). Hallazgos principales: (1) HU-12 es l√≥gica pura de backend ‚Äî no tiene pantalla propia (E5/H1/H2 consumen datos via HU-13/HU-17). (2) 7 de los 24 CAs ya est√°n cubiertos por HU-10 ‚Äî HU-12 consume sin reimplementar. (3) 4 reglas puras nuevas separadas en write-time (`ModuleFatigueRule`, `DeloadNeedRule`) y read-time (`PlateauCausalAnalysisRule`, `CorrectiveActionRule`). (4) Establece infraestructura de alertas (`AlertEntity` + `AlertDao`) que HU-17 reutilizar√° ‚Äî solo escribe 2 de 7 tipos (`PLATEAU`, `MODULE_REQUIRES_DELOAD`). (5) Evaluaci√≥n post-loop a nivel de m√≥dulo: fatiga acumulada + necesidad de descarga. (6) Guardia de descarga: `session.deload_id != null` omite paso 6 para evitar falsos positivos (Decisi√≥n 12). (7) Denominadores diferentes: fatiga ‚Üí ejercicios con registros; descarga ‚Üí prescritos para la versi√≥n. (8) Deduplicaci√≥n + resoluci√≥n autom√°tica de alertas. (9) `moduleVersionId` se obtiene de `session.module_version_id`. (10) Los mensajes de alerta son gen√©ricos; nombres se resuelven por JOIN al leer. (11) An√°lisis causal y acciones correctivas son read-time ‚Äî no se persisten. (12) La cumulatividad de acciones correctivas (sesi√≥n 6 = ambas) es decisi√≥n de dise√±o de CA-12.17. (13) La fatiga acumulada del m√≥dulo (CA-12.04) escala directamente a `MODULE_REQUIRES_DELOAD` ‚Äî no tiene tipo de alerta propio.

**Nivel de complejidad:**
MEDIA-ALTA ‚Äî HU-12 toca 13 archivos (8 nuevos + 5 modificados) con l√≥gica distribuida en 5 bloques funcionales. Las 4 reglas puras son individualmente simples (O(1)/O(n)), pero la integraci√≥n en `evaluateProgression()` es compleja: acumuladores intra-loop + evaluaci√≥n post-loop + deduplicaci√≥n/resoluci√≥n de alertas + guardia de descarga. La migraci√≥n de BD (v4‚Üív5) agrega una nueva tabla con 4 √≠ndices y 2 FKs. El total de tests unitarios estimados es ~26 escenarios. No hay componentes UI.

**Riesgos t√©cnicos conocidos:**

1. **Migraci√≥n destructiva (v4‚Üív5):** `TensionDatabase` usa `fallbackToDestructiveMigration()`. Al subir la versi√≥n de 4 a 5 con `AlertEntity`, Room destruir√° la BD existente y la recrear√°. Aceptable para MVP pre-producci√≥n ‚Äî no hay datos de usuario reales. En producci√≥n se necesitar√° migraci√≥n incremental.
2. **`countAffectedForDeload` query con triple LEFT JOIN:** La query combina `plan_assignment + exercise_progression + session_exercise` para contar ejercicios afectados. Con m√°ximo 11 ejercicios por versi√≥n, el costo es despreciable. Sin embargo, la l√≥gica de la query es sutilmente compleja ‚Äî un ejercicio cuenta como "afectado" si est√° `IN_PLATEAU` en `exercise_progression` OR si tiene `REGRESSION` en `session_exercise` de esta sesi√≥n.
3. **Race condition te√≥rica: resoluci√≥n de alerta vs creaci√≥n simult√°nea.** Si `evaluateProgression()` resuelve una alerta MODULE_REQUIRES_DELOAD (m√≥dulo ya no cumple umbral) y en la misma transacci√≥n la recrear√≠a (fatiga detectada), la l√≥gica secuencial del c√≥digo evita esto: primero eval√∫a, luego act√∫a condicionalmente. La guardia `existsActiveByModule` previene duplicados.
4. **Guardia de descarga pre-HU-14:** `session.deload_id` es siempre `null` hasta que HU-14 cree DeloadEntity. La guardia `isDeloadSession = deloadId != null` es inerte (siempre false) hasta HU-14 ‚Äî dise√±o forward-compatible.

**Patrones y convenciones del equipo (establecidos en HU-01‚ÄîHU-11):**

- C√≥digo fuente en ingl√©s, UI y datos de dominio en espa√±ol (Arquitectura T√©cnica ¬ß5.1)
- Naming: `{Nombre}Rule` para reglas del motor (¬ß5.2) ‚Äî `ModuleFatigueRule`, `DeloadNeedRule`, `PlateauCausalAnalysisRule`, `CorrectiveActionRule`
- `object` singleton para reglas puras (patr√≥n `ProgressionClassificationRule`, `DoubleThresholdRule`)
- `@Entity` con `@ForeignKey`, `@Index` ‚Äî patr√≥n `SessionEntity`, `ExerciseProgressionEntity`
- `@Dao` interface con `@Insert`, `@Query`, `@Update` ‚Äî patr√≥n `SessionDao`, `ExerciseProgressionDao`
- `exerciseProgressionDao.update(currentProgression.copy(...))` ‚Äî extend el `copy()` (HU-10/HU-11)
- `database.withTransaction {}` para atomicidad ‚Äî patr√≥n `closeSession()` (HU-09)
- Constantes como `const val` dentro del `object` (patr√≥n `PLATEAU_THRESHOLD = 3`)
- Tests: JUnit 4, helper factories `sessionData(vararg sets)` + `set(w, r, rir)`, sin mocks
- `fallbackToDestructiveMigration()` para migraci√≥n ‚Äî patr√≥n actual en `DatabaseModule`
- Hilt `@Provides` para nuevos DAOs ‚Äî patr√≥n `provideExerciseSetDao()` en `DatabaseModule`

**Dependencias nuevas a instalar:**
Ninguna.

**Estrategia de testing:**
JUnit 4 (sin MockK ‚Äî funciones puras) | 4 archivos de test: `ModuleFatigueRuleTest` (~5 escenarios), `DeloadNeedRuleTest` (~7 escenarios), `PlateauCausalAnalysisRuleTest` (~7 escenarios), `CorrectiveActionRuleTest` (~7 escenarios). Total: ~26 escenarios. Cubren umbrales de 50%, combinaciones de fatiga+meseta+regresi√≥n, an√°lisis causal por RIR, y escalonamiento de acciones correctivas a sesiones 4/6.

### Historias Relacionadas Consultadas

**Implementaciones similares analizadas:**

- HU-10 (ProgressionClassificationRule) ‚Äî Implement√≥ `evaluateProgression()` con loop per-ejercicio, `resolveNewProgressionState()`, estados IN_PLATEAU/IN_PROGRESSION/IN_DELOAD, y contador `sessionsWithoutProgression`. HU-12 consume TODO esto: el `classification` del loop alimenta los acumuladores de regresi√≥n; `newStatus` informa las transiciones de meseta para alertas; el contador alimenta `CorrectiveActionRule`. Los 7 CAs ya cubiertos provienen de HU-10.
- HU-11 (DoubleThresholdRule) ‚Äî Implement√≥ prescripci√≥n de carga en el mismo loop (`evaluateProgression()`, paso 5b). HU-12 se integra DESPU√âS de HU-11: el paso 5c (acumuladores) y 5d (alertas de meseta) van entre la prescripci√≥n de carga (HU-11) y el `exerciseProgressionDao.update()`. No hay dependencia de datos entre HU-11 y HU-12.
- HU-09 (closeSession) ‚Äî Defini√≥ la transacci√≥n `closeSession()` donde se invoca `evaluateProgression()`. HU-12 modifica la firma de `evaluateProgression()` agregando `moduleVersionId` y `isDeloadSession`, y extiende la invocaci√≥n en `closeSession()` con queries previas a `SessionDao`.
- HU-05 (alert badge placeholder) ‚Äî Implement√≥ `alertCount = 0` y `onNavigateToAlerts = { /* TODO */ }` proactivamente. HU-17 los conectar√° con `AlertDao.countActive()`.

**Patrones de c√≥digo reutilizados:**

- `object` singleton con funciones puras ‚Üí 4 nuevas reglas
- `@Entity` + `@Dao` + `TensionDatabase` + `DatabaseModule` ‚Üí AlertEntity/AlertDao
- Extension del loop `evaluateProgression()` ‚Üí acumuladores + alertas
- `database.withTransaction {}` ‚Üí atomicidad ya garantizada por `closeSession()`
- `LocalDate.now().toString()` ‚Üí patr√≥n para `createdAt`/`resolvedAt` en alertas

**Mejores pr√°cticas aplicadas:**

- Write-time vs read-time: las detecciones se persisten como alertas; el an√°lisis causal y recomendaciones se computan on-demand desde datos inmutables
- Deduplicaci√≥n por `existsActiveByExercise/Module` antes de insertar ‚Äî previene alertas duplicadas
- Resoluci√≥n autom√°tica bidireccional: salir de IN_PLATEAU ‚Üí resolver alerta PLATEAU; m√≥dulo no cumple umbral ‚Üí resolver alerta MODULE_REQUIRES_DELOAD
- Guardia de descarga omite evaluaci√≥n m√≥dulo-nivel durante deload ‚Äî evita falsos positivos

---

## Tareas de Implementaci√≥n (Developer)

### Fase 1: Domain ‚Äî Reglas puras write-time + tests

<!-- Basado en Hito #2 del An√°lisis Arquitect√≥nico -->

#### üì¶ Domain Rules (write-time)

- [ ] **Crear `ModuleFatigueRule`** (AC: 4, 5)
  - [ ] Crear archivo: `domain/rules/ModuleFatigueRule.kt`
  - [ ] Constante: `FATIGUE_THRESHOLD = 0.50`
  - [ ] `fun detectFatigue(regressionCount: Int, exercisesWithRecords: Int): Boolean` ‚Äî guard `exercisesWithRecords == 0` ‚Üí false, luego `regressionCount / exercisesWithRecords >= 0.50`
- [ ] **Test unitario `ModuleFatigueRuleTest`** (~5 escenarios)
  - [ ] Crear archivo: `src/test/java/com/estebancoloradogonzalez/tension/domain/rules/ModuleFatigueRuleTest.kt`
  - [ ] 0 ejercicios con registros ‚Üí `false` (guard)
  - [ ] 5 regresiones de 10 ejercicios ‚Üí `true` (exactamente 50%, CA-12.04)
  - [ ] 4 regresiones de 10 ejercicios ‚Üí `false` (40%, bajo umbral)
  - [ ] 6 regresiones de 10 ejercicios ‚Üí `true` (60%, CA-12.04)
  - [ ] 1 regresi√≥n de 1 ejercicio ‚Üí `true` (100%, sesi√≥n incompleta CA-12.05)
- [ ] **Crear `DeloadNeedRule`** (AC: 20, 21, 22)
  - [ ] Crear archivo: `domain/rules/DeloadNeedRule.kt`
  - [ ] Constante: `DELOAD_THRESHOLD = 0.50`
  - [ ] `fun needsDeload(affectedCount: Int, totalCount: Int, fatigueDetected: Boolean): Boolean` ‚Äî si `fatigueDetected` ‚Üí `true` (CA-12.21); guard `totalCount == 0` ‚Üí false; luego `affectedCount / totalCount >= 0.50` (CA-12.20)
- [ ] **Test unitario `DeloadNeedRuleTest`** (~7 escenarios)
  - [ ] Crear archivo: `src/test/java/com/estebancoloradogonzalez/tension/domain/rules/DeloadNeedRuleTest.kt`
  - [ ] fatiga detectada, 0 afectados ‚Üí `true` (CA-12.21 ‚Äî fatiga prevalece)
  - [ ] fatiga detectada, 100% afectados ‚Üí `true` (ambos criterios)
  - [ ] sin fatiga, 6 de 11 afectados ‚Üí `true` (54.5% ‚â• 50%, CA-12.20)
  - [ ] sin fatiga, 5 de 11 afectados ‚Üí `false` (45.5% < 50%)
  - [ ] sin fatiga, 5 de 9 afectados (m√≥dulo C) ‚Üí `true` (55.6% ‚â• 50%, CA-12.22)
  - [ ] sin fatiga, 0 total ‚Üí `false` (guard)
  - [ ] boundary: sin fatiga, 5 de 10 ‚Üí `true` (exactamente 50%)

### Fase 2: Domain ‚Äî Reglas puras read-time + enums + tests

<!-- Basado en Hito #3 del An√°lisis Arquitect√≥nico -->

#### üì¶ Domain Models (enums)

- [ ] **Crear `PlateauCause`** (AC: 10, 11, 12)
  - [ ] Crear archivo: `domain/model/PlateauCause.kt`
  - [ ] Enum values: `LOW_RIR_LIMIT`, `HIGH_RIR_CONSERVATIVE`, `GROUP_STAGNATION`, `MIXED`
- [ ] **Crear `CorrectiveAction`** (AC: 15, 16)
  - [ ] Crear archivo: `domain/model/CorrectiveAction.kt`
  - [ ] Enum values: `MICRO_INCREMENT_OR_EXTEND_REPS`, `ROTATE_VERSION`

#### üì¶ Domain Rules (read-time)

- [ ] **Crear `PlateauCausalAnalysisRule`** (AC: 10, 11, 12)
  - [ ] Crear archivo: `domain/rules/PlateauCausalAnalysisRule.kt`
  - [ ] Constantes: `LOW_RIR_THRESHOLD = 1.0`, `HIGH_RIR_THRESHOLD = 3.0`
  - [ ] `fun analyze(lastSessionsAvgRir: List<Double>, isGroupStagnant: Boolean): PlateauCause` ‚Äî si `isGroupStagnant` ‚Üí GROUP_STAGNATION (CA-12.12); guard lista vac√≠a ‚Üí MIXED; promedio ‚â§ 1.0 ‚Üí LOW_RIR_LIMIT (CA-12.10); promedio ‚â• 3.0 ‚Üí HIGH_RIR_CONSERVATIVE (CA-12.11); else ‚Üí MIXED
- [ ] **Test unitario `PlateauCausalAnalysisRuleTest`** (~7 escenarios)
  - [ ] Crear archivo: `src/test/java/com/estebancoloradogonzalez/tension/domain/rules/PlateauCausalAnalysisRuleTest.kt`
  - [ ] avgRir [0.5, 0.8, 1.0] ‚Üí `LOW_RIR_LIMIT` (CA-12.10 ‚Äî promedio 0.77)
  - [ ] avgRir [3.5, 4.0, 3.0] ‚Üí `HIGH_RIR_CONSERVATIVE` (CA-12.11 ‚Äî promedio 3.5)
  - [ ] avgRir [1.5, 2.0, 2.5] ‚Üí `MIXED` (promedio 2.0, entre umbrales)
  - [ ] isGroupStagnant = true, cualquier RIR ‚Üí `GROUP_STAGNATION` (CA-12.12 ‚Äî prioridad)
  - [ ] lista vac√≠a ‚Üí `MIXED` (guard)
  - [ ] boundary: avgRir [1.0, 1.0, 1.0] ‚Üí `LOW_RIR_LIMIT` (exactamente 1.0)
  - [ ] boundary: avgRir [3.0, 3.0, 3.0] ‚Üí `HIGH_RIR_CONSERVATIVE` (exactamente 3.0)
- [ ] **Crear `CorrectiveActionRule`** (AC: 15, 16, 17)
  - [ ] Crear archivo: `domain/rules/CorrectiveActionRule.kt`
  - [ ] Constantes: `MICRO_INCREMENT_THRESHOLD = 4`, `ROTATE_VERSION_THRESHOLD = 6`
  - [ ] `fun recommend(sessionsWithoutProgression: Int): List<CorrectiveAction>` ‚Äî < 4 ‚Üí vac√≠a; ‚â• 4 ‚Üí `[MICRO_INCREMENT_OR_EXTEND_REPS]` (CA-12.15); ‚â• 6 ‚Üí `[MICRO_INCREMENT_OR_EXTEND_REPS, ROTATE_VERSION]` (CA-12.16, CA-12.17 acumulativo)
- [ ] **Test unitario `CorrectiveActionRuleTest`** (~7 escenarios)
  - [ ] Crear archivo: `src/test/java/com/estebancoloradogonzalez/tension/domain/rules/CorrectiveActionRuleTest.kt`
  - [ ] counter 0 ‚Üí `[]` (sin recomendaciones)
  - [ ] counter 3 ‚Üí `[]` (justo debajo del umbral, meseta reci√©n detectada)
  - [ ] counter 4 ‚Üí `[MICRO_INCREMENT_OR_EXTEND_REPS]` (CA-12.15 ‚Äî 1¬™ intervenci√≥n)
  - [ ] counter 5 ‚Üí `[MICRO_INCREMENT_OR_EXTEND_REPS]` (mantiene 1¬™ sin 2¬™)
  - [ ] counter 6 ‚Üí `[MICRO_INCREMENT_OR_EXTEND_REPS, ROTATE_VERSION]` (CA-12.16/17 ‚Äî acumulativo)
  - [ ] counter 10 ‚Üí `[MICRO_INCREMENT_OR_EXTEND_REPS, ROTATE_VERSION]` (se mantiene en ‚â• 6)
  - [ ] counter 1 ‚Üí `[]` (progresi√≥n sin meseta)

### Fase 3: Data ‚Äî Infraestructura de alertas (AlertEntity + AlertDao + migraci√≥n)

<!-- Basado en Hito #1 del An√°lisis Arquitect√≥nico -->

#### üì¶ Data Layer (entity + DAO)

- [ ] **Crear `AlertEntity`** (AC: 6, 24)
  - [ ] Crear archivo: `data/local/entity/AlertEntity.kt`
  - [ ] `@Entity(tableName = "alert")` con 10 campos: `id` (PK autoGenerate), `type` (String), `level` (String), `exerciseId` (Long?), `moduleCode` (String?), `muscleGroup` (String?), `message` (String), `isActive` (Int, default 1), `createdAt` (String), `resolvedAt` (String?)
  - [ ] ForeignKeys: `exerciseId ‚Üí exercise(id) RESTRICT`, `moduleCode ‚Üí module(code) RESTRICT`
  - [ ] Indices: `is_active`, `type`, `exercise_id`, `module_code`
- [ ] **Crear `AlertDao`** (AC: 6, 9, 24)
  - [ ] Crear archivo: `data/local/dao/AlertDao.kt`
  - [ ] `insert(alert: AlertEntity): Long`
  - [ ] `existsActiveByExercise(exerciseId: Long, type: String): Boolean` ‚Äî SELECT EXISTS WHERE is_active = 1
  - [ ] `existsActiveByModule(moduleCode: String, type: String): Boolean` ‚Äî SELECT EXISTS WHERE is_active = 1
  - [ ] `resolveByExerciseAndType(exerciseId: Long, type: String, resolvedAt: String)` ‚Äî UPDATE is_active = 0
  - [ ] `resolveByModuleAndType(moduleCode: String, type: String, resolvedAt: String)` ‚Äî UPDATE is_active = 0
  - [ ] `countActive(): Flow<Int>` ‚Äî SELECT COUNT WHERE is_active = 1
  - [ ] `getActiveAlerts(): Flow<List<AlertEntity>>` ‚Äî SELECT WHERE is_active = 1 ORDER BY level, created_at
- [ ] **Modificar `TensionDatabase`** (AC: 6, 24)
  - [ ] Agregar `AlertEntity::class` al array de entities
  - [ ] Subir versi√≥n de 4 a 5
  - [ ] Agregar `abstract fun alertDao(): AlertDao`
  - [ ] Agregar import de `AlertEntity`
- [ ] **Modificar `DatabaseModule`** (AC: 6, 24)
  - [ ] Agregar import de `AlertDao`
  - [ ] Agregar `@Provides fun provideAlertDao(database: TensionDatabase): AlertDao`

### Fase 4: Data ‚Äî Queries de agregaci√≥n

<!-- Basado en Hito #4 del An√°lisis Arquitect√≥nico -->

#### üì¶ Data Layer (queries nuevas)

- [ ] **Modificar `SessionDao`** (AC: 20, Decisi√≥n 12)
  - [ ] Agregar query `getModuleVersionIdBySessionId(sessionId: Long): Long` ‚Äî `SELECT module_version_id FROM session WHERE id = :sessionId`
  - [ ] Agregar query `getDeloadIdBySessionId(sessionId: Long): Long?` ‚Äî `SELECT deload_id FROM session WHERE id = :sessionId`
- [ ] **Modificar `PlanAssignmentDao`** (AC: 22)
  - [ ] Agregar query `countExercisesForModuleVersion(moduleVersionId: Long): Int` ‚Äî `SELECT COUNT(*) FROM plan_assignment WHERE module_version_id = :moduleVersionId`
  - [ ] Agregar query `countAffectedForDeload(moduleVersionId: Long, sessionId: Long): Int` ‚Äî triple LEFT JOIN: `plan_assignment + exercise_progression + session_exercise`, cuenta DISTINCT exercise_id donde `ep.status = 'IN_PLATEAU' OR se.progression_classification = 'REGRESSION'`

### Fase 5: Data ‚Äî Integraci√≥n en evaluateProgression()

<!-- Basado en Hito #5 del An√°lisis Arquitect√≥nico -->

#### üì¶ Repository

- [ ] **Extender `evaluateProgression()` en `SessionRepositoryImpl`** (AC: 4, 5, 6, 9, 20, 21, 23, 24)
  - [ ] Cambiar firma: `evaluateProgression(sessionId: Long)` ‚Üí `evaluateProgression(sessionId: Long, moduleVersionId: Long, isDeloadSession: Boolean)`
  - [ ] Agregar imports: `ModuleFatigueRule`, `DeloadNeedRule`, `AlertEntity`, `ProgressionClassification`, `LocalDate`
  - [ ] Inyectar `AlertDao` en `SessionRepositoryImpl` (agregar a constructor ‚Äî `PlanAssignmentDao` ya est√° inyectado desde HU-09)
  - [ ] Agregar `val today = LocalDate.now().toString()` al inicio
  - [ ] Agregar acumuladores antes del loop: `var regressionCount = 0`, `var exercisesWithRecords = 0`
  - [ ] Paso 5c (dentro del loop, despu√©s de HU-11 paso 5b): Si `classification != null` ‚Üí `exercisesWithRecords++`; si `classification == REGRESSION` ‚Üí `regressionCount++`
  - [ ] Paso 5d (dentro del loop, despu√©s de paso 5c, antes de `exerciseProgressionDao.update()`): Detectar transici√≥n a/desde IN_PLATEAU ‚Äî si `previousStatus != "IN_PLATEAU" && newStatus == "IN_PLATEAU"` ‚Üí `alertDao.insert(PLATEAU alert)` con guardia `existsActiveByExercise`; si `previousStatus == "IN_PLATEAU" && newStatus != "IN_PLATEAU"` ‚Üí `alertDao.resolveByExerciseAndType()`
  - [ ] Paso 6 (post-loop, fuera del for): Guardia `if (isDeloadSession) return` (Decisi√≥n 12). Obtener `moduleCode` de `exercises.firstOrNull()?.moduleCode`. Detectar fatiga: `ModuleFatigueRule.detectFatigue()`. Evaluar necesidad de descarga: `DeloadNeedRule.needsDeload()` con `countExercisesForModuleVersion()` y `countAffectedForDeload()`. Si `deloadNeeded` ‚Üí insertar alerta `MODULE_REQUIRES_DELOAD` (con guardia `existsActiveByModule`); else ‚Üí `resolveByModuleAndType()`.
  - [ ] Modificar `closeSession()`: Agregar queries `getModuleVersionIdBySessionId()` y `getDeloadIdBySessionId()` antes de invocar `evaluateProgression()`. Pasar `moduleVersionId` y `isDeloadSession = deloadId != null` como argumentos.

### Fase N: QA y Deployment

- [ ] **Ejecutar Agente Peer Review** (MANUAL)
- [ ] **Resolver incidentes del Peer Review** (MANUAL, condicional)
- [ ] **Crear Pull Request** (MANUAL)
- [ ] **Ejecutar pipeline deployment DEV** (MANUAL)
- [ ] **Dise√±ar set de pruebas manuales** (MANUAL)
- [ ] **Ejecutar pruebas manuales** (MANUAL)

---

**Notas sobre vinculaci√≥n con Criterios de Aceptaci√≥n:**

**Bloque A ‚Äî Regresi√≥n (CA-12.01 a CA-12.03):**
- CA-12.01 ‚Üí ‚úÖ Ya cubierto por HU-10 (`classifyStandard()` ‚Üí `REGRESSION` por totalReps < previous). Nota: RF29 define criterio per-serie (‚â•2 series); HU-10 usa criterio agregado (totalReps). Discrepancia aceptable para MVP (Nota 10).
- CA-12.02 ‚Üí ‚úÖ Ya cubierto por HU-10 (`classifyStandard()` ‚Üí `REGRESSION` por `rirRise >= 1.5`).
- CA-12.03 ‚Üí ‚úÖ Ya cubierto por HU-10 (`classifyStandard()` ‚Üí `REGRESSION` por `isWeightLower`).

**Bloque B ‚Äî Fatiga Acumulada (CA-12.04 a CA-12.06):**
- CA-12.04 ‚Üí Fase 1 (`ModuleFatigueRule.detectFatigue()` ‚Äî ‚â•50% regresiones en ejercicios con registros) + Fase 5 (acumuladores intra-loop)
- CA-12.05 ‚Üí Fase 1 (`exercisesWithRecords` como denominador ‚Äî solo cuenta ejercicios que tienen `classification != null`) + tests
- CA-12.06 ‚Üí Fase 3 (`alertDao.insert()` ‚Äî persiste detecciones como alertas) + Fase 5 (paso 5d + paso 6)

**Bloque C ‚Äî Meseta (CA-12.07 a CA-12.14):**
- CA-12.07 ‚Üí ‚úÖ Ya cubierto por HU-10 (`PLATEAU_THRESHOLD = 3` en `resolveNewProgressionState()`).
- CA-12.08 ‚Üí ‚úÖ Ya cubierto por HU-10 (dise√±o inherente ‚Äî `sessionsWithoutProgression` es per-exerciseId).
- CA-12.09 ‚Üí Fase 5 paso 5d (insertar alerta PLATEAU al transicionar a `IN_PLATEAU`).
- CA-12.10 ‚Üí Fase 2 (`PlateauCausalAnalysisRule.analyze()` ‚Üí `LOW_RIR_LIMIT` cuando avgRir ‚â§ 1.0).
- CA-12.11 ‚Üí Fase 2 (`PlateauCausalAnalysisRule.analyze()` ‚Üí `HIGH_RIR_CONSERVATIVE` cuando avgRir ‚â• 3.0).
- CA-12.12 ‚Üí Fase 2 (`PlateauCausalAnalysisRule.analyze()` ‚Üí `GROUP_STAGNATION` cuando `isGroupStagnant = true`).
- CA-12.13 ‚Üí Parcial HU-12 + HU-17: HU-12 asigna `level = "HIGH_ALERT"` a alertas PLATEAU; HU-17 aplica diferenciaci√≥n visual por level (colores/iconos, RNF05).
- CA-12.14 ‚Üí ‚úÖ Ya cubierto por HU-10 (`resolveNewProgressionState()` ‚Üí status = `IN_PLATEAU`).

**Bloque D ‚Äî Acciones Correctivas (CA-12.15 a CA-12.19):**
- CA-12.15 ‚Üí Fase 2 (`CorrectiveActionRule.recommend(4+)` ‚Üí `[MICRO_INCREMENT_OR_EXTEND_REPS]`).
- CA-12.16 ‚Üí Fase 2 (`CorrectiveActionRule.recommend(6+)` ‚Üí agrega `ROTATE_VERSION`).
- CA-12.17 ‚Üí Fase 2 (retorno acumulativo ‚Äî `recommend(6)` retorna ambas acciones como lista).
- CA-12.18 ‚Üí ‚úÖ Ya cubierto (dise√±o inherente ‚Äî alertas son datos, no gates).
- CA-12.19 ‚Üí Parcial HU-12 + HU-17: HU-12 provee la alerta PLATEAU + las reglas de an√°lisis causal/acciones; HU-17 orquesta la presentaci√≥n conjunta en H2.

**Bloque E ‚Äî Necesidad de Descarga (CA-12.20 a CA-12.24):**
- CA-12.20 ‚Üí Fase 1 (`DeloadNeedRule.needsDeload()` ‚Äî umbral ‚â•50% meseta/regresi√≥n) + Fase 4 (`countAffectedForDeload` query) + Fase 5 paso 6.
- CA-12.21 ‚Üí Fase 1 (`DeloadNeedRule.needsDeload(fatigueDetected = true)` ‚Üí `true` autom√°ticamente).
- CA-12.22 ‚Üí Fase 4 (`countExercisesForModuleVersion()` ‚Äî denominador sobre total prescritos para la versi√≥n).
- CA-12.23 ‚Üí Fase 5 paso 6 (insertar alerta `MODULE_REQUIRES_DELOAD` ‚Äî se√±al informativa, no bloqueante).
- CA-12.24 ‚Üí Fase 3 + Fase 5 (`alertDao.insert()` con `moduleCode` + `createdAt` ‚Äî persistida para consulta).

<!-- AUDITOR√çA PROFUNDA v2 (2026-02-16):
Auditor√≠a exhaustiva post-refinamiento: archivo por archivo contra toda la documentaci√≥n.

=== SCOPE ===
6 docs arquitectura + 5 docs business + 18 HUs + Mapa de Historias + 14 archivos de c√≥digo fuente verificados.

=== BLOQUE 1: DOCUMENTOS DE ARQUITECTURA (6 archivos) ===

Modelo de Datos ¬ß3.16 (alert):
- 10 columnas verificadas column-by-column vs AlertEntity: id, type, level, exercise_id, module_code, muscle_group, message, is_active, created_at, resolved_at ‚úÖ
- CHECK type IN (7 valores): PLATEAU, LOW_PROGRESSION_RATE, RIR_OUT_OF_RANGE, LOW_ADHERENCE, TONNAGE_DROP, MODULE_INACTIVITY, MODULE_REQUIRES_DELOAD ‚úÖ
- CHECK level IN (3 valores): CRISIS, HIGH_ALERT, MEDIUM_ALERT ‚úÖ
- FKs: exercise_id‚Üíexercise(id) RESTRICT ‚úÖ, module_code‚Üímodule(code) RESTRICT ‚úÖ
- Indices (4): is_active, type, exercise_id, module_code ‚úÖ
- Detalle tipos: PLATEAU‚Üíexercise_id+HIGH_ALERT ‚úÖ, MODULE_REQUIRES_DELOAD‚Üímodule_code+HIGH_ALERT ‚úÖ
- Room no soporta CHECK constraints declarativos ‚Äî aceptable, validaci√≥n por dominio ‚úÖ
- NO hay columna session_id en alert ‚Äî por dise√±o: datos de disparo se recalculan en read-time ‚úÖ

Modelo de Datos ¬ß3.13 (exercise_progression):
- sessions_without_progression INTEGER NOT NULL DEFAULT 0, CHECK >= 0, sin MAX/cap ‚úÖ
- Status CHECK: NO_HISTORY, IN_PROGRESSION, IN_PLATEAU, IN_DELOAD, MASTERED (5 valores) ‚úÖ
- prescribed_load_kg REAL NULL ‚úÖ

Modelo de Datos ¬ß3.10 (session):
- deload_id INTEGER NULL FK‚Üídeload(id) ON DELETE RESTRICT ‚úÖ
- deload_id con √≠ndice ‚úÖ
- SessionEntity tiene columna+√≠ndice pero NO FK (DeloadEntity no existe a√∫n ‚Äî HU-14) ‚úÖ

Modelo de Datos ¬ß3.15 (deload): ACTIVE/COMPLETED, creado por HU-14 ‚Äî no existe en c√≥digo ‚úÖ
Modelo de Datos ¬ß3.11 (session_exercise): progression_classification TEXT NULL ‚úÖ

ADR-06: reglas puras en domain.rules ‚Äî 4 nuevas reglas como object singleton ‚úÖ
ADR-18: JUnit 4, tests en src/test/, sin emulador para reglas ‚úÖ
No hay ADR sobre migraci√≥n destructiva ‚Äî es decisi√≥n de implementaci√≥n, no arquitectura ‚úÖ
No hay ADR sobre deduplicaci√≥n de alertas ‚Äî detalle de dominio ‚úÖ

Arquitectura T√©cnica:
- ¬ß5.1 idioma: c√≥digo en ingl√©s ‚úÖ
- ¬ß5.2 naming: {Nombre}Rule ‚Äî se respeta ‚úÖ
- ¬ß3.2 paquetes: domain/rules/, domain/model/, data/local/entity/, data/local/dao/ ‚Äî correctos ‚úÖ
- Nota: ¬ß5.2 ejemplo dice PlateauDetectionRule pero refinamiento crea PlateauCausalAnalysisRule ‚Äî documentado en Nota 9 ‚úÖ

Especificaci√≥n Visual:
- Se√±ales progresi√≥n (RNF05): ‚Üì Regresi√≥n = #C62828 (light) / #EF9A9A (dark) ‚úÖ
- Estados progresi√≥n: En Meseta = üü° #8D6E00 / #FFD54F ‚úÖ
- Niveles alerta: Crisis üî¥, Alerta alta üü†, Alerta media üü° ‚Äî PLATEAU y MODULE_REQUIRES_DELOAD = HIGH_ALERT = üü† ‚úÖ
- Indicador Descarga: #1565C0 / #64B5F6 ‚úÖ

Mapa de Navegaci√≥n:
- B1: badge alertas activas (HU-17 consume AlertDao.countActive()) ‚úÖ
- E5: "se√±ales de acci√≥n...considerar descarga" ‚Äî HU Indirectas: HU-12 ‚úÖ
- H1: "m√≥dulo requiere descarga (‚â•50% meseta/regresi√≥n)" ‚Äî HU Indirectas: HU-12 ‚úÖ
- H2: "an√°lisis causal (RIR bajo, RIR alto, estancamiento grupal) y recomendaciones escalonadas" ‚Äî HU Indirectas: HU-12 ‚úÖ
- Flujo H: B1 ‚Üí H1 ‚Üí H2 ‚Üí F3/I1 ‚úÖ

Wireframes:
- E5: "‚Üì Regresi√≥n" + "Considerar descarga" visibles en wireframe ‚úÖ
- B1: Badge "üîî N" con conteo alertas activas ‚úÖ
- H1: Centro de Alertas ‚Äî secciones Crisis üî¥ y Alertas üü†üü°, tipos: üü† Meseta detectada, üü† M√≥dulo requiere descarga ‚úÖ
- H2: Detalle de Alerta ‚Äî trigger data, an√°lisis causal, recomendaciones correctivas ‚úÖ
- ORDER BY level ASC: funciona por coincidencia alfab√©tica (CRISIS < HIGH_ALERT < MEDIUM_ALERT) ‚úÖ

=== BLOQUE 2: DOCUMENTOS DE NEGOCIO (5 archivos) ===

Requerimientos:
- RF29: "‚â• 2 de las 4 series" (per-serie). HU-10 usa agregado (totalReps). Discrepancia MVP documentada en Nota 10 ‚úÖ
- RF30: "‚â• 50% de los ejercicios de una misma sesi√≥n" ‚Üí ModuleFatigueRule usa exercisesWithRecords ‚úÖ
- RF34: "3 sesiones consecutivas del mismo ejercicio" ‚Äî SIN restricci√≥n de versi√≥n ‚úÖ
- RF35: "RIR (0-1)" = ‚â§1.0 ‚úÖ, "RIR (3+)" = ‚â•3.0 ‚úÖ, estancamiento grupal ‚úÖ
- RF36: sesi√≥n 4 microincremento o extensi√≥n reps ‚úÖ, sesi√≥n 6 rotar versi√≥n ‚úÖ
- RF37: "‚â• 50% meseta/regresi√≥n O fatiga acumulada (RF30)" ‚Äî OR relaci√≥n implementada ‚úÖ
- RNF05: se√±ales visuales por colores e iconograf√≠a ‚úÖ

Manifiesto de Dominio Sist√©mico:
- R3 meseta: "3 sesiones consecutivas en la misma versi√≥n del m√≥dulo" ‚Äî MDS dice "misma versi√≥n" PERO RF34 no lo dice. Decisi√≥n documentada en HU-10 Nota 9: seguir RF34 + Modelo de Datos (counter global per exercise). Deliberada, no omisi√≥n ‚úÖ
- R3 intervenciones: 1¬™ (sesi√≥n 4) = "verificar t√©cnica y microincremento o extensi√≥n reps" ‚Äî "verificar t√©cnica" omitido por RF36, gap presentaci√≥n-HU-17 (LOW) ‚úÖ
  2¬™ (sesi√≥n 6) = rotar versi√≥n ‚úÖ. 3¬™ (‚â•50% m√≥dulo) = descarga ‚úÖ
- R3 cumulatividad: MDS no dice expl√≠citamente "acumulativo" ‚Äî CA-12.17 interpreta as√≠. Decisi√≥n de dise√±o razonable ‚úÖ
- R4 regresi√≥n: "‚â• 2 series" (MDS) vs "‚â• 2 de las 4 series" (RF29) ‚Äî ambos resueltos por agregado ‚úÖ
- R4 fatiga: "‚â• 50% de los ejercicios de una sesi√≥n" ‚úÖ
- ¬ß5 lifecycle states: Sin Historial, En Progresi√≥n, En Meseta, En Descarga. MASTERED solo en c√≥digo (isom√©tricos) ‚úÖ
- R5 protocolo descarga: carga 60%, no cambiar versi√≥n ‚Äî refuerza guardia de descarga ‚úÖ

Visi√≥n del Producto: Detectar, meseta, fatiga, regresi√≥n, descarga, alertas, an√°lisis causal ‚Äî todo mencionado como core. Valida scope HU-12 ‚úÖ

Plan de Entrenamiento: A=11, B=11, C=9 por versi√≥n (9 versiones verificadas) ‚Äî denominadores DeloadNeedRule ‚úÖ

Diccionario de Ejercicios: 43 ejercicios (15+14+14), pool para versiones. Sin referencia a detecci√≥n ‚úÖ

=== BLOQUE 3: 18 HUs VERIFICADAS ===

Predecesoras (5 confirmadas):
- HU-01: colores sem√°nticos para regresi√≥n/alertas/descarga (L94, L236) ‚Äî weak ‚úÖ
- HU-05: ExerciseProgressionEntity status enums, deload_id, alert badge placeholder alertCount=0 (L98, L120, L335) ‚úÖ
- HU-06: exercise_set data producer (L483, L649) ‚úÖ
- HU-09: closeSession() transacci√≥n + expl√≠cito "HU-12" (L474, L490) ‚úÖ
- HU-10: evaluateProgression loop, REGRESSION, IN_PLATEAU, PLATEAU_THRESHOLD=3, counter, Nota 8/9 boundary (L468, L498, 11+ refs) ‚úÖ

Peers (1 confirmado):
- HU-11: ambos extienden evaluateProgression independientemente, no lee/escribe datos HU-12 (L413) ‚úÖ

Sucesoras (3 confirmadas):
- HU-13: CA-13.05 "Considerar descarga" consume REGRESSION + MODULE_REQUIRES_DELOAD (L41) ‚úÖ
- HU-14: expl√≠cito "(HU-12)" como se√±al de descarga (L26) ‚úÖ
- HU-17: "la misma tabla (alert)" ‚Äî reutiliza AlertEntity/AlertDao para 5 tipos adicionales (L13) ‚úÖ

Sin referencia (9 confirmadas): HU-02, HU-03, HU-04, HU-07, HU-08, HU-15, HU-16, HU-18 ‚úÖ
- HU-15: "meseta" gen√©rica sin coupling funcional ‚úÖ
- HU-16: lee progression_classification de HU-10, no HU-12 ‚úÖ

Consolidaci√≥n Mapa ¬ß5: HU-12 ‚Üê HU-12+14+15+16 originales, 24 CAs ‚úÖ
RF‚ÜíHU: RF29-RF37 ‚Üí HU-12 ‚úÖ. RNF05 ‚Üí HU-12, HU-13, HU-17 ‚úÖ
HU-10 Nota 9: documenta EXPL√çCITAMENTE que counter es global per exercise, NO per version ‚Äî divergencia deliberada de MDS R3 ‚úÖ

=== BLOQUE 4: C√ìDIGO VERIFICADO (14 archivos) ===

Modificados (5):
- SessionRepositoryImpl.kt (392 l√≠neas): evaluateProgression() L314-392 (private, 3‚Üí3 params), closeSession() L297-311 (punto extensi√≥n pre-evaluateProgression). PlanAssignmentDao YA inyectado en constructor L40 ‚úÖ
- TensionDatabase.kt (70 l√≠neas): version=4, entities[14], NO AlertEntity, NO alertDao() ‚úÖ
- DatabaseModule.kt (115 l√≠neas): NO provideAlertDao() ‚Äî agregar ‚úÖ
- SessionDao.kt (57 l√≠neas): NO getModuleVersionIdBySessionId, NO getDeloadIdBySessionId ‚Äî agregar ‚úÖ
- PlanAssignmentDao.kt (70 l√≠neas): NO countExercisesForModuleVersion, NO countAffectedForDeload ‚Äî agregar ‚úÖ

Infraestructura (7):
- SessionEntity.kt (43 l√≠neas): deloadId: Long? = null + Index ‚úÖ, NO FK a DeloadEntity (correcto pre-HU-14) ‚úÖ
- ExerciseProgressionEntity.kt (33 l√≠neas): PK exercise_id, status String, sessionsWithoutProgression Int, prescribedLoadKg Double? ‚úÖ
- ProgressionClassificationRule.kt (136 l√≠neas): classifyStandard REGRESSION 3 causas, resolveNewProgressionState IN_PLATEAU at counter‚â•3, IN_DELOAD/MASTERED guards ‚úÖ
- DoubleThresholdRule.kt (33 l√≠neas): paso 5b ‚Äî no afectado ‚úÖ
- ExerciseProgressionDao.kt (25 l√≠neas): insert/insertIfNotExists/update ‚Äî suficiente ‚úÖ
- ModuleEntity.kt (22 l√≠neas): PK code: String ‚Äî confirma FK AlertEntity‚Üímodule(code) ‚úÖ
- ExerciseEntity.kt (60 l√≠neas): FK module_code‚Üímodule(code), PK id: Long ‚Äî confirma FK AlertEntity‚Üíexercise(id) ‚úÖ

Referencia (2):
- ProgressionClassificationRuleTest.kt (646 l√≠neas): patr√≥n helpers sessionData/set, JUnit 4, assertTrue/assertFalse/assertEquals ‚úÖ
- DoubleThresholdRuleTest.kt (146 l√≠neas): mismo patr√≥n ‚úÖ

API layer:
- SessionRepository.kt (24 l√≠neas): evaluateProgression NO est√° en interface (private) ‚Äî cambio firma es interno ‚úÖ
- RepositoryModule.kt (46 l√≠neas): bindSessionRepository existe ‚Äî Hilt resuelve AlertDao autom√°ticamente ‚úÖ

Nuevos (8 ‚Äî confirmado NO existen): ModuleFatigueRule.kt, DeloadNeedRule.kt, PlateauCausalAnalysisRule.kt, CorrectiveActionRule.kt, PlateauCause.kt, CorrectiveAction.kt, AlertEntity.kt, AlertDao.kt ‚úÖ
Directorios destino: domain/rules/ y domain/model/ existen ‚úÖ, data/local/entity/ y data/local/dao/ existen ‚úÖ

=== BLOQUE 5: VERIFICACI√ìN L√ìGICA (4 reglas + integraci√≥n) ===

ModuleFatigueRule:
- guard exercisesWithRecords==0 ‚Üí false ‚úÖ
- regressionCount.toDouble()/exercisesWithRecords >= 0.50 ‚Äî .toDouble() evita int division ‚úÖ
- 5/10=0.50 ‚Üí true, 4/10=0.40 ‚Üí false, 1/1=1.0 ‚Üí true ‚úÖ

DeloadNeedRule:
- fatigueDetected ‚Üí true (CA-12.21, OR independiente) ‚úÖ
- guard totalCount==0 ‚Üí false ‚úÖ
- affectedCount.toDouble()/totalCount >= 0.50 ‚Äî .toDouble() evita int division ‚úÖ
- 6/11=0.545 ‚Üí true, 5/11=0.454 ‚Üí false, 5/9=0.556 ‚Üí true, 5/10=0.50 ‚Üí true ‚úÖ

PlateauCausalAnalysisRule:
- isGroupStagnant ‚Üí GROUP_STAGNATION (prioridad, CA-12.12) ‚úÖ
- lista vac√≠a ‚Üí MIXED ‚úÖ
- avg ‚â§ 1.0 ‚Üí LOW_RIR_LIMIT (CA-12.10) ‚úÖ
- avg ‚â• 3.0 ‚Üí HIGH_RIR_CONSERVATIVE (CA-12.11) ‚úÖ
- 1.0 < avg < 3.0 ‚Üí MIXED ‚úÖ
- lastSessionsAvgRir.average() ‚Äî List<Double>.average() retorna Double ‚úÖ

CorrectiveActionRule:
- counter < 4 ‚Üí [] ‚úÖ
- counter ‚â• 4 ‚Üí [MICRO_INCREMENT_OR_EXTEND_REPS] (CA-12.15) ‚úÖ
- counter ‚â• 6 ‚Üí [MICRO_INCREMENT_OR_EXTEND_REPS, ROTATE_VERSION] (CA-12.16/17, acumulativo) ‚úÖ
- Usa Int comparison, no division ‚úÖ

Integraci√≥n evaluateProgression():
- Acumuladores regressionCount/exercisesWithRecords antes del loop ‚úÖ
- Step 5c: classification != null ‚Üí exercisesWithRecords++; == REGRESSION ‚Üí regressionCount++ ‚úÖ
- Step 5d: previousStatus/newStatus transiciones ‚Üí alert insert/resolve con dedup ‚úÖ
- ProgressionClassification NO importado en SessionRepositoryImpl ‚Äî necesita import (documentado) ‚úÖ
- Step 6 post-loop: deload guard ‚Üí fatigue ‚Üí deload need ‚Üí alert insert/resolve ‚úÖ
- closeSession(): getModuleVersionIdBySessionId + getDeloadIdBySessionId antes de evaluateProgression ‚úÖ

countAffectedForDeload query:
- SELECT COUNT(DISTINCT pa.exercise_id) FROM plan_assignment pa LEFT JOIN exercise_progression ep ON pa.exercise_id = ep.exercise_id LEFT JOIN session_exercise se ON pa.exercise_id = se.exercise_id AND se.session_id = :sessionId WHERE pa.module_version_id = :moduleVersionId AND (ep.status = 'IN_PLATEAU' OR se.progression_classification = 'REGRESSION')
- Correcto: cuenta ejercicios prescritos que est√°n IN_PLATEAU globalmente O tienen REGRESSION en esta sesi√≥n ‚úÖ
- LEFT JOIN previene exclusi√≥n de ejercicios sin progression/session_exercise ‚úÖ
- DISTINCT previene duplicados ‚úÖ

=== BLOQUE 6: TRAZABILIDAD 24 CAs ===

Ya cubiertos por HU-10 (7):
- CA-12.01 ‚Üí classifyStandard() totalReps < previous ‚Üí REGRESSION ‚úÖ
- CA-12.02 ‚Üí classifyStandard() rirRise >= 1.5 ‚Üí REGRESSION ‚úÖ
- CA-12.03 ‚Üí classifyStandard() isWeightLower ‚Üí REGRESSION ‚úÖ
- CA-12.07 ‚Üí resolveNewProgressionState() counter >= 3 ‚Üí IN_PLATEAU ‚úÖ
- CA-12.08 ‚Üí dise√±o inherente, sessionsWithoutProgression per exerciseId ‚úÖ
- CA-12.14 ‚Üí resolveNewProgressionState() ‚Üí status = IN_PLATEAU ‚úÖ
- CA-12.18 ‚Üí dise√±o inherente, alertas informativas no bloquean ‚úÖ

Por implementar en HU-12 (15):
- CA-12.04 ‚Üí Fase 1 ModuleFatigueRule + Fase 5 acumuladores ‚úÖ
- CA-12.05 ‚Üí Fase 1 exercisesWithRecords denominator ‚úÖ
- CA-12.06 ‚Üí Fase 3 AlertDao.insert + Fase 5 paso 5d/6 ‚úÖ
- CA-12.09 ‚Üí Fase 5 paso 5d insert PLATEAU alert ‚úÖ
- CA-12.10 ‚Üí Fase 2 PlateauCausalAnalysisRule ‚Üí LOW_RIR_LIMIT ‚úÖ
- CA-12.11 ‚Üí Fase 2 PlateauCausalAnalysisRule ‚Üí HIGH_RIR_CONSERVATIVE ‚úÖ
- CA-12.12 ‚Üí Fase 2 PlateauCausalAnalysisRule ‚Üí GROUP_STAGNATION ‚úÖ
- CA-12.15 ‚Üí Fase 2 CorrectiveActionRule counter ‚â• 4 ‚úÖ
- CA-12.16 ‚Üí Fase 2 CorrectiveActionRule counter ‚â• 6 ‚úÖ
- CA-12.17 ‚Üí Fase 2 retorno acumulativo ‚úÖ
- CA-12.20 ‚Üí Fase 1 DeloadNeedRule + Fase 4 countAffectedForDeload + Fase 5 paso 6 ‚úÖ
- CA-12.21 ‚Üí Fase 1 DeloadNeedRule fatigueDetected ‚Üí true ‚úÖ
- CA-12.22 ‚Üí Fase 4 countExercisesForModuleVersion ‚úÖ
- CA-12.23 ‚Üí Fase 5 paso 6 insert MODULE_REQUIRES_DELOAD alert ‚úÖ
- CA-12.24 ‚Üí Fase 3 AlertEntity + Fase 5 alertDao.insert con moduleCode + createdAt ‚úÖ

Parciales HU-12+HU-17 (2):
- CA-12.13 ‚Üí HU-12 asigna level HIGH_ALERT; HU-17 aplica colores/iconos RNF05 ‚úÖ
- CA-12.19 ‚Üí HU-12 provee PLATEAU alert + reglas causal/correctivas; HU-17 presenta conjuntamente en H2 ‚úÖ

Total: 7 + 15 + 2 = 24 CAs ‚úÖ

=== BLOQUE 7: ERRORES ENCONTRADOS Y CORREGIDOS ===

E1-CORREGIDO: Fase 5 dec√≠a "Inyectar AlertDao y PlanAssignmentDao en SessionRepositoryImpl". PlanAssignmentDao YA est√° inyectado (SessionRepositoryImpl.kt L40). Corregido a "Inyectar AlertDao en SessionRepositoryImpl (PlanAssignmentDao ya est√° inyectado desde HU-09)".

=== BLOQUE 8: CONTRADICCIONES DOCUMENTALES (4 analizadas) ===

C1-INFO (heredada, documentada): MDS R3 dice "en la misma versi√≥n del m√≥dulo" pero RF34 NO dice eso. HU-10 Nota 9 documenta expl√≠citamente la divergencia: counter global per exercise, siguiendo RF34 + Modelo de Datos. Decisi√≥n deliberada, no omisi√≥n.
C2-LOW (heredada de HU-10, documentada): RF29 define regresi√≥n per-serie (‚â•2 de 4 series) pero HU-10 usa criterio agregado (totalReps < previous). Nota 10 documenta discrepancia aceptable para MVP.
C3-LOW (gap presentaci√≥n): MDS R3 1¬™ intervenci√≥n incluye "verificar la t√©cnica de ejecuci√≥n". RF36 y CA-12.15 omiten t√©cnica. Gap es presentaci√≥n-layer, addressable en texto H2 (HU-17) sin cambio de c√≥digo.
C4-INFO (decisi√≥n de dise√±o): MDS R3 lista intervenciones como escalamiento sin decir "acumulativo". CA-12.17 interpreta sesi√≥n 6 = ambas acciones. Razonable.

=== BLOQUE 9: CHECKLIST FORMAL (25 items) ===

1. 8 archivos nuevos marcados "Crear archivo" ‚úÖ
2. 5 archivos modificados existen en codebase ‚úÖ
3. 4 archivos de test con ~26 escenarios ‚úÖ
4. JUnit 4, helpers sessionData/set, sin mocks ‚úÖ
5. 13 decisiones arquitect√≥nicas consumidas ‚úÖ
6. 5 fases alineadas con 5 hitos ‚úÖ
7. 24 CAs mapeados (7 cubiertos + 15 por implementar + 2 parciales) ‚úÖ
8. 4 riesgos t√©cnicos documentados ‚úÖ
9. 0 dependencias nuevas ‚úÖ
10. Migraci√≥n BD v4‚Üív5, fallbackToDestructiveMigration ‚úÖ
11. DI: provideAlertDao() en DatabaseModule ‚úÖ
12. Guards: deload session guard post-loop ‚úÖ
13. Dedup: existsActiveByExercise/Module antes de insert ‚úÖ
14. Forward-compatible: deload guard inerte pre-HU-14 ‚úÖ
15. Alertas extensibles: solo 2 de 7 tipos, HU-17 agrega 5 ‚úÖ
16. Integer division: .toDouble() en ambas reglas de umbral ‚úÖ
17. SessionRepository interface: evaluateProgression es private, no cambia API ‚úÖ
18. RepositoryModule: no necesita cambios, Hilt resuelve AlertDao autom√°ticamente ‚úÖ
19. PlanAssignmentDao: ya inyectado en SessionRepositoryImpl ‚Äî solo AlertDao es nuevo (CORREGIDO) ‚úÖ
20. ProgressionClassification: import necesario en SessionRepositoryImpl (documentado) ‚úÖ
21. ModuleEntity PK = code: String ‚Äî FK AlertEntity‚Üímodule(code) coherente ‚úÖ
22. ExerciseEntity PK = id: Long ‚Äî FK AlertEntity‚Üíexercise(id) coherente ‚úÖ
23. ORDER BY level ASC: CRISIS < HIGH_ALERT < MEDIUM_ALERT por orden alfab√©tico ‚Äî funcional ‚úÖ
24. countAffectedForDeload: LEFT JOIN + DISTINCT correctos ‚úÖ
25. Patrones JUnit verificados contra ProgressionClassificationRuleTest.kt + DoubleThresholdRuleTest.kt ‚úÖ

=== RESULTADO FINAL ===
1 ERROR CORREGIDO (E1: PlanAssignmentDao ya inyectado), 0 HIGH, 0 MEDIUM, 2 LOW (RF29 per-serie + t√©cnica MDS R3), 2 INFO (version-scoping + cumulatividad).
Totales verificados: 6 docs arquitectura + 5 docs business + 18 HUs + Mapa + 14 archivos c√≥digo + 24 CAs + ~26 escenarios test + 25 items checklist.
Refinamiento t√©cnico APROBADO con 1 correcci√≥n aplicada. -->