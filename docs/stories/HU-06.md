# HU-06 — Registrar series de ejercicios en sesión activa

## Requisitos relacionados

RF13, RF14, RF15, RF17, RF22, RNF02, RNF03, RNF04, RNF10, RNF12

## Descripción

Como ejecutante, quiero registrar los datos de cada serie de cada ejercicio durante una sesión activa de forma rápida, en cualquier orden y con los datos precargados de mi última sesión, para capturar mi entrenamiento con la menor fricción posible mientras mantengo precisión y completitud en los registros.

## Criterios de Aceptación

### CA-06.01 — Captura de datos por serie

**Dado que** el ejecutante tiene una sesión activa y selecciona un ejercicio para registrar una serie,
**cuando** accede al formulario de registro de serie,
**entonces** el sistema solicita exactamente tres datos: Peso en Kg, Repeticiones logradas y RIR (Reps In Reserve), todos obligatorios para completar el registro.

### CA-06.02 — Registro en máximo 3 toques

**Dado que** el ejecutante ha seleccionado un ejercicio en la sesión activa,
**cuando** registra una serie,
**entonces** el flujo de registro requiere un máximo de 3 toques para completarse: ingresar peso, ingresar repeticiones, ingresar RIR y confirmar, aprovechando la precarga de datos y minimizando la fricción.

### CA-06.03 — Teclado numérico para campos de entrada

**Dado que** el ejecutante está registrando una serie durante la sesión activa,
**cuando** activa cualquier campo de entrada numérica (peso, repeticiones o RIR),
**entonces** el sistema despliega un teclado numérico optimizado, no el teclado alfanumérico completo.

### CA-06.04 — Precarga del último peso utilizado

**Dado que** el ejecutante tiene historial previo para el ejercicio que está registrando,
**cuando** accede al formulario de registro de serie para ese ejercicio,
**entonces** el campo de peso se precarga automáticamente con el último peso utilizado para ese ejercicio, permitiendo al ejecutante confirmar rápidamente si la carga no cambió.

### CA-06.05 — Validación de peso

**Dado que** el ejecutante ingresa un valor de peso en el registro de serie,
**cuando** el valor es menor que 0,
**entonces** el sistema rechaza el registro y muestra un mensaje de error claro indicando que el peso debe ser ≥ 0 Kg (donde 0 es válido exclusivamente para ejercicios de peso corporal).

### CA-06.06 — Validación de repeticiones

**Dado que** el ejecutante ingresa un valor de repeticiones en el registro de serie,
**cuando** el valor es menor que 1,
**entonces** el sistema rechaza el registro y muestra un mensaje de error claro indicando que las repeticiones deben ser ≥ 1.

### CA-06.07 — Validación de RIR

**Dado que** el ejecutante ingresa un valor de RIR en el registro de serie,
**cuando** el valor está fuera del rango 0 a 5,
**entonces** el sistema rechaza el registro y muestra un mensaje de error claro indicando que el RIR debe estar entre 0 y 5.

### CA-06.08 — Asociación automática de metadatos

**Dado que** el ejecutante confirma el registro de una serie con datos válidos,
**cuando** el sistema persiste el registro,
**entonces** asocia automáticamente la serie con: la Fecha actual, el Módulo de la sesión, la Versión del módulo, el Ejercicio ejecutado y el Número de Serie secuencial (1, 2, 3 o 4), sin requerir que el ejecutante ingrese ninguno de estos datos manualmente.

### CA-06.09 — Secuencia de series por ejercicio

**Dado que** el ejecutante registra series de un ejercicio durante la sesión activa,
**cuando** registra cada serie,
**entonces** el sistema asigna automáticamente el número de serie secuencial: la primera serie registrada es 1, la segunda es 2, la tercera es 3 y la cuarta es 4, sin permitir más de 4 series por ejercicio.

### CA-06.10 — Orden libre de registro de ejercicios

**Dado que** el ejecutante tiene una sesión activa con múltiples ejercicios prescritos,
**cuando** decide registrar series,
**entonces** el sistema permite registrar los ejercicios en cualquier orden, sin imponer la secuencia en que aparecen en el Plan de Entrenamiento. El ejecutante puede empezar por cualquier ejercicio, registrar series parciales de uno, cambiar a otro y volver.

### CA-06.11 — Vinculación al ejercicio realmente ejecutado

**Dado que** el ejecutante ha realizado una sustitución puntual de un ejercicio durante la sesión,
**cuando** registra las series del ejercicio sustituto,
**entonces** el sistema vincula los datos registrados al ejercicio que realmente se ejecutó (el sustituto), no al ejercicio originalmente prescrito, garantizando coherencia entre lo registrado y lo efectivamente realizado.

### CA-06.12 — Estado visual de ejercicios en la sesión

**Dado que** el ejecutante tiene una sesión activa,
**cuando** visualiza la lista de ejercicios de la sesión,
**entonces** el sistema muestra el estado de cada ejercicio: "No Iniciado" cuando tiene 0 series registradas, "En Ejecución" cuando tiene entre 1 y 3 series registradas, o "Completado" cuando tiene 4 series registradas.

### CA-06.13 — Preservación de datos ante cierre inesperado

**Dado que** el ejecutante tiene una sesión activa con series registradas,
**cuando** la aplicación se cierra inesperadamente (cierre por el usuario, falta de batería o crash),
**entonces** el sistema preserva todos los datos de la sesión en progreso y todas las series registradas hasta ese momento. Al reabrir la aplicación, la sesión puede continuarse desde el punto donde quedó.

## Análisis Arquitectónico (Arquitecto)

### Decisiones de Diseño

**Patrón Arquitectónico:** Clean Architecture (MVVM + Use Cases + Repository) — consistente con HU-01 a HU-05.

**Justificación:** HU-06 sigue el mismo flujo de datos del resto de la app: pantalla E2 → ViewModel → UseCase → Repository → DAOs → Room. La complejidad reside en la lógica de validación (3 campos, 3 reglas) y la transacción atómica de registro con asignación secuencial del número de serie. Ambas están bien servidas por este patrón sin necesidad de alternativas.

**Componentes Afectados:**

#### 1. Data Layer — DAOs (Modificaciones)

Paquete: `data.local.dao`.

- **`ExerciseSetDao`** (Modificación Mayor): Actualmente stub vacío (creado en HU-05). Se convierte en DAO funcional con:

  - `insert(set: ExerciseSetEntity): Long` — `@Insert`. Persiste una serie individual. Retorna el `id` generado por autoincrement.

  - `getNextSetNumber(sessionExerciseId: Long): Int` — `@Query` suspend. Calcula `COUNT(*) + 1` para asignar automáticamente el número secuencial (CA-06.09). Si ya hay 4 series, retornará 5 — la capa de repository lo valida como error.

    ```sql
    SELECT COUNT(*) + 1 FROM exercise_set
    WHERE session_exercise_id = :sessionExerciseId
    ```

  - `getLastWeightForExercise(exerciseId: Long): Double?` — `@Query` suspend. Query cross-session para precarga del último peso utilizado (CA-06.04, RNF04). Busca en todas las sesiones anteriores, no solo la sesión activa. Retorna `null` si sin historial (primera sesión del ejercicio).

    ```sql
    SELECT es.weight_kg
    FROM exercise_set es
    INNER JOIN session_exercise se ON es.session_exercise_id = se.id
    WHERE se.exercise_id = :exerciseId
    ORDER BY es.id DESC
    LIMIT 1
    ```

    **Justificación del ORDER BY `es.id` DESC:** El `id` autoincrement de `exercise_set` es monotónicamente creciente. La última serie insertada para un ejercicio dado será siempre la de mayor `id`. Esto es más eficiente que un JOIN adicional a `session.date` + `es.set_number` y produce el mismo resultado.

- **`SessionExerciseDao`** (Modificación Menor): Agregar query suspend para obtener la información del ejercicio necesaria para poblar el formulario E2.

  - `getExerciseInfoForSet(sessionExerciseId: Long): SetExerciseInfo?` — `@Query` suspend. Query JOIN multi-tabla que retorna nombre del ejercicio, flags booleanos, y `totalSets`. Usa LEFT JOIN para `plan_assignment` con `COALESCE(pa.sets, 4)` como protección ante ejercicios sustituidos (HU-07 futuro) donde `exercise_id` podría no existir en `plan_assignment` para ese `module_version_id`.

    ```sql
    SELECT
        se.exercise_id AS exerciseId,
        e.name AS exerciseName,
        e.is_bodyweight AS isBodyweight,
        e.is_isometric AS isIsometric,
        e.is_to_technical_failure AS isToTechnicalFailure,
        COALESCE(pa.sets, 4) AS totalSets
    FROM session_exercise se
    INNER JOIN exercise e ON se.exercise_id = e.id
    INNER JOIN session s ON se.session_id = s.id
    LEFT JOIN plan_assignment pa ON pa.module_version_id = s.module_version_id
        AND pa.exercise_id = se.exercise_id
    WHERE se.id = :sessionExerciseId
    ```

  - **`SetExerciseInfo`**: Data class intermedia (no `@Entity`), definida en `SessionExerciseDao.kt` (mismo patrón de `SessionExerciseWithDetails` y `ActiveSessionInfo`). Campos: `exerciseId: Long`, `exerciseName: String`, `isBodyweight: Int`, `isIsometric: Int`, `isToTechnicalFailure: Int`, `totalSets: Int`.

- **`ExerciseProgressionDao`** (Modificación Menor): Agregar método para creación idempotente de la fila de progresión.

  - `insertIfNotExists(progression: ExerciseProgressionEntity)` — `@Insert(onConflict = OnConflictStrategy.IGNORE)`. Al registrar la primera serie de un ejercicio, se crea la fila `exercise_progression` con defaults (`status = "NO_HISTORY"`, `prescribedLoadKg = null`, `sessionsWithoutProgression = 0`). La PK es `exercise_id`, por lo tanto el IGNORE asegura idempotencia: si la fila ya existe (ejercicio con historial previo), no se modifica (Modelo de Datos §3.13: "Se crea una fila por ejercicio al registrar la primera serie del ejercicio").

#### 2. Domain Layer — Modelo Nuevo

Paquete: `domain.model`.

- **`RegisterSetInfo`**: Data class que encapsula la información necesaria para poblar el formulario E2.
  - `sessionExerciseId: Long` — ID del ejercicio-en-sesión. Usado para el INSERT.
  - `exerciseId: Long` — ID del ejercicio base. Usado para consultar último peso.
  - `exerciseName: String` — Nombre mostrado en el Top Bar de E2.
  - `currentSetNumber: Int` — Próximo número de serie a registrar (1-4). Calculado via `getNextSetNumber()`.
  - `totalSets: Int` — Siempre 4 en MVP. Viene del `COALESCE(pa.sets, 4)`.
  - `lastWeightKg: Double?` — Último peso utilizado para precarga (CA-06.04). `null` = sin historial → campo vacío. `0.0` = peso corporal/isométrico → campo fijo no editable.
  - `isBodyweight: Boolean` — Flag de peso corporal (CA-08.01).
  - `isIsometric: Boolean` — Flag de isométrico (CA-08.04, CA-08.05).
  - `isToTechnicalFailure: Boolean` — Flag de fallo técnico (informativo).

#### 3. Domain Layer — Repository Interface (Modificación)

Paquete: `domain.repository`.

- **`SessionRepository`** (Modificación): Agregar 2 métodos al contrato existente.

  - `suspend fun getRegisterSetInfo(sessionExerciseId: Long): RegisterSetInfo?` — Obtiene la información necesaria para poblar E2. Retorna `null` si `sessionExerciseId` no existe (defensa contra argumento inválido). Método `suspend` (no Flow) porque es una consulta one-shot al abrir E2.

  - `suspend fun registerSet(sessionExerciseId: Long, weightKg: Double, reps: Int, rir: Int)` — Ejecuta la transacción atómica de registro: calcula número de serie, INSERT en `exercise_set`, INSERT idempotente en `exercise_progression`. Lanza `IllegalStateException` si el ejercicio ya tiene 4 series (defensa en profundidad).

#### 4. Domain Layer — Use Cases Nuevos

Paquete: `domain.usecase.session`.

- **`GetRegisterSetInfoUseCase`** (Nuevo): Wrapper de `SessionRepository.getRegisterSetInfo()`.

  ```kotlin
  class GetRegisterSetInfoUseCase @Inject constructor(
      private val sessionRepository: SessionRepository,
  ) {
      suspend operator fun invoke(sessionExerciseId: Long): RegisterSetInfo? {
          return sessionRepository.getRegisterSetInfo(sessionExerciseId)
      }
  }
  ```

  Justificación como clase separada: mantiene consistencia con el patrón de use cases de HU-01 a HU-05 y permite agregar lógica de dominio futura (e.g., cálculo de carga sugerida) sin modificar el ViewModel.

- **`RegisterSetUseCase`** (Nuevo): Valida reglas de negocio y delega persistencia.

  ```kotlin
  class RegisterSetUseCase @Inject constructor(
      private val sessionRepository: SessionRepository,
  ) {
      suspend operator fun invoke(
          sessionExerciseId: Long,
          weightKg: Double,
          reps: Int,
          rir: Int,
      ) {
          require(weightKg >= 0) { "El peso debe ser ≥ 0 Kg" }
          require(reps >= 1) { "Las repeticiones deben ser ≥ 1" }
          require(rir in 0..5) { "El RIR debe estar entre 0 y 5" }
          sessionRepository.registerSet(sessionExerciseId, weightKg, reps, rir)
      }
  }
  ```

  **Validación en `require()` vs. UI:** La validación en el Use Case es la última línea de defensa. La UI también valida en tiempo real (feedback inmediato al usuario). La redundancia es intencional: el Use Case protege la integridad de los datos independientemente de qué UI lo invoque (principio de la Clean Architecture).

#### 5. Data Layer — Repository Implementation (Modificación Mayor)

Paquete: `data.repository`.

- **`SessionRepositoryImpl`** (Modificación Mayor): Implementar los 2 nuevos métodos. Requiere inyección de `ExerciseSetDao` y `ExerciseProgressionDao` (ambos ya provistos en `DatabaseModule` desde HU-05).

  - `getRegisterSetInfo(sessionExerciseId: Long): RegisterSetInfo?`:
    1. Consulta `sessionExerciseDao.getExerciseInfoForSet(sessionExerciseId)`. Si `null` → retorna `null`.
    2. Consulta `exerciseSetDao.getNextSetNumber(sessionExerciseId)`. Si > 4 → retorna `null` (ejercicio ya completado, no se puede registrar más).
    3. Determina `lastWeightKg`:
       - Si `isBodyweight == 1` o `isIsometric == 1` → `0.0` (peso fijo no editable, CA-08.01).
       - Si no → `exerciseSetDao.getLastWeightForExercise(info.exerciseId)` (puede ser `null` si sin historial).
    4. Mapea a `RegisterSetInfo` convirtiendo flags `Int` → `Boolean`.

  - `registerSet(sessionExerciseId: Long, weightKg: Double, reps: Int, rir: Int)`:
    Ejecuta en `database.withTransaction {}`:
    1. `val nextSetNumber = exerciseSetDao.getNextSetNumber(sessionExerciseId)`.
    2. Valida `nextSetNumber <= 4`. Si no, lanza `IllegalStateException("Exercise already has 4 sets")`.
    3. INSERT: `exerciseSetDao.insert(ExerciseSetEntity(sessionExerciseId = sessionExerciseId, setNumber = nextSetNumber, weightKg = weightKg, reps = reps, rir = rir))`.
    4. Obtiene `exerciseId` via `sessionExerciseDao.getExerciseInfoForSet(sessionExerciseId)`.
    5. INSERT idempotente: `exerciseProgressionDao.insertIfNotExists(ExerciseProgressionEntity(exerciseId = exerciseId))` con defaults. Si la fila ya existe, `IGNORE` la descarta silenciosamente.

  **¿Por qué la transacción es necesaria?** Los pasos 1-3 deben ser atómicos para evitar condiciones de carrera en la asignación de `setNumber`. Sin transacción, dos llamadas rápidas podrían obtener el mismo `nextSetNumber` y violar el UNIQUE constraint `(session_exercise_id, set_number)`. La transacción serializa el acceso.

  **Inyección adicional en constructor:** Agregar `exerciseSetDao: ExerciseSetDao` y `exerciseProgressionDao: ExerciseProgressionDao` al constructor de `SessionRepositoryImpl`. Los providers ya existen en `DatabaseModule` (creados en HU-05).

#### 6. UI Layer — Estado y ViewModel

Paquete: `ui.session`.

- **`RegisterSetUiState`** (Nuevo): Data class de estado reactivo del formulario E2.

  ```kotlin
  data class RegisterSetUiState(
      val isLoading: Boolean = true,
      val exerciseName: String = "",
      val currentSetNumber: Int = 1,
      val totalSets: Int = 4,
      val weightKg: String = "",
      val reps: String = "",
      val selectedRir: Int? = null,
      val isWeightEditable: Boolean = true,
      val isIsometric: Boolean = false,
      val isBodyweight: Boolean = false,
      val weightError: String? = null,
      val repsError: String? = null,
      val isSaving: Boolean = false,
  ) {
      val isConfirmEnabled: Boolean
          get() = selectedRir != null &&
              weightKg.isNotBlank() &&
              reps.isNotBlank() &&
              weightError == null &&
              repsError == null &&
              !isSaving
  }
  ```

  **Campos de texto como `String`:** Los campos `weightKg` y `reps` son `String` (no `Double`/`Int`) porque representan el texto del `OutlinedTextField`. El parseo a tipo numérico se realiza en `onConfirm()`. Esto permite que el usuario vea exactamente lo que escribió y reciba errores solo al intentar confirmar o durante la validación en tiempo real.

- **`RegisterSetViewModel`** (Nuevo): `@HiltViewModel`. Gestiona el ciclo de vida del formulario E2.

  - **Inyecta:** `GetRegisterSetInfoUseCase`, `RegisterSetUseCase`, `SavedStateHandle`.
  - **Session exercise ID:** `savedStateHandle.get<Long>("sessionExerciseId")` — extraído del argumento de navegación.
  - **Estado:** `MutableStateFlow<RegisterSetUiState>` → `StateFlow<RegisterSetUiState>`.
  - **Evento de navegación:** `MutableSharedFlow<Boolean>(replay = 0)` → la UI observa con `LaunchedEffect` y navega back al emitir `true`.

  - **`init`:** Llama a `GetRegisterSetInfoUseCase(sessionExerciseId)` en `viewModelScope.launch`. Si resultado es `null`, permanece en loading (E2 no debería alcanzarse con ID inválido). Si resultado es válido:
    - `exerciseName` ← `info.exerciseName`.
    - `currentSetNumber` ← `info.currentSetNumber`.
    - `totalSets` ← `info.totalSets`.
    - `isWeightEditable` ← `!info.isBodyweight && !info.isIsometric`.
    - `isIsometric` ← `info.isIsometric`.
    - `isBodyweight` ← `info.isBodyweight`.
    - `weightKg`:
      - Si bodyweight/isometric → `"0"` (fijo, CA-08.01).
      - Si `lastWeightKg != null` → formateado (e.g., `"60.0"`).
      - Si `null` → `""` (vacío, sin historial).

  - **`onWeightChanged(value: String)`:** Actualiza `weightKg`. Valida: parsea a Double, si `< 0` → `weightError = "El peso debe ser ≥ 0 Kg"`. Si vacío o inválido → `weightError = null` (no mostrar error hasta que intente confirmar). Se limita a validación no-bloqueante.

  - **`onRepsChanged(value: String)`:** Actualiza `reps`. Valida: parsea a Int, si `< 1` → `repsError` con mensaje según variante ("Las repeticiones deben ser ≥ 1" o "La duración debe ser ≥ 1 segundo" para isométrico).

  - **`onRirSelected(rir: Int)`:** Actualiza `selectedRir`. Sin validación necesaria — los chips 0-5 garantizan rango válido por diseño (CA-06.07 se cumple por construcción, no por validación).

  - **`onConfirm()`:** Ejecuta en `viewModelScope.launch`:
    1. Parsea `weightKg` → `Double`, `reps` → `Int`. Si parseo falla, actualiza errores y retorna.
    2. Marca `isSaving = true` (deshabilita botón, protección anti-double-tap).
    3. `try { registerSetUseCase(sessionExerciseId, weight, reps, rir) }` — el UC valida y persiste.
    4. Si éxito: emite `true` en `navigateBack` SharedFlow.
    5. Si `IllegalArgumentException`: actualiza errores en UI.
    6. Si `IllegalStateException`: "Exercise already has 4 sets" — emite `true` igualmente (graceful: retorna a E1 donde el estado ya refleja completado).
    7. `finally { isSaving = false }` — reestablece por si hubo error no terminal.

#### 7. UI Layer — Pantalla E2

Paquete: `ui.session`.

- **`RegisterSetScreen`** (Nuevo): Composable que implementa la vista E2 según Wireframes E2 y Especificación Visual §8 E2.

  Firma:
  ```kotlin
  @Composable
  fun RegisterSetScreen(
      onNavigateBack: () -> Unit,
      viewModel: RegisterSetViewModel = hiltViewModel(),
  )
  ```

  **Estructura de layout:**

  - **Top Bar:** `CenterAlignedTopAppBar` (M3).
    - `navigationIcon`: `IconButton` con `Icons.Default.Close` (✕), tint `On Surface`. `onClick = onNavigateBack` (descarta sin registrar).
    - `title`: `Column` con:
      - `Text` nombre del ejercicio — `Title Large`.
      - `Text` "Serie N de 4" — `Title Small`, `On Surface Variant`. Formato: `register_set_title_format`.

  - **Body:** `Column` con padding 16 dp, spacing vertical 16 dp.
    - **Campo "Peso (Kg)":** `OutlinedTextField`.
      - **Variante estándar:** `enabled = true`, `keyboardType = KeyboardType.Decimal`, texto precargado con último peso, label "Peso (Kg)", trailingIcon "Kg" en `Body Small, On Surface Variant`. Borde: `Outline` → `Primary` al focus. `supportingText` con error si `weightError != null` (color `Error #BA1A1A`).
      - **Variante peso corporal:** `enabled = false`, valor "0", label "Peso (Kg) (Peso corporal)", fondo `Surface Container Highest (#EDE0D5)` con opacity 0.5, texto `On Surface Variant`.
      - **Variante isométrico:** `enabled = false`, valor "0", label "Peso (Kg) (Isométrico)", mismos estilos deshabilitado.

    - **Campo "Repeticiones" / "Segundos sostenidos":** `OutlinedTextField`.
      - **Estándar y peso corporal:** label "Repeticiones", `keyboardType = KeyboardType.Number`, trailingIcon "reps", sin precarga (vacío).
      - **Isométrico:** label "Segundos sostenidos", `keyboardType = KeyboardType.Number`, trailingIcon "seg", `supportingText = "(Referencia: 30-45 seg)"` en `Body Small, On Surface Variant` (CA-08.05).
      - Error inline si `repsError != null`.

    - **Selector RIR:** `Column` con:
      - Label "RIR" en `Label Medium, On Surface Variant`.
      - `Row` horizontal con spacing 8 dp, 6 chips circulares (0, 1, 2, 3, 4, 5).
      - Cada chip: `Box` 48×48 dp (RNF06), `CircleShape`.
        - No seleccionado: fondo `Surface Container (#F8EBE0)`, borde `Outline`, texto `On Surface`.
        - Seleccionado: fondo `Primary (#8B1A1A)`, sin borde, texto `On Primary (#FFFFFF)`.
      - Single select. Sin precarga.

    - **Botón "Confirmar":** `FilledButton` full width, `containerColor = Primary`, height 48 dp, margin top 24 dp. `enabled = isConfirmEnabled`. Al click → `viewModel.onConfirm()`.

    - **"Cancelar":** `TextButton` centrado, color `Primary`. Al click → `onNavigateBack()` (descarta sin cambios).

  - **Sin Bottom Navigation** (Arquitectura Técnica §4.5.1: E2 siempre oculta).

  - **Navegación de retorno:** `LaunchedEffect` que observa `viewModel.navigateBack` SharedFlow y llama a `onNavigateBack()` cuando emite `true`. Esto garantiza que la navegación ocurra después de la persistencia exitosa.

  **Cumplimiento de RNF02 (máximo 3 toques):** Con peso precargado, el flujo óptimo es: (1) ingresar repeticiones, (2) tocar chip RIR, (3) tocar "Confirmar". El peso ya está precargado y no requiere interacción si no cambió. Para primera sesión (sin precarga), el flujo es 4 toques: peso + reps + RIR + confirmar, que es aceptable dado que la precarga no es posible sin historial.

#### 8. Navegación (Modificaciones)

Paquete: `ui.navigation`.

- **`NavigationRoutes`** (Modificación Menor): Agregar ruta E2.
  - `const val REGISTER_SET = "register-set/{sessionExerciseId}"` (Arquitectura Técnica §4.3 ruta #10).
  - `fun registerSetRoute(sessionExerciseId: Long) = "register-set/$sessionExerciseId"`.

- **`TensionNavHost`** (Modificación): 2 cambios.
  - **Wiring del callback** en `ACTIVE_SESSION`: reemplazar `onNavigateToRegisterSet = { /* TODO: HU-06 */ }` por:
    ```kotlin
    onNavigateToRegisterSet = { sessionExerciseId ->
        navController.navigate(NavigationRoutes.registerSetRoute(sessionExerciseId))
    }
    ```
  - **Nuevo composable entry:** `composable(route = NavigationRoutes.REGISTER_SET, arguments = listOf(navArgument("sessionExerciseId") { type = NavType.LongType }))` que monta `RegisterSetScreen(onNavigateBack = { navController.popBackStack() })`.

  **Nota sobre `showBottomBar`:** La condición existente `!currentRoute.startsWith("active-session")` NO cubre `register-set`. Agregar exclusión: `&& !currentRoute.startsWith("register-set")`.

#### 9. Recursos

Archivo: `app/src/main/res/values/strings.xml`.

- Agregar ~12 strings para E2:
  ```xml
  <!-- Register Set E2 -->
  <string name="register_set_title_format">Serie %1$d de %2$d</string>
  <string name="register_set_weight_label">Peso (Kg)</string>
  <string name="register_set_weight_bodyweight_label">Peso (Kg) (Peso corporal)</string>
  <string name="register_set_weight_isometric_label">Peso (Kg) (Isométrico)</string>
  <string name="register_set_weight_suffix">Kg</string>
  <string name="register_set_reps_label">Repeticiones</string>
  <string name="register_set_reps_suffix">reps</string>
  <string name="register_set_seconds_label">Segundos sostenidos</string>
  <string name="register_set_seconds_suffix">seg</string>
  <string name="register_set_seconds_reference">(Referencia: 30\u201345 seg)</string>
  <string name="register_set_rir_label">RIR</string>
  <string name="register_set_confirm">Confirmar</string>
  <string name="register_set_cancel">Cancelar</string>
  <string name="error_weight_negative">El peso debe ser \u2265 0 Kg</string>
  <string name="error_reps_min">Las repeticiones deben ser \u2265 1</string>
  <string name="error_seconds_min">La duración debe ser \u2265 1 segundo</string>
  ```

### Validación de Impacto

**Código verificado antes de proponer (paso 1.5):**

| Archivo | Estado verificado | Hallazgo |
|---|---|---|
| `ExerciseSetDao.kt` | Stub vacío — solo `@Dao interface ExerciseSetDao` | ✅ Confirma necesidad de 3 métodos nuevos |
| `ExerciseSetEntity.kt` | Completa con 6 columnas (id, sessionExerciseId, setNumber, weightKg, reps, rir) | ✅ Columnas coinciden con INSERT propuesto. CHECK constraints definidos: `set_number 1-4`, `weight_kg >= 0`, `reps >= 1`, `rir 0-5` |
| `SessionExerciseDao.kt` | `getBySessionId()` y `getBySessionIdWithDetails()` existen | ✅ No hay método para obtener info individual. Se necesita `getExerciseInfoForSet()` |
| `ExerciseProgressionDao.kt` | Tiene `insert()` y `update()` | ✅ `insert()` usa `@Insert` default (ABORT on conflict) — no serve para idempotencia. Se necesita `insertIfNotExists()` con IGNORE |
| `SessionRepositoryImpl.kt` | 165 líneas, inyecta 6 DAOs | ✅ No inyecta `ExerciseSetDao` ni `ExerciseProgressionDao`. Se agregan al constructor |
| `SessionRepository.kt` | 6 métodos actuales | ✅ Ninguno cubre registro de series. Se agregan 2 |
| `NavigationRoutes.kt` | 8 rutas, sin `REGISTER_SET` | ✅ Se agrega |
| `TensionNavHost.kt` | `onNavigateToRegisterSet = { /* TODO: HU-06 */ }` | ✅ Stub confirmado. Se reemplaza con navegación real |
| `TensionNavHost.kt` — `showBottomBar` | Excluye `REGISTER` y `active-session` | ⚠️ No excluye `register-set`. Se agrega |
| `ActiveSessionScreen.kt` | "Registrar" button navega via `onNavigateToRegisterSet(exercise.sessionExerciseId)` | ✅ Ya pasa `sessionExerciseId` correcto |
| `DatabaseModule.kt` | `provideExerciseSetDao()` y `provideExerciseProgressionDao()` ya existen | ✅ No se necesitan nuevos providers |
| `RepositoryModule.kt` | Binding `SessionRepository → SessionRepositoryImpl` ya existe | ✅ No se necesitan nuevos bindings |
| `strings.xml` | Sin strings de E2 | ✅ Se agregan ~12 strings |

**Impacto en el Flow reactivo de E1:** Al insertar una serie en `exercise_set`, Room invalida automáticamente el query `getBySessionIdWithDetails()` en E1 (que hace `COUNT(exercise_set)` como subquery). El Flow re-emite la lista actualizada y `completedSets` refleja la nueva serie. El estado del ejercicio cambia reactivamente: 0 → `NOT_STARTED`, 1-3 → `IN_PROGRESS`, 4 → `COMPLETED`. No se requiere ningún refresh manual ni notificación explícita.

**Impacto en la Card "Reanudar" de B1:** El `completedExercises` en `ActiveSessionInfo` también se recalcula reactivamente cuando se completa un ejercicio (4 series). Si el usuario mata la app y reabre, B1 mostrará el progreso actualizado.

### Notas Técnicas

1. **CA-06.08 (metadatos automáticos) se cumple por contexto relacional.** La cadena `exercise_set → session_exercise → session → module_version` proporciona: Fecha (`session.date`), Módulo (`module_version.module_code`), Versión (`module_version.version_number`), Ejercicio (`session_exercise.exercise_id`), Número de serie (`exercise_set.set_number`). El ejecutante solo ingresa: peso, reps, RIR. Los 5 metadatos se derivan automáticamente.

2. **CA-06.10 (orden libre) se cumple por diseño de E1.** Cada ejercicio tiene su propio botón "Registrar" independiente. No hay secuencia forzada. El ejecutante puede registrar 2 series de Press de banca, 1 de Remo, volver a Press para la 3ra, etc. El `set_number` es secuencial *dentro de cada ejercicio*, no a nivel de sesión.

3. **CA-06.11 (vinculación al ejercicio sustituto) se cumple automáticamente.** La serie se inserta con referencia al `session_exercise_id`, que apunta al `exercise_id` que realmente se ejecutó. Si hubo sustitución (HU-07), `session_exercise.exercise_id` ya contiene el sustituto. La query `getLastWeightForExercise()` busca por `exercise_id`, por lo que el historial del sustituto se precarga correctamente.

4. **CA-06.12 (estado visual) ya fue implementado en HU-05.** Los 3 estados (No Iniciado, En Ejecución, Completado) se derivan en `SessionRepositoryImpl.getSessionExercises()` del `completedSets` count. Al insertar una serie, Room invalida el Flow y E1 re-renderiza con el nuevo estado. No se requiere trabajo adicional en HU-06 para este CA.

5. **CA-06.13 (preservación ante cierre) se cumple por Room.** Cada INSERT en `exercise_set` se persiste en SQLite de forma inmediata tras el `withTransaction` commit. Si la app se cierra 1ms después de confirmar, la serie está persistida. Si la app se cierra *durante* la transacción, Room hace rollback y es como si el usuario no hubiera tocado "Confirmar" (no hay pérdida de datos parciales).

6. **Relación con HU-08.** Los CAs de HU-08 referenciados en E2 (CA-08.01, CA-08.04, CA-08.05, CA-08.08) se cubren en este diseño:
   - CA-08.01 (peso = 0 bodyweight): `isWeightEditable = false`, valor fijo "0".
   - CA-08.04 (input en segundos para isométrico): label/suffix cambian a "Segundos sostenidos" / "seg".
   - CA-08.05 (referencia 30-45 seg): `supportingText = "(Referencia: 30-45 seg)"`.
   - CA-08.08 (validación): misma lógica `reps >= 1` aplica tanto a repeticiones como a segundos (el campo `exercise_set.reps` almacena ambos, como documenta Modelo de Datos §3.12).
   - **Nota:** CA-08.02 (progresión por repeticiones totales), CA-08.03 (exclusión Doble Umbral), CA-08.06 (progresión isométrica), CA-08.07 (marcado "dominado") son responsabilidad de HU-10/HU-11, no de HU-06. El registro de datos es agnóstico al tipo — la interpretación ocurre al cerrar sesión.

7. **Impacto en la HU-07 (sustitución).** El LEFT JOIN en `getExerciseInfoForSet()` con `COALESCE(pa.sets, 4)` prepara E2 para recibir ejercicios sustituidos. Cuando HU-07 reemplace `session_exercise.exercise_id`, E2 funcionará sin cambios porque la query busca por `se.exercise_id` (el ejercicio actual, no el original).

8. **`getLastWeightForExercise()` es cross-session.** Busca el último peso en TODAS las sesiones (actuales y pasadas), no solo en la sesión activa. Esto permite que si un ejercicio tuvo peso 60 Kg en la sesión anterior, al iniciar una nueva sesión el peso se precargue correctamente. Si el ejercicio no tiene historial en ninguna sesión previa, retorna `null` y el campo queda vacío.

9. **Decisión diferida: precarga vs. carga prescrita post-descarga (HU-17).** La query `getLastWeightForExercise()` retorna el "último peso utilizado" sin filtrar sesiones de descarga. Tras un ciclo de descarga (HU-17), el E2 precargaría el peso de descarga (60% de la carga habitual) mientras E1 muestra la carga prescrita de reinicio (90% de la carga pre-descarga) desde `exercise_progression.prescribed_load_kg`. Esta discrepancia es **intencionada** según CA-06.04 ("último peso utilizado") vs. la carga objetivo de E1 ("carga prescrita"). Si HU-17 requiere cambiar el comportamiento de precarga (e.g., usar `prescribed_load_kg` cuando disponible, o filtrar sesiones de descarga), la modificación se aplica sobre la query de HU-06 sin cambiar la interfaz. Modelo de Datos §3.15 confirma que la "carga habitual" para cálculos de descarga usa una query diferente que SÍ filtra sesiones de descarga (`WHERE session.deload_id IS NULL AND session.date < deload.activation_date`).

10. **`keyboardType` para campo Peso: `Decimal` (no `Number`).** La Especificación Visual §8 E2 usa el término genérico "keyboardType: Number" para todos los campos numéricos. Sin embargo, `weight_kg` es `REAL` (Double) en la BD y las cargas usan incrementos de 2.5 Kg (HU-11, MDS §6-A R1), requiriendo entrada decimal. Se implementa con `KeyboardType.Decimal` (muestra teclado con separador decimal) para peso, y `KeyboardType.Number` (solo dígitos, sin decimal) para repeticiones/segundos (ambos `INTEGER`). Esta es una refinación técnica del término genérico de la especificación, no una desviación.

### Referencias y Validación

**Documentación consultada:**

- Modelo de Datos (§3.10-§3.13) — Estructura de session, session_exercise, exercise_set, exercise_progression
- Wireframes E2 — Registro de Serie (estándar, isométrico, peso corporal)
- Especificación Visual §8 E2 — Componentes M3, estilos, estados de validación
- Mapa de Navegación §5 (E2) — Flujo E1→E2→E1
- Arquitectura Técnica §4.3 (ruta #10: `register-set/{sessionExerciseId}`) y §4.5.1 (Bottom Nav oculta en E2)
- ADR (D-03: inmutabilidad post-cierre, D-04: E4 es diálogo no ruta)
- Requerimientos: RF13, RF14, RF15, RF17, RF22, RNF02, RNF03, RNF04, RNF10, RNF12
- Manifiesto de Dominio Sistémico §5.A.5 — "Registro de datos por serie"
- Plan de Entrenamiento — Prescripciones (4 series, 8-12 reps, TO_TECHNICAL_FAILURE, 30-45_SEC)

**Historias relacionadas:**

- HU-05: Determinar e iniciar sesión — Creó ExerciseSetEntity/Dao como stubs. Creó E1 con callbacks `onNavigateToRegisterSet`. Creó SessionRepository y su impl.
- HU-07: Sustitución puntual de ejercicios — El LEFT JOIN en getExerciseInfoForSet() prepara para ejercicios sustituidos donde exercise_id no existe en plan_assignment.
- HU-08: Ejercicios de peso corporal e isométricos — Los CAs de registro (CA-08.01, CA-08.04, CA-08.05, CA-08.08) se implementan en HU-06 como variantes del formulario E2. Los CAs de progresión (CA-08.02, CA-08.03, CA-08.06, CA-08.07) son responsabilidad de HU-10/HU-11.
- HU-09: Cerrar sesión — Lee de exercise_set para determinar estado completado vs incompleto. HU-06 proporciona los datos que HU-09 consumirá.
- HU-10: Clasificación de progresión — Lee exercise_set para calcular promedios de peso/reps/RIR y comparar con sesión anterior.
- HU-11: Señal de subir carga (Doble Umbral) — Lee exercise_set para verificar condiciones de progresión y escribir exercise_progression.prescribed_load_kg.
- HU-12: Detección de regresión y fatiga acumulada — Lee exercise_set (weight_kg, reps, rir) para comparar contra registro histórico y detectar regresión. Consumidor directo al mismo nivel que HU-10/HU-11.
- HU-13: Resumen post-sesión — Lee exercise_set para calcular tonelaje, promedios y clasificación visual.
- HU-17: Activar y gestionar ciclo de descarga — Lee exercise_set.weight_kg para calcular 60% (carga de descarga) y 90% (carga de reinicio). Ver Nota Técnica 9 sobre decisión diferida de precarga vs. carga prescrita post-descarga.
- HU-23: Historial y tendencia de carga de un ejercicio — Lee exercise_set (weight_kg, reps, rir) para mostrar historial completo por ejercicio, independiente de versión.
- HU-24: Historial de sesiones pasadas — Lee exercise_set para mostrar detalle de series registradas (peso, reps, RIR) en vista de sesión pasada.

**Validado por:** esteban.colorado | **Fecha:** 2026-02-14 | **Enfoque:** Exploratorio

---

### Hitos de implementación

| # | Entregable | Dependencia |
|---|---|---|
| 1 | Data Layer — DAOs: `ExerciseSetDao` (+3 métodos: `insert`, `getNextSetNumber`, `getLastWeightForExercise`), `SessionExerciseDao` (+`getExerciseInfoForSet` + `SetExerciseInfo`), `ExerciseProgressionDao` (+`insertIfNotExists`) | — |
| 2 | Domain — Model: `RegisterSetInfo` | — |
| 3 | Domain — Repository Interface: `SessionRepository` (+2 métodos: `getRegisterSetInfo`, `registerSet`) | Hito 2 |
| 4 | Domain — Use Cases: `GetRegisterSetInfoUseCase`, `RegisterSetUseCase` | Hito 3 |
| 5 | Data — Repository Impl: `SessionRepositoryImpl` (+2 métodos, +2 DAOs inyectados) | Hito 1, 3 |
| 6 | UI — State + ViewModel: `RegisterSetUiState`, `RegisterSetViewModel` | Hito 4 |
| 7 | UI — Screen: `RegisterSetScreen` (E2 completo con variantes estándar/bodyweight/isométrico) | Hito 6 |
| 8 | Navegación: `NavigationRoutes` (+REGISTER_SET), `TensionNavHost` (wiring E1→E2 + showBottomBar exclusión) | Hito 7 |
| 9 | Recursos: `strings.xml` (~12 strings E2) | — (independiente) |

### Notas de auditoría

1. **CA-06.01 (captura de 3 datos) se resuelve con 3 campos en E2.** OutlinedTextField "Peso (Kg)" + OutlinedTextField "Repeticiones" / "Segundos sostenidos" + Selector RIR (6 chips). Los 3 son obligatorios — el botón "Confirmar" se deshabilita hasta que todos tengan valor válido.
2. **CA-06.02 (máximo 3 toques) se cumple con precarga.** Con peso precargado: (1) reps, (2) RIR chip, (3) Confirmar. Sin precarga (primera sesión): 4 toques, aceptable dado la ausencia de historial.
3. **CA-06.03 (teclado numérico) se cumple via `keyboardType`.** Peso: `KeyboardType.Decimal` (permite decimales). Repeticiones/Segundos: `KeyboardType.Number` (solo enteros). RIR: chips de selección directa, no requiere teclado.
4. **CA-06.04 (precarga último peso) se cumple via `getLastWeightForExercise()`.** Query cross-session que busca la última serie del ejercicio. Retorna `null` si sin historial → campo vacío. Para bodyweight/isometric → value fijo `"0"`.
5. **CA-06.05 a CA-06.07 (validaciones) cubiertos con doble capa.** Validación en tiempo real en ViewModel (feedback inmediato) + validación en UseCase (defensa de integridad) + CHECK constraints en BD (última línea de defensa). 3 capas de protección.
6. **CA-06.08 (metadatos automáticos) se cumple por estructura relacional.** La cadena `exercise_set → session_exercise → session → module_version` proporciona fecha, módulo, versión, ejercicio y número de serie sin input del ejecutante.
7. **CA-06.09 (secuencia 1-2-3-4) se cumple con `COUNT(*) + 1`.** Dentro de transacción para evitar race conditions. UNIQUE constraint como safety net. Validación `<= 4` antes de INSERT.
8. **CA-06.10 (orden libre) se cumple por diseño.** Cada ejercicio es independiente — no hay secuencia forzada entre ejercicios ni entre series de distintos ejercicios.
9. **CA-06.11 (vinculación al sustituto) se cumple automáticamente.** `session_exercise.exercise_id` ya apunta al ejercicio efectivamente ejecutado tras sustitución (HU-07).
10. **CA-06.12 (estado visual) ya implementado en HU-05.** El Flow reactivo de Room actualiza E1 tras cada INSERT en `exercise_set` vía subquery COUNT. No requiere trabajo adicional.
11. **CA-06.13 (preservación ante cierre) se cumple por Room.** INSERT atómico en `withTransaction`. Datos persistidos inmediatamente tras commit. Crash recovery de B1 (HU-05) detecta sesión `IN_PROGRESS` y permite reanudar.
12. **RNF02 (3 toques) implementado via precarga + chips.** Flujo óptimo: reps → RIR chip → Confirmar = 3 toques.
13. **RNF03 (teclado numérico) implementado via `keyboardType`.** No se muestra teclado alfanumérico en ningún campo.
14. **RNF04 (precarga peso) implementado via `getLastWeightForExercise()`.** Cross-session, busca por exercise_id.
15. **RNF10 (crash recovery) cubierto por Room + HU-05 B1 Card "Reanudar".** Series ya registradas se preservan. Sesión `IN_PROGRESS` se detecta al reabrir.
16. **RNF12 (validación rangos) cubierto en 3 capas:** UI → UseCase → BD CHECK constraints.

### Riesgos y mitigaciones

| Riesgo | Probabilidad | Impacto | Mitigación |
|---|---|---|---|
| Condición de carrera en asignación de `set_number` (doble-tap rápido) | Baja | Alto | `database.withTransaction {}` serializa accesos. `UNIQUE(session_exercise_id, set_number)` como safety net. UI deshabilita botón via `isSaving = true` |
| LEFT JOIN `plan_assignment` falla con ejercicio sustituido (HU-07 futuro) | Nula en HU-06 | Alto en HU-07 | LEFT JOIN + `COALESCE(pa.sets, 4)` protege. En HU-06 no hay sustituciones |
| Registro de serie 5+ por error de lógica | Baja | Alto | Validación en repository (`nextSetNumber <= 4`). `CHECK(set_number >= 1 AND set_number <= 4)` en BD. UI no muestra "Registrar" en ejercicios COMPLETED |
| Pérdida de datos entre confirm y persist (crash) | Baja | Medio | Room transacción atómica: o se persiste todo o nada. No hay estado intermedio |
| Precarga del peso retorna valores del ejercicio en otra sesión | Esperado | Nulo | Comportamiento correcto por diseño: el peso del ejercicio es cross-session (CA-06.04) |
| El ejecutante mata la app antes de navegar back a E1 tras confirmar | Baja | Nulo | La serie ya está persistida (transacción committed). Al reabrir, B1 detecta sesión activa → E1 muestra la serie registrada |

### Verificación cruzada de CAs

| CA | Mecanismo de cumplimiento | Verificado contra |
|---|---|---|
| CA-06.01 | 3 campos obligatorios en E2: Peso, Reps/Segundos, RIR | Wireframes E2, Especificación Visual §8 E2, RF13 |
| CA-06.02 | Precarga peso + chips RIR = 3 toques (reps, chip, confirmar) | RNF02, Wireframes E2 §Comportamiento #7 |
| CA-06.03 | `keyboardType = Decimal/Number` en OutlinedTextField | RNF03, Especificación Visual §8 E2 |
| CA-06.04 | `getLastWeightForExercise()` cross-session | RNF04, Wireframes E2 #4 "Precargado con último peso" |
| CA-06.05 | `require(weightKg >= 0)` + CHECK en BD | RNF12, Modelo de Datos §3.12 |
| CA-06.06 | `require(reps >= 1)` + CHECK en BD | RNF12, Modelo de Datos §3.12 |
| CA-06.07 | Chips 0-5 (imposible seleccionar fuera de rango) + `require(rir in 0..5)` | RNF12, Modelo de Datos §3.12 |
| CA-06.08 | Relación `exercise_set → session_exercise → session → module_version` | MDS §5.A.5, RF14, Modelo de Datos §3.12 nota metadatos |
| CA-06.09 | `COUNT(*) + 1` en transacción + UNIQUE constraint | Modelo de Datos §3.12, RF15 |
| CA-06.10 | Botón "Registrar" independiente por ejercicio en E1 | Wireframes E1 #7, MDS §5.A.3 "el orden que decida" |
| CA-06.11 | `session_exercise.exercise_id` = ejercicio efectivo tras sustitución (HU-07) | Modelo de Datos §3.11, MDS §5.A.4 |
| CA-06.12 | `completedSets` derivado via COUNT subquery en E1 (HU-05 existente) | Modelo de Datos §3.11 "no se almacena — se deriva", RF17 |
| CA-06.13 | Room INSERT atómico + crash recovery B1 | RNF10, Modelo de Datos §3.12 "inmutable tras creación" |
