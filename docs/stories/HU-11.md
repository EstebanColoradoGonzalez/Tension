# HU-11 ‚Äî Prescribir carga objetivo seg√∫n Regla de Doble Umbral

## Requisitos relacionados

RF25, RF26, RF27, RF31

## Descripci√≥n

Como ejecutante, quiero que el sistema determine autom√°ticamente si debo subir de peso en un ejercicio seg√∫n la Regla de Doble Umbral y me prescriba la carga exacta para la pr√≥xima sesi√≥n, para progresar de forma sostenible bas√°ndome en evidencia propia y no en sensaciones subjetivas.

## Criterios de Aceptaci√≥n

### CA-11.01 ‚Äî Detecci√≥n de cumplimiento del Doble Umbral

**Dado que** el sistema eval√∫a un ejercicio al cerrar una sesi√≥n,
**cuando** el ejecutante alcanz√≥ ‚â• 12 repeticiones en al menos 3 de las 4 series **y** el RIR promedio de las 4 series fue ‚â• 2,
**entonces** el sistema se√±ala que el ejercicio est√° listo para incrementar carga, cumpliendo ambas condiciones de la Regla de Doble Umbral simult√°neamente.

### CA-11.02 ‚Äî Exigencia de ambas condiciones

**Dado que** el sistema eval√∫a un ejercicio al cerrar una sesi√≥n,
**cuando** solo una de las dos condiciones se cumple (ej: ‚â• 12 reps en 3/4 series pero RIR promedio < 2, o RIR promedio ‚â• 2 pero sin alcanzar 12 reps en 3/4 series),
**entonces** el sistema no se√±ala el ejercicio como listo para incrementar carga; ambas condiciones deben cumplirse simult√°neamente.

### CA-11.03 ‚Äî Incremento de carga para tren superior (M√≥dulos A y B)

**Dado que** un ejercicio de los M√≥dulos A o B cumple la Regla de Doble Umbral,
**cuando** el sistema calcula la carga objetivo para la pr√≥xima sesi√≥n,
**entonces** prescribe la carga actual + 2.5 Kg como nueva carga objetivo.

### CA-11.04 ‚Äî Incremento de carga para tren inferior (M√≥dulo C)

**Dado que** un ejercicio del M√≥dulo C cumple la Regla de Doble Umbral,
**cuando** el sistema calcula la carga objetivo para la pr√≥xima sesi√≥n,
**entonces** prescribe la carga actual + 5 Kg como nueva carga objetivo.

### CA-11.05 ‚Äî Reinicio del objetivo de repeticiones tras incremento

**Dado que** el sistema prescribe un incremento de carga para un ejercicio,
**cuando** determina los par√°metros para la pr√≥xima sesi√≥n,
**entonces** el objetivo de repeticiones se restablece al l√≠mite inferior del rango (8 repeticiones), esperando que el ejecutante progrese de 8 hacia 12 con la nueva carga.

### CA-11.06 ‚Äî Mantenimiento de carga cuando no se cumple el Doble Umbral

**Dado que** un ejercicio no cumple la Regla de Doble Umbral al cerrar la sesi√≥n (no alcanz√≥ ‚â• 12 reps en 3/4 series, o el RIR promedio fue < 2, o ambas),
**cuando** el sistema calcula la carga objetivo para la pr√≥xima sesi√≥n,
**entonces** prescribe la misma carga utilizada en la sesi√≥n actual, priorizando la progresi√≥n en repeticiones dentro del rango de 8 a 12.

### CA-11.07 ‚Äî Persistencia de la carga prescrita

**Dado que** el sistema ha calculado la carga objetivo para la pr√≥xima sesi√≥n de un ejercicio,
**cuando** completa el procesamiento post-sesi√≥n,
**entonces** persiste la carga prescrita de manera que al iniciar la pr√≥xima sesi√≥n que incluya ese ejercicio (HU-05), la carga objetivo se muestre correctamente.

### CA-11.08 ‚Äî No aplica a ejercicios de peso corporal

**Dado que** un ejercicio es de peso corporal (Peso = 0 Kg),
**cuando** el sistema eval√∫a si aplica la Regla de Doble Umbral,
**entonces** no aplica la regla ni prescribe incremento de carga, ya que la progresi√≥n de estos ejercicios se mide exclusivamente por repeticiones totales (CA-10.10).

> **Nota:** Cubre RF31 (exclusi√≥n de bodyweight del Doble Umbral). Criterio originalmente en HU-08 (ex CA-08.03), ya cubierto por este CA-11.08.

---

## An√°lisis Arquitect√≥nico (Arquitecto)

### Decisiones de Dise√±o

**1. HU-11 es l√≥gica pura de backend ‚Äî no tiene pantalla propia.**

Mapa de Navegaci√≥n ¬ß5 (fila HU-11): "representaci√≥n indirecta (output en pantallas existentes)". HU-11 produce un dato (`prescribed_load_kg`) que consumen E1 (HU-05: carga objetivo al iniciar sesi√≥n) y E5 (HU-13: se√±al "Subir carga ‚Üí X Kg" en resumen post-sesi√≥n). No hay UI ni ViewModel nuevos. La l√≥gica se ejecuta dentro de `evaluateProgression()` en `SessionRepositoryImpl`, extendiendo el punto de extensi√≥n ya establecido por HU-10.

**2. La Regla de Doble Umbral es una funci√≥n pura en `domain.rules` (ADR-06).**

ADR-06 establece reglas como funciones puras testeables sin emulador. Arquitectura T√©cnica ¬ß5.2 prescribe naming `{Nombre}Rule` ‚Äî ejemplo expl√≠cito: `DoubleThresholdRule`. HU-10 Nota T√©cnica 2 anticip√≥ este archivo como segundo en `domain/rules/`. La regla implementa MDS R1 (Doble Umbral) y R2 (Mantenimiento de carga) como operaciones complementarias.

**3. La "carga actual" es `avgWeightKg` de los sets de la sesi√≥n actual.**

MDS R1 dice: $Peso_{siguiente} = Peso_{actual} + \Delta_{min}$. El "peso actual" se interpreta como el peso promedio usado en la sesi√≥n actual (`ExerciseSessionData.avgWeightKg`), no el `prescribed_load_kg` anterior. Justificaci√≥n: el ejecutante puede no haber usado la carga prescrita (ajust√≥ por disponibilidad de equipo, sensaci√≥n del d√≠a, etc.). El peso real registrado es la fuente de verdad.

**4. Los incrementos provienen de la base de datos (`module.load_increment_kg`), no de constantes hardcodeadas.**

ADR D-07 sugiere constantes (`LOAD_INCREMENT_UPPER = 2.5`, `LOAD_INCREMENT_LOWER = 5.0`), pero la base de datos ya contiene estos valores en la tabla `module` (columna `load_increment_kg`: A=2.5, B=2.5, C=5.0), seeded por `ModuleSeeder`. Duplicar los valores en el motor de reglas crea dos fuentes de verdad ‚Äî si un valor cambia en seed data pero no en la constante (o viceversa), el comportamiento diverge silenciosamente. La decisi√≥n: **leer `load_increment_kg` desde la DB** extendiendo el DTO `SessionExerciseForProgression` con un campo `loadIncrementKg` (costo marginal: un JOIN adicional a `module`). La regla pura recibe el incremento como par√°metro ‚Äî sigue siendo testeable sin DB. ADR D-07 se reinterpreta: los VALORES son 2.5/5.0, pero la FUENTE es la tabla `module`, no constantes Kotlin.

**5. Bodyweight e isom√©tricos quedan excluidos ‚Äî `prescribed_load_kg` permanece `NULL`.**

CA-11.08 y RF31: No aplica el Doble Umbral a ejercicios de peso corporal. Los isom√©tricos son subconjunto de bodyweight (MDS R7, HU-10 Decisi√≥n 6). Para ambos tipos, `prescribed_load_kg` queda `NULL` permanentemente. El Modelo de Datos ¬ß3.13 lo confirma: *"`NULL` para ejercicios de peso corporal e isom√©tricos"*. El guard `isBodyweight || isIsometric` cortocircuita la evaluaci√≥n antes de invocar la regla.

**6. CA-11.05 (reinicio a 8 reps) no requiere almacenamiento ‚Äî es derivable.**

CA-11.05 dice "el objetivo de repeticiones se restablece al l√≠mite inferior del rango (8 repeticiones)". No hay columna `target_reps` en `exercise_progression` ni en ninguna otra tabla. El rango prescrito `8-12` ya est√° en `plan_assignment.reps` (Modelo de Datos ¬ß3.7) y la query `getBySessionIdWithDetails` ya lo incluye como `reps: String` en `SessionExerciseWithDetails`. Cuando `prescribed_load_kg` sube (Doble Umbral cumplido), la UI de E1 ya muestra el rango `8-12` ‚Äî el ejecutante sabe que debe apuntar a 8 reps con la nueva carga. No se requiere persistencia adicional.

**7. La evaluaci√≥n del Doble Umbral es POSTERIOR a la clasificaci√≥n de HU-10.**

El flujo dentro de `evaluateProgression()` es secuencial por ejercicio: (1) HU-10 clasifica progresi√≥n, (2) HU-10 actualiza estado + contador, (3) **HU-11 prescribe carga**. El paso 3 usa datos del paso 1 (clasificaci√≥n) y datos frescos (sets actuales). `prescribed_load_kg` se persiste en la misma llamada `exerciseProgressionDao.update()` que ya actualiza `status` y `sessionsWithoutProgression` ‚Äî se extiende el `copy()` existente para incluir `prescribedLoadKg`.

**8. La prescripci√≥n de carga se ejecuta siempre ‚Äî no solo cuando hay Doble Umbral.**

CA-11.06 requiere que cuando NO se cumple el Doble Umbral, la carga se mantenga. Esto significa que HU-11 siempre calcula `prescribed_load_kg`: si se cumple ‚Üí carga + incremento; si no se cumple ‚Üí carga actual (mantenimiento). Para ejercicios est√°ndar, el valor NUNCA queda `NULL` despu√©s de la primera sesi√≥n con sets. Solo queda `NULL` para bodyweight/isom√©tricos y para ejercicios que nunca se han ejecutado.

### Componentes Nuevos

**1. `DoubleThresholdRule`** ‚Äî `domain/rules/DoubleThresholdRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

import com.estebancoloradogonzalez.tension.domain.model.ExerciseSessionData

object DoubleThresholdRule {

    const val REP_THRESHOLD = 12
    const val MIN_SERIES_MEETING_REP_THRESHOLD = 3
    const val REQUIRED_SETS = 4
    const val RIR_THRESHOLD = 2.0

    fun meetsDoubleThreshold(current: ExerciseSessionData): Boolean {
        if (current.setCount < REQUIRED_SETS) return false

        val seriesMeetingRepThreshold = current.sets.count { it.reps >= REP_THRESHOLD }
        val meetsRepCondition = seriesMeetingRepThreshold >= MIN_SERIES_MEETING_REP_THRESHOLD
        val meetsRirCondition = current.avgRir >= RIR_THRESHOLD

        return meetsRepCondition && meetsRirCondition
    }

    fun prescribeLoad(
        currentAvgWeightKg: Double,
        loadIncrementKg: Double,
        meetsThreshold: Boolean,
    ): Double {
        if (!meetsThreshold) return currentAvgWeightKg
        return currentAvgWeightKg + loadIncrementKg
    }
}
```

Funci√≥n pura, testeable unitariamente sin emulador (ADR-06, RNF29, RNF30). Opera sobre modelos de dominio (`ExerciseSessionData`). La condici√≥n del Doble Umbral verifica AMBOS criterios simult√°neamente (CA-11.02):

- **Reps:** ‚â• 12 en al menos 3 de 4 series ‚Üí `seriesMeetingRepThreshold >= 3`
- **RIR:** Promedio ‚â• 2 ‚Üí `avgRir >= 2.0`
- **Guard:** `setCount < 4` ‚Üí `false` ‚Äî CA-11.01 y RF25 dicen "3 de las 4 series", por lo que se requieren las 4 series completas

`prescribeLoad()` recibe `loadIncrementKg` como par√°metro (le√≠do de la DB), no como constante interna. Es idempotente ‚Äî dado los mismos inputs, produce el mismo output.

### Componentes Modificados

**2. `SessionExerciseDao.kt`** ‚Äî extender DTO y query con `loadIncrementKg`

```kotlin
data class SessionExerciseForProgression(
    val sessionExerciseId: Long,
    val exerciseId: Long,
    val isBodyweight: Int,
    val isIsometric: Int,
    val moduleCode: String,
    val loadIncrementKg: Double,
)
```

Query actualizada ‚Äî agrega JOIN a `module` y selecciona `load_increment_kg`:

```sql
SELECT 
    se.id AS sessionExerciseId,
    se.exercise_id AS exerciseId,
    e.is_bodyweight AS isBodyweight,
    e.is_isometric AS isIsometric,
    e.module_code AS moduleCode,
    m.load_increment_kg AS loadIncrementKg
FROM session_exercise se
INNER JOIN exercise e ON se.exercise_id = e.id
INNER JOIN module m ON e.module_code = m.code
WHERE se.session_id = :sessionId
```

El JOIN a `module` es de costo marginal (PK string lookup) y elimina la duplicaci√≥n de constantes con la BD.

**3. `SessionRepositoryImpl.evaluateProgression()`** ‚Äî extender con prescripci√≥n de carga

El flujo actual (HU-10) para cada ejercicio es:
1. Obtener sets actuales y hist√≥ricos
2. Clasificar progresi√≥n
3. Actualizar `session_exercise.progression_classification`
4. Resolver nuevo estado de progresi√≥n
5. Actualizar `exercise_progression` (status + counter)

HU-11 agrega un paso 5b entre el paso 4 y 5:
- Si el ejercicio es bodyweight o isom√©trico ‚Üí `prescribedLoadKg` = `null` (sin cambio)
- Si no ‚Üí evaluar Doble Umbral ‚Üí calcular `prescribedLoadKg`
- Incluir `prescribedLoadKg` en el `copy()` de `exerciseProgressionDao.update()`

```kotlin
private suspend fun evaluateProgression(sessionId: Long) {
    val exercises = sessionExerciseDao.getSessionExercisesForProgression(sessionId)

    for (exercise in exercises) {
        val currentSetDtos = exerciseSetDao.getSetsForSessionExercise(
            exercise.sessionExerciseId,
        )
        if (currentSetDtos.isEmpty()) continue

        val currentData = ExerciseSessionData(
            sets = currentSetDtos.map { SetData(it.weightKg, it.reps, it.rir) },
        )

        val previousSetDtos = exerciseSetDao.getLastHistoricalSets(
            exercise.exerciseId,
            sessionId,
        )
        val previousData = if (previousSetDtos.isNotEmpty()) {
            ExerciseSessionData(
                sets = previousSetDtos.map { SetData(it.weightKg, it.reps, it.rir) },
            )
        } else {
            null
        }

        val isBodyweight = exercise.isBodyweight == 1
        val isIsometric = exercise.isIsometric == 1

        val classification = ProgressionClassificationRule.classify(
            current = currentData,
            previous = previousData,
            isBodyweight = isBodyweight,
            isIsometric = isIsometric,
        )

        sessionExerciseDao.updateProgressionClassification(
            exercise.sessionExerciseId,
            classification?.name,
        )

        val isMastered = isIsometric &&
            ProgressionClassificationRule.isIsometricMastered(currentData)

        val currentProgression = exerciseProgressionDao
            .getByExerciseId(exercise.exerciseId).first()

        if (currentProgression == null) continue

        val (newStatus, newCounter) =
            ProgressionClassificationRule.resolveNewProgressionState(
                currentStatus = currentProgression.status,
                currentCounter = currentProgression.sessionsWithoutProgression,
                classification = classification,
                isIsometric = isIsometric,
                isMastered = isMastered,
            )

        // Step 5b: Prescribe load (HU-11)
        val prescribedLoadKg = if (isBodyweight || isIsometric) {
            null
        } else {
            val meetsThreshold = DoubleThresholdRule.meetsDoubleThreshold(currentData)
            DoubleThresholdRule.prescribeLoad(
                currentAvgWeightKg = currentData.avgWeightKg,
                loadIncrementKg = exercise.loadIncrementKg,
                meetsThreshold = meetsThreshold,
            )
        }

        exerciseProgressionDao.update(
            currentProgression.copy(
                status = newStatus,
                sessionsWithoutProgression = newCounter,
                prescribedLoadKg = prescribedLoadKg,
            ),
        )
    }
}
```

Cambios respecto al c√≥digo HU-10 existente: (a) calcular `prescribedLoadKg` antes del `update`, (b) incluirlo en el `copy()`, y (c) usar `exercise.loadIncrementKg` del DTO. El import de `DoubleThresholdRule` se agrega en la secci√≥n de imports.

### Verificaci√≥n Exhaustiva CA por CA

**CA-11.01 ‚Äî Detecci√≥n de cumplimiento del Doble Umbral:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `DoubleThresholdRule.meetsDoubleThreshold(currentData)` | Verifica ambas condiciones sobre `ExerciseSessionData` |
| Condici√≥n reps | `sets.count { it.reps >= 12 } >= 3` | ‚â• 12 reps en ‚â• 3 de 4 series |
| Condici√≥n RIR | `avgRir >= 2.0` | RIR promedio ‚â• 2 |
| MDS R1 | F√≥rmula del Doble Umbral | Match exacto |

**CA-11.02 ‚Äî Exigencia de ambas condiciones:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `return meetsRepCondition && meetsRirCondition` | Operador AND ‚Äî ambas deben ser true |
| Guard | `setCount < REQUIRED_SETS (4) ‚Üí false` | Si hay <4 sets, no se eval√∫a (RF25: "3 de las 4 series") |

**CA-11.03 ‚Äî Incremento de carga para tren superior (M√≥dulos A y B):**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| DB | `module.load_increment_kg = 2.5` para m√≥dulos A y B | `ModuleSeeder`: A=2.5, B=2.5 |
| Rule | `prescribeLoad(loadIncrementKg = 2.5)` | Recibe incremento como par√°metro |
| C√°lculo | `currentAvgWeightKg + 2.5` | Peso actual + incremento |

**CA-11.04 ‚Äî Incremento de carga para tren inferior (M√≥dulo C):**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|----------|
| DB | `module.load_increment_kg = 5.0` para m√≥dulo C | `ModuleSeeder`: C=5.0 |
| Rule | `prescribeLoad(loadIncrementKg = 5.0)` | Recibe incremento como par√°metro |
| C√°lculo | `currentAvgWeightKg + 5.0` | Peso actual + incremento |

**CA-11.05 ‚Äî Reinicio del objetivo de repeticiones tras incremento:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Derivable | Sin persistencia ‚Äî rango `8-12` ya en `plan_assignment.reps` | `SessionExerciseWithDetails.reps` = `"8-12"` |
| UX | Con nueva carga, el ejecutante apunta a 8 reps | Modelo de Datos no tiene columna `target_reps` |
| MDS R1 | "reestablece el objetivo de repeticiones al l√≠mite inferior del rango" | Impl√≠cito por el rango prescrito |

**CA-11.06 ‚Äî Mantenimiento de carga cuando no se cumple el Doble Umbral:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `if (!meetsThreshold) return currentAvgWeightKg` | `prescribeLoad()` con flag false |
| MDS R2 | "la carga se mantiene para la pr√≥xima sesi√≥n" | `prescribed_load_kg` = peso actual |
| RF27 | "prescribir la misma carga" | Match exacto |

**CA-11.07 ‚Äî Persistencia de la carga prescrita:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Repository | `exerciseProgressionDao.update(currentProgression.copy(prescribedLoadKg = ...))` | Persistido en `exercise_progression.prescribed_load_kg` |
| Consumo | E1 ‚Üí `SessionExerciseWithDetails.prescribedLoadKg` (JOIN ya existe) | Query `getBySessionIdWithDetails` ya incluye `ep.prescribed_load_kg` |
| Modelo de Datos | ¬ß3.13: "Calculada por el motor de Doble Umbral al cierre de sesi√≥n y persistida" | Match exacto |

**CA-11.08 ‚Äî No aplica a ejercicios de peso corporal:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Guard | `if (isBodyweight \|\| isIsometric) ‚Üí prescribedLoadKg = null` | Skip antes de invocar regla |
| RF31 | "sin aplicar la Regla de Doble Umbral de carga" | Match exacto |
| Modelo de Datos | ¬ß3.13: "`NULL` para ejercicios de peso corporal e isom√©tricos" | Match exacto |

### Validaci√≥n de Impacto

**Archivos nuevos:**

| Archivo | Prop√≥sito |
|---|---|
| `domain/rules/DoubleThresholdRule.kt` | Regla pura: evaluaci√≥n Doble Umbral + prescripci√≥n de carga |
| `test/.../domain/rules/DoubleThresholdRuleTest.kt` | Tests unitarios de la regla |

**Archivos modificados:**

| Archivo | Acci√≥n | Secci√≥n |
|---|---|---|
| `SessionExerciseDao.kt` | Agregar `loadIncrementKg` al DTO + JOIN a `module` en query | `getSessionExercisesForProgression()` |
| `SessionRepositoryImpl.kt` | Agregar c√°lculo de `prescribedLoadKg` + import `DoubleThresholdRule` | `evaluateProgression()` |

**Archivos NO tocados:**

| Archivo | Raz√≥n |
|---|---|
| `ProgressionClassificationRule.kt` | Sin cambios ‚Äî HU-11 es una regla independiente |
| `ExerciseSessionData.kt` | Sin cambios ‚Äî `avgWeightKg`, `avgRir`, `setCount`, `sets` ya existen |
| `SetData.kt` | Sin cambios ‚Äî `reps`, `rir`, `weightKg` ya existen |
| `ProgressionClassification.kt` | Sin cambios |
| `ExerciseProgressionEntity.kt` | Sin cambios ‚Äî `prescribedLoadKg: Double?` ya existe |
| `ExerciseProgressionDao.kt` | Sin cambios ‚Äî `update()` ya acepta el entity completo |
| `ExerciseSetDao.kt` | Sin cambios ‚Äî queries de HU-10 son suficientes |
| `SessionRepository.kt` | Sin cambios ‚Äî interfaz mantiene misma firma |
| `CloseSessionUseCase.kt` | Sin cambios ‚Äî sigue delegando a `closeSession()` |
| `SessionExerciseWithDetails` | Sin cambios ‚Äî ya incluye `prescribedLoadKg` por JOIN con `exercise_progression` |
| `ActiveSessionViewModel.kt` | Sin cambios ‚Äî HU-11 no tiene UI |
| `ActiveSessionScreen.kt` | Sin cambios ‚Äî ya muestra `prescribedLoadKg` cuando no es null (HU-05) |

### Notas T√©cnicas

1. **HU-11 agrega 0 queries nuevas, solo extiende 1 existente.** La query `getSessionExercisesForProgression` se extiende con un JOIN a `module` para obtener `load_increment_kg`. El resto de la informaci√≥n ya est√° disponible en el loop: `currentData` (sets con reps, rir, weight), `exercise.isBodyweight`, `exercise.isIsometric`. El `moduleCode` fue previsto por HU-10 Nota T√©cnica 5.

2. **El `avgWeightKg` usa el peso PROMEDIO de los sets, no la moda ni el m√°ximo.** En la pr√°ctica, todas las series de un ejercicio se ejecutan con el mismo peso (el peso prescrito o disponible). Pero si el ejecutante ajust√≥ el peso intra-ejercicio (ej: warm-up set, strip set), el promedio refleja mejor la intensidad real. El Modelo de Datos ¬ß3.12 registra `weight_kg` por set individual ‚Äî el promedio se computa desde los datos reales.

3. **El guard `setCount < REQUIRED_SETS (4)` en `meetsDoubleThreshold`.** CA-11.01 y RF25 dicen expl√≠citamente "al menos 3 **de las 4 series**", fijando 4 como la cantidad requerida. Si el ejercicio tiene <4 sets (sesi√≥n incompleta), el Doble Umbral no se eval√∫a ‚Äî la carga se mantiene (CA-11.06 fallback). Esto previene que una sesi√≥n con 3 sets brillantes active un incremento prematuro. La constante `REQUIRED_SETS = 4` hace expl√≠cita esta decisi√≥n.

4. **La constante `RIR_THRESHOLD = 2.0` es Double, no Int.** Aunque el RIR se registra como Int (0-5) por set, el promedio de 4 sets es un Double. La comparaci√≥n `avgRir >= 2.0` es consistente con el tipo. Ejemplo: sets con RIR [2, 2, 1, 2] ‚Üí promedio = 1.75 ‚Üí NO cumple (< 2.0).

5. **`prescribeLoad()` siempre retorna un valor.** No retorna `null` ‚Äî para ejercicios est√°ndar, siempre hay una carga prescrita (la actual o la incrementada). El `null` solo ocurre para bodyweight/isom√©tricos, y ese caso se resuelve en el guard del repositorio ANTES de invocar la regla. La separaci√≥n de responsabilidades es clara: el repositorio decide SI prescribir; la regla decide CU√ÅNTO.

6. **La prescripci√≥n de carga durante `IN_DELOAD` sigue el flujo normal.** HU-10 ya guarda el estado `IN_DELOAD` (no lo modifica). HU-11 prescribe la carga basada en los sets reales de la sesi√≥n de descarga (que son al 60% de la carga habitual). Cuando la descarga termine (HU-17), la carga se reiniciar√° al 90% de la pre-descarga ‚Äî eso es responsabilidad de HU-17 (CA-17.05), no de HU-11. HU-11 simplemente prescribe carga actual + incremento (si aplica) o carga actual (si no aplica), independientemente del estado de descarga.

7. **El Doble Umbral NO depende de la clasificaci√≥n de progresi√≥n.** Son evaluaciones independientes: la clasificaci√≥n de HU-10 compara contra historial (sesi√≥n actual vs anterior); el Doble Umbral eval√∫a solo la sesi√≥n actual (¬øcumpli√≥ los umbrales de reps y RIR?). Un ejercicio puede tener `MAINTENANCE` (misma carga, mismas reps) y aun as√≠ cumplir el Doble Umbral (12+ reps con RIR ‚â• 2) ‚Äî en ese caso, se prescribe incremento.

### Historias Relacionadas

**Predecesoras (datos que HU-11 consume):**

- HU-05: Cre√≥ `ExerciseProgressionEntity` con `prescribedLoadKg`. Implement√≥ el JOIN en `getBySessionIdWithDetails` que muestra `prescribedLoadKg` en E1. Infraestructura de persistencia ya lista.
- HU-06: Persisti√≥ datos de `exercise_set` (peso, reps, RIR) que HU-11 eval√∫a para el Doble Umbral.
- HU-10: Estableci√≥ `evaluateProgression()` con el loop por ejercicio, los datos de sesi√≥n (`currentData`, `exercise.moduleCode`) y la llamada a `exerciseProgressionDao.update()` que HU-11 extiende.

**Sucesoras (dependen de HU-11):**

- HU-13: E5 (Resumen Post-Sesi√≥n) ‚Äî mostrar√° "Subir carga ‚Üí X Kg" cuando `prescribed_load_kg` > carga actual, o "Mantener carga" cuando son iguales. Leer√° `exercise_progression.prescribed_load_kg`.
- HU-15: Recomendaciones escalonadas ‚Äî sesi√≥n 4 recomendar√° microincremento (MDS R3: "1.25 Kg si est√° disponible, o a√±adir 1 rep por serie"). Podr√° usar `prescribed_load_kg` como base.
- HU-17: Protocolo de descarga ‚Äî post-descarga la carga se reinicia al 90% de la pre-descarga (CA-17.05). HU-17 escribir√° directamente sobre `prescribed_load_kg`.

**Consumidoras indirectas:**

- HU-20: M√©tricas globales ‚Äî podr√° derivar progresi√≥n de carga comparando `prescribed_load_kg` a lo largo del tiempo.
- HU-22: KPIs por ejercicio ‚Äî tasa de progresi√≥n de carga.
- HU-23: Historial de ejercicio (F3) ‚Äî podr√° mostrar evoluci√≥n de carga prescrita.

### Referencias y Validaci√≥n

**Documentaci√≥n consultada:**

- MDS ¬ß6-A Regla 1: Doble Umbral ‚Äî f√≥rmula completa y condiciones.
- MDS ¬ß6-A Regla 2: Mantenimiento de carga ‚Äî cuando R1 no se cumple.
- MDS ¬ß6-A Regla 6: Peso corporal ‚Äî exclusi√≥n del Doble Umbral.
- Modelo de Datos ¬ß3.13 (`exercise_progression`): columna `prescribed_load_kg` con l√≥gica de step 6.
- ADR-06: Motor de reglas como Kotlin puro en `domain.rules`.
- ADR D-07: Valores de incremento 2.5/5.0 ‚Äî fuente real: `module.load_increment_kg` en la BD.
- Arquitectura T√©cnica ¬ß5.2: Naming `DoubleThresholdRule`.
- HU-10 an√°lisis: Nota T√©cnica 2 (primer archivo en `domain/rules/`), Nota T√©cnica 5 (`moduleCode` proactivo).
- HU-10 implementaci√≥n: `evaluateProgression()` como punto de extensi√≥n.
- Requerimientos: RF25, RF26, RF27, RF31.

### Verificaci√≥n Cruzada de CAs

| CA | Estado | Mecanismo | Implementado en |
|---|---|---|---|
| CA-11.01 | üî® Por implementar | `meetsDoubleThreshold()` ‚Äî verifica reps ‚â• 12 en ‚â• 3 series AND avgRir ‚â• 2 | HU-11 (Rule) |
| CA-11.02 | üî® Por implementar | `&&` operator ‚Äî ambas condiciones simult√°neas | HU-11 (Rule) |
| CA-11.03 | üî® Por implementar | `prescribeLoad(loadIncrementKg = 2.5)` ‚Äî incremento le√≠do de `module.load_increment_kg` | HU-11 (Rule + DTO) |
| CA-11.04 | üî® Por implementar | `prescribeLoad(loadIncrementKg = 5.0)` ‚Äî incremento le√≠do de `module.load_increment_kg` | HU-11 (Rule + DTO) |
| CA-11.05 | ‚úÖ Ya cubierto | Derivable ‚Äî rango `8-12` en `plan_assignment.reps` | HU-05 (query existente) |
| CA-11.06 | üî® Por implementar | `prescribeLoad()` con `meetsThreshold = false` ‚Üí misma carga | HU-11 (Rule) |
| CA-11.07 | üî® Por implementar | `exerciseProgressionDao.update(copy(prescribedLoadKg = ...))` | HU-11 (Repository) |
| CA-11.08 | üî® Por implementar | Guard `isBodyweight \|\| isIsometric ‚Üí null` | HU-11 (Repository) |

### Hitos de implementaci√≥n

| # | Entregable | Archivos | CAs |
|---|---|---|---|
| 1 | Regla pura ‚Äî `DoubleThresholdRule` + tests unitarios exhaustivos | `DoubleThresholdRule.kt`, `DoubleThresholdRuleTest.kt` | CA-11.01, CA-11.02, CA-11.03, CA-11.04, CA-11.06 |
| 2 | DTO + query ‚Äî extender `SessionExerciseForProgression` con `loadIncrementKg` | `SessionExerciseDao.kt` | CA-11.03, CA-11.04 |
| 3 | Integraci√≥n ‚Äî extender `evaluateProgression()` con prescripci√≥n de carga | `SessionRepositoryImpl.kt` | CA-11.07, CA-11.08 |

---

## Refinamiento T√©cnico (Developer)

<!-- ============================================================================ -->
<!-- SECCI√ìN AGREGADA POR: Workflow refinamiento-tecnico                         -->
<!-- ETAPA: Refinamiento T√©cnico                                                  -->
<!-- RESPONSABLE: Developer                                                       -->
<!-- BASE: An√°lisis Arquitect√≥nico (Arquitecto) - Ver secci√≥n arriba             -->
<!-- FECHA: 2026-02-15                                                            -->
<!-- ESTADO: Refinado (Developer) - Basado en An√°lisis Arquitect√≥nico             -->
<!-- ============================================================================ -->

### Consideraciones Generales

**Basado en an√°lisis arquitect√≥nico:**
An√°lisis Arquitect√≥nico de HU-11 con 8 decisiones de dise√±o, 3 hitos de implementaci√≥n, 3 componentes (1 nuevo + 2 modificados). Hallazgos principales: (1) HU-11 es l√≥gica pura de backend ‚Äî no hay UI, ViewModel ni pantalla nueva. (2) La Regla de Doble Umbral es funci√≥n pura en `domain/rules/DoubleThresholdRule.kt` (ADR-06, Arquitectura T√©cnica ¬ß5.2). (3) Los incrementos de carga provienen de `module.load_increment_kg` en la BD, no de constantes hardcodeadas (reinterpretaci√≥n ADR D-07). (4) `prescribeLoad()` siempre retorna valor para ejercicios est√°ndar: carga+incremento (si cumple) o carga actual (si no cumple). (5) Bodyweight e isom√©tricos quedan excluidos con guard (`prescribedLoadKg = null`). (6) La evaluaci√≥n se integra dentro del loop existente de `evaluateProgression()` como paso 5b, extendiendo el `copy()` del `exerciseProgressionDao.update()`. (7) CA-11.05 (reinicio a 8 reps) es derivable ‚Äî sin persistencia adicional. (8) El Doble Umbral es INDEPENDIENTE de la clasificaci√≥n de progresi√≥n (HU-10).

**Nivel de complejidad:**
BAJA ‚Äî HU-11 toca 4 archivos (2 nuevos + 2 modificados) con l√≥gica sencilla y predecible. La regla pura tiene 2 funciones simples (`meetsDoubleThreshold` + `prescribeLoad`), sin ramificaci√≥n compleja ni m√°quina de estados. La integraci√≥n extiende c√≥digo existente (HU-10) con adiciones m√≠nimas: 1 campo nuevo en DTO, 1 JOIN adicional en query, ~10 l√≠neas de l√≥gica en `evaluateProgression()`. Los tests son combinatorios pero de baja complejidad (~12 escenarios). No hay componentes UI.

**Riesgos t√©cnicos conocidos:**

1. **JOIN adicional a `module` en query de progresi√≥n:** La query `getSessionExercisesForProgression` agrega un JOIN a `module` (via `exercise.module_code = module.code`). El costo es marginal ‚Äî lookup por PK string, tabla `module` tiene solo 3 filas. El JOIN ya existe impl√≠citamente en la cadena `exercise ‚Üí module` y los √≠ndices est√°n presentes (`module_code` indexado en `exercise`).
2. **`avgWeightKg` como base de prescripci√≥n:** En escenarios normales, todas las series usan el mismo peso, por lo que `avgWeightKg` = peso real. En caso extremo de pesos diferentes intra-ejercicio, el promedio podr√≠a producir un valor no est√°ndar (ej: 47.5 Kg). Esto es aceptable ‚Äî la UI muestra el valor con un decimal y el ejecutante ajusta al equipo disponible.
3. **Prescripci√≥n de carga durante `IN_DELOAD`:** HU-11 prescribe carga normalmente durante descarga. El valor se sobrescribir√° por HU-17 (90% de pre-descarga, CA-17.05) al finalizar el protocolo. No hay conflicto ‚Äî el flujo es secuencial.

**Patrones y convenciones del equipo (establecidos en HU-01‚ÄîHU-10):**

- C√≥digo fuente en ingl√©s, UI y datos de dominio en espa√±ol (Arquitectura T√©cnica ¬ß5.1)
- Naming: `{Nombre}Rule` para reglas del motor (¬ß5.2) ‚Äî `DoubleThresholdRule`
- `object` singleton para reglas puras (patr√≥n `ProgressionClassificationRule`, `RotationResolver`)
- DTOs de DAO como `data class` con sufijo descriptivo (patr√≥n `SessionExerciseForProgression`)
- Funciones puras testeables sin emulador, mocks ni coroutines (ADR-06)
- Constantes como `const val` dentro del `object` (patr√≥n `RIR_SIGNIFICANT_RISE = 1.5` en `ProgressionClassificationRule`)
- `exerciseProgressionDao.update(currentProgression.copy(...))` ‚Äî patr√≥n ya establecido en HU-10 L372-375

**Dependencias nuevas a instalar:**
Ninguna.

**Estrategia de testing:**
JUnit 4 (sin MockK ‚Äî funci√≥n pura) | `DoubleThresholdRuleTest` con ~12 escenarios: `meetsDoubleThreshold()` √ó (cumple ambas / solo reps / solo RIR / ninguna / <4 sets / boundary 12 reps / boundary 2.0 RIR) + `prescribeLoad()` √ó (cumple ‚Üí incremento / no cumple ‚Üí mantiene / diferentes incrementos / carga 0). Foco en cobertura de condiciones del Doble Umbral y valores de prescripci√≥n.

### Historias Relacionadas Consultadas

**Implementaciones similares analizadas:**

- HU-10 (ProgressionClassificationRule) ‚Äî Implement√≥ `evaluateProgression()` con el loop por ejercicio, cre√≥ `ProgressionClassificationRule` como `object` en `domain/rules/`, y estableci√≥ el patr√≥n `exerciseProgressionDao.update(currentProgression.copy(status=..., sessionsWithoutProgression=...))`. HU-11 extiende este `copy()` agregando `prescribedLoadKg`. El `moduleCode` fue proactivamente incluido en `SessionExerciseForProgression` (HU-10 Nota 5) ‚Äî ahora se complementa con `loadIncrementKg` (lectura directa del valor desde BD).
- HU-05 (SessionExerciseWithDetails) ‚Äî Implement√≥ el LEFT JOIN a `exercise_progression` en `getBySessionIdWithDetails` que ya lee `ep.prescribed_load_kg AS prescribedLoadKg`. Este es el consumer final del valor que HU-11 escribe: al iniciar la pr√≥xima sesi√≥n, E1 muestra la carga objetivo.
- HU-06 (RegisterSet) ‚Äî Cre√≥ `ExerciseProgressionEntity` con `insertIfNotExists()` (L221 SessionRepositoryImpl). Garantiza que la entidad existe antes de que HU-10/HU-11 la lean/actualicen.

**Patrones de c√≥digo reutilizados:**

- `object` singleton con funciones puras: `ProgressionClassificationRule.classify()` ‚Üí `DoubleThresholdRule.meetsDoubleThreshold()` + `prescribeLoad()`
- Extension del `copy()` en `exerciseProgressionDao.update()`: HU-10 ya hace `copy(status=..., sessionsWithoutProgression=...)` ‚Üí HU-11 agrega `prescribedLoadKg=...`
- DTO extension con JOIN adicional: `SessionExerciseForProgression` ya tiene `moduleCode` ‚Üí se agrega `loadIncrementKg` con JOIN a `module`
- Helper factories en tests: `sessionData(vararg sets)` + `set(weightKg, reps, rir)` ‚Äî patr√≥n de `ProgressionClassificationRuleTest`

**Mejores pr√°cticas aplicadas:**

- Incremento de carga le√≠do de BD (`module.load_increment_kg`) en vez de constantes Kotlin ‚Äî una sola fuente de verdad
- Guard `isBodyweight || isIsometric` antes de invocar regla ‚Äî separaci√≥n: repositorio decide SI, regla decide CU√ÅNTO
- `prescribeLoad()` recibe incremento como par√°metro ‚Üí testeable con cualquier valor de incremento sin DB
- `meetsDoubleThreshold()` requiere `setCount >= 4` ‚Äî previene incremento prematuro en sesiones incompletas

---

## Tareas de Implementaci√≥n (Developer)

### Fase 1: Domain ‚Äî Regla pura + tests exhaustivos

<!-- Basado en Hito #1 del An√°lisis Arquitect√≥nico -->

#### üì¶ Domain Rules

- [ ] **Crear `DoubleThresholdRule`** (AC: 1, 2, 3, 4, 6)
  - [ ] Crear archivo: `domain/rules/DoubleThresholdRule.kt`
  - [ ] Constantes: `REP_THRESHOLD = 12`, `MIN_SERIES_MEETING_REP_THRESHOLD = 3`, `REQUIRED_SETS = 4`, `RIR_THRESHOLD = 2.0`
  - [ ] `fun meetsDoubleThreshold(current: ExerciseSessionData): Boolean` ‚Äî guard `setCount < 4` ‚Üí false, luego verifica reps ‚â• 12 en ‚â• 3 series AND avgRir ‚â• 2.0
  - [ ] `fun prescribeLoad(currentAvgWeightKg: Double, loadIncrementKg: Double, meetsThreshold: Boolean): Double` ‚Äî si cumple: carga + incremento, si no: carga actual
- [ ] **Test unitario `DoubleThresholdRuleTest`** (AC: 1, 2, 3, 4, 6)
  - [ ] Crear archivo: `src/test/java/com/estebancoloradogonzalez/tension/domain/rules/DoubleThresholdRuleTest.kt`
  - [ ] Reutilizar helpers: `sessionData(vararg sets)` + `set(weightKg, reps, rir)`
  - [ ] **meetsDoubleThreshold tests (~7):**
    - [ ] 4 sets √ó 12 reps √ó RIR 2 ‚Üí `true` (ambas condiciones OK, CA-11.01)
    - [ ] 3 sets √ó 12 reps + 1 set √ó 11 reps, RIR avg ‚â• 2 ‚Üí `true` (3/4 es suficiente, CA-11.01)
    - [ ] 4 sets √ó 12 reps pero RIR avg < 2 ‚Üí `false` (solo reps, CA-11.02)
    - [ ] 4 sets √ó 10 reps pero RIR avg ‚â• 2 ‚Üí `false` (solo RIR, CA-11.02)
    - [ ] 3 sets √ó 10 reps + 1 set √ó 12 reps, RIR avg ‚â• 2 ‚Üí `false` (solo 1/4 series, CA-11.02)
    - [ ] 3 sets √∫nicamente (sesi√≥n incompleta) ‚Üí `false` (guard setCount < 4)
    - [ ] Boundary: 4 sets con RIR [2,2,2,1] ‚Üí avg 1.75 ‚Üí `false` (< 2.0, Nota 4)
  - [ ] **prescribeLoad tests (~4):**
    - [ ] Cumple + incremento 2.5 ‚Üí 40.0 + 2.5 = 42.5 (CA-11.03, m√≥dulo A/B)
    - [ ] Cumple + incremento 5.0 ‚Üí 60.0 + 5.0 = 65.0 (CA-11.04, m√≥dulo C)
    - [ ] No cumple ‚Üí 40.0 (misma carga, CA-11.06)
    - [ ] Cumple + carga 0.0 + incremento 2.5 ‚Üí 2.5 (edge case primer peso)

### Fase 2: Data ‚Äî DTO + query extension

<!-- Basado en Hito #2 del An√°lisis Arquitect√≥nico -->

#### üì¶ Data Layer

- [ ] **Extender DTO y query en `SessionExerciseDao`** (AC: 3, 4)
  - [ ] Agregar campo `loadIncrementKg: Double` al data class `SessionExerciseForProgression`
  - [ ] Modificar query `getSessionExercisesForProgression`: agregar `INNER JOIN module m ON e.module_code = m.code` y seleccionar `m.load_increment_kg AS loadIncrementKg`

### Fase 3: Data ‚Äî Integraci√≥n en evaluateProgression()

<!-- Basado en Hito #3 del An√°lisis Arquitect√≥nico -->

#### üì¶ Repository

- [ ] **Extender `evaluateProgression()` en `SessionRepositoryImpl`** (AC: 7, 8)
  - [ ] Agregar import: `com.estebancoloradogonzalez.tension.domain.rules.DoubleThresholdRule`
  - [ ] Agregar paso 5b entre resolveNewProgressionState y exerciseProgressionDao.update(): calcular `prescribedLoadKg`
  - [ ] Guard: `if (isBodyweight || isIsometric) ‚Üí prescribedLoadKg = null` (CA-11.08)
  - [ ] Else: `val meetsThreshold = DoubleThresholdRule.meetsDoubleThreshold(currentData)` + `val prescribedLoadKg = DoubleThresholdRule.prescribeLoad(currentData.avgWeightKg, exercise.loadIncrementKg, meetsThreshold)`
  - [ ] Extender el `copy()` existente en `exerciseProgressionDao.update()`: agregar `prescribedLoadKg = prescribedLoadKg`

### Fase N: QA y Deployment

- [ ] **Ejecutar Agente Peer Review** (MANUAL)
- [ ] **Resolver incidentes del Peer Review** (MANUAL, condicional)
- [ ] **Crear Pull Request** (MANUAL)
- [ ] **Ejecutar pipeline deployment DEV** (MANUAL)
- [ ] **Dise√±ar set de pruebas manuales** (MANUAL)
- [ ] **Ejecutar pruebas manuales** (MANUAL)

---

**Notas sobre vinculaci√≥n con Criterios de Aceptaci√≥n:**

- CA-11.01 ‚Üí Fase 1 (`meetsDoubleThreshold()` ‚Äî ‚â•12 reps en ‚â•3/4 series AND avgRir ‚â•2, ambas simult√°neas) + tests
- CA-11.02 ‚Üí Fase 1 (`meetsRepCondition && meetsRirCondition` ‚Äî operador AND exige ambas) + tests (solo reps / solo RIR ‚Üí false)
- CA-11.03 ‚Üí Fase 1 (`prescribeLoad(loadIncrementKg=2.5)`) + Fase 2 (`module.load_increment_kg` = 2.5 para A/B, le√≠do de BD via JOIN) + tests
- CA-11.04 ‚Üí Fase 1 (`prescribeLoad(loadIncrementKg=5.0)`) + Fase 2 (`module.load_increment_kg` = 5.0 para C, le√≠do de BD via JOIN) + tests
- CA-11.05 ‚Üí Ya cubierto (derivable ‚Äî rango `8-12` en `plan_assignment.reps`, mostrado por `SessionExerciseWithDetails` en E1, HU-05)
- CA-11.06 ‚Üí Fase 1 (`prescribeLoad(meetsThreshold=false)` ‚Üí retorna `currentAvgWeightKg`) + tests
- CA-11.07 ‚Üí Fase 3 (`exerciseProgressionDao.update(copy(prescribedLoadKg=...))` ‚Äî persistido en `exercise_progression.prescribed_load_kg`, consumido por HU-05 en pr√≥xima sesi√≥n)
- CA-11.08 ‚Üí Fase 3 (guard `isBodyweight || isIsometric ‚Üí null` ‚Äî skip antes de invocar regla, RF31)

<!-- AUDITOR√çA PROFUNDA (2026-02-15):

=== SCOPE ===
7 docs arquitectura + 5 docs business + 32 HUs + Mapa de Historias + 8 archivos de c√≥digo fuente verificados.

=== DOCUMENTOS CRUZADOS ===
Arquitectura: Modelo de Datos ¬ß3.13 (exercise_progression.prescribed_load_kg ‚Äî "Calculada por el motor de Doble Umbral al cierre de sesi√≥n y persistida (CA-11.07). NULL para bodyweight/isom√©tricos. Tras descarga: 90% (CA-17.05)" ‚úÖ), ¬ß3.13 paso 6 l√≥gica de actualizaci√≥n ("Calcular y persistir prescribed_load_kg seg√∫n Doble Umbral R1 o mantenimiento R2" ‚úÖ), module.load_increment_kg ¬ß3.1 (CHECK > 0, seed A=2.5 B=2.5 C=5.0 ‚úÖ), ADR-06 (reglas puras en domain.rules ‚úÖ), ADR D-07 (reinterpretado: valores 2.5/5.0 son de BD, no constantes Kotlin ‚úÖ), Arquitectura T√©cnica ¬ß2.5 (Motor de Reglas R1-R7 ‚úÖ), ¬ß5.2 (DoubleThresholdRule naming expl√≠cito ‚úÖ), Mapa de Navegaci√≥n ¬ß5 (HU-11 "representaci√≥n indirecta en E1/E5" ‚úÖ), Especificaci√≥n Visual (E5: "Subir carga ‚Üí X Kg" / "Progresar en reps" ‚úÖ), Wireframes (E1: carga objetivo, E5: se√±al de subir carga ‚úÖ).
Business: Requerimientos RF25 (‚â•12 reps en ‚â•3/4 AND RIR avg ‚â•2 ‚úÖ), RF26 (prescribir +2.5 A/B, +5 C ‚úÖ), RF27 (misma carga si no cumple ‚úÖ), RF31 (bodyweight excluido ‚úÖ), RNF30 (pruebas unitarias Doble Umbral ‚úÖ). MDS ¬ß6-A R1 (f√≥rmula Doble Umbral completa ‚úÖ), R2 (mantenimiento de carga ‚úÖ), R6 (Œîmin=0 para bodyweight ‚úÖ).

=== HUs CRUZADAS (11 con referencias) ===
Predecesoras (6): HU-03 (ModuleEntity.load_increment_kg creada ‚úÖ), HU-05 (14 refs: ExerciseProgressionEntity con prescribedLoadKg, SessionExerciseWithDetails JOIN, DAO methods ‚úÖ), HU-06 (7 refs: insertIfNotExists crea entity, exercise_set data producer, CA redistribuci√≥n ‚úÖ), HU-08 (14 refs: CA-08.03‚ÜíCA-11.08, bodyweight exclusi√≥n ‚úÖ), HU-09 (2 refs: punto extensi√≥n closeSession ‚úÖ), HU-10 (11 refs: evaluateProgression() loop, moduleCode proactivo, ProgressionClassificationRule patr√≥n, paso 6 diferido ‚úÖ).
Sucesoras (5): HU-13 (E5 "Subir carga ‚Üí X Kg" consume prescribedLoadKg ‚úÖ), HU-15 (microincremento sesi√≥n 4 usa prescribedLoadKg como base ‚úÖ), HU-17 (CA-17.05 sobrescribe prescribedLoadKg con 90% pre-descarga ‚úÖ), HU-20 (relaci√≥n d√©bil ‚Äî tonnage usa exercise_set, no prescribedLoadKg; podr√≠a derivar progresi√≥n de carga indirectamente ‚ö†Ô∏è), HU-23 (relaci√≥n d√©bil ‚Äî evoluci√≥n de carga usa exercise_set; podr√≠a mostrar prescribedLoadKg opcionalmente ‚ö†Ô∏è).
Peers (1): HU-12 (regresi√≥n independiente, comparte evaluateProgression, no lee/escribe prescribedLoadKg ‚úÖ).
Sin referencias (17): HU-01, HU-02, HU-04, HU-07, HU-14, HU-16, HU-18, HU-19, HU-21, HU-24, HU-25-HU-32 ‚úÖ.
Consumidoras indirectas d√©biles (2): HU-22 (KPIs por ejercicio ‚Äî tasa de progresi√≥n de carga, podr√≠a usar prescribedLoadKg pero sus CAs no lo exigen expl√≠citamente ‚ö†Ô∏è), HU-20 (ver sucesoras arriba ‚ö†Ô∏è).
Nota: HU-05 como sucesor c√≠clico ‚Äî la PR√ìXIMA instancia de HU-05 (iniciar nueva sesi√≥n) lee prescribedLoadKg escrito por HU-11 en el cierre anterior ‚úÖ.

=== C√ìDIGO VERIFICADO (8 archivos) ===
Modificados (2): SessionExerciseDao.kt (164 l√≠neas ‚Äî DTO SessionExerciseForProgression L44-50 tiene moduleCode pero NO loadIncrementKg, query getSessionExercisesForProgression L134-143 hace JOIN exercise pero NO module, necesita extensi√≥n ‚úÖ), SessionRepositoryImpl.kt (378 l√≠neas ‚Äî evaluateProgression() L313-377, paso final exerciseProgressionDao.update copy() L372-375 NO incluye prescribedLoadKg, necesita extensi√≥n ‚úÖ).
Infraestructura (4): ModuleEntity.kt (22 l√≠neas ‚Äî PK code String, loadIncrementKg Double, tabla "module" ‚úÖ), ExerciseProgressionEntity.kt (33 l√≠neas ‚Äî prescribedLoadKg: Double? = null en L29 ‚úÖ), ExerciseSessionData.kt (23 l√≠neas ‚Äî setCount, avgWeightKg, totalReps, avgRir propiedades disponibles ‚úÖ), ProgressionClassificationRule.kt (referencia patr√≥n object singleton ‚úÖ).
Referencia (2): ModuleSeeder.kt (A=2.5, B=2.5, C=5.0 confirmado L17-19 ‚úÖ), ProgressionClassificationRuleTest.kt (patr√≥n helpers sessionData/set confirmado L19-22 ‚úÖ).
Nuevos (2 ‚Äî confirmado que NO existen): DoubleThresholdRule.kt ‚úÖ, DoubleThresholdRuleTest.kt ‚úÖ. domain/rules/ ya existe desde HU-10 ‚úÖ.

=== VERIFICACI√ìN L√ìGICA ===
meetsDoubleThreshold (4 condiciones): guard setCount<4‚Üífalse ‚úÖ, seriesMeetingRepThreshold = sets.count{reps>=12} >= 3 ‚úÖ, meetsRirCondition = avgRir >= 2.0 ‚úÖ, return meetsRepCondition && meetsRirCondition (AND ‚Äî CA-11.02) ‚úÖ.
prescribeLoad (2 ramas): !meetsThreshold ‚Üí currentAvgWeightKg (CA-11.06) ‚úÖ, meetsThreshold ‚Üí currentAvgWeightKg + loadIncrementKg (CA-11.03/04) ‚úÖ.
Integraci√≥n (3 ramas): isBodyweight||isIsometric ‚Üí null (CA-11.08) ‚úÖ, est√°ndar cumple ‚Üí carga+incremento (CA-11.03/04) ‚úÖ, est√°ndar no cumple ‚Üí misma carga (CA-11.06) ‚úÖ.
Cobertura incremental: moduleCode se mantiene en DTO Y se agrega loadIncrementKg ‚Äî sin costo adicional (mismo JOIN base a exercise, JOIN a module agrega solo 1 lookup PK). Coherente con filosof√≠a proactiva de HU-10 Nota 5 ‚úÖ.

=== CHECKLIST FORMAL (18 items) ===
1-Archivos: 2 nuevos archivos marcados "Crear archivo" ‚úÖ, 2 modificados existen ‚úÖ.
2-Testing: JUnit 4 ‚úÖ, test path convenci√≥n ‚úÖ, helpers reutilizados ‚úÖ.
3-Arquitectura: 8 decisiones consumidas ‚úÖ, 3 fases = 3 hitos ‚úÖ.
4-Completitud: 8 CAs mapeadas (7 por implementar + 1 ya cubierta CA-11.05) ‚úÖ.
5-Riesgos: 3 documentados ‚úÖ.
6-Fallos: ninguno detectado ‚úÖ.

=== CONTRADICCIONES DOCUMENTALES (1 analizada) ===
C1-BAJA: ADR D-07 dice constantes LOAD_INCREMENT_UPPER/LOWER, pero arquitecto HU-11 decidi√≥ leer de BD (module.load_increment_kg). Reinterpretaci√≥n correcta: ADR D-07 establece VALORES (2.5/5.0), la FUENTE es la BD. Evita duplicaci√≥n de fuentes de verdad ‚úÖ.

=== RESULTADO FINAL ===
0 HIGH, 0 MEDIUM, 1 LOW (reinterpretaci√≥n ADR D-07 ‚Äî correctamente justificada), 2 INFO (HU-20/HU-23 son sucesoras d√©biles ‚Äî sus CAs no exigen consumo de prescribedLoadKg).
Totales verificados: 32 HUs, 4 RFs, 3 reglas MDS, 8 CAs, 8 archivos de c√≥digo, 20 escenarios de regla, 18 items de checklist.
Inconsistencia interna corregida: HU-22 reclasificada de "sin referencia" a "consumidora indirecta d√©bil"; HU-20/HU-23 anotadas como sucesoras con relaci√≥n d√©bil.
Refinamiento t√©cnico APROBADO. -->
