# HU-14 ‚Äî Protocolo de Descarga y Conteo de Microciclos

## Requisitos relacionados

RF38, RF39, RF40, RF41

## Descripci√≥n

Como ejecutante, quiero poder activar un modo de descarga (Deload) que ajuste autom√°ticamente las cargas al 60%, mantenerlo durante un microciclo completo, que al finalizar el sistema calcule mis cargas de reinicio al 90%, y que el sistema lleve un conteo preciso de todos mis microciclos completados, para recuperar mi SNC y tejidos conectivos de forma estructurada, retomar el entrenamiento aprovechando la supercompensaci√≥n, y tener una referencia clara de cu√°ntos ciclos completos de entrenamiento llevo acumulados.

## Historias originales consolidadas

Esta historia consolida las siguientes historias del dise√±o original, que son funcionalmente inseparables (la descarga se mide en microciclos, y el conteo de microciclos incluye los de descarga):

- **HU-17 original** ‚Äî Activar y gestionar ciclo de descarga completo (RF38, RF39, RF40)
- **HU-18 original** ‚Äî Contar microciclos completados (RF41)

---

## Criterios de Aceptaci√≥n

### Bloque A ‚Äî Activaci√≥n y Gesti√≥n del Ciclo de Descarga (RF38, RF39, RF40)

#### CA-14.01 ‚Äî Activaci√≥n del modo Descarga

**Dado que** el sistema ha se√±alado que un m√≥dulo requiere descarga (HU-12) o el ejecutante decide proactivamente descargar,
**cuando** el ejecutante activa el modo de Descarga,
**entonces** el sistema ajusta los par√°metros de prescripci√≥n para todas las sesiones del per√≠odo de descarga: carga al 60% de la carga habitual de cada ejercicio, mantener 4 series por ejercicio, repeticiones en el l√≠mite inferior del rango (8), y RIR objetivo de 4-5.

#### CA-14.02 ‚Äî C√°lculo del 60% de carga por ejercicio

**Dado que** el modo de Descarga est√° activo,
**cuando** el sistema prescribe la carga para un ejercicio en una sesi√≥n de descarga,
**entonces** calcula el 60% de la √∫ltima carga de trabajo registrada para ese ejercicio, redondeando al incremento m√°s cercano disponible (2.5 Kg para tren superior, 5 Kg para tren inferior).

#### CA-14.03 ‚Äî Duraci√≥n del modo Descarga: 1 microciclo completo

**Dado que** el modo de Descarga est√° activo,
**cuando** el ejecutante completa sesiones durante la descarga,
**entonces** el modo se mantiene activo durante exactamente 1 microciclo completo (A-B-C-A-B-C = 6 sesiones), desactiv√°ndose autom√°ticamente al cerrar la sexta sesi√≥n del microciclo de descarga.

#### CA-14.04 ‚Äî Versi√≥n congelada durante la descarga

**Dado que** el modo de Descarga est√° activo,
**cuando** el sistema determina la versi√≥n del m√≥dulo para cada sesi√≥n de descarga,
**entonces** mantiene la misma versi√≥n que estaba activa al momento de activar la descarga para cada m√≥dulo respectivo; la secuencia de versiones no avanza durante el per√≠odo de descarga.

#### CA-14.05 ‚Äî C√°lculo de carga de reinicio post-descarga

**Dado que** el modo de Descarga ha finalizado tras completar el microciclo,
**cuando** el sistema calcula las cargas para el nuevo mesociclo,
**entonces** prescribe para cada ejercicio una carga de reinicio equivalente al 90% de la √∫ltima carga de trabajo pre-descarga, no el 90% de la carga de descarga.

#### CA-14.06 ‚Äî Redondeo de la carga de reinicio

**Dado que** el sistema calcula la carga de reinicio al 90%,
**cuando** el resultado no es un m√∫ltiplo exacto del incremento m√≠nimo (2.5 Kg o 5 Kg),
**entonces** redondea al incremento m√°s cercano disponible seg√∫n el m√≥dulo del ejercicio (redondeando hacia abajo para proteger al ejecutante).

#### CA-14.07 ‚Äî Indicaci√≥n visual del modo Descarga

**Dado que** el modo de Descarga est√° activo,
**cuando** el ejecutante visualiza la sesi√≥n o la prescripci√≥n,
**entonces** el sistema indica claramente que se est√° en per√≠odo de descarga, mostrando las cargas ajustadas y cu√°ntas sesiones restan para completar el microciclo de descarga.

#### CA-14.08 ‚Äî Transici√≥n al nuevo mesociclo

**Dado que** el modo de Descarga finaliza,
**cuando** el ejecutante inicia la primera sesi√≥n post-descarga,
**entonces** el sistema presenta las cargas de reinicio (90% pre-descarga) como cargas objetivo, la secuencia de versiones retoma su avance normal, y los estados de progresi√≥n de los ejercicios se actualizan de "En Descarga" al estado que corresponda seg√∫n los nuevos registros.

#### CA-14.09 ‚Äî Ejercicios de peso corporal e isom√©tricos durante descarga

**Dado que** el modo de Descarga est√° activo y la sesi√≥n incluye ejercicios de peso corporal o isom√©tricos,
**cuando** el sistema prescribe par√°metros de descarga,
**entonces** para ejercicios de peso corporal prescribe 8 repeticiones con RIR 4-5 (sin ajuste de carga porque Peso = 0), y para isom√©tricos prescribe 30 segundos con RIR 4-5.

### Bloque B ‚Äî Conteo de Microciclos (RF41)

#### CA-14.10 ‚Äî Incremento del contador al completar un microciclo

**Dado que** el ejecutante ha cerrado sesiones de entrenamiento,
**cuando** los 6 m√≥dulos de la rotaci√≥n (A-B-C-A-B-C) han sido ejecutados desde el √∫ltimo incremento,
**entonces** el sistema incrementa el conteo de microciclos completados en 1.

#### CA-14.11 ‚Äî Conteo basado en la rotaci√≥n, no en el calendario

**Dado que** el sistema lleva el conteo de microciclos,
**cuando** eval√∫a si un microciclo se ha completado,
**entonces** se basa exclusivamente en la secuencia de sesiones ejecutadas (6 m√≥dulos: A, B, C, A, B, C), independientemente de cu√°ntos d√≠as naturales haya tomado completarlos.

#### CA-14.12 ‚Äî Conteo persistente

**Dado que** el sistema ha registrado microciclos completados,
**cuando** la aplicaci√≥n se cierra, se reinicia el dispositivo o se actualiza la app,
**entonces** el conteo de microciclos persiste y se recupera correctamente al reabrir la aplicaci√≥n.

#### CA-14.13 ‚Äî Conteo durante per√≠odo de descarga

**Dado que** el modo de Descarga est√° activo (CA-14.01),
**cuando** el ejecutante completa las 6 sesiones del microciclo de descarga,
**entonces** el sistema incrementa el contador de microciclos igualmente, ya que un microciclo de descarga es un microciclo completo ejecutado.

#### CA-14.14 ‚Äî Consulta del conteo

**Dado que** el ejecutante desea conocer su progreso temporal,
**cuando** consulta el conteo de microciclos,
**entonces** el sistema muestra el n√∫mero total de microciclos completados desde el inicio del uso del sistema.

## An√°lisis Arquitect√≥nico (Arquitecto)

### Decisiones de Dise√±o

**Patr√≥n Arquitect√≥nico:** MVVM con orquestaci√≥n de dominio en m√∫ltiples capas ‚Äî entidad nueva + reglas puras + modificaci√≥n de flujos existentes (inicio/cierre de sesi√≥n, rotaci√≥n).

**Justificaci√≥n:** HU-14 es la historia m√°s transversal del sistema: introduce una entidad nueva (`deload`), crea dos reglas de dominio (`DeloadLoadRule` para c√°lculo de 60%/90%, redondeo), modifica el flujo de inicio de sesi√≥n (`startSession()` con `deloadId`), modifica el cierre de sesi√≥n (`closeSession()` con completaci√≥n de deload), modifica la rotaci√≥n (`advanceRotation()` con congelamiento de versiones), modifica la progresi√≥n (`evaluateProgression()` con transici√≥n IN_DELOAD ‚Üí IN_PROGRESSION post-deload), y a√±ade una pantalla nueva (I1). Su correcta implementaci√≥n es cr√≠tica porque un error en el flujo de descarga produce prescripciones de carga incorrectas que podr√≠an causar lesiones (sobreentrenamiento al no descargar, o p√©rdida de est√≠mulo por descarga eterna).

### Decisiones Fundamentadas

**1. HU-14 opera en tres fases temporalmente distintas: activaci√≥n ‚Üí ciclo ‚Üí finalizaci√≥n.**

La activaci√≥n (CA-14.01) crea un registro `deload` con estado ACTIVE y congela las versiones del momento. El ciclo (CA-14.03) dura 6 sesiones ‚Äî cada sesi√≥n se crea con `deload_id` apuntando al deload activo, las cargas se prescriben al 60% (CA-14.02), y la rotaci√≥n avanza posici√≥n pero NO versiones (CA-14.04). La finalizaci√≥n (CA-14.05) ocurre al cerrar la sexta sesi√≥n: el deload pasa a COMPLETED, las cargas se reinician al 90% de la carga pre-descarga (CA-14.06), y los estados de progresi√≥n de ejercicios se transicionan de `IN_DELOAD` a `IN_PROGRESSION` (CA-14.08). Estas tres fases se implementan en puntos de extensi√≥n diferentes del c√≥digo existente.

**2. `DeloadEntity` es una entidad nueva en la capa Data que persiste el ciclo de descarga.**

El Modelo de Datos ¬ß3.15 define la tabla `deload` con: `id`, `status` (ACTIVE/COMPLETED), `activation_date`, `completion_date`, `frozen_version_module_a/b/c`. El conteo de sesiones del deload **no se almacena** ‚Äî se calcula como `SELECT COUNT(*) FROM session WHERE deload_id = ? AND status IN ('COMPLETED', 'INCOMPLETE')`. Esto evita una columna derivada que requerir√≠a sincronizaci√≥n. Solo puede existir un deload con `status = 'ACTIVE'` a la vez.

**3. `DeloadLoadRule` es una funci√≥n pura en `domain/rules/` (ADR-06) con tres funciones.**

- `calculateDeloadLoad(lastWeightKg, loadIncrementKg)`: calcula 60% de la carga habitual, redondeado hacia abajo al incremento m√°s cercano. F√≥rmula: `floor(lastWeightKg * 0.60 / loadIncrementKg) * loadIncrementKg`.
- `calculateResetLoad(preDeloadWeightKg, loadIncrementKg)`: calcula 90% de la √∫ltima carga pre-descarga, redondeado hacia abajo. F√≥rmula: `floor(preDeloadWeightKg * 0.90 / loadIncrementKg) * loadIncrementKg`.
- Ambas funciones reciben `loadIncrementKg` como par√°metro (2.5 para m√≥dulos A/B, 5.0 para m√≥dulo C) ‚Äî ya disponible en `module.load_increment_kg` (HU-11 Decisi√≥n 4).
- Para ejercicios de peso corporal e isom√©tricos (`isBodyweight || isIsometric`): no se calcula carga de descarga ni reinicio, ya que `prescribed_load_kg` es siempre NULL para estos tipos (CA-14.09, Modelo de Datos ¬ß3.13).

**4. La "√∫ltima carga de trabajo habitual" se deriva de los datos existentes, no se almacena.**

Modelo de Datos ¬ß3.15: "La carga habitual de cada ejercicio antes de la descarga [...] se deriva consultando el √∫ltimo `exercise_set.weight_kg` registrado por ejercicio en sesiones anteriores a `activation_date` que no sean de descarga." La query busca `AVG(weight_kg)` de las series del ejercicio en la √∫ltima sesi√≥n no-deload antes de la activaci√≥n. Para la carga de reinicio (90% post-deload), se usa la misma referencia: la carga pre-descarga, no la carga de descarga. Esto se implementa como un DAO query `getPreDeloadAvgWeight(exerciseId, activationDate)`.

**5. `RotationResolver.advanceRotation()` se modifica para recibir `isDeload: Boolean`.**

HU-09 Decisi√≥n 6 anticip√≥ esta modificaci√≥n: *"Cuando HU-17 se implemente, `advanceRotation` recibir√° `isDeload: Boolean` adicional."* Cuando `isDeload = true` y `position == 6`:
- La posici√≥n vuelve a 1 (el microciclo de descarga se completa normalmente).
- `microcycleCount` se incrementa (CA-14.13: un microciclo de descarga cuenta como microciclo completado).
- Las versiones **NO avanzan** ‚Äî se mantienen iguales (CA-14.04: versiones congeladas durante descarga).

Cuando `isDeload = false`, el comportamiento permanece id√©ntico al actual (posici√≥n avanza, versiones rotan al completar posici√≥n 6). Los tests existentes de `RotationResolver` se mantienen v√°lidos para el caso `isDeload = false`.

**6. `startSession()` se modifica para pasar `deloadId` cuando hay deload activo.**

Actualmente, `startSession()` siempre crea `SessionEntity(deloadId = null)`. Con HU-14, antes de crear la sesi√≥n, se consulta `deloadDao.getActiveDeload()`. Si retorna un deload activo:
- `SessionEntity.deloadId` se asigna con el ID del deload activo.
- Las versiones para la sesi√≥n se toman de `deload.frozen_version_module_X`, no de `rotation_state.current_version_module_X` (CA-14.04). La resoluci√≥n del `moduleVersionId` debe usar las versiones congeladas.
- No se modifica la determinaci√≥n del m√≥dulo (la posici√≥n de la rotaci√≥n sigue avanzando normalmente).

**7. `closeSession()` se ampl√≠a con l√≥gica de finalizaci√≥n de deload.**

Cuando la sesi√≥n cerrada tiene `deloadId != null`, despu√©s de `evaluateProgression()` y `advanceRotation()`:
1. Contar sesiones del deload: `sessionDao.countDeloadSessions(deloadId)`.
2. Si el conteo == 6 (microciclo completo):
   a. Marcar deload como COMPLETED: `deloadDao.complete(deloadId, today)`.
   b. Para cada ejercicio est√°ndar (no bodyweight, no isometric) que tenga `exercise_progression.status == 'IN_DELOAD'`:
      - Obtener la carga pre-deload: `getPreDeloadAvgWeight(exerciseId, deload.activationDate)`.
      - Calcular carga de reinicio: `DeloadLoadRule.calculateResetLoad(preDeloadWeight, loadIncrementKg)`.
      - Actualizar `exercise_progression.prescribed_load_kg = resetLoad`.
      - Transicionar `exercise_progression.status` de `IN_DELOAD` a `IN_PROGRESSION`.
      - Resetear `sessions_without_progression = 0`.
   c. Resolver alertas: `alertDao.resolveByModuleAndType(moduleCode, "MODULE_REQUIRES_DELOAD", today)` para todos los m√≥dulos.

**8. La activaci√≥n del deload transiciona TODOS los ejercicios a estado `IN_DELOAD`.**

CA-14.01 dice "ajusta los par√°metros de prescripci√≥n para TODAS las sesiones del per√≠odo de descarga". Al activar el deload:
1. Se crea `DeloadEntity(status = ACTIVE, activationDate = hoy, frozenVersionA/B/C = rotation_state.current_version_module_a/b/c)`.
2. Se transicionan TODOS los ejercicios con estado != `NO_HISTORY` y != `MASTERED` a `IN_DELOAD`: `exerciseProgressionDao.transitionToDeload()`.
3. Se congela el `sessions_without_progression` (el contador no se resetea al activar ‚Äî se preserva para cuando el deload termine y se retome el tracking de meseta, pero esto es debatible: Regla 5 dice "post-descarga se reinicia" ‚Üí se resetea a 0 al finalizar, no al activar).

Esta transici√≥n es global (no por m√≥dulo) porque la descarga afecta a TODO el plan ‚Äî MDS R5: "Ejercicios: Mantener los mismos del plan."

**9. La pantalla I1 tiene 3 estados mutuamente excluyentes gestionados por `DeloadManagementUiState`.**

Wireframe I1 y Especificaci√≥n Visual ¬ßI1 definen 3 estados:
- **Estado A (Descarga requerida):** No hay deload activo pero existe alerta `MODULE_REQUIRES_DELOAD`. Muestra info del m√≥dulo afectado, protocolo detallado, bot√≥n "Activar Descarga".
- **Estado B (Descarga activa):** Deload activo con progreso N/6 sesiones. Barra de progreso, par√°metros vigentes, versiones congeladas.
- **Estado C (Post-descarga):** Deload reci√©n completado, primera visita post-deload. Muestra cargas de reinicio (90%) por ejercicio est√°ndar. Las versiones retoman avance normal.

Un cuarto estado impl√≠cito: **Sin descarga requerida ni activa** ‚Äî I1 no es accesible directamente (el card en B1 no se muestra y el enlace desde H2 no existe). Si el usuario llega por deep link, se muestra un mensaje "No hay descarga pendiente" con bot√≥n de retorno.

**10. El conteo de microciclos (Bloque B) ya est√° implementado.**

`RotationResolver.advanceRotation()` ya incrementa `microcycleCount` al cerrar posici√≥n 6 (HU-09). `GetMicrocycleCountUseCase` ya existe y `HomeUiState.microcycleCount` ya se muestra en B1. Los CAs 14.10-14.14 se satisfacen con la implementaci√≥n existente:
- CA-14.10: `advanceRotation()` ya incrementa al completar posici√≥n 6. ‚úÖ
- CA-14.11: La rotaci√≥n es agn√≥stica al calendario (MDS ¬ß6-B.9). ‚úÖ
- CA-14.12: Persistido en `rotation_state.microcycle_count` v√≠a Room. ‚úÖ
- CA-14.13: El deload s√≠ incrementa `microcycleCount` ‚Äî `advanceRotation(isDeload=true)` al llegar a posici√≥n 6 incrementa el contador. ‚úÖ (ya cubierto por Decisi√≥n 5).
- CA-14.14: `HomeScreen` ya muestra el contador. ‚úÖ

**No se requiere c√≥digo nuevo para el Bloque B.** Solo verificar que `advanceRotation(isDeload=true)` incrementa `microcycleCount` (nuevo test).

**11. La versi√≥n de la sesi√≥n durante deload usa las versiones congeladas del DeloadEntity.**

Cuando hay deload activo, la resoluci√≥n de versi√≥n debe usar `deload.frozen_version_module_X` en vez de `rotation_state.current_version_module_X`. Esto afecta dos puntos del c√≥digo:

- `SessionRepositoryImpl.getNextModuleVersionId()` (l√≠nea 56): actualmente usa `rotationStateDao.getRotationState()` para obtener las versiones. Con deload activo, debe consultar el deload activo y usar las versiones congeladas.
- `GetNextSessionInfoUseCase.invoke()`: tambi√©n usa `sessionRepository.getRotationState()` para resolver m√≥dulo/versi√≥n y pasarlos a `NextSession`. Con deload activo, debe usar las versiones congeladas del deload para resolver `versionNumber`.
- `startSession()`: el `moduleVersionId` que recibe ya viene resuelto por los dos puntos anteriores, por lo que solo necesita asignar `deloadId`.
- La resoluci√≥n del m√≥dulo (A/B/C) sigue usando `rotation_state.microcycle_position` ‚Äî la posici√≥n NO se congela, solo las versiones.

**12. `evaluateProgression()` durante deload NO ejecuta clasificaci√≥n ni actualizaci√≥n de progresi√≥n.**

El c√≥digo actual tiene `if (isDeloadSession) return` al inicio del bloque del m√≥dulo (HU-12: skip module-level detection during deload). Para HU-14, la l√≥gica debe extenderse: durante sesiones de deload, `evaluateProgression()` ejecuta la clasificaci√≥n individual per-exercise (para que `session_exercise.progression_classification` tenga valor para E5), pero NO actualiza `exercise_progression` (status, counter, prescribed_load_kg permanecen en IN_DELOAD). El guard `if (isDeloadSession)` se mueve del final (bloque m√≥dulo) al punto correcto: justo despu√©s de guardar la clasificaci√≥n, antes de actualizar `exercise_progression`.

Correcci√≥n: Actualmente `isDeloadSession` hace `return` al inicio del bloque post-loop (module-level detection, l√≠nea 442). Pero el loop s√≠ ejecuta todo incluyendo updateProgression. `ProgressionClassificationRule.resolveNewProgressionState()` (l√≠nea 48) tiene `if (currentStatus == "IN_DELOAD") return currentStatus to currentCounter` ‚Äî el estado y contador no cambian durante deload ‚úÖ. Sin embargo, `DoubleThresholdRule.prescribeLoad()` (l√≠neas 397-401) S√ç se ejecuta y sobreescribe `prescribed_load_kg` ‚Äî esto es incorrecto. Hay que agregar un guard: si `isDeloadSession`, preservar la `prescribed_load_kg` actual del `exerciseProgressionDao` en vez de recalcularla. Tambi√©n hay que proteger la gesti√≥n de alertas de meseta (l√≠neas 415-430): durante deload no deber√≠a crearse ni resolverse alertas PLATEAU porque el estado es IN_DELOAD y los ejercicios no est√°n progresando normalmente.

**13. El redondeo de carga de descarga/reinicio es hacia ABAJO (protector).**

CA-14.06: "redondea al incremento m√°s cercano disponible seg√∫n el m√≥dulo del ejercicio (redondeando hacia abajo para proteger al ejecutante)." Esto se implementa con `floor()` en `DeloadLoadRule`:
- 60% de 60 Kg = 36.0 Kg ‚Üí `floor(36.0 / 2.5) * 2.5 = 35.0 Kg` (m√≥dulo A/B, increment=2.5).
- 60% de 55 Kg = 33.0 Kg ‚Üí `floor(33.0 / 2.5) * 2.5 = 32.5 Kg`.
- 90% de 60 Kg = 54.0 Kg ‚Üí `floor(54.0 / 2.5) * 2.5 = 52.5 Kg`.
- 60% de 100 Kg = 60.0 Kg ‚Üí `floor(60.0 / 5.0) * 5.0 = 60.0 Kg` (m√≥dulo C, increment=5.0).
- 90% de 100 Kg = 90.0 Kg ‚Üí `floor(90.0 / 5.0) * 5.0 = 90.0 Kg`.

**14. Pantalla I1 usa `DeloadManagementViewModel` con `SavedStateHandle` y navegaci√≥n desde B1/H2.**

El ViewModel carga:
- Deload activo: `deloadDao.getActiveDeload()` (Flow reactivo).
- Si no hay deload activo, verificar si hay alerta `MODULE_REQUIRES_DELOAD` activa: `alertDao.getActiveModuleAlerts("MODULE_REQUIRES_DELOAD")`.
- Si hay deload completado reciente (√∫ltimo deload donde `completion_date == today` o las cargas prescribidas son post-deload): mostrar Estado C con cargas de reinicio.
- Acciones: `activateDeload()` lanza el UseCase `ActivateDeloadUseCase` que ejecuta la transacci√≥n de activaci√≥n.

La navegaci√≥n B1 ‚Üí I1 se habilita cuando el card "Estado de Descarga" es visible (deload activo o alerta MODULE_REQUIRES_DELOAD). Ruta: `deload-management` (sin par√°metros ‚Äî el estado se carga del deload activo/alertas).

**Componentes Afectados:**

**Componentes nuevos:**

| # | Componente | Capa | Responsabilidad |
|---|---|---|---|
| 1 | `DeloadEntity` | Data (entity) | Entidad Room para tabla `deload`: id, status, activation_date, completion_date, frozen_version_module_a/b/c |
| 2 | `DeloadDao` | Data (dao) | DAO Room: `insert()`, `getActiveDeload()` (Flow), `getActiveDeloadOnce()` (suspend), `complete()`, `getById()`, `countSessions()` |
| 3 | `DeloadLoadRule` | Domain (rules) | Funci√≥n pura: `calculateDeloadLoad()` (60% con redondeo down) y `calculateResetLoad()` (90% con redondeo down). ADR-06 |
| 4 | `ActivateDeloadUseCase` | Domain (usecase/deload) | Orquesta: crear DeloadEntity + transicionar ejercicios a IN_DELOAD + guardar versiones congeladas |
| 5 | `GetDeloadStateUseCase` | Domain (usecase/deload) | Lee estado de deload activo/completado + alertas MODULE_REQUIRES_DELOAD ‚Üí `DeloadState` |
| 6 | `DeloadState` | Domain (model) | Sealed interface: `NoDeloadNeeded`, `DeloadRequired(modules)`, `DeloadActive(progress, frozenVersions)`, `DeloadCompleted(resetLoads)` |
| 7 | `DeloadManagementViewModel` | UI (deload) | Carga estado v√≠a UseCase, acci√≥n `activateDeload()`, expone `StateFlow<DeloadManagementUiState>` |
| 8 | `DeloadManagementUiState` | UI (deload) | Sealed interface: `Loading`, `Content(deloadState)`, `Error(message)` |
| 9 | `DeloadManagementScreen` | UI (deload) | Composable I1: 3 estados (requerida/activa/post-descarga) + Bottom Navigation |

**Componentes modificados:**

| # | Componente | Modificaci√≥n | Nivel |
|---|---|---|---|
| 1 | `TensionDatabase` | Agregar `DeloadEntity` a entities, bump version a 6, agregar migration 5‚Üí6, agregar `deloadDao()` | Mayor |
| 2 | `SessionEntity` | Agregar FK constraint a `deload(id)` ahora que la tabla existe | Menor |
| 3 | `RotationResolver.advanceRotation()` | Agregar par√°metro `isDeload: Boolean = false`. Cuando `isDeload && position == 6`: posici√≥n‚Üí1, microcycleCount++, versiones NO avanzan | Mayor |
| 4 | `SessionRepositoryImpl.startSession()` | Consultar deload activo. Si existe: asignar `deloadId`, resolver `moduleVersionId` con versiones congeladas | Mayor |
| 5 | `SessionRepositoryImpl.closeSession()` | Pasar `isDeload` a `advanceRotation()`. Despu√©s de rotaci√≥n: si deload y conteo == 6 ‚Üí finalizar deload (COMPLETED, reset loads 90%, transicionar IN_DELOAD ‚Üí IN_PROGRESSION, resolver alertas) | Mayor |
| 6 | `SessionRepositoryImpl.evaluateProgression()` | Durante deload: mantener clasificaci√≥n per-exercise pero proteger `prescribed_load_kg` de recalculaci√≥n y saltar gesti√≥n de alertas PLATEAU. Guards: no prescribir carga + no crear/resolver alertas plateau durante deload | Medio |
| 7 | `SessionRepositoryImpl.getNextModuleVersionId()` | Consultar deload activo. Si existe: usar versiones congeladas para resoluci√≥n de moduleVersionId | Medio |
| 7b | `GetNextSessionInfoUseCase` | Consultar deload activo. Si existe: usar versiones congeladas para resoluci√≥n de versionNumber en NextSession | Medio |
| 7c | `ExerciseSetDao.getLastWeightForExercise()` | Excluir sesiones de deload del query para que la precarga E2 post-deload sea la carga pre-descarga (Nota 8, HU-06) | Menor |
| 8 | `SessionRepository` (interfaz) | Agregar `activateDeload()`, `getDeloadState()` | Menor |
| 9 | `HomeUiState` | Agregar `deloadState: DeloadHomeState?` (info m√≠nima para card B1) | Menor |
| 10 | `HomeViewModel` | Cargar estado de deload para card B1 (descarga activa + progreso, o m√≥dulo requiere descarga) | Menor |
| 11 | `HomeScreen` | Agregar Card "Estado de Descarga" condicional con enlace "Ver gesti√≥n de descarga ‚Üí" ‚Üí I1 | Medio |
| 12 | `TensionNavHost` | Registrar composable I1 en ruta `deload-management`, agregar navegaci√≥n B1 ‚Üí I1 | Menor |
| 13 | `NavigationRoutes` | Agregar ruta `DELOAD_MANAGEMENT = "deload-management"` | Menor |
| 14 | `DatabaseModule` | Proveer `DeloadDao` via `@Provides` | Menor |
| 15 | `RepositoryModule` | Inyectar `DeloadDao` en `SessionRepositoryImpl` | Menor |

**Hitos de Implementaci√≥n:**

| # | Componente(s) | Descripci√≥n | Dependencias |
|---|---|---|---|
| 1 | `DeloadLoadRule` + tests | Regla pura: `calculateDeloadLoad()` (60%, round down), `calculateResetLoad()` (90%, round down). Tests JUnit con edge cases de redondeo | Ninguna |
| 2 | `DeloadEntity` + `DeloadDao` + migration | Entity Room, DAO con queries, migration 5‚Üí6 (CREATE TABLE deload), FK en SessionEntity | Ninguna |
| 3 | `RotationResolver` modificaci√≥n + tests | Agregar `isDeload: Boolean = false`. Test: isDeload=true en position 6 ‚Üí versions no avanzan, microcycleCount s√≠. Tests existentes pasan sin cambio (default false) | Ninguna |
| 4 | `SessionRepositoryImpl` ‚Äî activaci√≥n | `activateDeload()`: crear DeloadEntity, transicionar ejercicios a IN_DELOAD, congelar versiones. `ActivateDeloadUseCase` | Hitos 2, 3 |
| 5 | `SessionRepositoryImpl` ‚Äî inicio de sesi√≥n | Modificar `startSession()`: consultar deload activo, asignar deloadId. Modificar `getNextModuleVersionId()`: versiones congeladas. Modificar `GetNextSessionInfoUseCase`: versiones congeladas. Modificar `ExerciseSetDao.getLastWeightForExercise()`: excluir deload | Hito 4 |
| 6 | `SessionRepositoryImpl` ‚Äî cierre de sesi√≥n | Modificar `closeSession()`: pasar isDeload a advanceRotation. Finalizaci√≥n al 6to: complete deload, reset loads 90%, IN_DELOAD‚ÜíIN_PROGRESSION, resolver alertas. Guards evaluateProgression: proteger `prescribed_load_kg` + saltar alertas PLATEAU durante deload | Hitos 4, 5 |
| 7 | Domain models + UseCases | `DeloadState` (sealed), `GetDeloadStateUseCase`, `ActivateDeloadUseCase` | Hitos 4, 5, 6 |
| 8 | Home ‚Äî Card Descarga | `DeloadHomeState`, modificar HomeUiState/ViewModel/Screen para card condicional B1 | Hito 7 |
| 9 | I1 ‚Äî Screen + ViewModel | `DeloadManagementUiState`, `DeloadManagementViewModel`, `DeloadManagementScreen` (3 estados), navegaci√≥n | Hito 7 |
| 10 | Navegaci√≥n + integraci√≥n | Ruta en NavigationRoutes, composable en TensionNavHost, enlace B1‚ÜíI1, enlace H2‚ÜíI1 (placeholder) | Hito 9 |

### Validaci√≥n de Impacto

**C√≥digo real verificado (paso 1.5):**

- `SessionEntity.kt`: Campo `deloadId: Long? = null` ya existe con index. Falta FK constraint a tabla `deload` (no existe a√∫n). Se agrega al crear `DeloadEntity`.
- `RotationResolver.kt`: `advanceRotation(current: RotationState)` ‚Äî firma actual sin `isDeload`. Se agrega par√°metro con default `false` para retrocompatibilidad. Los 6 tests existentes en `RotationResolverTest` siguen pasando sin cambio.
- `SessionRepositoryImpl.kt`: `startSession()` (l√≠neas 76-109) siempre crea con `deloadId = null`. `closeSession()` (l√≠neas 279-324) usa `deloadId != null` para `isDeloadSession` pasado a `evaluateProgression()`. El `advanceRotation()` se invoca en l√≠nea 313 sin par√°metro `isDeload` ‚Äî se agrega.
- `ProgressionClassificationRule.kt`: `resolveNewProgressionState()` l√≠nea 48: `if (currentStatus == "IN_DELOAD") return currentStatus to currentCounter` ‚Äî ya maneja IN_DELOAD correctamente. No se necesita modificaci√≥n.
- `evaluateProgression()` (l√≠neas 326-490): El guard `if (isDeloadSession) return` est√° en l√≠nea 442, que es el bloque post-loop (module-level detection). El loop s√≠ ejecuta: clasificaci√≥n ‚úÖ, resolveNewProgressionState (IN_DELOAD ‚Üí no change ‚úÖ), prescribeLoad (‚ö†Ô∏è recalcula carga durante deload ‚Äî necesita guard), alertas PLATEAU (‚ö†Ô∏è se crean/resuelven durante deload ‚Äî necesita guard).
- `DoubleThresholdRule.prescribeLoad()`: Durante deload se ejecuta y sobreescribe `prescribed_load_kg`. Esto es incorrecto ‚Äî durante deload, la carga prescrita debe mantenerse intacta (se sobreescribir√° con 90% post-deload). Se agrega guard en `evaluateProgression`: `if (isDeloadSession) { prescribedLoadKg = currentProgression.prescribedLoadKg }`. Igualmente, la gesti√≥n de alertas PLATEAU (l√≠neas 415-430) se salta durante deload: `if (!isDeloadSession) { /* plateau alert logic */ }`.
- `ExerciseSetDao.kt`: `getLastWeightForExercise()` (l√≠nea 32) existe ‚Äî consulta el √∫ltimo `weight_kg` sin filtrar por deload. Post-deload retornar√≠a la carga de descarga (60%), no la pre-descarga. Ver Nota 8 (precarga E2 post-deload).
- `SessionDao.kt`: `getActiveSession()`, `getDeloadIdBySessionId()` ya existen. Falta `countDeloadSessions(deloadId)`.
- `ExerciseProgressionDao.kt`: `update()` existe. Falta `transitionToDeload()` (UPDATE masivo para activaci√≥n).
- `AlertDao.kt`: `resolveByModuleAndType()` ya existe (HU-12). `existsActiveByModule()` existe. `getActiveAlerts()` retorna todas las alertas activas sin filtro. Falta `getActiveAlertsByType(type)` para I1 Estado A.
- `HomeUiState.kt`: Tiene `microcycleCount` y `alertCount`. Falta `deloadState`.
- `HomeViewModel.kt`: Carga `microcycleCount` y `alertCount`. Falta cargar deload state.
- `HomeScreen.kt`: No tiene Card de Descarga. Se agrega condicionalmente.
- `NavigationRoutes.kt`: No tiene ruta para I1. Se agrega.
- `TensionNavHost.kt`: No tiene composable I1. Se agrega. El placeholder `onNavigateToAlerts` tiene `{ /* TODO: HU-14+ */ }`.
- `TensionDatabase.kt`: version=5, 15 entities. Se bumpa a 6, se agrega `DeloadEntity` (16 entities).
- `DatabaseModule.kt`: Provee DAOs. Se agrega `DeloadDao`.
- `RepositoryModule.kt`: Provee `SessionRepositoryImpl` con 8 DAOs. Se agrega `DeloadDao` como 9no.
- `GetNextSessionInfoUseCase.kt`: Usa `sessionRepository.getRotationState()` para resolver m√≥dulo/versi√≥n. Con deload activo, debe usar versiones congeladas.

**An√°lisis de dependencias:**

- HU-14 depende de: HU-05 (startSession ‚Äî punto de extensi√≥n para asignar deloadId), HU-06 (precarga E2 ‚Äî decisi√≥n diferida post-deload resuelta en Nota 8), HU-08 (ejercicios bodyweight/isom√©tricos ‚Äî prescripciones espec√≠ficas durante deload anticipadas por HU-08), HU-09 (rotaci√≥n + cierre de sesi√≥n ‚Äî punto de extensi√≥n `advanceRotation`), HU-10 (clasificaci√≥n y estado IN_DELOAD ya soportado), HU-11 (prescripci√≥n de carga ‚Äî `prescribedLoadKg` que se sobreescribir√° post-deload), HU-12 (alerta MODULE_REQUIRES_DELOAD ‚Äî trigger visual para activar descarga + acciones correctivas escalonadas), HU-13 (E5 muestra clasificaci√≥n durante deload sessions ‚Äî lectura, se√±ales de acci√≥n inocuas).
- HU-14 alimenta: HU-15 (KPIs y m√©tricas ‚Äî tasa de progresi√≥n y tonelaje durante deload son datos derivados), HU-17 (H1/H2 alertas con enlace "Gestionar descarga" ‚Üí I1; CA-17.19-17.20 verifican si ca√≠da de tonelaje es por descarga planificada).
- HU-14 modifica componentes de: HU-05 (startSession), HU-06 (getLastWeightForExercise exclusi√≥n deload), HU-09 (closeSession, advanceRotation), HomeScreen.

**Impacto en performance:**

- `getActiveDeload()`: 1 SELECT con `WHERE status = 'ACTIVE' LIMIT 1`. Index en `status`. Despreciable.
- `countDeloadSessions(deloadId)`: COUNT con WHERE en columna indexada. O(1).
- `getPreDeloadAvgWeight(exerciseId, activationDate)`: Subquery con JOIN en exercise_set ‚Üí session_exercise ‚Üí session, filtrada por `session.deload_id IS NULL AND session.date < activationDate`. Con √≠ndices existentes, no supera 100 filas. Despreciable.
- `transitionToDeload()`: UPDATE masivo de `exercise_progression` WHERE status NOT IN ('NO_HISTORY', 'MASTERED'). M√°ximo ~40 filas (total ejercicios del sistema). Despreciable.
- Impacto total: m√≠nimo. Todas las operaciones son O(1) o O(n) con n ‚â§ 40.

**Cadena de invocaci√≥n ‚Äî Activaci√≥n:**

```
DeloadManagementScreen ‚Üí onActivateDeload()
  ‚Üí DeloadManagementViewModel.activateDeload()
    ‚Üí ActivateDeloadUseCase(sessionRepository)
      ‚Üí sessionRepository.activateDeload()
        ‚Üí database.withTransaction {
            rotationState = rotationStateDao.getRotationState().first()
            deloadDao.insert(DeloadEntity(
              status = "ACTIVE",
              activationDate = today,
              frozenVersionModuleA = rotationState.currentVersionModuleA,
              frozenVersionModuleB = rotationState.currentVersionModuleB,
              frozenVersionModuleC = rotationState.currentVersionModuleC,
            ))
            exerciseProgressionDao.transitionToDeload()
          }
```

**Cadena de invocaci√≥n ‚Äî Ciclo (inicio de sesi√≥n):**

```
HomeScreen ‚Üí onStartSession(moduleVersionId)
  ‚Üí StartSessionUseCase(sessionRepository)
    ‚Üí sessionRepository.startSession(moduleVersionId)
      ‚Üí deload = deloadDao.getActiveDeloadOnce()
      ‚Üí sessionEntity = SessionEntity(
          moduleVersionId = moduleVersionId,
          deloadId = deload?.id,   // ‚Üê NEW: asigna deloadId
          date = today,
        )
      ‚Üí sessionDao.insert(sessionEntity)
```

**Cadena de invocaci√≥n ‚Äî Finalizaci√≥n (cierre sesi√≥n 6):**

```
ActiveSessionViewModel.onCloseSessionConfirmed()
  ‚Üí closeSessionUseCase(sessionId)
    ‚Üí sessionRepository.closeSession(sessionId)
      ‚Üí evaluateProgression(sessionId, moduleVersionId, isDeloadSession=true)
        ‚Üí [clasificaci√≥n per-exercise, NO recalculo de prescribed_load_kg]
      ‚Üí advanceRotation(currentRotation, isDeload=true)
        ‚Üí [posici√≥n avanza, microcycleCount++, versiones NO rotan]
      ‚Üí sessionCount = sessionDao.countDeloadSessions(deloadId)
      ‚Üí if (sessionCount == 6) {
          deloadDao.complete(deloadId, today)
          // Reset loads to 90% pre-deload
          for each standard exercise:
            preDeloadWeight = getPreDeloadAvgWeight(exerciseId, activationDate)
            resetLoad = DeloadLoadRule.calculateResetLoad(preDeloadWeight, loadIncrementKg)
            exerciseProgressionDao.update(
              status = "IN_PROGRESSION",
              prescribedLoadKg = resetLoad,
              sessionsWithoutProgression = 0,
            )
          // Resolve MODULE_REQUIRES_DELOAD alerts
          alertDao.resolveAllByType("MODULE_REQUIRES_DELOAD", today)
        }
```

### Notas T√©cnicas

**Nota 1 ‚Äî La FK de `session.deload_id` a `deload.id` se agrega en la migration 5‚Üí6.**

Actualmente `SessionEntity` tiene la columna `deload_id` con index pero sin FK constraint (la tabla `deload` no exist√≠a). La migration 5‚Üí6 crea la tabla `deload` y luego agrega la FK. En SQLite, no se puede `ALTER TABLE ADD CONSTRAINT` ‚Äî se necesita recrear la tabla session. **Sin embargo**, dado que la columna ya existe y tiene los valores correctos (todos NULL), una alternativa m√°s simple es: crear tabla `deload` y dejar la FK como "l√≥gica" (verificada a nivel de aplicaci√≥n, no a nivel DB). Esto es consistente con el patr√≥n existente: `session.deload_id` ya tiene Index pero no FK en el Entity actual. Se mantiene este enfoque por simplicidad de migraci√≥n.

**Nota 2 ‚Äî `getNextModuleVersionId()` y `GetNextSessionInfoUseCase` ya no pueden usar solo `rotation_state` para versiones.**

Actualmente, `SessionRepositoryImpl.getNextModuleVersionId()` (l√≠neas 56-75) usa `rotationStateDao.getRotationState()` para resolver m√≥dulo y versi√≥n. `GetNextSessionInfoUseCase.invoke()` tambi√©n usa `sessionRepository.getRotationState()` para resolver `versionNumber` y construir `NextSession`. Con deload activo, la versi√≥n debe venir de `deload.frozen_version_module_X`. Se modifica el Flow para: consultar deload activo ‚Üí si existe, usar versiones congeladas ‚Üí si no, usar rotation_state normal. Esto requiere combinar dos Flows con `combine()` o consultar deload como suspend inside the map. Ambos puntos (`getNextModuleVersionId` y `GetNextSessionInfoUseCase`) deben ser consistentes.

**Nota 3 ‚Äî El "Estado C: Post-descarga" de I1 es ef√≠mero.**

El Estado C (cargas de reinicio) se muestra entre que el deload se completa y la primera sesi√≥n post-deload se cierra. Despu√©s, las cargas de reinicio ya est√°n persistidas en `exercise_progression.prescribed_load_kg` y el deload tiene `status = COMPLETED`. Para determinar si mostrar Estado C: verificar si existe un deload COMPLETED cuya `completion_date` sea reciente Y no se haya iniciado ninguna sesi√≥n posterior sin `deload_id`. Alternativa m√°s simple: el Estado C se muestra cuando el √∫ltimo deload es COMPLETED y no se ha iniciado sesi√≥n post-deload. Una vez que el ejecutante inicia la siguiente sesi√≥n, el Estado C desaparece de I1 y la pantalla muestra "No hay descarga pendiente".

**Nota 4 ‚Äî Bodyweight e isom√©tricos durante deload: no se calcula carga.**

CA-14.09 especifica: bodyweight ‚Üí 8 reps, RIR 4-5 (Peso=0); isom√©tricos ‚Üí 30 segundos, RIR 4-5. Estos par√°metros son de **prescripci√≥n visual** (se muestran en E1 y I1), pero no se persisten en `exercise_progression` (prescribed_load_kg sigue NULL). La UI de E1 ya muestra el rango de reps del plan_assignment ‚Äî durante deload, la prescripci√≥n visual puede mostrar "8 reps" y "RIR 4-5" como overlay informativo. La implementaci√≥n de E1-deload visual es responsabilidad de esta HU (CA-14.07).

**Nota 5 ‚Äî La sesi√≥n incompleta durante deload s√≠ cuenta para el progreso del microciclo de descarga.**

El conteo de sesiones del deload usa `status IN ('COMPLETED', 'INCOMPLETE')`. Una sesi√≥n cerrada como incompleta durante deload avanza el progreso (4/6 ‚Üí 5/6). El ejecutante no puede "saltarse" la descarga cerrando sesiones incompletas a prop√≥sito ‚Äî las sesiones registradas tienen datos reales que ser√°n clasificados.

**Nota 6 ‚Äî Solo puede haber una descarga activa a la vez.**

`activateDeload()` verifica que no exista deload con `status = 'ACTIVE'` antes de crear uno nuevo. Si ya hay uno activo, la operaci√≥n lanza una excepci√≥n o simplemente no crea otro (el bot√≥n "Activar Descarga" solo aparece en Estado A, que requiere ausencia de deload activo).

**Nota 7 ‚Äî La migration 5‚Üí6 es destructiva solo si hay datos inconsistentes.**

La tabla `deload` se crea vac√≠a. La columna `session.deload_id` ya existe con todos valores NULL. No hay datos que migrar ‚Äî solo se crea la estructura. La migration es una simple `CREATE TABLE IF NOT EXISTS deload (...)`.

**Nota 8 ‚Äî Precarga en E2 post-deload: decisi√≥n diferida de HU-06.**

HU-06 (Nota 9) identifica un conflicto post-deload: `ExerciseSetDao.getLastWeightForExercise()` (l√≠nea 32) consulta el √∫ltimo `weight_kg` para un ejercicio sin filtrar sesiones de deload. Post-deload, la primera sesi√≥n normal precargar√≠a la carga de descarga (60%) en E2, mientras que E1 mostrar√≠a la carga de reinicio (90% pre-descarga) de `exercise_progression.prescribed_load_kg`. Existen dos opciones:

- **Opci√≥n A (recomendada):** Modificar `getLastWeightForExercise()` para excluir sesiones de deload: agregar `INNER JOIN session s ON s.id = se.session_id WHERE s.deload_id IS NULL` al query. As√≠ la precarga en E2 ser√≠a la carga pre-descarga, coherente con la carga de reinicio (90%).
- **Opci√≥n B:** Aceptar la discrepancia: E2 precarga la √∫ltima carga usada (60% deload), E1 muestra la carga objetivo (90% reinicio). El ejecutante ajustar√≠a manualmente al registrar.

Se elige la **Opci√≥n A** para consistencia UX. Este cambio se implementa en HU-14 y resuelve la decisi√≥n diferida de HU-06.

**Nota 9 ‚Äî Se√±ales de acci√≥n en E5 durante sesiones de deload.**

HU-13 define `ActionSignalRule` que genera se√±ales para E5 ("Subir carga", "Mantener carga", "Considerar descarga"). Durante una sesi√≥n de deload, estas se√±ales son sem√°nticamente innecesarias porque las cargas est√°n fijadas al 60% y la progresi√≥n est√° congelada (IN_DELOAD). El `ActionSignalRule` puede generar se√±ales incorrectas (ej: "Subir carga" porque la clasificaci√≥n fue POSITIVE_PROGRESSION comparada con la serie reducida de deload). Sin embargo, como `prescribed_load_kg` est√° protegido por el guard de Decisi√≥n 12 y los estados no cambian, las se√±ales son inocuas ‚Äî no se persisten ni afectan la l√≥gica. Para mayor claridad UX, el desarrollador puede optar por mostrar una se√±al gen√©rica "Sesi√≥n de descarga" en E5 cuando `deloadId != null`, suprimiendo las se√±ales individuales.

### Verificaci√≥n Cruzada de CAs

| CA | Estado | Mecanismo | Implementado en |
|---|---|---|---|
| CA-14.01 | üî® Por implementar | `ActivateDeloadUseCase` ‚Üí crear `DeloadEntity(ACTIVE)` + `transitionToDeload()` | HU-14 (UseCase + Repository) |
| CA-14.02 | üî® Por implementar | `DeloadLoadRule.calculateDeloadLoad(lastWeight, increment)` ‚Üí 60% redondeado down. Se muestra en E1 como prescripci√≥n visual | HU-14 (Rule + UI E1) |
| CA-14.03 | üî® Por implementar | `countDeloadSessions(deloadId) == 6` ‚Üí `deloadDao.complete()` en `closeSession()` | HU-14 (Repository) |
| CA-14.04 | üî® Por implementar | `advanceRotation(isDeload=true)` ‚Üí versiones NO avanzan. `startSession()` usa `deload.frozen_version_module_X` | HU-14 (RotationResolver + Repository) |
| CA-14.05 | üî® Por implementar | `DeloadLoadRule.calculateResetLoad(preDeloadWeight, increment)` ‚Üí 90% redondeado down. Persistido en `prescribed_load_kg` al finalizar deload | HU-14 (Rule + Repository) |
| CA-14.06 | üî® Por implementar | `floor(value / increment) * increment` con `loadIncrementKg` de `module.load_increment_kg` | HU-14 (Rule) |
| CA-14.07 | üî® Por implementar | I1 Estado B muestra progreso + par√°metros. Indicador en B1 (Card Descarga). Indicador en E1 (badge deload) | HU-14 (Screen I1 + HomeScreen + ActiveSessionScreen indicator) |
| CA-14.08 | üî® Por implementar | Al finalizar deload: `exercise_progression.status` ‚Üí `IN_PROGRESSION`, `sessions_without_progression = 0`, `prescribed_load_kg = resetLoad (90%)` | HU-14 (Repository) |
| CA-14.09 | üî® Por implementar | Guard: `if (isBodyweight \|\| isIsometric)` ‚Üí no calcula carga deload/reinicio. Prescripci√≥n visual: 8 reps / 30 seg, RIR 4-5 | HU-14 (Rule guard + UI) |
| CA-14.10 | ‚úÖ Ya implementado | `advanceRotation()` incrementa `microcycleCount` al cerrar posici√≥n 6 | HU-09 (RotationResolver) |
| CA-14.11 | ‚úÖ Ya implementado | Rotaci√≥n agn√≥stica al calendario ‚Äî basada en secuencia de sesiones | HU-09 (RotationResolver) |
| CA-14.12 | ‚úÖ Ya implementado | `rotation_state.microcycle_count` persistido en Room | HU-09 (RotationStateEntity) |
| CA-14.13 | üî® Por implementar | `advanceRotation(isDeload=true)` en posici√≥n 6 ‚Üí incrementa microcycleCount (nuevo test) | HU-14 (RotationResolver test) |
| CA-14.14 | ‚úÖ Ya implementado | `HomeScreen` ya muestra `microcycleCount` via `GetMicrocycleCountUseCase` | HU-05 (HomeScreen) |

### Referencias y Validaci√≥n

**Documentaci√≥n consultada:**

- Manifiesto de Dominio Sist√©mico ¬ß6-A R5 ‚Äî Protocolo de Descarga (60%, 4 series, 8 reps, RIR 4-5, 1 microciclo, post-descarga 90%)
- Modelo de Datos ¬ß3.10 (session.deload_id), ¬ß3.13 (exercise_progression.status IN_DELOAD), ¬ß3.14 (rotation_state.microcycle_count), ¬ß3.15 (deload ‚Äî entidad nueva completa)
- ADR-06 ‚Äî Motor de reglas Kotlin puro
- ADR D-08 ‚Äî Descarga dura 1 microciclo (6 sesiones), versiones congeladas
- Arquitectura T√©cnica ¬ß5.2 ‚Äî Naming: `DeloadLoadRule`, `DeloadManagementScreen`, `DeloadManagementViewModel`
- Wireframes I1 ‚Äî Gesti√≥n de Descarga (3 estados: requerida/activa/post-descarga)
- Especificaci√≥n Visual ¬ßI1 ‚Äî Componentes M3, colores azul descarga (#1565C0/#64B5F6), LinearProgressIndicator
- Wireframes B1 ‚Äî Card "Estado de Descarga" condicional
- Especificaci√≥n Visual ¬ßB1 ‚Äî Card Descarga: Secondary Container, enlace "Ver gesti√≥n de descarga ‚Üí"
- Mapa de Navegaci√≥n ¬ß6 (I1) ‚Äî B1‚ÜíI1, H2‚ÜíI1
- Requerimientos RF38-41

**Historias relacionadas:**

- HU-05: Establece `startSession()` ‚Äî punto de extensi√≥n para asignar `deloadId` y resolver versiones congeladas.
- HU-06: Define `getLastWeightForExercise()` para precarga en E2. Nota 9 de HU-06 defiere la decisi√≥n post-deload a HU-14. Resuelta en Nota 8 (excluir sesiones de deload del query).
- HU-08: Anticipa prescripciones espec√≠ficas para bodyweight (8 reps, RIR 4-5) e isom√©tricos (30 seg, RIR 4-5) durante deload ‚Äî referencia "CA-17.09" (ahora CA-14.09).
- HU-09: Establece `closeSession()`, `advanceRotation()`, `RotationState` ‚Äî puntos de extensi√≥n principales de HU-14. Decisi√≥n 6 de HU-09 anticipa el par√°metro `isDeload: Boolean`.
- HU-10: Produce `session_exercise.progression_classification` y `exercise_progression.status`. `resolveNewProgressionState()` (l√≠nea 48) ya maneja IN_DELOAD (no change). Nota 6 de HU-10 discute la frontera con el deload.
- HU-11: Produce `exercise_progression.prescribed_load_kg`. HU-14 sobreescribe este valor post-deload con 90% de carga pre-deload.
- HU-12: Produce alerta `MODULE_REQUIRES_DELOAD` ‚Äî trigger visual para I1 Estado A y Card B1. Guard `isDeloadSession` ya aplicado en module-level detection. Tambi√©n contiene acciones correctivas escalonadas (Bloque C/D).
- HU-13: E5 muestra clasificaci√≥n durante sesiones de deload. `ActionSignalRule` genera se√±ales que son inocuas durante deload (ver Nota 9). `moduleRequiresDeload` se consulta via `alertDao.existsActiveByModule()`.
- HU-15: KPIs y m√©tricas ‚Äî la tasa de progresi√≥n y el tonelaje durante deload son datos derivados que HU-15 consumir√°.
- HU-17 (futuro): Sistema de Alertas H1/H2 con enlace "Gestionar descarga" ‚Üí I1. CA-17.19 y CA-17.20 verifican si una ca√≠da de tonelaje es por descarga planificada, referenciando HU-14 expl√≠citamente.

**Validado por:** esteban.colorado | **Fecha:** 2026-02-17 | **Enfoque:** Exploratorio

## Refinamiento T√©cnico (Developer)

<!-- === DEVELOPER RECORD ‚Äî HU-14 ===
Generado por: Developer Agent (metodo-ceiba)
Fecha: 2026-02-17
Estado: APROBADO con correcciones
=== -->

<!-- === BLOQUE 1: CONTEXTO CARGADO === -->

<!--
Documentos le√≠dos:
- docs/architecture/ADR.md (ADR-06, ADR D-08)
- docs/architecture/Arquitectura T√©cnica.md (¬ß2.5, ¬ß2.6, ¬ß3.2, ¬ß5.1, ¬ß5.2)
- docs/architecture/Especificaci√≥n Visual.md (¬ßI1, ¬ßB1 Card Descarga)
- docs/architecture/Mapa de Navegaci√≥n.md (I1 transitions)
- docs/architecture/Modelo de Datos.md (¬ß3.10, ¬ß3.13, ¬ß3.14, ¬ß3.15)
- docs/architecture/Wireframes.md (I1 wireframe, B1 Card Descarga)
- docs/business_definition/Requerimientos.md (RF38-41)
- docs/business_definition/Manifiesto de Dominio Sist√©mico.md (R5)
- docs/business_definition/Visi√≥n del Producto.md
- docs/stories/HU-05.md, HU-06.md, HU-08.md, HU-09.md, HU-10.md, HU-11.md, HU-12.md, HU-13.md

Archivos fuente verificados:
- SessionRepositoryImpl.kt (493 l√≠neas) ‚Äî constructor L43-53, startSession L76-109, closeSession L279-325, evaluateProgression L326-482
- RotationResolver.kt (37 l√≠neas) ‚Äî advanceRotation L24-36, resolveModuleCode L5, resolveVersionNumber L12
- SessionEntity.kt (41 l√≠neas) ‚Äî deloadId L35 existente con index, sin FK
- ExerciseProgressionEntity.kt (34 l√≠neas) ‚Äî status string (NO_HISTORY/IN_PROGRESSION/IN_PLATEAU/IN_DELOAD/MASTERED)
- RotationStateEntity.kt (29 l√≠neas) ‚Äî currentVersionModuleA/B/C, microcycleCount
- ModuleEntity.kt (20 l√≠neas) ‚Äî loadIncrementKg (2.5 para A/B, 5.0 para C)
- ExerciseSetDao.kt (69 l√≠neas) ‚Äî getLastWeightForExercise L22-31 (sin filtro deload)
- ExerciseProgressionDao.kt (26 l√≠neas) ‚Äî getByExerciseId, insert, insertIfNotExists, update
- AlertDao.kt (59 l√≠neas) ‚Äî existsActiveByModule, resolveByModuleAndType, countActive, getActiveAlerts
- SessionDao.kt (93 l√≠neas) ‚Äî getDeloadIdBySessionId L66, getActiveSessionWithModuleVersion
- RotationStateDao.kt (22 l√≠neas) ‚Äî getRotationState Flow
- DoubleThresholdRule.kt (33 l√≠neas) ‚Äî prescribeLoad L22-29
- ProgressionClassificationRule.kt (135 l√≠neas) ‚Äî resolveNewProgressionState L35, IN_DELOAD guard L44: no change ‚úì
- GetNextSessionInfoUseCase.kt (43 l√≠neas) ‚Äî resolveModuleCode + resolveVersionNumber via rotationState
- HomeViewModel.kt (74 l√≠neas) ‚Äî combine 3 flows, alertCount hardcoded = 0
- HomeUiState.kt (16 l√≠neas) ‚Äî sin deloadState
- HomeScreen.kt (279 l√≠neas) ‚Äî sin Card Descarga
- NavigationRoutes.kt (30 l√≠neas) ‚Äî sin DELOAD_MANAGEMENT
- TensionNavHost.kt (341 l√≠neas) ‚Äî L119: TODO HU-14+, showBottomBar L81-89
- TensionDatabase.kt (74 l√≠neas) ‚Äî version=5, 15 entities, 14 DAOs
- DatabaseModule.kt (117 l√≠neas) ‚Äî fallbackToDestructiveMigration, 14 provides
- RepositoryModule.kt (45 l√≠neas) ‚Äî bindSessionRepository
- RotationResolverTest.kt (106 l√≠neas) ‚Äî 6 tests, sin caso isDeload
- Color.kt ‚Äî DeloadActiveLight (#1565C0) / DeloadActiveDark (#64B5F6) ya definidos
- Theme.kt ‚Äî deloadActive en TensionSemanticColors ya definido
- ActiveSessionViewModel.kt (111 l√≠neas) ‚Äî combine 2 flows, loadDisplayText switch sin deload
- ActiveSessionUiState.kt (39 l√≠neas) ‚Äî sin isDeloadSession ni deload badge support
- ActiveSessionScreen.kt (520 l√≠neas) ‚Äî sin badge deload, LoadText sin variantes 60%
-->

**Basado en an√°lisis arquitect√≥nico:**
HU-14 es la historia m√°s transversal del sistema: 9 componentes nuevos + 17 modificados distribuidos en 11 fases. Opera en tres fases temporalmente distintas (activaci√≥n ‚Üí ciclo de 6 sesiones ‚Üí finalizaci√≥n) e interviene en los flujos cr√≠ticos de inicio/cierre de sesi√≥n, rotaci√≥n, y progresi√≥n. Hallazgos principales verificados contra el c√≥digo: (1) `SessionEntity.deloadId` ya existe con index pero sin FK ‚Äî la migraci√≥n 5‚Üí6 solo crea tabla `deload`, FK queda l√≥gica (Nota 1 del arquitecto). (2) `ProgressionClassificationRule.resolveNewProgressionState()` L48 ya maneja IN_DELOAD (no change). (3) `DoubleThresholdRule.prescribeLoad()` L22-29 S√ç se ejecuta durante deload y sobreescribe `prescribed_load_kg` ‚Äî necesita guard expl√≠cito. (4) Gesti√≥n de alertas PLATEAU L415-430 en `evaluateProgression()` S√ç se ejecuta durante deload ‚Äî necesita guard. (5) `ExerciseSetDao.getLastWeightForExercise()` L22-31 no filtra sesiones de deload ‚Äî post-deload precargar√≠a peso 60% en E2. (6) `RotationResolver.advanceRotation()` no tiene par√°metro `isDeload` ‚Äî se agrega con default=false para retrocompatibilidad. (7) El Bloque B (CA-14.10 a CA-14.14) ya est√° implementado: rotaci√≥n incrementa microcycleCount, persistido en Room, mostrado en B1. Solo necesita test nuevo para caso isDeload=true. (8) Colores sem√°nticos de deload ya definidos: DeloadActiveLight (#1565C0) / DeloadActiveDark (#64B5F6). (9) Especificaci√≥n Visual ¬ßI1 y Wireframes I1 referencian HU-16/HU-17 (numeraci√≥n original pre-consolidaci√≥n) ‚Äî en este proyecto son HU-14.

**Nivel de complejidad:**
ALTA ‚Äî HU-14 toca 26 archivos (9 nuevos + 17 modificados) con l√≥gica distribuida en todas las capas. La transversalidad es cr√≠tica: modifica `startSession()`, `closeSession()`, `evaluateProgression()`, `advanceRotation()`, y `getNextModuleVersionId()` ‚Äî los 5 flujos m√°s importantes del sistema. `DeloadLoadRule` es simple (2 funciones puras), pero la orquestaci√≥n en `SessionRepositoryImpl` es delicada: 3 guards en `evaluateProgression`, 1 bloque de finalizaci√≥n en `closeSession` (~30 l√≠neas), y 2 puntos de resoluci√≥n de versiones congeladas. La pantalla I1 tiene 3 estados mutuamente excluyentes + 1 estado impl√≠cito (sin descarga). La migraci√≥n 5‚Üí6 es simple (CREATE TABLE). Riesgo principal: un error en los guards de `evaluateProgression` produce prescripciones de carga incorrectas durante deload. Tests unitarios: ~15 escenarios (DeloadLoadRule) + ~3 escenarios (RotationResolver isDeload).

**Riesgos t√©cnicos conocidos:**

1. **Guard `prescribeLoad()` durante deload:** `DoubleThresholdRule.prescribeLoad()` se ejecuta en L393-402 de `evaluateProgression()` y sobreescribe `prescribed_load_kg` incluso durante deload. Sin guard, la carga de reinicio post-deload se pierde. Guard: `if (isDeloadSession) { prescribedLoadKg = currentProgression.prescribedLoadKg }`.
2. **Guard alertas PLATEAU durante deload:** L412-430 crea/resuelve alertas PLATEAU durante deload. Durante deload, los ejercicios est√°n en estado IN_DELOAD y no deber√≠an generar alertas de meseta. Guard: `if (!isDeloadSession) { /* plateau alert logic */ }`.
3. **`getLastWeightForExercise()` sin filtro deload:** Post-deload, la primera sesi√≥n normal precargar√≠a la carga de descarga (60%) en E2, mientras que E1 mostrar√≠a la carga de reinicio (90%). Se agrega filtro `s.deload_id IS NULL` al query (HU-06 Nota 9, opci√≥n A).
4. **Resoluci√≥n de versiones congeladas en 2 puntos:** `getNextModuleVersionId()` (Flow reactivo) y `GetNextSessionInfoUseCase` (Flow reactivo) ambos necesitan consultar deload activo para versiones congeladas. Deben ser consistentes ‚Äî ambos usan dominio `Deload` como fuente (mapeado desde `DeloadEntity` en la capa data).
5. **Finalizaci√≥n de deload en `closeSession()` es transaccional:** El bloque (complete deload + reset loads 90% + transition IN_DELOAD‚ÜíIN_PROGRESSION + resolver alertas) debe ejecutarse dentro del mismo `database.withTransaction {}` existente.
6. **Se√±ales E5 durante deload son inocuas:** `ActionSignalRule` genera se√±ales basadas en clasificaci√≥n y `prescribed_load_kg` que est√°n protegidas. Las se√±ales resultantes pueden no tener sentido sem√°ntico pero no afectan la l√≥gica. Decisi√≥n: no modificar E5 en esta HU.

**Patrones y convenciones del equipo (establecidos en HU-01‚ÄîHU-13):**

- C√≥digo fuente en ingl√©s, UI y datos de dominio en espa√±ol (Arquitectura T√©cnica ¬ß5.1)
- Naming: `{Nombre}Rule` para reglas, `{Feature}Screen` para composables, `{Feature}ViewModel` para VMs, `{Feature}UiState` para estados
- `object` singleton para reglas puras (patr√≥n `ProgressionClassificationRule`, `ModuleFatigueRule`)
- Entity Room: `@Entity(tableName = "...")` con indices y FK declarativos
- DAO: `@Dao interface` con queries `@Query("""...""")`, DTOs como data class fuera de la interfaz
- Repository: interface en `domain/repository/`, implementaci√≥n en `data/repository/`
- UseCase: `@Inject constructor` + `operator fun invoke()`
- `@HiltViewModel` + `SavedStateHandle` (si args de navegaci√≥n) o `@Inject constructor` directo
- Tests: JUnit 4, helpers factories, sin mocks para reglas puras
- `composable()` con `navArgument` para rutas parametrizadas
- `database.withTransaction {}` para operaciones multi-tabla
- `fallbackToDestructiveMigration()` en DatabaseModule (migraci√≥n destructiva ‚Äî aceptable en pre-release)

**Dependencias nuevas a instalar:**
Ninguna.

**Estrategia de testing:**
JUnit 4 para reglas puras | 2 archivos de test: (1) `DeloadLoadRuleTest` (~15 escenarios): cubre 60% con redondeo A/B (increment 2.5), 60% con redondeo C (increment 5.0), 90% con redondeo, edge cases (carga 0, carga m√≠nima 2.5, carga con residuo no m√∫ltiplo). (2) `RotationResolverTest` (+3 escenarios agregados al archivo existente): `advanceRotation(isDeload=true)` en posiciones 1-5, posici√≥n 6 (versions frozen, microcycleCount s√≠ incrementa), position 6 con versiones mixtas. Las queries DAO, la l√≥gica de `evaluateProgression` con guards, y la pantalla I1 se validan manualmente o con tests instrumentados en Fase N.

### Historias Relacionadas Consultadas

**Implementaciones similares analizadas:**

- HU-09 (`closeSession()`, `advanceRotation()`, `RotationResolver`) ‚Äî Punto de extensi√≥n principal. Decisi√≥n 6 de HU-09: "Cuando HU-17 se implemente, `advanceRotation` recibir√° `isDeload: Boolean` adicional." L√≠nea 313 invoca `advanceRotation(currentRotation)` sin `isDeload` ‚Üí se agrega.
- HU-10 (`evaluateProgression()`, `ProgressionClassificationRule`) ‚Äî L48: `resolveNewProgressionState(currentStatus="IN_DELOAD")` retorna mismo estado/counter. Ya funciona para HU-14. HU-14 agrega guards previos a esta l√≠nea.
- HU-11 (`DoubleThresholdRule.prescribeLoad()`) ‚Äî Escribe `prescribed_load_kg` L388-401. Durante deload esta asignaci√≥n se guarda en `prescribedLoadKg` variable ‚Üí guard: usar `currentProgression.prescribedLoadKg` en vez de recalcular.
- HU-12 (`AlertDao`, `ModuleFatigueRule`, `DeloadNeedRule`) ‚Äî Produce alertas MODULE_REQUIRES_DELOAD que disparan I1 Estado A. Guard `isDeloadSession` en L442 ya salta module-level detection. HU-14 agrega guard tambi√©n para alertas PLATEAU per-exercise.
- HU-06 (`ExerciseSetDao.getLastWeightForExercise()`) ‚Äî Nota 9 difiere decisi√≥n post-deload a HU-14. Opci√≥n A (excluir deload sessions) seleccionada.
- HU-05 (`startSession()`, `HomeScreen`, `HomeViewModel`) ‚Äî Punto de extensi√≥n para `deloadId` assignment y Card Descarga en B1.
- HU-13 (`ActionSignalRule`, `SessionSummaryScreen`) ‚Äî Se√±ales inocuas durante deload (Nota 9 del arquitecto). No se modifica.

**Patrones de c√≥digo reutilizados:**

- `database.withTransaction {}` ‚Üí bloque de activaci√≥n y bloque de finalizaci√≥n (patr√≥n `closeSession`)
- `object` singleton con funci√≥n pura ‚Üí `DeloadLoadRule` (patr√≥n `DoubleThresholdRule`)
- `sealed interface` con variantes ‚Üí `DeloadState` (patr√≥n `ActionSignal`, `ExerciseDetailUiState`)
- `sealed interface UiState` con `Loading | Content | Error` ‚Üí `DeloadManagementUiState`
- `@HiltViewModel` + `viewModelScope.launch` ‚Üí `DeloadManagementViewModel` (patr√≥n `HomeViewModel`)
- DAO queries con JOINs ‚Üí `getPreDeloadAvgWeight`, `countDeloadSessions`
- `Flow.flatMapLatest` con conditional ‚Üí resoluci√≥n de versiones congeladas (patr√≥n `getNextModuleVersionId`)

**Mejores pr√°cticas aplicadas:**

- Guards defensivos en `evaluateProgression()`: proteger `prescribed_load_kg` y alertas PLATEAU durante deload
- Transaccionalidad: toda la finalizaci√≥n de deload (complete + reset loads + transition + resolve alerts) en una sola transacci√≥n
- Retrocompatibilidad: `advanceRotation(isDeload=false)` default ‚Üí tests existentes pasan sin cambio
- Migraci√≥n no destructiva: `CREATE TABLE IF NOT EXISTS deload(...)` ‚Äî la columna `session.deload_id` ya existe
- Inmutabilidad de datos de referencia: carga pre-deload derivada de datos hist√≥ricos, no almacenada

---

## Tareas de Implementaci√≥n (Developer)

### Fase 1: Domain ‚Äî DeloadLoadRule + tests

<!-- Basado en Hito #1 del An√°lisis Arquitect√≥nico -->

#### üì¶ Domain Rule

- [ ] **Crear `DeloadLoadRule`** (AC: 2, 5, 6, 13)
  - [ ] Crear archivo: `domain/rules/DeloadLoadRule.kt`
  - [ ] `object DeloadLoadRule`
  - [ ] `fun calculateDeloadLoad(lastWeightKg: Double, loadIncrementKg: Double): Double`
    - F√≥rmula: `floor(lastWeightKg * 0.60 / loadIncrementKg) * loadIncrementKg`
    - Guard: `if (loadIncrementKg <= 0.0) return 0.0`
    - Guard: `if (lastWeightKg <= 0.0) return 0.0`
  - [ ] `fun calculateResetLoad(preDeloadWeightKg: Double, loadIncrementKg: Double): Double`
    - F√≥rmula: `floor(preDeloadWeightKg * 0.90 / loadIncrementKg) * loadIncrementKg`
    - Guard: `if (loadIncrementKg <= 0.0) return 0.0`
    - Guard: `if (preDeloadWeightKg <= 0.0) return 0.0`
  - [ ] Ambas funciones: `import kotlin.math.floor`
  - [ ] Constantes: `private const val DELOAD_PERCENTAGE = 0.60`, `private const val RESET_PERCENTAGE = 0.90`

#### üì¶ Tests

- [ ] **Crear `DeloadLoadRuleTest`** (AC: 2, 5, 6)
  - [ ] Crear archivo: `test/.../domain/rules/DeloadLoadRuleTest.kt`
  - [ ] ~15 escenarios:
    1. 60% de 60 Kg, increment 2.5 ‚Üí 35.0 Kg
    2. 60% de 55 Kg, increment 2.5 ‚Üí 32.5 Kg
    3. 60% de 100 Kg, increment 5.0 ‚Üí 60.0 Kg
    4. 60% de 80 Kg, increment 5.0 ‚Üí 45.0 Kg (80√ó0.6=48 ‚Üí floor(48/5)√ó5 = 45)
    5. 60% de 2.5 Kg, increment 2.5 ‚Üí 0.0 Kg (2.5√ó0.6=1.5 ‚Üí floor(1.5/2.5)√ó2.5 = 0.0)
    6. 60% de 0 Kg, increment 2.5 ‚Üí 0.0 Kg
    7. 90% de 60 Kg, increment 2.5 ‚Üí 52.5 Kg (60√ó0.9=54 ‚Üí floor(54/2.5)√ó2.5 = 52.5)
    8. 90% de 55 Kg, increment 2.5 ‚Üí 47.5 Kg (55√ó0.9=49.5 ‚Üí floor(49.5/2.5)√ó2.5 = 47.5)
    9. 90% de 100 Kg, increment 5.0 ‚Üí 90.0 Kg
    10. 90% de 80 Kg, increment 5.0 ‚Üí 70.0 Kg (80√ó0.9=72 ‚Üí floor(72/5)√ó5 = 70)
    11. 90% de 0 Kg, increment 2.5 ‚Üí 0.0 Kg
    12. 60% de 62.5 Kg, increment 2.5 ‚Üí 37.5 Kg (62.5√ó0.6=37.5 ‚Üí exacto)
    13. 90% de 62.5 Kg, increment 2.5 ‚Üí 55.0 Kg (62.5√ó0.9=56.25 ‚Üí floor(56.25/2.5)√ó2.5 = 55.0)
    14. 60% con increment 0.0 ‚Üí 0.0 (guard)
    15. 90% con increment 0.0 ‚Üí 0.0 (guard)

### Fase 2: Data ‚Äî DeloadEntity + DeloadDao + migration

<!-- Basado en Hito #2 del An√°lisis Arquitect√≥nico -->

#### üì¶ Data Layer (entity + dao + database)

- [ ] **Crear `DeloadEntity`** (AC: 1, 3, 4)
  - [ ] Crear archivo: `data/local/entity/DeloadEntity.kt`
  - [ ] `@Entity(tableName = "deload", indices = [Index(value = ["status"])])`
  - [ ] Columnas (¬ß3.15 Modelo de Datos):
    - `@PrimaryKey(autoGenerate = true) val id: Long = 0`
    - `@ColumnInfo(name = "status") val status: String = "ACTIVE"` ‚Äî CHECK(ACTIVE, COMPLETED)
    - `@ColumnInfo(name = "activation_date") val activationDate: String`
    - `@ColumnInfo(name = "completion_date") val completionDate: String? = null`
    - `@ColumnInfo(name = "frozen_version_module_a") val frozenVersionModuleA: Int`
    - `@ColumnInfo(name = "frozen_version_module_b") val frozenVersionModuleB: Int`
    - `@ColumnInfo(name = "frozen_version_module_c") val frozenVersionModuleC: Int`
- [ ] **Crear `DeloadDao`** (AC: 1, 3, 7)
  - [ ] Crear archivo: `data/local/dao/DeloadDao.kt`
  - [ ] `@Dao interface DeloadDao`
  - [ ] Queries:
    - `@Insert suspend fun insert(deload: DeloadEntity): Long`
    - `@Query("SELECT * FROM deload WHERE status = 'ACTIVE' LIMIT 1") fun getActiveDeload(): Flow<DeloadEntity?>`
    - `@Query("SELECT * FROM deload WHERE status = 'ACTIVE' LIMIT 1") suspend fun getActiveDeloadOnce(): DeloadEntity?`
    - `@Query("UPDATE deload SET status = 'COMPLETED', completion_date = :completionDate WHERE id = :deloadId") suspend fun complete(deloadId: Long, completionDate: String)`
    - `@Query("SELECT * FROM deload WHERE id = :deloadId") suspend fun getById(deloadId: Long): DeloadEntity?`
    - `@Query("SELECT * FROM deload WHERE status = 'COMPLETED' ORDER BY completion_date DESC LIMIT 1") suspend fun getLastCompletedDeload(): DeloadEntity?`
- [ ] **Modificar `TensionDatabase`** (AC: 1)
  - [ ] Agregar `DeloadEntity::class` al array `entities` (16¬™ entidad)
  - [ ] Bump `version = 5` a `version = 6`
  - [ ] Agregar: `abstract fun deloadDao(): DeloadDao`
  - [ ] Agregar import de `DeloadEntity` y `DeloadDao`
  - [ ] **Nota migration:** `fallbackToDestructiveMigration()` est√° activo en `DatabaseModule.kt` ‚Üí no se necesita migration manual. Room destruye y recrea la BD al cambiar de versi√≥n. Aceptable en pre-release.
- [ ] **Modificar `DatabaseModule`** (AC: 1)
  - [ ] Agregar:
    ```kotlin
    @Provides
    fun provideDeloadDao(database: TensionDatabase): DeloadDao {
        return database.deloadDao()
    }
    ```
  - [ ] Agregar import de `DeloadDao`

### Fase 3: Domain ‚Äî RotationResolver modificaci√≥n + tests

<!-- Basado en Hito #3 del An√°lisis Arquitect√≥nico -->

#### üì¶ Domain Model

- [ ] **Modificar `RotationResolver.advanceRotation()`** (AC: 4, 13)
  - [ ] Cambiar firma de `fun advanceRotation(current: RotationState)` a `fun advanceRotation(current: RotationState, isDeload: Boolean = false)`
  - [ ] Modificar bloque `else` (posici√≥n == 6):
    ```kotlin
    fun advanceRotation(current: RotationState, isDeload: Boolean = false): RotationState {
        return if (current.microcyclePosition < 6) {
            current.copy(microcyclePosition = current.microcyclePosition + 1)
        } else {
            if (isDeload) {
                current.copy(
                    microcyclePosition = 1,
                    microcycleCount = current.microcycleCount + 1,
                )
            } else {
                current.copy(
                    microcyclePosition = 1,
                    currentVersionModuleA = (current.currentVersionModuleA % 3) + 1,
                    currentVersionModuleB = (current.currentVersionModuleB % 3) + 1,
                    currentVersionModuleC = (current.currentVersionModuleC % 3) + 1,
                    microcycleCount = current.microcycleCount + 1,
                )
            }
        }
    }
    ```
  - [ ] Tests existentes (6) siguen pasando sin cambio ‚Äî default `isDeload = false` mantiene el comportamiento actual

#### üì¶ Tests

- [ ] **Modificar `RotationResolverTest`** (+3 escenarios) (AC: 4, 13)
  - [ ] Agregar al archivo existente `test/.../domain/model/RotationResolverTest.kt`:
    1. `advanceRotation isDeload=true from position 3 increments to 4` ‚Äî posici√≥n avanza normalmente durante deload
    2. `advanceRotation isDeload=true from position 6 wraps to 1 versions frozen microcycleCount increments` ‚Äî posici√≥n‚Üí1, versions unchanged, microcycleCount++
    3. `advanceRotation isDeload=true from position 6 with mixed versions preserves all versions` ‚Äî versiones mixtas (A=2, B=3, C=1) ‚Üí todas preservadas, microcycleCount++

### Fase 4: Data/Repository ‚Äî Activaci√≥n del deload

<!-- Basado en Hito #4 del An√°lisis Arquitect√≥nico -->

#### üì¶ Data Layer

- [ ] **Modificar `ExerciseProgressionDao`** (AC: 1, 8)
  - [ ] Agregar query: `transitionToDeload()`:
    ```kotlin
    @Query("""
        UPDATE exercise_progression
        SET status = 'IN_DELOAD'
        WHERE status NOT IN ('NO_HISTORY', 'MASTERED')
    """)
    suspend fun transitionToDeload()
    ```
- [ ] **Modificar `AlertDao`** (AC: 7)
  - [ ] Agregar query: `getActiveAlertsByType(type: String): List<AlertEntity>`:
    ```kotlin
    @Query("""
        SELECT * FROM alert
        WHERE type = :type AND is_active = 1
        ORDER BY created_at DESC
    """)
    suspend fun getActiveAlertsByType(type: String): List<AlertEntity>
    ```
  - [ ] Agregar query: `resolveAllByType(type: String, resolvedAt: String)`:
    ```kotlin
    @Query("""
        UPDATE alert
        SET is_active = 0, resolved_at = :resolvedAt
        WHERE type = :type AND is_active = 1
    """)
    suspend fun resolveAllByType(type: String, resolvedAt: String)
    ```

#### üì¶ Domain Layer (repository interface)

- [ ] **Modificar `SessionRepository`** (AC: 1)
  - [ ] Agregar: `suspend fun activateDeload()`
  - [ ] Agregar: `suspend fun getDeloadState(): DeloadState`

#### üì¶ Data Layer (repository implementation)

- [ ] **Modificar `SessionRepositoryImpl`** ‚Äî constructor y activaci√≥n (AC: 1, 8)
  - [ ] Agregar 4 nuevos par√°metros al constructor (total 13: 9 existentes + deloadDao + exerciseDao + moduleDao + database):
    ```kotlin
    private val deloadDao: DeloadDao,
    private val exerciseDao: ExerciseDao,
    private val moduleDao: ModuleDao,
    ```
  - [ ] **Nota:** `ExerciseDao` y `ModuleDao` ya est√°n provistos en `DatabaseModule`. `@Binds` en `RepositoryModule` resuelve autom√°ticamente los nuevos params via Hilt. No se necesita cambiar `RepositoryModule`.
  - [ ] Implementar `activateDeload()`:
    ```kotlin
    override suspend fun activateDeload() {
        database.withTransaction {
            val existingDeload = deloadDao.getActiveDeloadOnce()
            if (existingDeload != null) {
                throw IllegalStateException("A deload cycle is already active")
            }
            val rotationEntity = rotationStateDao.getRotationState().first()
                ?: throw IllegalStateException("Rotation state not found")
            val today = LocalDate.now().toString()
            deloadDao.insert(
                DeloadEntity(
                    activationDate = today,
                    frozenVersionModuleA = rotationEntity.currentVersionModuleA,
                    frozenVersionModuleB = rotationEntity.currentVersionModuleB,
                    frozenVersionModuleC = rotationEntity.currentVersionModuleC,
                ),
            )
            exerciseProgressionDao.transitionToDeload()
        }
    }
    ```

### Fase 5: Data/Repository ‚Äî Inicio de sesi√≥n con deload

<!-- Basado en Hito #5 del An√°lisis Arquitect√≥nico -->

#### üì¶ Data Layer

- [ ] **Agregar `SessionDao.countDeloadSessions()`** (AC: 3)
  - [ ] Agregar query:
    ```kotlin
    @Query("""
        SELECT COUNT(*) FROM session
        WHERE deload_id = :deloadId AND status IN ('COMPLETED', 'INCOMPLETE')
    """)
    suspend fun countDeloadSessions(deloadId: Long): Int
    ```
- [ ] **Modificar `ExerciseSetDao.getLastWeightForExercise()`** (AC: 5, 8, Nota 8)
  - [ ] Modificar query existente L22-31 para excluir sesiones de deload:
    ```sql
    SELECT es.weight_kg
    FROM exercise_set es
    INNER JOIN session_exercise se ON es.session_exercise_id = se.id
    INNER JOIN session s ON se.session_id = s.id
    WHERE se.exercise_id = :exerciseId
      AND s.deload_id IS NULL
    ORDER BY es.id DESC
    LIMIT 1
    ```
  - [ ] **Justificaci√≥n:** Post-deload, la precarga en E2 debe ser la carga pre-descarga, no la carga de descarga (60%). Resuelve decisi√≥n diferida de HU-06 Nota 9, opci√≥n A.

#### üì¶ Data Layer ‚Äî DAO adicional para carga pre-deload

- [ ] **Agregar `ExerciseSetDao.getPreDeloadAvgWeight()`** (AC: 5, 6)
  - [ ] Agregar query:
    ```kotlin
    @Query("""
        SELECT AVG(es.weight_kg)
        FROM exercise_set es
        INNER JOIN session_exercise se ON es.session_exercise_id = se.id
        INNER JOIN session s ON se.session_id = s.id
        WHERE se.exercise_id = :exerciseId
          AND s.deload_id IS NULL
          AND s.date < :activationDate
          AND s.status IN ('COMPLETED', 'INCOMPLETE')
        ORDER BY s.date DESC, s.id DESC
        LIMIT 1
    """)
    suspend fun getPreDeloadAvgWeight(exerciseId: Long, activationDate: String): Double?
    ```
  - [ ] **NOTA IMPORTANTE:** Este query obtiene el AVG(weight_kg) de las series del ejercicio en la **√∫ltima sesi√≥n no-deload anterior a la activaci√≥n**. Sin embargo, `AVG` sin `GROUP BY` sobre un `LIMIT 1` puede no funcionar como se espera ‚Äî `LIMIT 1` se aplica a la sesi√≥n, no a los sets. La estructura correcta requiere nested subquery:
    ```sql
    SELECT AVG(es.weight_kg)
    FROM exercise_set es
    WHERE es.session_exercise_id = (
        SELECT se.id
        FROM session_exercise se
        INNER JOIN session s ON se.session_id = s.id
        WHERE se.exercise_id = :exerciseId
          AND s.deload_id IS NULL
          AND s.date < :activationDate
          AND s.status IN ('COMPLETED', 'INCOMPLETE')
        ORDER BY s.date DESC, s.id DESC
        LIMIT 1
    )
    ```

#### üì¶ Repository ‚Äî Modificar startSession

- [ ] **Modificar `SessionRepositoryImpl.startSession()`** (AC: 1, 4)
  - [ ] Despu√©s de validar que no hay sesi√≥n activa (L81-83), consultar deload activo:
    ```kotlin
    val activeDeload = deloadDao.getActiveDeloadOnce()
    ```
  - [ ] Cambiar la creaci√≥n de `SessionEntity` (L85-89) para asignar `deloadId`:
    ```kotlin
    val sessionId = sessionDao.insert(
        SessionEntity(
            moduleVersionId = moduleVersionId,
            date = LocalDate.now().toString(),
            status = "IN_PROGRESS",
            deloadId = activeDeload?.id,
        ),
    )
    ```

#### üì¶ Repository ‚Äî Modificar resoluci√≥n de versiones congeladas

- [ ] **Modificar `SessionRepositoryImpl.getNextModuleVersionId()`** (AC: 4, 11)
  - [ ] Refactorizar el Flow L56-75 para consultar deload activo y, si existe, usar versiones congeladas:
    ```kotlin
    @OptIn(ExperimentalCoroutinesApi::class)
    override fun getNextModuleVersionId(): Flow<Long> {
        return rotationStateDao.getRotationState().flatMapLatest { rotationState ->
            if (rotationState == null) {
                flowOf(0L)
            } else {
                val moduleCode = RotationResolver.resolveModuleCode(
                    rotationState.microcyclePosition,
                )
                deloadDao.getActiveDeload().flatMapLatest { deload ->
                    val versionNumber = if (deload != null) {
                        RotationResolver.resolveVersionNumber(
                            moduleCode,
                            deload.frozenVersionModuleA,
                            deload.frozenVersionModuleB,
                            deload.frozenVersionModuleC,
                        )
                    } else {
                        RotationResolver.resolveVersionNumber(
                            moduleCode,
                            rotationState.currentVersionModuleA,
                            rotationState.currentVersionModuleB,
                            rotationState.currentVersionModuleC,
                        )
                    }
                    moduleVersionDao.getByModuleCodeAndVersion(moduleCode, versionNumber)
                        .map { it?.id ?: 0L }
                }
            }
        }
    }
    ```
- [ ] **Modificar `GetNextSessionInfoUseCase`** (AC: 4, 11)
  - [ ] Agregar `SessionRepository` method para obtener deload activo o exponer versiones congeladas. Alternativa m√°s sencilla: dado que `getNextModuleVersionId()` ya resuelve versiones congeladas, solo hace falta que la resoluci√≥n de `versionNumber` en `GetNextSessionInfoUseCase` tambi√©n consulte el deload.
  - [ ] Opci√≥n recomendada: agregar `fun getActiveDeload(): Flow<Deload?>` a `SessionRepository` (tipo domain, no entity; ver creaci√≥n de `Deload` domain model abajo) y usarla en el UseCase:
    ```kotlin
    @OptIn(ExperimentalCoroutinesApi::class)
    operator fun invoke(): Flow<NextSession?> {
        return sessionRepository.getRotationState().flatMapLatest { rotationState ->
            if (rotationState == null) {
                flowOf(null)
            } else {
                val moduleCode = RotationResolver.resolveModuleCode(
                    rotationState.microcyclePosition,
                )
                combine(
                    sessionRepository.getNextModuleVersionId(),
                    sessionRepository.getActiveDeload(),
                ) { moduleVersionId, deload -> // deload: Deload? (domain model, not entity)
                    val versionNumber = if (deload != null) {
                        RotationResolver.resolveVersionNumber(
                            moduleCode,
                            deload.frozenVersionModuleA,
                            deload.frozenVersionModuleB,
                            deload.frozenVersionModuleC,
                        )
                    } else {
                        RotationResolver.resolveVersionNumber(
                            moduleCode,
                            rotationState.currentVersionModuleA,
                            rotationState.currentVersionModuleB,
                            rotationState.currentVersionModuleC,
                        )
                    }
                    NextSession(
                        moduleCode = moduleCode,
                        versionNumber = versionNumber,
                        moduleVersionId = moduleVersionId,
                    )
                }
            }
        }
    }
    ```
  - [ ] **Crear `Deload` domain model** (para evitar layer violation):
    - [ ] Crear archivo: `domain/model/Deload.kt`
    - [ ] `data class Deload(val id: Long, val status: String, val activationDate: String, val completionDate: String?, val frozenVersionModuleA: Int, val frozenVersionModuleB: Int, val frozenVersionModuleC: Int)`
  - [ ] Agregar `fun getActiveDeload(): Flow<Deload?>` a `SessionRepository` interface
  - [ ] Implementar en `SessionRepositoryImpl`:
    ```kotlin
    override fun getActiveDeload(): Flow<Deload?> = deloadDao.getActiveDeload().map { entity ->
        entity?.let {
            Deload(
                id = it.id,
                status = it.status,
                activationDate = it.activationDate,
                completionDate = it.completionDate,
                frozenVersionModuleA = it.frozenVersionModuleA,
                frozenVersionModuleB = it.frozenVersionModuleB,
                frozenVersionModuleC = it.frozenVersionModuleC,
            )
        }
    }
    ```

### Fase 6: Data/Repository ‚Äî Cierre de sesi√≥n con deload

<!-- Basado en Hito #6 del An√°lisis Arquitect√≥nico -->

#### üì¶ Repository ‚Äî Guards en evaluateProgression

- [ ] **Modificar `SessionRepositoryImpl.evaluateProgression()`** (AC: 1, 8, 9, 12)
  - [ ] **Guard 1 ‚Äî prescribeLoad:** En L388-401, envolver el bloque de prescripci√≥n con guard deload:
    ```kotlin
    // Step 5b: Prescribe load (HU-11)
    val prescribedLoadKg = if (isDeloadSession) {
        currentProgression.prescribedLoadKg
    } else if (isBodyweight || isIsometric) {
        null
    } else {
        val meetsThreshold = DoubleThresholdRule.meetsDoubleThreshold(currentData)
        DoubleThresholdRule.prescribeLoad(
            currentAvgWeightKg = currentData.avgWeightKg,
            loadIncrementKg = exercise.loadIncrementKg,
            meetsThreshold = meetsThreshold,
        )
    }
    ```
  - [ ] **Guard 2 ‚Äî alertas PLATEAU:** En L415-430, envolver con `if (!isDeloadSession)`:
    ```kotlin
    // Step 5d: Plateau alert management (HU-12)
    if (!isDeloadSession) {
        val previousStatus = currentProgression.status
        if (previousStatus != "IN_PLATEAU" && newStatus == "IN_PLATEAU") {
            if (!alertDao.existsActiveByExercise(exercise.exerciseId, "PLATEAU")) {
                alertDao.insert(
                    AlertEntity(
                        type = "PLATEAU",
                        level = "HIGH_ALERT",
                        exerciseId = exercise.exerciseId,
                        message = "3 sesiones sin progresi√≥n",
                        isActive = 1,
                        createdAt = today,
                    ),
                )
            }
        } else if (previousStatus == "IN_PLATEAU" && newStatus != "IN_PLATEAU") {
            alertDao.resolveByExerciseAndType(exercise.exerciseId, "PLATEAU", today)
        }
    }
    ```
  - [ ] **Nota:** El guard `if (isDeloadSession) return` en L442 (module-level detection) ya es correcto y se mantiene sin cambio.

#### üì¶ Repository ‚Äî Finalizaci√≥n de deload en closeSession

- [ ] **Modificar `SessionRepositoryImpl.closeSession()`** (AC: 3, 5, 6, 8)
  - [ ] Paso 3 ‚Äî pasar `isDeload` a `advanceRotation()`:
    ```kotlin
    val isDeloadSession = deloadId != null
    val newRotation = RotationResolver.advanceRotation(currentRotation, isDeloadSession)
    ```
  - [ ] Paso 4 (NUEVO) ‚Äî despu√©s de `rotationStateDao.update(...)` y antes del cierre de `withTransaction`:
    ```kotlin
    // Step 4: Deload finalization (HU-14)
    if (isDeloadSession && deloadId != null) {
        val deloadSessionCount = sessionDao.countDeloadSessions(deloadId)
        if (deloadSessionCount == 6) {
            val today = LocalDate.now().toString()
            val deload = deloadDao.getById(deloadId)
                ?: throw IllegalStateException("Deload $deloadId not found")

            // 4a: Mark deload as COMPLETED
            deloadDao.complete(deloadId, today)

            // 4b: Reset loads to 90% for standard exercises
            val allExerciseProgressions = exerciseProgressionDao.getAllInDeload()
            for (progression in allExerciseProgressions) {
                val exercise = exerciseDao.getByIdOnce(progression.exerciseId)
                    ?: continue
                val isBodyweight = exercise.isBodyweight == 1
                val isIsometric = exercise.isIsometric == 1

                if (isBodyweight || isIsometric) {
                    // Bodyweight/isometric: just transition status, no load calc
                    exerciseProgressionDao.update(
                        progression.copy(
                            status = "IN_PROGRESSION",
                            sessionsWithoutProgression = 0,
                        ),
                    )
                } else {
                    val preDeloadWeight = exerciseSetDao.getPreDeloadAvgWeight(
                        progression.exerciseId,
                        deload.activationDate,
                    )
                    val moduleCode = exercise.moduleCode
                    val module = moduleDao.getByCode(moduleCode)
                    val loadIncrementKg = module?.loadIncrementKg ?: 2.5

                    val resetLoad = if (preDeloadWeight != null && preDeloadWeight > 0.0) {
                        DeloadLoadRule.calculateResetLoad(preDeloadWeight, loadIncrementKg)
                    } else {
                        null
                    }

                    exerciseProgressionDao.update(
                        progression.copy(
                            status = "IN_PROGRESSION",
                            prescribedLoadKg = resetLoad,
                            sessionsWithoutProgression = 0,
                        ),
                    )
                }
            }

            // 4c: Resolve all MODULE_REQUIRES_DELOAD alerts
            alertDao.resolveAllByType("MODULE_REQUIRES_DELOAD", today)
        }
    }
    ```
  - [ ] **Agregar queries nuevas necesarias:**
    - `ExerciseProgressionDao.getAllInDeload()`:
      ```kotlin
      @Query("SELECT * FROM exercise_progression WHERE status = 'IN_DELOAD'")
      suspend fun getAllInDeload(): List<ExerciseProgressionEntity>
      ```
    - **Crear `ExerciseDao.getByIdOnce()`** ‚Äî `getById()` existente retorna `Flow<ExerciseWithDetails?>` (con JOINs), NO es suspend. Se necesita query suspending directo:
      ```kotlin
      @Query("SELECT * FROM exercise WHERE id = :exerciseId")
      suspend fun getByIdOnce(exerciseId: Long): ExerciseEntity?
      ```
    - **Crear `ModuleDao.getByCode()`** ‚Äî NO existe actualmente. Agregar:
      ```kotlin
      @Query("SELECT * FROM module WHERE code = :code")
      suspend fun getByCode(code: String): ModuleEntity?
      ```
  - [ ] **Agregar import de `DeloadLoadRule`** en `SessionRepositoryImpl.kt`

### Fase 7: Domain ‚Äî Models + UseCases

<!-- Basado en Hito #7 del An√°lisis Arquitect√≥nico -->

#### üì¶ Domain Models

- [ ] **Crear `DeloadState`** (AC: 7)
  - [ ] Crear archivo: `domain/model/DeloadState.kt`
  - [ ] `sealed interface DeloadState`:
    - `data object NoDeloadNeeded : DeloadState` ‚Äî sin deload activo ni alerta
    - `data class DeloadRequired(val modules: List<String>) : DeloadState` ‚Äî alertas MODULE_REQUIRES_DELOAD activas, sin deload activo
    - `data class DeloadActive(val progress: Int, val totalSessions: Int, val frozenVersionA: Int, val frozenVersionB: Int, val frozenVersionC: Int) : DeloadState` ‚Äî deload activo con progreso N/6
    - `data class DeloadCompleted(val resetLoads: List<ExerciseResetLoad>) : DeloadState` ‚Äî deload reci√©n completado, cargas de reinicio
  - [ ] Crear `data class ExerciseResetLoad(val exerciseName: String, val resetLoadKg: Double)` dentro del mismo archivo

- [ ] **Crear `DeloadHomeState`** (AC: 7)
  - [ ] Crear archivo: `domain/model/DeloadHomeState.kt`
  - [ ] `sealed interface DeloadHomeState`:
    - `data class Active(val progress: Int, val moduleCode: String) : DeloadHomeState`
    - `data class Required(val moduleCode: String) : DeloadHomeState`

#### üì¶ Domain UseCases

- [ ] **Crear `ActivateDeloadUseCase`** (AC: 1)
  - [ ] Crear archivo: `domain/usecase/deload/ActivateDeloadUseCase.kt`
  - [ ] `class ActivateDeloadUseCase @Inject constructor(private val sessionRepository: SessionRepository)`
  - [ ] `suspend operator fun invoke() { sessionRepository.activateDeload() }`

- [ ] **Crear `GetDeloadStateUseCase`** (AC: 7)
  - [ ] Crear archivo: `domain/usecase/deload/GetDeloadStateUseCase.kt`
  - [ ] `class GetDeloadStateUseCase @Inject constructor(private val sessionRepository: SessionRepository)`
  - [ ] `suspend operator fun invoke(): DeloadState { return sessionRepository.getDeloadState() }`

- [ ] **Implementar `SessionRepositoryImpl.getDeloadState()`** (AC: 7)
  - [ ] L√≥gica:
    ```kotlin
    override suspend fun getDeloadState(): DeloadState {
        val activeDeload = deloadDao.getActiveDeloadOnce()
        if (activeDeload != null) {
            val progress = sessionDao.countDeloadSessions(activeDeload.id)
            return DeloadState.DeloadActive(
                progress = progress,
                totalSessions = 6,
                frozenVersionA = activeDeload.frozenVersionModuleA,
                frozenVersionB = activeDeload.frozenVersionModuleB,
                frozenVersionC = activeDeload.frozenVersionModuleC,
            )
        }

        val lastCompleted = deloadDao.getLastCompletedDeload()
        if (lastCompleted != null) {
            val hasPostDeloadSession = sessionDao.hasSessionAfterDeload(lastCompleted.id)
            if (!hasPostDeloadSession) {
                val resetLoads = getResetLoadsForCompletedDeload(lastCompleted)
                return DeloadState.DeloadCompleted(resetLoads)
            }
        }

        val deloadAlerts = alertDao.getActiveAlertsByType("MODULE_REQUIRES_DELOAD")
        if (deloadAlerts.isNotEmpty()) {
            val modules = deloadAlerts.mapNotNull { it.moduleCode }.distinct()
            return DeloadState.DeloadRequired(modules)
        }

        return DeloadState.NoDeloadNeeded
    }
    ```
  - [ ] **Agregar `SessionDao.hasSessionAfterDeload()`:**
    ```kotlin
    @Query("""
        SELECT EXISTS(
            SELECT 1 FROM session
            WHERE deload_id IS NULL
              AND status IN ('COMPLETED', 'INCOMPLETE')
              AND id > (SELECT MAX(id) FROM session WHERE deload_id = :deloadId)
        )
    """)
    suspend fun hasSessionAfterDeload(deloadId: Long): Boolean
    ```
  - [ ] **Helper `getResetLoadsForCompletedDeload()`:** (private en SessionRepositoryImpl)
    ```kotlin
    private suspend fun getResetLoadsForCompletedDeload(
        deload: DeloadEntity,
    ): List<ExerciseResetLoad> {
        val progressions = exerciseProgressionDao.getAllWithPrescribedLoad()
        return progressions.mapNotNull { progression ->
            val exercise = exerciseDao.getByIdOnce(progression.exerciseId) ?: return@mapNotNull null
            if (exercise.isBodyweight == 1 || exercise.isIsometric == 1) return@mapNotNull null
            val loadKg = progression.prescribedLoadKg ?: return@mapNotNull null
            ExerciseResetLoad(exerciseName = exercise.name, resetLoadKg = loadKg)
        }
    }
    ```
  - [ ] **Agregar `ExerciseProgressionDao.getAllWithPrescribedLoad()`:**
    ```kotlin
    @Query("SELECT * FROM exercise_progression WHERE prescribed_load_kg IS NOT NULL")
    suspend fun getAllWithPrescribedLoad(): List<ExerciseProgressionEntity>
    ```

### Fase 8: UI ‚Äî Home Card Descarga

<!-- Basado en Hito #8 del An√°lisis Arquitect√≥nico -->

#### üì¶ UI Layer

- [ ] **Modificar `HomeUiState`** (AC: 7)
  - [ ] Agregar campo: `val deloadState: DeloadHomeState? = null`
  - [ ] Agregar import de `DeloadHomeState`

- [ ] **Modificar `HomeViewModel`** (AC: 7)
  - [ ] Agregar inyecci√≥n de `GetDeloadStateUseCase` en constructor (o directamente usar `SessionRepository.getActiveDeload()` Flow)
  - [ ] Agregar `deloadState` al combine:
    ```kotlin
    combine(
        getNextSessionInfoUseCase(),
        getActiveSessionUseCase(),
        getMicrocycleCountUseCase(),
        sessionRepository.getActiveDeload(),
    ) { nextSession, activeSession, microcycleCount, activeDeload ->
        val deloadHomeState = if (activeDeload != null) {
            DeloadHomeState.Active(
                progress = 0, // Se carga asincr√≥nicamente
                moduleCode = "",
            )
        } else {
            null // TODO: check MODULE_REQUIRES_DELOAD alerts
        }
        HomeUiState(
            isLoading = false,
            nextSession = if (activeSession != null) null else nextSession,
            activeSession = activeSession,
            microcycleCount = microcycleCount,
            alertCount = 0,
            deloadState = deloadHomeState,
        )
    }
    ```
  - [ ] **Nota:** La carga completa del estado de deload (con progreso y alertas) requiere una suspending call (`getDeloadState()`), no un Flow. Opci√≥n m√°s simple: usar `getActiveDeload()` como Flow para detectar presencia/ausencia, y cargar el progreso via `viewModelScope.launch` separado solo si hay deload activo. Alternativa: crear un `Flow<DeloadHomeState?>` dedicado.

- [ ] **Modificar `HomeScreen`** (AC: 7)
  - [ ] Agregar par√°metro callback: `onNavigateToDeloadManagement: () -> Unit`
  - [ ] Agregar Card "Estado de Descarga" despu√©s de las cards existentes y antes del `ProgressSection`:
    ```kotlin
    if (uiState.deloadState != null) {
        item {
            Spacer(modifier = Modifier.height(16.dp))
            DeloadStatusCard(
                deloadState = uiState.deloadState,
                onNavigateToDeload = onNavigateToDeloadManagement,
            )
        }
    }
    ```
  - [ ] Crear composable `DeloadStatusCard`:
    - Card Filled: fondo Secondary Container (`#F0E0E0`), corner 12.dp
    - √çcono üîÑ 24.dp, color azul descarga (`semanticColors.deloadActive`)
    - Si `Active`: "üîÑ Descarga activa" TitleMedium, On Secondary Container + "M√≥dulo {code} ‚Äî Sesi√≥n {progress} de 6" BodyMedium, On Secondary Container
    - Si `Required`: "‚ö†Ô∏è M√≥dulo {code} requiere descarga" TitleMedium, On Secondary Container
    - Text Button: "Ver gesti√≥n de descarga ‚Üí", color Primary ‚Üí `onNavigateToDeload()`
    - **Nota:** Ambos estados usan `On Secondary Container` como color del t√≠tulo seg√∫n Especificaci√≥n Visual ¬ßB1. El √≠cono üîÑ usa azul descarga (`semanticColors.deloadActive`) como acento visual.

### Fase 8.5: UI ‚Äî ActiveSessionScreen deload badge + cargas 60%

<!-- Agregada por auditor√≠a profunda: CA-14.02 y CA-14.07 exigen indicaci√≥n visual en E1 -->
<!-- Especificaci√≥n Visual ¬ßE1: Badge descarga condicional + variantes de carga deload -->
<!-- Wireframes E1 elemento #3: Indicador de descarga (badge + cargas ajustadas 60%) -->

#### üì¶ UI Layer (estado)

- [ ] **Modificar `ActiveSessionUiState`** (AC: 2, 7)
  - [ ] Agregar campo: `val isDeloadSession: Boolean = false`
  - [ ] Agregar campo: `val deloadProgress: String = ""` ‚Äî formato "N/6" para el badge

#### üì¶ UI Layer (ViewModel)

- [ ] **Modificar `ActiveSessionViewModel`** (AC: 2, 7)
  - [ ] Agregar inyecci√≥n de `SessionRepository` (ya inyectado) para consultar `getActiveDeload()`
  - [ ] En el bloque `init`, despu√©s de cargar `sessionId`, determinar si la sesi√≥n es de deload:
    ```kotlin
    viewModelScope.launch {
        // Check if this is a deload session
        val deloadId = sessionRepository.getDeloadIdBySessionId(sessionId)
        val isDeload = deloadId != null
        val deloadProgressText = if (isDeload && deloadId != null) {
            val count = sessionRepository.countDeloadSessions(deloadId)
            "$count/6"
        } else ""

        combine(
            getSessionExercisesUseCase(sessionId),
            sessionRepository.getSessionModuleVersion(sessionId),
        ) { exercises, moduleVersion ->
            exercises to moduleVersion
        }.collect { (exercises, moduleVersion) ->
            _uiState.update { current ->
                current.copy(
                    isLoading = false,
                    isDeloadSession = isDeload,
                    deloadProgress = deloadProgressText,
                    moduleCode = moduleVersion?.first ?: "",
                    versionNumber = moduleVersion?.second ?: 0,
                    exercises = exercises.map { detail ->
                        // ... existing mapping with deload-aware loadText
                    },
                )
            }
        }
    }
    ```
  - [ ] Modificar `loadText` en el `when` block para incluir variantes de carga deload (Especificaci√≥n Visual ¬ßE1):
    ```kotlin
    val loadText = when {
        // Deload variants (Especificaci√≥n Visual ¬ßE1, CA-14.02, CA-14.09)
        isDeload && detail.isIsometric -> "Isom√©trico (30s)"
        isDeload && detail.isBodyweight -> "Peso corporal (8 reps objetivo)"
        isDeload && detail.prescribedLoadKg != null -> {
            val deloadLoad = DeloadLoadRule.calculateDeloadLoad(
                detail.prescribedLoadKg,
                // loadIncrementKg resolved from module
                detail.loadIncrementKg,
            )
            "üîÑ %.1f Kg".format(deloadLoad)
        }
        // Normal variants (existing)
        detail.isIsometric -> "Isom√©trico (30‚Äì45s)"
        detail.isBodyweight -> "Peso corporal"
        detail.prescribedLoadKg != null ->
            "%.1f Kg".format(detail.prescribedLoadKg)
        else -> "Sin historial ‚Äî establecer carga"
    }
    ```
  - [ ] **Nota:** `detail.loadIncrementKg` NO existe actualmente en `ExerciseSessionDetail`. Se necesita agregar (ver datos layer abajo).
  - [ ] **Agregar `SessionRepository.getDeloadIdBySessionId()`** ‚Äî ya existe en `SessionDao.getDeloadIdBySessionId()`. Exponer a trav√©s de la interfaz:
    ```kotlin
    suspend fun getDeloadIdBySessionId(sessionId: Long): Long?
    suspend fun countDeloadSessions(deloadId: Long): Int
    ```
  - [ ] **Implementar ambos en `SessionRepositoryImpl`:**
    ```kotlin
    override suspend fun getDeloadIdBySessionId(sessionId: Long): Long? =
        sessionDao.getDeloadIdBySessionId(sessionId)

    override suspend fun countDeloadSessions(deloadId: Long): Int =
        sessionDao.countDeloadSessions(deloadId)
    ```

#### üì¶ Data Layer (DTO extension)

- [ ] **Modificar `ExerciseSessionDetail`** (o el DTO usado por `GetSessionExercisesUseCase`)
  - [ ] Agregar campo: `val loadIncrementKg: Double = 2.5`
  - [ ] Modificar el query en `SessionExerciseDao` que produce `ExerciseSessionDetail` para incluir `m.load_increment_kg AS loadIncrementKg` via JOIN a `module` (a trav√©s de `exercise.module_code ‚Üí module.code`)
- [ ] **Modificar `ExerciseUiItem`** en `ActiveSessionUiState.kt`
  - [ ] Agregar campo: `val loadIncrementKg: Double = 2.5`
  - [ ] Pasar desde `detail.loadIncrementKg` en el mapping

#### üì¶ UI Layer (composable)

- [ ] **Modificar `ActiveSessionScreen`** (AC: 7)
  - [ ] Agregar badge deload condicional en el header area (bajo "Sesi√≥n activa"):
    ```kotlin
    if (uiState.isDeloadSession) {
        AssistChip(
            onClick = {},
            label = {
                Text(
                    text = "Descarga ¬∑ Sesi√≥n ${uiState.deloadProgress}",
                    style = MaterialTheme.typography.labelMedium,
                )
            },
            leadingIcon = {
                Text("üîÑ", fontSize = 16.sp)
            },
            colors = AssistChipDefaults.assistChipColors(
                containerColor = Color(0xFFE3F2FD), // Light theme
            ),
            modifier = Modifier.padding(top = 4.dp),
        )
    }
    ```
  - [ ] **Nota:** Los colores del badge deben respetar dark theme: `#E3F2FD` (light) / `#1A2733` (dark). Usar `if (isSystemInDarkTheme()) Color(0xFF1A2733) else Color(0xFFE3F2FD)` o definir tokens sem√°nticos.
  - [ ] Modificar composable `LoadText` para aplicar color azul descarga durante deload:
    ```kotlin
    @Composable
    fun LoadText(exercise: ExerciseUiItem, isDeloadSession: Boolean) {
        val textColor = if (isDeloadSession && !exercise.loadDisplayText.startsWith("Sin")) {
            TensionThemeExtended.semanticColors.deloadActive
        } else if (!exercise.isBodyweight && !exercise.isIsometric && exercise.prescribedLoadKg == null) {
            MaterialTheme.colorScheme.onSurfaceVariant
        } else {
            MaterialTheme.colorScheme.onSurface
        }
        Text(
            text = exercise.loadDisplayText,
            style = MaterialTheme.typography.bodyMedium,
            color = textColor,
            fontStyle = if (exercise.prescribedLoadKg == null && !exercise.isBodyweight && !exercise.isIsometric)
                FontStyle.Italic else FontStyle.Normal,
        )
    }
    ```
  - [ ] Pasar `isDeloadSession = uiState.isDeloadSession` a cada fila de ejercicio donde `LoadText` se usa

### Fase 9: UI ‚Äî DeloadManagementScreen + ViewModel

<!-- Basado en Hito #9 del An√°lisis Arquitect√≥nico -->

#### üì¶ UI Layer (estado + VM)

- [ ] **Crear `DeloadManagementUiState`** (AC: 7)
  - [ ] Crear archivo: `ui/deload/DeloadManagementUiState.kt`
  - [ ] `sealed interface DeloadManagementUiState`
  - [ ] `data object Loading : DeloadManagementUiState`
  - [ ] `data class Content(val deloadState: DeloadState) : DeloadManagementUiState`
  - [ ] `data class Error(val message: String) : DeloadManagementUiState`

- [ ] **Crear `DeloadManagementViewModel`** (AC: 1, 7)
  - [ ] Crear archivo: `ui/deload/DeloadManagementViewModel.kt`
  - [ ] `@HiltViewModel class DeloadManagementViewModel @Inject constructor(private val getDeloadStateUseCase: GetDeloadStateUseCase, private val activateDeloadUseCase: ActivateDeloadUseCase)`
  - [ ] `private val _uiState = MutableStateFlow<DeloadManagementUiState>(DeloadManagementUiState.Loading)`
  - [ ] `val uiState: StateFlow<DeloadManagementUiState> = _uiState.asStateFlow()`
  - [ ] `init { loadState() }`
  - [ ] `private fun loadState()`:
    ```kotlin
    viewModelScope.launch {
        try {
            val state = getDeloadStateUseCase()
            _uiState.value = DeloadManagementUiState.Content(state)
        } catch (e: Exception) {
            _uiState.value = DeloadManagementUiState.Error(e.message ?: "Error desconocido")
        }
    }
    ```
  - [ ] `fun activateDeload()`:
    ```kotlin
    viewModelScope.launch {
        try {
            activateDeloadUseCase()
            loadState() // Reload after activation
        } catch (e: Exception) {
            _uiState.value = DeloadManagementUiState.Error(e.message ?: "Error al activar")
        }
    }
    ```

#### üì¶ UI Layer (composables)

- [ ] **Crear `DeloadManagementScreen`** (AC: 1, 2, 3, 4, 5, 6, 7, 8, 9)
  - [ ] Crear archivo: `ui/deload/DeloadManagementScreen.kt`
  - [ ] `@Composable fun DeloadManagementScreen(onNavigateBack: () -> Unit)`
  - [ ] `val viewModel: DeloadManagementViewModel = hiltViewModel()`
  - [ ] `val uiState by viewModel.uiState.collectAsStateWithLifecycle()`
  - [ ] Estructura (seg√∫n Wireframe I1 y Especificaci√≥n Visual ¬ßI1):
    - `Scaffold` con `CenterAlignedTopAppBar`: title = "Gesti√≥n de Descarga", navigationIcon = ArrowBack ‚Üí `onNavigateBack()`
    - Estado `Loading` ‚Üí `CircularProgressIndicator` centrado
    - Estado `Error` ‚Üí texto de error centrado
    - Estado `Content(deloadState)` ‚Üí `when (deloadState)`:

      **Estado A ‚Äî `DeloadRequired(modules)`:**
      - Outlined Card (Border Outline, corner 12.dp):
        - "No hay descarga activa" BodyLarge, OnSurface
        - ‚ö†Ô∏è + "M√≥dulo {X} requiere descarga" BodyMedium, Error
        - "‚â• 50% de los ejercicios est√°n en meseta o regresi√≥n" BodySmall, OnSurfaceVariant
      - Filled Card (fondo Secondary Container `#F0E0E0`, corner 12.dp):
        - "Al activar la descarga:" TitleSmall, OnSecondaryContainer
        - Lista con leading "¬∑": "Carga al 60%", "4 series", "8 repeticiones", "RIR 4-5", "Duraci√≥n 1 microciclo (6 sesiones)", "Versiones congeladas"
        - Excepciones (CA-14.09): "¬∑ Peso corporal: 8 reps, RIR 4-5 (sin ajuste de carga, Peso = 0)", "¬∑ Isom√©tricos: 30 seg, RIR 4-5"
        - Nota final: "¬∑ Al finalizar: reinicio al 90% de carga pre-descarga"
      - Filled Button "Activar Descarga" full width, containerColor Primary, marginTop 24.dp ‚Üí `viewModel.activateDeload()`

      **Estado B ‚Äî `DeloadActive(progress, totalSessions, frozenVersionA/B/C)`:**
      - Filled Card (fondo Secondary Container, corner 12.dp):
        - üîÑ 24.dp color azul descarga + "Descarga activa" TitleMedium, color azul descarga
        - "Progreso: {progress}/6 sesiones" BodyMedium, OnSecondaryContainer
        - `LinearProgressIndicator(progress = progress / 6f)` determinado, height 8.dp, indicator azul descarga, track SurfaceVariant
        - "Sesiones restantes: {6 - progress}" BodyMedium, OnSecondaryContainer
      - Filled Card (fondo SurfaceContainerHigh, corner 12.dp):
        - Par√°metros: "Carga: 60%", "Series: 4", "Reps: 8", "RIR objetivo: 4-5" BodyMedium, OnSurface
        - "Versi√≥n congelada: A-V{a}, B-V{b}, C-V{c}" BodyMedium, OnSurfaceVariant

      **Estado C ‚Äî `DeloadCompleted(resetLoads)`:**
      - Filled Card (fondo Tertiary Container `#E0EEDD`, corner 12.dp):
        - ‚úÖ 24.dp verde + "Descarga completada" TitleMedium, OnTertiaryContainer (`#334A29`)
        - "Cargas de reinicio (90% pre-descarga):" BodyMedium, OnTertiaryContainer
        - Lista de ejercicios: "{nombre}: {loadKg} Kg" BodyMedium, OnTertiaryContainer
        - "Las versiones retoman su avance normal." BodySmall, OnTertiaryContainer, italic

      **Estado `NoDeloadNeeded`:**
      - Text centrado: "No hay descarga pendiente" BodyLarge, OnSurfaceVariant
      - Text Button: "Volver al inicio" ‚Üí `onNavigateBack()`

    - Bottom Navigation: NavigationBar M3, Inicio activo

### Fase 10: Navegaci√≥n + integraci√≥n

<!-- Basado en Hito #10 del An√°lisis Arquitect√≥nico -->

#### üì¶ Navigation

- [ ] **Modificar `NavigationRoutes`** (AC: 7)
  - [ ] Agregar: `const val DELOAD_MANAGEMENT = "deload"`

- [ ] **Modificar `TensionNavHost`** (AC: 7)
  - [ ] Reemplazar TODO L119:
    ```kotlin
    composable(NavigationRoutes.HOME) {
        HomeScreen(
            onNavigateToAlerts = { /* TODO: HU-17 */ },
            onNavigateToDeloadManagement = {
                navController.navigate(NavigationRoutes.DELOAD_MANAGEMENT)
            },
            onNavigateToActiveSession = { sessionId ->
                navController.navigate(
                    NavigationRoutes.activeSessionRoute(sessionId),
                )
            },
        )
    }
    ```
  - [ ] Registrar composable I1 despu√©s del bloque SESSION_SUMMARY:
    ```kotlin
    composable(NavigationRoutes.DELOAD_MANAGEMENT) {
        DeloadManagementScreen(
            onNavigateBack = { navController.popBackStack() },
        )
    }
    ```
  - [ ] **Nota:** `showBottomBar` NO necesita excluir `deload` ‚Äî I1 S√ç tiene Bottom Navigation (Wireframe I1: "Incluye Bottom Navigation", Especificaci√≥n Visual ¬ßI1: "Bottom: NavigationBar M3, Inicio activo"). Ya se muestra correctamente.

### Fase N: QA y Deployment

- [ ] **Ejecutar Agente Peer Review** (MANUAL)
- [ ] **Resolver incidentes del Peer Review** (MANUAL, condicional)
- [ ] **Crear Pull Request** (MANUAL)
- [ ] **Ejecutar pipeline deployment DEV** (MANUAL)
- [ ] **Dise√±ar set de pruebas manuales** (MANUAL)
- [ ] **Ejecutar pruebas manuales** (MANUAL)

---

**Notas sobre vinculaci√≥n con Criterios de Aceptaci√≥n:**

**CA-14.01 ‚Äî Activaci√≥n del modo Descarga:**
‚Üí Fase 4 (`activateDeload()`: crear DeloadEntity ACTIVE + transitionToDeload()) + Fase 9 (I1 Estado A con bot√≥n "Activar Descarga"). Cadena: DeloadManagementScreen ‚Üí viewModel.activateDeload() ‚Üí ActivateDeloadUseCase ‚Üí sessionRepository.activateDeload() ‚Üí withTransaction { deloadDao.insert + exerciseProgressionDao.transitionToDeload() }

**CA-14.02 ‚Äî 60% de carga:**
‚Üí Fase 1 (`DeloadLoadRule.calculateDeloadLoad(lastWeight, increment)` con floor). Se computa visualmente en **Fase 8.5** (`ActiveSessionViewModel` usa `DeloadLoadRule` para mostrar cargas 60% en E1). No se almacena en exercise_progression.

**CA-14.03 ‚Äî Duraci√≥n 1 microciclo (6 sesiones):**
‚Üí Fase 6 (`closeSession()` cuenta sesiones del deload; si == 6 ‚Üí finalizaci√≥n). Count via `sessionDao.countDeloadSessions(deloadId)`.

**CA-14.04 ‚Äî Versiones congeladas:**
‚Üí Fase 5 (`getNextModuleVersionId()` + `GetNextSessionInfoUseCase` usan `deload.frozen_version_module_X`) + Fase 3 (`advanceRotation(isDeload=true)` en posici√≥n 6 ‚Üí versiones NO avanzan).

**CA-14.05 ‚Äî 90% carga reinicio:**
‚Üí Fase 1 (`DeloadLoadRule.calculateResetLoad(preDeloadWeight, increment)`) + Fase 6 (finalizaci√≥n: `getPreDeloadAvgWeight` + `calculateResetLoad` ‚Üí update exercise_progression).

**CA-14.06 ‚Äî Redondeo hacia abajo:**
‚Üí Fase 1 (`floor(value / increment) * increment`). loadIncrementKg viene de `module.load_increment_kg`.

**CA-14.07 ‚Äî Indicaci√≥n visual:**
‚Üí Fase 8 (Card Descarga en B1) + **Fase 8.5 (Badge deload + cargas 60% en E1 ActiveSessionScreen)** + Fase 9 (I1 Estados A/B/C con progreso, par√°metros, versiones congeladas).

**CA-14.08 ‚Äî Transici√≥n post-descarga:**
‚Üí Fase 6 (finalizaci√≥n: IN_DELOAD ‚Üí IN_PROGRESSION, prescribedLoadKg = resetLoad, sessionsWithoutProgression = 0).

**CA-14.09 ‚Äî Bodyweight/isom√©tricos:**
‚Üí Fase 6 (finalization guard: `if (isBodyweight || isIsometric)` ‚Üí transition status only, no load calc) + Fase 9 (I1 Estado A muestra excepciones CA-14.09).

**CA-14.10 a CA-14.14 ‚Äî Conteo microciclos:**
‚Üí Ya implementados (HU-09). Solo verificar CA-14.13 con nuevo test (Fase 3: advanceRotation isDeload=true position 6 incrementa microcycleCount).

---

### Auditor√≠a del Refinamiento

<!-- === DEV AUDIT LOG v2 ‚Äî Auditor√≠a Profunda === -->
<!-- Generada: 2026-02-17 -->
<!-- Alcance: 29 documentos consultados (6 arquitectura + 5 negocio + 18 HUs) + 27 archivos fuente -->

#### Ronda 1 ‚Äî Auditor√≠a inicial (7 hallazgos corregidos en refinamiento)

| # | Severidad | Hallazgo | Correcci√≥n |
| --- | --- | --- | --- |
| E1 | **CRITICAL** | `ModuleDao.getByCode()` NO existe ‚Äî Fase 6 referenciaba un m√©todo inexistente para obtener `loadIncrementKg` por m√≥dulo | Agregada creaci√≥n expl√≠cita del query `suspend fun getByCode(code: String): ModuleEntity?` como tarea en Fase 6 |
| E2 | **CRITICAL** | `ExerciseDao` y `ModuleDao` no inyectados en `SessionRepositoryImpl` ‚Äî Fase 6 (finalizaci√≥n deload) los usa sin tenerlos disponibles en el constructor | Constructor ampliado de 10 a 13 par√°metros (9 existentes + deloadDao + exerciseDao + moduleDao + database). Tarea expl√≠cita agregada en Fase 4 |
| E3 | **CRITICAL** | `SessionRepository.getActiveDeload()` retornaba `Flow<DeloadEntity?>` ‚Äî violaci√≥n de capas (domain interface exponiendo entity de data layer). `GetNextSessionInfoUseCase` consum√≠a el tipo entity | Creado `Deload` data class en `domain/model/`. `SessionRepository` retorna `Flow<Deload?>`. `SessionRepositoryImpl` mapea `DeloadEntity ‚Üí Deload`. UseCase usa tipo domain |
| E4 | **HIGH** | `ExerciseDao.getById()` retorna `Flow<ExerciseWithDetails?>` (con JOINs), no es suspend ‚Äî Fase 6 y Fase 7 lo usaban como `?: continue` que no compila sin `.first()` | Creado `getByIdOnce()` como `suspend fun` con query directo a tabla exercise. Todas las referencias actualizadas a `getByIdOnce()` |
| E5 | **MEDIUM** | `evaluateProgression` reportado como L326-493 pero termina en ~L482 (√∫ltimas 11 l√≠neas son `getSessionSummaryData`) | Corregido a L326-482 en el comentario de contexto |
| E6 | **MEDIUM** | `prescribeLoad` block reportado como L388-401; real empieza en L393 (comment Step 5b). `ProgressionClassificationRule.kt` reportado como 119 l√≠neas; real: 135 l√≠neas | Corregido a L393-402 (riesgo #1). Line count corregido a 135 |
| E7 | **LOW** | `RotationResolver.kt` reportado como 38 l√≠neas / `advanceRotation` L25. Real: 37 l√≠neas / L24. Offsets sistem√°ticos ¬±1 en m√∫ltiples archivos | Corregido a 37 l√≠neas / L24-36 |

#### Ronda 2 ‚Äî Auditor√≠a profunda contra documentaci√≥n completa (10 hallazgos, 4 corregidos)

**Metodolog√≠a:** Lectura completa de los 6 documentos de arquitectura, 5 documentos de negocio, 18 historias de usuario, y 27 archivos fuente. 28 verificaciones contra Modelo de Datos, ADR, Especificaci√≥n Visual, Wireframes, Mapa de Navegaci√≥n, y Arquitectura T√©cnica. 18 verificaciones cruzadas contra HU-01 a HU-18.

**Hallazgos CORREGIDOS:**

| # | Severidad | Hallazgo | Fuente | Correcci√≥n aplicada |
| --- | --- | --- | --- | --- |
| A1 | **CRITICAL** | **E1 (ActiveSessionScreen) deload badge + cargas 60% NO implementados en ninguna fase.** CA-14.02 y CA-14.07 exigen indicaci√≥n visual durante sesi√≥n activa. Especificaci√≥n Visual ¬ßE1 L686 especifica badge `AssistChip` con "Descarga ¬∑ Sesi√≥n N/6". Wireframes E1 elemento #3 especifica "cargas reflejan ajuste al 60%". Especificaci√≥n Visual L700 define 3 variantes de carga deload (est√°ndar 60%, bodyweight "8 reps objetivo", isom√©trico "30s"). Sin esta fase, el usuario en deload ve cargas pre-deload incorrectas y no tiene indicador visual de que est√° en descarga. | Esp. Visual ¬ßE1, Wireframes E1 #3 | **Creada Fase 8.5** completa: `ActiveSessionUiState` +isDeloadSession/deloadProgress, `ActiveSessionViewModel` con `DeloadLoadRule.calculateDeloadLoad()` para cargas 60%, `ExerciseSessionDetail` +loadIncrementKg, `ActiveSessionScreen` con badge `AssistChip` + `LoadText` color azul descarga + 3 variantes deload |
| A2 | **MEDIUM** | **B1 Card DeloadStatusCard usa colores incorrectos.** Fase 8 especificaba `semanticColors.deloadActive` para Active y `color Error` para Required. Especificaci√≥n Visual ¬ßB1 L483 establece ambos estados con `Title Medium, On Secondary Container`. | Esp. Visual ¬ßB1 L483 | B1 Card actualizada: ambos estados usan `On Secondary Container` para t√≠tulo. Solo el √≠cono üîÑ mantiene `semanticColors.deloadActive` como acento visual |
| A3 | **MEDIUM** | **Ruta `deload-management` contradice Arquitectura T√©cnica.** Fase 10 usaba `deload-management` pero Arquitectura T√©cnica ¬ß4.3 L405 define ruta `deload`. El Mermaid graph L466 tambi√©n usa `deload`. | Arq. T√©cnica ¬ß4.3 L405 | Ruta cambiada de `deload-management` a `deload` en Fase 10 y todas las referencias |
| A4 | **INFO** | **Conteo de componentes desactualizado.** El summary dec√≠a "9 nuevos + 15 modificados, 10 fases". Con Fase 8.5, los componentes modificados son 17 (+2: ActiveSessionScreen, ActiveSessionViewModel) y las fases son 11. | ‚Äî | Actualizado a "9 nuevos + 17 modificados, 11 fases" en summary y complejidad |

**Hallazgos ACEPTADOS (no requieren correcci√≥n):**

| # | Severidad | Hallazgo | Fuente | Justificaci√≥n de no-correcci√≥n |
| --- | --- | --- | --- | --- |
| A5 | **MEDIUM** | **`getPreDeloadAvgWeight` usa `AVG(weight_kg)` pero Modelo de Datos ¬ß3.15 L625 dice "√∫ltimo `exercise_set.weight_kg`" (escalar).** El arquitecto eligi√≥ AVG en Decisi√≥n 4. | Modelo de Datos ¬ß3.15 | En sesiones normales, las 4 series usan la misma carga ‚Äî AVG = valor individual. Edge case con series piramidales: AVG da un valor representativo m√°s justo. Decisi√≥n del arquitecto documentada y razonable. Sin cambio. |
| A6 | **MEDIUM** | **E2 precarga durante deload activo muestra peso pre-deload.** `getLastWeightForExercise()` con filtro `s.deload_id IS NULL` retorna carga pre-deload (60 Kg), no la carga deload (36 Kg). Usuario debe ajustar manualmente en cada sesi√≥n deload (6 sesiones). | HU-06 Nota 9 | Trade-off deliberado (Nota 8, Opci√≥n A): la UX post-deload (correcta precarga 90%) se prioriza sobre la UX durante-deload (precarga incorrecta durante 6 sesiones). Aceptable: usuario ya sabe que est√° en deload y las cargas objetivo se muestran en E1 (Fase 8.5). |
| A7 | **LOW** | **E5 se√±ales durante deload pueden ser sem√°nticamente misleading** ("Considerar descarga" mientras deload ACTIVO, porque MODULE_REQUIRES_DELOAD a√∫n no resuelto). | HU-13 Nota 9 | Se√±ales son inocuas ‚Äî no persisten ni afectan l√≥gica. Se resuelven al finalizar deload (alertDao.resolveAllByType). Nota 9 documenta: "no modificar E5 en esta HU". |
| A8 | **LOW** | **Especificaci√≥n Visual ¬ßI1 y ¬ßB1 usan numeraci√≥n vieja** (HU-16/HU-17 pre-consolidaci√≥n). | Esp. Visual ¬ßI1, ¬ßB1 | Inconsistencia de documentaci√≥n ‚Äî el refinamiento lo reconoce. No afecta implementaci√≥n. |
| A9 | **LOW** | **CHECK constraints de tabla `deload`** no se aplican en Room Entity (`CHECK(status IN ('ACTIVE','COMPLETED'))`, `CHECK(frozen_version >= 1 AND <= 3)`). | Modelo de Datos ¬ß3.15 | Room `@Entity` no soporta CHECK constraints nativamente. Validaci√≥n a nivel de aplicaci√≥n compensa. Pre-release con `fallbackToDestructiveMigration()`. |
| A10 | **INFO** | **HU-11 Nota 6 "no hay conflicto"** es sobreoptimista ‚Äî HU-14 identifica conflicto real (prescribeLoad sobreescribe durante deload) y agrega guard. | HU-11 Nota 6 | El refinamiento de HU-14 tiene la visi√≥n correcta. HU-11 no ten√≠a contexto suficiente. Guard implementado correctamente en Fase 6. |

#### Verificaciones cruzadas que PASARON (22)

- **Modelo de Datos ¬ß3.15** (DeloadEntity): 7 columnas match exacto con DeloadEntity ‚úÖ
- **Modelo de Datos ¬ß3.10** (session.deload_id): campo existe con index, FK l√≥gica (Nota 1) ‚úÖ
- **Modelo de Datos ¬ß3.13** (exercise_progression.status): IN_DELOAD es valor v√°lido ‚úÖ
- **Modelo de Datos ¬ß3.14** (rotation_state): microcycle_count existe, frozen versions en deload (no rotation_state) ‚úÖ
- **ADR-06**: DeloadLoadRule sigue patr√≥n object/fun pura ‚úÖ
- **ADR D-08**: 6 sesiones + versiones congeladas implementados correctamente ‚úÖ
- **Esp. Visual ¬ßI1 Estado A/B/C**: todos los componentes, tipograf√≠a, colores, y spacing match ‚úÖ
- **Wireframes I1**: 3 estados + 4to defensivo, back via popBackStack ‚úÖ
- **Mapa de Navegaci√≥n ¬ß7**: B1‚ÜíI1, H2‚ÜíI1 (placeholder), I1‚ÜíB1/H2 (popBackStack) ‚úÖ
- **Arq. T√©cnica ¬ß2.5**: separaci√≥n de capas (Deload domain model, no entity en domain) ‚úÖ
- **Arq. T√©cnica ¬ß5.2**: naming (DeloadLoadRule, DeloadManagementScreen, etc.) ‚úÖ
- **Arq. T√©cnica ¬ß5.1**: c√≥digo en ingl√©s, UI en espa√±ol ‚úÖ
- **Arq. T√©cnica ¬ß3.2-3.3**: packages (ui/deload/, domain/rules/, data/local/entity/) ‚úÖ
- **Arq. T√©cnica ¬ß5.4**: ViewModel pattern (@HiltViewModel, MutableStateFlow) ‚úÖ
- **Requerimientos RF38-41**: todos trazados a CAs y fases ‚úÖ
- **MDS R5** (Protocolo de Descarga): 60%/90%, 4 series, 8 reps, RIR 4-5, 1 microciclo ‚úÖ
- **MDS R6/R7** (Bodyweight/Isometric): CA-14.09 cubre ambos ‚úÖ
- **HU-09 Decisi√≥n 6**: isDeload parameter implementado ‚úÖ
- **HU-06 Nota 9**: decisi√≥n diferida resuelta (Opci√≥n A: excluir deload sessions) ‚úÖ
- **HU-10**: IN_DELOAD guard preexistente funciona correctamente ‚úÖ
- **HU-12**: MODULE_REQUIRES_DELOAD alerts consumidas; guard module-level preservado ‚úÖ
- **HU-05 ‚Üí HU-18**: sin conflictos cruzados, todas las dependencias identificadas ‚úÖ

#### Estad√≠sticas finales

| M√©trica | Valor |
| --- | --- |
| Documentos auditados | 29 (6 arq + 5 neg + 18 HUs) |
| Archivos fuente verificados | 27 |
| Verificaciones individuales | 46 (28 arq + 18 HU cross-ref) |
| Hallazgos Ronda 1 (corregidos) | 7 (3 CRITICAL, 1 HIGH, 2 MEDIUM, 1 LOW) |
| Hallazgos Ronda 2 ‚Äî corregidos | 4 (1 CRITICAL, 2 MEDIUM, 1 INFO) |
| Hallazgos Ronda 2 ‚Äî aceptados | 6 (2 MEDIUM, 3 LOW, 1 INFO) |
| Fases de implementaci√≥n | 11 (Fases 1-8, 8.5, 9-10 + N) |
| Componentes | 9 nuevos + 17 modificados = 26 total |
| CAs cubiertos | 14/14 con mecanismo de implementaci√≥n trazado |

