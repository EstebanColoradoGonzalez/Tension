# HU-11 ‚Äî Prescribir carga objetivo seg√∫n Regla de Doble Umbral

## Requisitos relacionados

RF25, RF26, RF27, RF31

## Descripci√≥n

Como ejecutante, quiero que el sistema determine autom√°ticamente si debo subir de peso en un ejercicio seg√∫n la Regla de Doble Umbral y me prescriba la carga exacta para la pr√≥xima sesi√≥n, para progresar de forma sostenible bas√°ndome en evidencia propia y no en sensaciones subjetivas.

## Criterios de Aceptaci√≥n

### CA-11.01 ‚Äî Detecci√≥n de cumplimiento del Doble Umbral

**Dado que** el sistema eval√∫a un ejercicio al cerrar una sesi√≥n,
**cuando** el ejecutante alcanz√≥ ‚â• 12 repeticiones en al menos 3 de las 4 series **y** el RIR promedio de las 4 series fue ‚â• 2,
**entonces** el sistema se√±ala que el ejercicio est√° listo para incrementar carga, cumpliendo ambas condiciones de la Regla de Doble Umbral simult√°neamente.

### CA-11.02 ‚Äî Exigencia de ambas condiciones

**Dado que** el sistema eval√∫a un ejercicio al cerrar una sesi√≥n,
**cuando** solo una de las dos condiciones se cumple (ej: ‚â• 12 reps en 3/4 series pero RIR promedio < 2, o RIR promedio ‚â• 2 pero sin alcanzar 12 reps en 3/4 series),
**entonces** el sistema no se√±ala el ejercicio como listo para incrementar carga; ambas condiciones deben cumplirse simult√°neamente.

### CA-11.03 ‚Äî Incremento de carga para tren superior (M√≥dulos A y B)

**Dado que** un ejercicio de los M√≥dulos A o B cumple la Regla de Doble Umbral,
**cuando** el sistema calcula la carga objetivo para la pr√≥xima sesi√≥n,
**entonces** prescribe la carga actual + 2.5 Kg como nueva carga objetivo.

### CA-11.04 ‚Äî Incremento de carga para tren inferior (M√≥dulo C)

**Dado que** un ejercicio del M√≥dulo C cumple la Regla de Doble Umbral,
**cuando** el sistema calcula la carga objetivo para la pr√≥xima sesi√≥n,
**entonces** prescribe la carga actual + 5 Kg como nueva carga objetivo.

### CA-11.05 ‚Äî Reinicio del objetivo de repeticiones tras incremento

**Dado que** el sistema prescribe un incremento de carga para un ejercicio,
**cuando** determina los par√°metros para la pr√≥xima sesi√≥n,
**entonces** el objetivo de repeticiones se restablece al l√≠mite inferior del rango (8 repeticiones), esperando que el ejecutante progrese de 8 hacia 12 con la nueva carga.

### CA-11.06 ‚Äî Mantenimiento de carga cuando no se cumple el Doble Umbral

**Dado que** un ejercicio no cumple la Regla de Doble Umbral al cerrar la sesi√≥n (no alcanz√≥ ‚â• 12 reps en 3/4 series, o el RIR promedio fue < 2, o ambas),
**cuando** el sistema calcula la carga objetivo para la pr√≥xima sesi√≥n,
**entonces** prescribe la misma carga utilizada en la sesi√≥n actual, priorizando la progresi√≥n en repeticiones dentro del rango de 8 a 12.

### CA-11.07 ‚Äî Persistencia de la carga prescrita

**Dado que** el sistema ha calculado la carga objetivo para la pr√≥xima sesi√≥n de un ejercicio,
**cuando** completa el procesamiento post-sesi√≥n,
**entonces** persiste la carga prescrita de manera que al iniciar la pr√≥xima sesi√≥n que incluya ese ejercicio (HU-05), la carga objetivo se muestre correctamente.

### CA-11.08 ‚Äî No aplica a ejercicios de peso corporal

**Dado que** un ejercicio es de peso corporal (Peso = 0 Kg),
**cuando** el sistema eval√∫a si aplica la Regla de Doble Umbral,
**entonces** no aplica la regla ni prescribe incremento de carga, ya que la progresi√≥n de estos ejercicios se mide exclusivamente por repeticiones totales (CA-10.10).

> **Nota:** Cubre RF31 (exclusi√≥n de bodyweight del Doble Umbral). Criterio originalmente en HU-08 (ex CA-08.03), ya cubierto por este CA-11.08.

---

## An√°lisis Arquitect√≥nico (Arquitecto)

### Decisiones de Dise√±o

**1. HU-11 es l√≥gica pura de backend ‚Äî no tiene pantalla propia.**

Mapa de Navegaci√≥n ¬ß5 (fila HU-11): "representaci√≥n indirecta (output en pantallas existentes)". HU-11 produce un dato (`prescribed_load_kg`) que consumen E1 (HU-05: carga objetivo al iniciar sesi√≥n) y E5 (HU-13: se√±al "Subir carga ‚Üí X Kg" en resumen post-sesi√≥n). No hay UI ni ViewModel nuevos. La l√≥gica se ejecuta dentro de `evaluateProgression()` en `SessionRepositoryImpl`, extendiendo el punto de extensi√≥n ya establecido por HU-10.

**2. La Regla de Doble Umbral es una funci√≥n pura en `domain.rules` (ADR-06).**

ADR-06 establece reglas como funciones puras testeables sin emulador. Arquitectura T√©cnica ¬ß5.2 prescribe naming `{Nombre}Rule` ‚Äî ejemplo expl√≠cito: `DoubleThresholdRule`. HU-10 Nota T√©cnica 2 anticip√≥ este archivo como segundo en `domain/rules/`. La regla implementa MDS R1 (Doble Umbral) y R2 (Mantenimiento de carga) como operaciones complementarias.

**3. La "carga actual" es `avgWeightKg` de los sets de la sesi√≥n actual.**

MDS R1 dice: $Peso_{siguiente} = Peso_{actual} + \Delta_{min}$. El "peso actual" se interpreta como el peso promedio usado en la sesi√≥n actual (`ExerciseSessionData.avgWeightKg`), no el `prescribed_load_kg` anterior. Justificaci√≥n: el ejecutante puede no haber usado la carga prescrita (ajust√≥ por disponibilidad de equipo, sensaci√≥n del d√≠a, etc.). El peso real registrado es la fuente de verdad.

**4. Los incrementos provienen de la base de datos (`module.load_increment_kg`), no de constantes hardcodeadas.**

ADR D-07 sugiere constantes (`LOAD_INCREMENT_UPPER = 2.5`, `LOAD_INCREMENT_LOWER = 5.0`), pero la base de datos ya contiene estos valores en la tabla `module` (columna `load_increment_kg`: A=2.5, B=2.5, C=5.0), seeded por `ModuleSeeder`. Duplicar los valores en el motor de reglas crea dos fuentes de verdad ‚Äî si un valor cambia en seed data pero no en la constante (o viceversa), el comportamiento diverge silenciosamente. La decisi√≥n: **leer `load_increment_kg` desde la DB** extendiendo el DTO `SessionExerciseForProgression` con un campo `loadIncrementKg` (costo marginal: un JOIN adicional a `module`). La regla pura recibe el incremento como par√°metro ‚Äî sigue siendo testeable sin DB. ADR D-07 se reinterpreta: los VALORES son 2.5/5.0, pero la FUENTE es la tabla `module`, no constantes Kotlin.

**5. Bodyweight e isom√©tricos quedan excluidos ‚Äî `prescribed_load_kg` permanece `NULL`.**

CA-11.08 y RF31: No aplica el Doble Umbral a ejercicios de peso corporal. Los isom√©tricos son subconjunto de bodyweight (MDS R7, HU-10 Decisi√≥n 6). Para ambos tipos, `prescribed_load_kg` queda `NULL` permanentemente. El Modelo de Datos ¬ß3.13 lo confirma: *"`NULL` para ejercicios de peso corporal e isom√©tricos"*. El guard `isBodyweight || isIsometric` cortocircuita la evaluaci√≥n antes de invocar la regla.

**6. CA-11.05 (reinicio a 8 reps) no requiere almacenamiento ‚Äî es derivable.**

CA-11.05 dice "el objetivo de repeticiones se restablece al l√≠mite inferior del rango (8 repeticiones)". No hay columna `target_reps` en `exercise_progression` ni en ninguna otra tabla. El rango prescrito `8-12` ya est√° en `plan_assignment.reps` (Modelo de Datos ¬ß3.7) y la query `getBySessionIdWithDetails` ya lo incluye como `reps: String` en `SessionExerciseWithDetails`. Cuando `prescribed_load_kg` sube (Doble Umbral cumplido), la UI de E1 ya muestra el rango `8-12` ‚Äî el ejecutante sabe que debe apuntar a 8 reps con la nueva carga. No se requiere persistencia adicional.

**7. La evaluaci√≥n del Doble Umbral es POSTERIOR a la clasificaci√≥n de HU-10.**

El flujo dentro de `evaluateProgression()` es secuencial por ejercicio: (1) HU-10 clasifica progresi√≥n, (2) HU-10 actualiza estado + contador, (3) **HU-11 prescribe carga**. El paso 3 usa datos del paso 1 (clasificaci√≥n) y datos frescos (sets actuales). `prescribed_load_kg` se persiste en la misma llamada `exerciseProgressionDao.update()` que ya actualiza `status` y `sessionsWithoutProgression` ‚Äî se extiende el `copy()` existente para incluir `prescribedLoadKg`.

**8. La prescripci√≥n de carga se ejecuta siempre ‚Äî no solo cuando hay Doble Umbral.**

CA-11.06 requiere que cuando NO se cumple el Doble Umbral, la carga se mantenga. Esto significa que HU-11 siempre calcula `prescribed_load_kg`: si se cumple ‚Üí carga + incremento; si no se cumple ‚Üí carga actual (mantenimiento). Para ejercicios est√°ndar, el valor NUNCA queda `NULL` despu√©s de la primera sesi√≥n con sets. Solo queda `NULL` para bodyweight/isom√©tricos y para ejercicios que nunca se han ejecutado.

### Componentes Nuevos

**1. `DoubleThresholdRule`** ‚Äî `domain/rules/DoubleThresholdRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

import com.estebancoloradogonzalez.tension.domain.model.ExerciseSessionData

object DoubleThresholdRule {

    const val REP_THRESHOLD = 12
    const val MIN_SERIES_MEETING_REP_THRESHOLD = 3
    const val REQUIRED_SETS = 4
    const val RIR_THRESHOLD = 2.0

    fun meetsDoubleThreshold(current: ExerciseSessionData): Boolean {
        if (current.setCount < REQUIRED_SETS) return false

        val seriesMeetingRepThreshold = current.sets.count { it.reps >= REP_THRESHOLD }
        val meetsRepCondition = seriesMeetingRepThreshold >= MIN_SERIES_MEETING_REP_THRESHOLD
        val meetsRirCondition = current.avgRir >= RIR_THRESHOLD

        return meetsRepCondition && meetsRirCondition
    }

    fun prescribeLoad(
        currentAvgWeightKg: Double,
        loadIncrementKg: Double,
        meetsThreshold: Boolean,
    ): Double {
        if (!meetsThreshold) return currentAvgWeightKg
        return currentAvgWeightKg + loadIncrementKg
    }
}
```

Funci√≥n pura, testeable unitariamente sin emulador (ADR-06, RNF29, RNF30). Opera sobre modelos de dominio (`ExerciseSessionData`). La condici√≥n del Doble Umbral verifica AMBOS criterios simult√°neamente (CA-11.02):

- **Reps:** ‚â• 12 en al menos 3 de 4 series ‚Üí `seriesMeetingRepThreshold >= 3`
- **RIR:** Promedio ‚â• 2 ‚Üí `avgRir >= 2.0`
- **Guard:** `setCount < 4` ‚Üí `false` ‚Äî CA-11.01 y RF25 dicen "3 de las 4 series", por lo que se requieren las 4 series completas

`prescribeLoad()` recibe `loadIncrementKg` como par√°metro (le√≠do de la DB), no como constante interna. Es idempotente ‚Äî dado los mismos inputs, produce el mismo output.

### Componentes Modificados

**2. `SessionExerciseDao.kt`** ‚Äî extender DTO y query con `loadIncrementKg`

```kotlin
data class SessionExerciseForProgression(
    val sessionExerciseId: Long,
    val exerciseId: Long,
    val isBodyweight: Int,
    val isIsometric: Int,
    val moduleCode: String,
    val loadIncrementKg: Double,
)
```

Query actualizada ‚Äî agrega JOIN a `module` y selecciona `load_increment_kg`:

```sql
SELECT 
    se.id AS sessionExerciseId,
    se.exercise_id AS exerciseId,
    e.is_bodyweight AS isBodyweight,
    e.is_isometric AS isIsometric,
    e.module_code AS moduleCode,
    m.load_increment_kg AS loadIncrementKg
FROM session_exercise se
INNER JOIN exercise e ON se.exercise_id = e.id
INNER JOIN module m ON e.module_code = m.code
WHERE se.session_id = :sessionId
```

El JOIN a `module` es de costo marginal (PK string lookup) y elimina la duplicaci√≥n de constantes con la BD.

**3. `SessionRepositoryImpl.evaluateProgression()`** ‚Äî extender con prescripci√≥n de carga

El flujo actual (HU-10) para cada ejercicio es:
1. Obtener sets actuales y hist√≥ricos
2. Clasificar progresi√≥n
3. Actualizar `session_exercise.progression_classification`
4. Resolver nuevo estado de progresi√≥n
5. Actualizar `exercise_progression` (status + counter)

HU-11 agrega un paso 5b entre el paso 4 y 5:
- Si el ejercicio es bodyweight o isom√©trico ‚Üí `prescribedLoadKg` = `null` (sin cambio)
- Si no ‚Üí evaluar Doble Umbral ‚Üí calcular `prescribedLoadKg`
- Incluir `prescribedLoadKg` en el `copy()` de `exerciseProgressionDao.update()`

```kotlin
private suspend fun evaluateProgression(sessionId: Long) {
    val exercises = sessionExerciseDao.getSessionExercisesForProgression(sessionId)

    for (exercise in exercises) {
        val currentSetDtos = exerciseSetDao.getSetsForSessionExercise(
            exercise.sessionExerciseId,
        )
        if (currentSetDtos.isEmpty()) continue

        val currentData = ExerciseSessionData(
            sets = currentSetDtos.map { SetData(it.weightKg, it.reps, it.rir) },
        )

        val previousSetDtos = exerciseSetDao.getLastHistoricalSets(
            exercise.exerciseId,
            sessionId,
        )
        val previousData = if (previousSetDtos.isNotEmpty()) {
            ExerciseSessionData(
                sets = previousSetDtos.map { SetData(it.weightKg, it.reps, it.rir) },
            )
        } else {
            null
        }

        val isBodyweight = exercise.isBodyweight == 1
        val isIsometric = exercise.isIsometric == 1

        val classification = ProgressionClassificationRule.classify(
            current = currentData,
            previous = previousData,
            isBodyweight = isBodyweight,
            isIsometric = isIsometric,
        )

        sessionExerciseDao.updateProgressionClassification(
            exercise.sessionExerciseId,
            classification?.name,
        )

        val isMastered = isIsometric &&
            ProgressionClassificationRule.isIsometricMastered(currentData)

        val currentProgression = exerciseProgressionDao
            .getByExerciseId(exercise.exerciseId).first()

        if (currentProgression == null) continue

        val (newStatus, newCounter) =
            ProgressionClassificationRule.resolveNewProgressionState(
                currentStatus = currentProgression.status,
                currentCounter = currentProgression.sessionsWithoutProgression,
                classification = classification,
                isIsometric = isIsometric,
                isMastered = isMastered,
            )

        // Step 5b: Prescribe load (HU-11)
        val prescribedLoadKg = if (isBodyweight || isIsometric) {
            null
        } else {
            val meetsThreshold = DoubleThresholdRule.meetsDoubleThreshold(currentData)
            DoubleThresholdRule.prescribeLoad(
                currentAvgWeightKg = currentData.avgWeightKg,
                loadIncrementKg = exercise.loadIncrementKg,
                meetsThreshold = meetsThreshold,
            )
        }

        exerciseProgressionDao.update(
            currentProgression.copy(
                status = newStatus,
                sessionsWithoutProgression = newCounter,
                prescribedLoadKg = prescribedLoadKg,
            ),
        )
    }
}
```

Cambios respecto al c√≥digo HU-10 existente: (a) calcular `prescribedLoadKg` antes del `update`, (b) incluirlo en el `copy()`, y (c) usar `exercise.loadIncrementKg` del DTO. El import de `DoubleThresholdRule` se agrega en la secci√≥n de imports.

### Verificaci√≥n Exhaustiva CA por CA

**CA-11.01 ‚Äî Detecci√≥n de cumplimiento del Doble Umbral:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `DoubleThresholdRule.meetsDoubleThreshold(currentData)` | Verifica ambas condiciones sobre `ExerciseSessionData` |
| Condici√≥n reps | `sets.count { it.reps >= 12 } >= 3` | ‚â• 12 reps en ‚â• 3 de 4 series |
| Condici√≥n RIR | `avgRir >= 2.0` | RIR promedio ‚â• 2 |
| MDS R1 | F√≥rmula del Doble Umbral | Match exacto |

**CA-11.02 ‚Äî Exigencia de ambas condiciones:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `return meetsRepCondition && meetsRirCondition` | Operador AND ‚Äî ambas deben ser true |
| Guard | `setCount < REQUIRED_SETS (4) ‚Üí false` | Si hay <4 sets, no se eval√∫a (RF25: "3 de las 4 series") |

**CA-11.03 ‚Äî Incremento de carga para tren superior (M√≥dulos A y B):**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| DB | `module.load_increment_kg = 2.5` para m√≥dulos A y B | `ModuleSeeder`: A=2.5, B=2.5 |
| Rule | `prescribeLoad(loadIncrementKg = 2.5)` | Recibe incremento como par√°metro |
| C√°lculo | `currentAvgWeightKg + 2.5` | Peso actual + incremento |

**CA-11.04 ‚Äî Incremento de carga para tren inferior (M√≥dulo C):**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|----------|
| DB | `module.load_increment_kg = 5.0` para m√≥dulo C | `ModuleSeeder`: C=5.0 |
| Rule | `prescribeLoad(loadIncrementKg = 5.0)` | Recibe incremento como par√°metro |
| C√°lculo | `currentAvgWeightKg + 5.0` | Peso actual + incremento |

**CA-11.05 ‚Äî Reinicio del objetivo de repeticiones tras incremento:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Derivable | Sin persistencia ‚Äî rango `8-12` ya en `plan_assignment.reps` | `SessionExerciseWithDetails.reps` = `"8-12"` |
| UX | Con nueva carga, el ejecutante apunta a 8 reps | Modelo de Datos no tiene columna `target_reps` |
| MDS R1 | "reestablece el objetivo de repeticiones al l√≠mite inferior del rango" | Impl√≠cito por el rango prescrito |

**CA-11.06 ‚Äî Mantenimiento de carga cuando no se cumple el Doble Umbral:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `if (!meetsThreshold) return currentAvgWeightKg` | `prescribeLoad()` con flag false |
| MDS R2 | "la carga se mantiene para la pr√≥xima sesi√≥n" | `prescribed_load_kg` = peso actual |
| RF27 | "prescribir la misma carga" | Match exacto |

**CA-11.07 ‚Äî Persistencia de la carga prescrita:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Repository | `exerciseProgressionDao.update(currentProgression.copy(prescribedLoadKg = ...))` | Persistido en `exercise_progression.prescribed_load_kg` |
| Consumo | E1 ‚Üí `SessionExerciseWithDetails.prescribedLoadKg` (JOIN ya existe) | Query `getBySessionIdWithDetails` ya incluye `ep.prescribed_load_kg` |
| Modelo de Datos | ¬ß3.13: "Calculada por el motor de Doble Umbral al cierre de sesi√≥n y persistida" | Match exacto |

**CA-11.08 ‚Äî No aplica a ejercicios de peso corporal:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Guard | `if (isBodyweight \|\| isIsometric) ‚Üí prescribedLoadKg = null` | Skip antes de invocar regla |
| RF31 | "sin aplicar la Regla de Doble Umbral de carga" | Match exacto |
| Modelo de Datos | ¬ß3.13: "`NULL` para ejercicios de peso corporal e isom√©tricos" | Match exacto |

### Validaci√≥n de Impacto

**Archivos nuevos:**

| Archivo | Prop√≥sito |
|---|---|
| `domain/rules/DoubleThresholdRule.kt` | Regla pura: evaluaci√≥n Doble Umbral + prescripci√≥n de carga |
| `test/.../domain/rules/DoubleThresholdRuleTest.kt` | Tests unitarios de la regla |

**Archivos modificados:**

| Archivo | Acci√≥n | Secci√≥n |
|---|---|---|
| `SessionExerciseDao.kt` | Agregar `loadIncrementKg` al DTO + JOIN a `module` en query | `getSessionExercisesForProgression()` |
| `SessionRepositoryImpl.kt` | Agregar c√°lculo de `prescribedLoadKg` + import `DoubleThresholdRule` | `evaluateProgression()` |

**Archivos NO tocados:**

| Archivo | Raz√≥n |
|---|---|
| `ProgressionClassificationRule.kt` | Sin cambios ‚Äî HU-11 es una regla independiente |
| `ExerciseSessionData.kt` | Sin cambios ‚Äî `avgWeightKg`, `avgRir`, `setCount`, `sets` ya existen |
| `SetData.kt` | Sin cambios ‚Äî `reps`, `rir`, `weightKg` ya existen |
| `ProgressionClassification.kt` | Sin cambios |
| `ExerciseProgressionEntity.kt` | Sin cambios ‚Äî `prescribedLoadKg: Double?` ya existe |
| `ExerciseProgressionDao.kt` | Sin cambios ‚Äî `update()` ya acepta el entity completo |
| `ExerciseSetDao.kt` | Sin cambios ‚Äî queries de HU-10 son suficientes |
| `SessionRepository.kt` | Sin cambios ‚Äî interfaz mantiene misma firma |
| `CloseSessionUseCase.kt` | Sin cambios ‚Äî sigue delegando a `closeSession()` |
| `SessionExerciseWithDetails` | Sin cambios ‚Äî ya incluye `prescribedLoadKg` por JOIN con `exercise_progression` |
| `ActiveSessionViewModel.kt` | Sin cambios ‚Äî HU-11 no tiene UI |
| `ActiveSessionScreen.kt` | Sin cambios ‚Äî ya muestra `prescribedLoadKg` cuando no es null (HU-05) |

### Notas T√©cnicas

1. **HU-11 agrega 0 queries nuevas, solo extiende 1 existente.** La query `getSessionExercisesForProgression` se extiende con un JOIN a `module` para obtener `load_increment_kg`. El resto de la informaci√≥n ya est√° disponible en el loop: `currentData` (sets con reps, rir, weight), `exercise.isBodyweight`, `exercise.isIsometric`. El `moduleCode` fue previsto por HU-10 Nota T√©cnica 5.

2. **El `avgWeightKg` usa el peso PROMEDIO de los sets, no la moda ni el m√°ximo.** En la pr√°ctica, todas las series de un ejercicio se ejecutan con el mismo peso (el peso prescrito o disponible). Pero si el ejecutante ajust√≥ el peso intra-ejercicio (ej: warm-up set, strip set), el promedio refleja mejor la intensidad real. El Modelo de Datos ¬ß3.12 registra `weight_kg` por set individual ‚Äî el promedio se computa desde los datos reales.

3. **El guard `setCount < REQUIRED_SETS (4)` en `meetsDoubleThreshold`.** CA-11.01 y RF25 dicen expl√≠citamente "al menos 3 **de las 4 series**", fijando 4 como la cantidad requerida. Si el ejercicio tiene <4 sets (sesi√≥n incompleta), el Doble Umbral no se eval√∫a ‚Äî la carga se mantiene (CA-11.06 fallback). Esto previene que una sesi√≥n con 3 sets brillantes active un incremento prematuro. La constante `REQUIRED_SETS = 4` hace expl√≠cita esta decisi√≥n.

4. **La constante `RIR_THRESHOLD = 2.0` es Double, no Int.** Aunque el RIR se registra como Int (0-5) por set, el promedio de 4 sets es un Double. La comparaci√≥n `avgRir >= 2.0` es consistente con el tipo. Ejemplo: sets con RIR [2, 2, 1, 2] ‚Üí promedio = 1.75 ‚Üí NO cumple (< 2.0).

5. **`prescribeLoad()` siempre retorna un valor.** No retorna `null` ‚Äî para ejercicios est√°ndar, siempre hay una carga prescrita (la actual o la incrementada). El `null` solo ocurre para bodyweight/isom√©tricos, y ese caso se resuelve en el guard del repositorio ANTES de invocar la regla. La separaci√≥n de responsabilidades es clara: el repositorio decide SI prescribir; la regla decide CU√ÅNTO.

6. **La prescripci√≥n de carga durante `IN_DELOAD` sigue el flujo normal.** HU-10 ya guarda el estado `IN_DELOAD` (no lo modifica). HU-11 prescribe la carga basada en los sets reales de la sesi√≥n de descarga (que son al 60% de la carga habitual). Cuando la descarga termine (HU-17), la carga se reiniciar√° al 90% de la pre-descarga ‚Äî eso es responsabilidad de HU-17 (CA-17.05), no de HU-11. HU-11 simplemente prescribe carga actual + incremento (si aplica) o carga actual (si no aplica), independientemente del estado de descarga.

7. **El Doble Umbral NO depende de la clasificaci√≥n de progresi√≥n.** Son evaluaciones independientes: la clasificaci√≥n de HU-10 compara contra historial (sesi√≥n actual vs anterior); el Doble Umbral eval√∫a solo la sesi√≥n actual (¬øcumpli√≥ los umbrales de reps y RIR?). Un ejercicio puede tener `MAINTENANCE` (misma carga, mismas reps) y aun as√≠ cumplir el Doble Umbral (12+ reps con RIR ‚â• 2) ‚Äî en ese caso, se prescribe incremento.

### Historias Relacionadas

**Predecesoras (datos que HU-11 consume):**

- HU-05: Cre√≥ `ExerciseProgressionEntity` con `prescribedLoadKg`. Implement√≥ el JOIN en `getBySessionIdWithDetails` que muestra `prescribedLoadKg` en E1. Infraestructura de persistencia ya lista.
- HU-06: Persisti√≥ datos de `exercise_set` (peso, reps, RIR) que HU-11 eval√∫a para el Doble Umbral.
- HU-10: Estableci√≥ `evaluateProgression()` con el loop por ejercicio, los datos de sesi√≥n (`currentData`, `exercise.moduleCode`) y la llamada a `exerciseProgressionDao.update()` que HU-11 extiende.

**Sucesoras (dependen de HU-11):**

- HU-13: E5 (Resumen Post-Sesi√≥n) ‚Äî mostrar√° "Subir carga ‚Üí X Kg" cuando `prescribed_load_kg` > carga actual, o "Mantener carga" cuando son iguales. Leer√° `exercise_progression.prescribed_load_kg`.
- HU-15: Recomendaciones escalonadas ‚Äî sesi√≥n 4 recomendar√° microincremento (MDS R3: "1.25 Kg si est√° disponible, o a√±adir 1 rep por serie"). Podr√° usar `prescribed_load_kg` como base.
- HU-17: Protocolo de descarga ‚Äî post-descarga la carga se reinicia al 90% de la pre-descarga (CA-17.05). HU-17 escribir√° directamente sobre `prescribed_load_kg`.

**Consumidoras indirectas:**

- HU-20: M√©tricas globales ‚Äî podr√° derivar progresi√≥n de carga comparando `prescribed_load_kg` a lo largo del tiempo.
- HU-22: KPIs por ejercicio ‚Äî tasa de progresi√≥n de carga.
- HU-23: Historial de ejercicio (F3) ‚Äî podr√° mostrar evoluci√≥n de carga prescrita.

### Referencias y Validaci√≥n

**Documentaci√≥n consultada:**

- MDS ¬ß6-A Regla 1: Doble Umbral ‚Äî f√≥rmula completa y condiciones.
- MDS ¬ß6-A Regla 2: Mantenimiento de carga ‚Äî cuando R1 no se cumple.
- MDS ¬ß6-A Regla 6: Peso corporal ‚Äî exclusi√≥n del Doble Umbral.
- Modelo de Datos ¬ß3.13 (`exercise_progression`): columna `prescribed_load_kg` con l√≥gica de step 6.
- ADR-06: Motor de reglas como Kotlin puro en `domain.rules`.
- ADR D-07: Valores de incremento 2.5/5.0 ‚Äî fuente real: `module.load_increment_kg` en la BD.
- Arquitectura T√©cnica ¬ß5.2: Naming `DoubleThresholdRule`.
- HU-10 an√°lisis: Nota T√©cnica 2 (primer archivo en `domain/rules/`), Nota T√©cnica 5 (`moduleCode` proactivo).
- HU-10 implementaci√≥n: `evaluateProgression()` como punto de extensi√≥n.
- Requerimientos: RF25, RF26, RF27, RF31.

### Verificaci√≥n Cruzada de CAs

| CA | Estado | Mecanismo | Implementado en |
|---|---|---|---|
| CA-11.01 | üî® Por implementar | `meetsDoubleThreshold()` ‚Äî verifica reps ‚â• 12 en ‚â• 3 series AND avgRir ‚â• 2 | HU-11 (Rule) |
| CA-11.02 | üî® Por implementar | `&&` operator ‚Äî ambas condiciones simult√°neas | HU-11 (Rule) |
| CA-11.03 | üî® Por implementar | `prescribeLoad(loadIncrementKg = 2.5)` ‚Äî incremento le√≠do de `module.load_increment_kg` | HU-11 (Rule + DTO) |
| CA-11.04 | üî® Por implementar | `prescribeLoad(loadIncrementKg = 5.0)` ‚Äî incremento le√≠do de `module.load_increment_kg` | HU-11 (Rule + DTO) |
| CA-11.05 | ‚úÖ Ya cubierto | Derivable ‚Äî rango `8-12` en `plan_assignment.reps` | HU-05 (query existente) |
| CA-11.06 | üî® Por implementar | `prescribeLoad()` con `meetsThreshold = false` ‚Üí misma carga | HU-11 (Rule) |
| CA-11.07 | üî® Por implementar | `exerciseProgressionDao.update(copy(prescribedLoadKg = ...))` | HU-11 (Repository) |
| CA-11.08 | üî® Por implementar | Guard `isBodyweight \|\| isIsometric ‚Üí null` | HU-11 (Repository) |

### Hitos de implementaci√≥n

| # | Entregable | Archivos | CAs |
|---|---|---|---|
| 1 | Regla pura ‚Äî `DoubleThresholdRule` + tests unitarios exhaustivos | `DoubleThresholdRule.kt`, `DoubleThresholdRuleTest.kt` | CA-11.01, CA-11.02, CA-11.03, CA-11.04, CA-11.06 |
| 2 | DTO + query ‚Äî extender `SessionExerciseForProgression` con `loadIncrementKg` | `SessionExerciseDao.kt` | CA-11.03, CA-11.04 |
| 3 | Integraci√≥n ‚Äî extender `evaluateProgression()` con prescripci√≥n de carga | `SessionRepositoryImpl.kt` | CA-11.07, CA-11.08 |
