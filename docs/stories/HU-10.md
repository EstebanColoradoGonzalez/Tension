# HU-10 ‚Äî Evaluar y clasificar progresi√≥n post-sesi√≥n

## Requisitos relacionados

RF23, RF24, RF28, RF31, RF32, RF33, RF43

## Descripci√≥n

Como ejecutante, quiero que el sistema eval√∫e autom√°ticamente la progresi√≥n de cada ejercicio al cerrar una sesi√≥n, comparando mis datos contra el historial, clasificando el resultado y actualizando el estado de progresi√≥n, para tener un diagn√≥stico objetivo de mi rendimiento sin interpretaciones subjetivas.

## Criterios de Aceptaci√≥n

### CA-10.01 ‚Äî Comparaci√≥n contra √∫ltimo registro hist√≥rico

**Dado que** el ejecutante cierra una sesi√≥n (Completada o Incompleta),
**cuando** el sistema ejecuta el an√°lisis de progresi√≥n,
**entonces** compara los datos de cada ejercicio registrado en la sesi√≥n contra su √∫ltimo registro hist√≥rico del mismo ejercicio, independientemente del m√≥dulo-versi√≥n en que se haya ejecutado anteriormente, evaluando: variaci√≥n de carga (peso), variaci√≥n de repeticiones y variaci√≥n del RIR.

### CA-10.02 ‚Äî Clasificaci√≥n como Progresi√≥n positiva

**Dado que** el sistema compara un ejercicio contra su historial,
**cuando** detecta que el ejecutante aument√≥ la carga y/o las repeticiones manteniendo el RIR estable (sin subir significativamente),
**entonces** clasifica la progresi√≥n del ejercicio en esta sesi√≥n como "Progresi√≥n positiva".

### CA-10.03 ‚Äî Clasificaci√≥n como Mantenimiento

**Dado que** el sistema compara un ejercicio contra su historial,
**cuando** detecta que el ejecutante mantuvo la misma carga y las mismas repeticiones con RIR estable,
**entonces** clasifica la progresi√≥n del ejercicio en esta sesi√≥n como "Mantenimiento".

### CA-10.04 ‚Äî Clasificaci√≥n como Regresi√≥n

**Dado que** el sistema compara un ejercicio contra su historial,
**cuando** detecta que el ejecutante disminuy√≥ la carga o las repeticiones, o que el RIR promedio subi√≥ ‚â• 1.5 puntos con la misma carga,
**entonces** clasifica la progresi√≥n del ejercicio en esta sesi√≥n como "Regresi√≥n".

### CA-10.05 ‚Äî C√°lculo y almacenamiento del RIR promedio

**Dado que** el ejecutante ha registrado las 4 series de un ejercicio en la sesi√≥n,
**cuando** el sistema ejecuta el an√°lisis post-sesi√≥n,
**entonces** calcula el RIR promedio aritm√©tico de las 4 series del ejercicio y lo almacena como dato derivado, disponible para reglas de decisi√≥n y c√°lculos de KPIs posteriores.

### CA-10.06 ‚Äî RIR promedio con series parciales

**Dado que** el ejecutante registr√≥ menos de 4 series de un ejercicio (sesi√≥n incompleta),
**cuando** el sistema calcula el RIR promedio,
**entonces** lo calcula con las series efectivamente registradas (promedio de las series disponibles) y lo almacena indicando que es un dato parcial.

### CA-10.07 ‚Äî Ejercicio sin historial previo

**Dado que** un ejercicio registrado en la sesi√≥n no tiene registros hist√≥ricos previos,
**cuando** el sistema ejecuta el an√°lisis de progresi√≥n,
**entonces** no emite clasificaci√≥n de progresi√≥n para ese ejercicio (no hay base de comparaci√≥n) y lo marca con estado "Sin Historial".

### CA-10.08 ‚Äî Actualizaci√≥n del estado persistente de progresi√≥n

**Dado que** el sistema ha clasificado la progresi√≥n de un ejercicio en la sesi√≥n,
**cuando** completa el an√°lisis,
**entonces** actualiza el estado persistente de progresi√≥n del ejercicio seg√∫n la siguiente l√≥gica:
- Si estaba "Sin Historial" y hay clasificaci√≥n ‚Üí pasa a "En Progresi√≥n"
- Si ten√≠a progresi√≥n positiva ‚Üí se mantiene "En Progresi√≥n"
- Si acumula 3 sesiones sin progresi√≥n ‚Üí pasa a "En Meseta"
- Si est√° en per√≠odo de descarga ‚Üí se mantiene "En Descarga"

### CA-10.09 ‚Äî Almacenamiento de la clasificaci√≥n por sesi√≥n

**Dado que** el sistema ha clasificado la progresi√≥n de cada ejercicio,
**cuando** completa el an√°lisis post-sesi√≥n,
**entonces** persiste la clasificaci√≥n (Progresi√≥n positiva, Mantenimiento o Regresi√≥n) vinculada a la sesi√≥n y al ejercicio, para consulta futura en el historial.

### CA-10.10 ‚Äî Progresi√≥n de peso corporal por repeticiones totales

**Dado que** el ejecutante ha completado las 4 series de un ejercicio de peso corporal,
**cuando** el sistema eval√∫a la progresi√≥n de ese ejercicio,
**entonces** mide la progresi√≥n exclusivamente por el total de repeticiones logradas en las 4 series comparado con la sesi√≥n anterior del mismo ejercicio, sin aplicar la Regla de Doble Umbral de carga.

> **Origen:** Redistribuido desde HU-08 (ex CA-08.02). Cubre RF31.

### CA-10.11 ‚Äî Progresi√≥n de isom√©tricos por tiempo sostenido

**Dado que** el ejecutante ha completado las 4 series de un ejercicio isom√©trico,
**cuando** el sistema eval√∫a la progresi√≥n,
**entonces** mide la progresi√≥n por los segundos sostenidos dentro del rango prescrito (30-45 segundos), comparando con la sesi√≥n anterior del mismo ejercicio.

> **Origen:** Redistribuido desde HU-08 (ex CA-08.06). Cubre RF32.

### CA-10.12 ‚Äî Marcado de isom√©trico como "dominado"

**Dado que** el ejecutante completa las 4 series de un ejercicio isom√©trico y las 4 series alcanzaron ‚â• 45 segundos,
**cuando** el sistema eval√∫a la progresi√≥n del ejercicio,
**entonces** marca el ejercicio como "dominado" e indica al ejecutante que el ejercicio ya no ofrece est√≠mulo progresivo suficiente en su forma actual.

> **Origen:** Redistribuido desde HU-08 (ex CA-08.07). Cubre RF33.
---

## An√°lisis Arquitect√≥nico (Arquitecto)

### Decisiones de Dise√±o

**1. HU-10 es l√≥gica pura de backend ‚Äî no tiene pantalla propia.**

Mapa de Navegaci√≥n ¬ß5 (fila HU-10): "representaci√≥n indirecta (output en pantallas existentes)". HU-10 produce datos que consumen E5 (HU-13), F2 (HU-24) y F3 (HU-23). No hay UI ni ViewModel nuevos. Todo ocurre dentro de la transacci√≥n de `closeSession()` (punto de extensi√≥n documentado en HU-09 Nota T√©cnica 4).

**2. La clasificaci√≥n es una funci√≥n pura en `domain.rules` (ADR-06).**

ADR-06 establece que las Reglas R1-R7 del MDS se implementan como funciones puras en `domain.rules`, testeables sin emulador. HU-10 implementa parcialmente R3 (detecci√≥n de meseta: transici√≥n de estado), R4 (regresi√≥n: clasificaci√≥n), R6 (peso corporal: comparaci√≥n por repeticiones totales) y R7 (isom√©tricos: comparaci√≥n por segundos + marcado "dominado"). El archivo es `ProgressionClassificationRule.kt`, siguiendo la convenci√≥n de naming `{Nombre}Rule` (Arquitectura T√©cnica ¬ß5.2).

**3. El RIR promedio NO se almacena en base de datos.**

CA-10.05 y RF28 usan "almacena". Sin embargo, el Modelo de Datos ¬ß2 (Convenciones) establece: *"Datos calculados: No se almacenan en base de datos"*. El Modelo de Datos ¬ß3.13 (`exercise_progression`) no tiene columna `average_rir`. El RIR promedio es derivable en cualquier momento como `AVG(exercise_set.rir) WHERE session_exercise_id = ?`. Para la clasificaci√≥n, se computa in-memory a partir de los sets ya fetched. Para KPIs futuros (HU-20, HU-22), se computar√° por query. **Misma resoluci√≥n que CA-09.04 (tonelaje).**

**4. La comparaci√≥n es contra el √∫ltimo registro del mismo ejercicio, independiente de versi√≥n.**

ADR D-06 es expl√≠cito: *"El query de comparaci√≥n busca la √∫ltima `session_exercise` del mismo `exercise_id`, sin filtrar por `module_version_id`"*. RF23 y CA-10.01 lo confirman. La query usa una subconsulta para encontrar el `session_exercise.id` m√°s reciente del mismo `exercise_id` en una sesi√≥n cerrada distinta (`COMPLETED` o `INCOMPLETE`), y obtiene sus sets.

**5. El umbral de "RIR significativamente elevado" es ‚â• 1.5 puntos.**

CA-10.04 define: regresi√≥n se detecta cuando el RIR promedio sube ‚â• 1.5 puntos con la misma carga. RF24 usa "sin subir significativamente" para progresi√≥n positiva. Se adopta 1.5 como umbral universal para "cambio significativo de RIR" en ambas direcciones. Constante: `RIR_SIGNIFICANT_RISE = 1.5`. RF29 (que pertenece a HU-12) usa el mismo umbral but con criterio per-series ‚Äî ver Nota T√©cnica 8.

**6. La clasificaci√≥n cubre 3 tipos de ejercicio con l√≥gica diferenciada.**

| Tipo | Flag | M√©trica principal | Regla MDS | CA |
|------|------|-------------------|-----------|-----|
| Est√°ndar | `!isBodyweight && !isIsometric` | Peso promedio + repeticiones totales + RIR | R1/R2/R4 | CA-10.02/03/04 |
| Peso corporal | `isBodyweight && !isIsometric` | Repeticiones totales (peso = 0) | R6 | CA-10.10 |
| Isom√©trico | `isIsometric` | Segundos sostenidos (en campo `reps`) | R7 | CA-10.11/12 |

Los isom√©tricos son subconjunto de bodyweight (`is_isometric = 1` implica `is_bodyweight = 1` en seed data). La evaluaci√≥n prioriza `isIsometric` sobre `isBodyweight` (orden: isom√©trico ‚Üí peso corporal ‚Üí est√°ndar).

**7. La transici√≥n a `IN_PLATEAU` se ejecuta en HU-10, las alertas en HU-14.**

CA-10.08 define la m√°quina de estados. El estado `IN_PLATEAU` se activa cuando `sessions_without_progression >= 3`. HU-14 (CA-14.01) emitir√° alertas con an√°lisis causal cuando un ejercicio entre en meseta. HU-10 solo ejecuta la transici√≥n de estado y actualiza el contador ‚Äî no emite alertas.

**Nota sobre MDS R3 vs RF34:** MDS ¬ß6-A R3 dice *"3 sesiones consecutivas del mismo ejercicio en la misma versi√≥n del m√≥dulo"*, pero RF34 dice solo *"3 sesiones consecutivas del mismo ejercicio"* sin constraint de versi√≥n. El Modelo de Datos ¬ß3.13 usa un √∫nico contador `sessions_without_progression` por `exercise_id` (sin partici√≥n por versi√≥n), y ADR D-06 establece comparaci√≥n independiente de versi√≥n. **Se sigue el Modelo de Datos y RF34** ‚Äî el contador es global por ejercicio, no por versi√≥n. Divergencia deliberada del MDS R3.

**8. El estado `MASTERED` es terminal para isom√©tricos.**

CA-10.12: si las 4 series ‚â• 45 segundos, el ejercicio se marca como `MASTERED`. La Modelo de Datos ¬ß3.13 incluye `MASTERED` en los estados v√°lidos. Una vez marcado, no hay transici√≥n de salida ‚Äî el ejercicio permanece "dominado" indefinidamente. El clasificador eval√∫a mastered DESPU√âS de la clasificaci√≥n normal (un ejercicio puede tener progresi√≥n positiva Y estar dominado simult√°neamente).

**9. Ejercicios sin historial reciben `null` como clasificaci√≥n.**

CA-10.07: sin datos previos, no hay base de comparaci√≥n ‚Üí no se emite clasificaci√≥n. La columna `session_exercise.progression_classification` queda `NULL`. El estado en `exercise_progression.status` se mantiene como `NO_HISTORY`. El primer registro hist√≥rico se crea al registrar sets (HU-06: `exerciseProgressionDao.insertIfNotExists()`). La clasificaci√≥n no opera sobre `NO_HISTORY` porque necesita 2 puntos de datos.

**10. La integraci√≥n sigue el patr√≥n de extensi√≥n documentado en HU-09.**

HU-09 Nota T√©cnica 4: *"El punto de extensi√≥n ser√° dentro de la transacci√≥n de `closeSession()`, despu√©s de actualizar el status y antes de avanzar la rotaci√≥n"*. `evaluateProgression()` se inserta exactamente ah√≠ como m√©todo privado de `SessionRepositoryImpl`. La regla pura (`ProgressionClassificationRule`) se importa en el repositorio, igual que `RotationResolver`.

### Componentes Nuevos

**1. `ProgressionClassification`** ‚Äî `domain/model/ProgressionClassification.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.model

enum class ProgressionClassification {
    POSITIVE_PROGRESSION,
    MAINTENANCE,
    REGRESSION,
}
```

Enum que mapea 1:1 con los valores de `session_exercise.progression_classification` (Modelo de Datos ¬ß3.11). El `.name` del enum produce el string exacto para persistencia (`"POSITIVE_PROGRESSION"`, `"MAINTENANCE"`, `"REGRESSION"`).

**2. `ExerciseSessionData` y `SetData`** ‚Äî `domain/model/ExerciseSessionData.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.model

data class SetData(
    val weightKg: Double,
    val reps: Int,
    val rir: Int,
)

data class ExerciseSessionData(
    val sets: List<SetData>,
) {
    val setCount: Int get() = sets.size

    val avgWeightKg: Double
        get() = if (sets.isEmpty()) 0.0 else sets.sumOf { it.weightKg } / sets.size

    val totalReps: Int
        get() = sets.sumOf { it.reps }

    val avgRir: Double
        get() = if (sets.isEmpty()) 0.0 else sets.sumOf { it.rir.toDouble() } / sets.size
}
```

Modelos de dominio puros (sin dependencias Android) que alimentan la regla. `SetData` es la unidad at√≥mica; `ExerciseSessionData` agrega y expone propiedades derivadas. El campo `reps` almacena repeticiones o segundos seg√∫n el tipo de ejercicio (Modelo de Datos ¬ß3.12).

**3. `ProgressionClassificationRule`** ‚Äî `domain/rules/ProgressionClassificationRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

import com.estebancoloradogonzalez.tension.domain.model.ExerciseSessionData
import com.estebancoloradogonzalez.tension.domain.model.ProgressionClassification
import kotlin.math.abs

object ProgressionClassificationRule {

    const val RIR_SIGNIFICANT_RISE = 1.5
    const val ISOMETRIC_MASTERED_THRESHOLD = 45
    const val PLATEAU_THRESHOLD = 3
    private const val WEIGHT_TOLERANCE = 0.01

    fun classify(
        current: ExerciseSessionData,
        previous: ExerciseSessionData?,
        isBodyweight: Boolean,
        isIsometric: Boolean,
    ): ProgressionClassification? {
        if (previous == null || previous.sets.isEmpty()) return null
        if (current.sets.isEmpty()) return null

        return when {
            isIsometric -> classifyIsometric(current, previous)
            isBodyweight -> classifyBodyweight(current, previous)
            else -> classifyStandard(current, previous)
        }
    }

    fun isIsometricMastered(current: ExerciseSessionData): Boolean {
        return current.setCount >= 4 &&
            current.sets.all { it.reps >= ISOMETRIC_MASTERED_THRESHOLD }
    }

    fun resolveNewProgressionState(
        currentStatus: String,
        currentCounter: Int,
        classification: ProgressionClassification?,
        isIsometric: Boolean,
        isMastered: Boolean,
    ): Pair<String, Int> {
        if (isIsometric && isMastered) return "MASTERED" to 0
        if (classification == null) return currentStatus to currentCounter
        if (currentStatus == "IN_DELOAD") return currentStatus to currentCounter
        if (currentStatus == "MASTERED") return currentStatus to currentCounter

        return when (classification) {
            ProgressionClassification.POSITIVE_PROGRESSION -> "IN_PROGRESSION" to 0

            ProgressionClassification.MAINTENANCE,
            ProgressionClassification.REGRESSION -> {
                val newCounter = currentCounter + 1
                val newStatus = when {
                    newCounter >= PLATEAU_THRESHOLD -> "IN_PLATEAU"
                    currentStatus == "NO_HISTORY" -> "IN_PROGRESSION"
                    else -> currentStatus
                }
                newStatus to newCounter
            }
        }
    }

    private fun classifyStandard(
        current: ExerciseSessionData,
        previous: ExerciseSessionData,
    ): ProgressionClassification {
        val repsDiff = current.totalReps - previous.totalReps
        val rirRise = current.avgRir - previous.avgRir

        return when {
            isWeightLower(current.avgWeightKg, previous.avgWeightKg) ->
                ProgressionClassification.REGRESSION

            isWeightEqual(current.avgWeightKg, previous.avgWeightKg) && repsDiff < 0 ->
                ProgressionClassification.REGRESSION

            isWeightEqual(current.avgWeightKg, previous.avgWeightKg) &&
                rirRise >= RIR_SIGNIFICANT_RISE ->
                ProgressionClassification.REGRESSION

            isWeightHigher(current.avgWeightKg, previous.avgWeightKg) &&
                rirRise < RIR_SIGNIFICANT_RISE ->
                ProgressionClassification.POSITIVE_PROGRESSION

            isWeightEqual(current.avgWeightKg, previous.avgWeightKg) &&
                repsDiff > 0 && rirRise < RIR_SIGNIFICANT_RISE ->
                ProgressionClassification.POSITIVE_PROGRESSION

            else -> ProgressionClassification.MAINTENANCE
        }
    }

    private fun classifyBodyweight(
        current: ExerciseSessionData,
        previous: ExerciseSessionData,
    ): ProgressionClassification {
        val repsDiff = current.totalReps - previous.totalReps
        val rirRise = current.avgRir - previous.avgRir

        return when {
            repsDiff < 0 -> ProgressionClassification.REGRESSION
            rirRise >= RIR_SIGNIFICANT_RISE && repsDiff <= 0 ->
                ProgressionClassification.REGRESSION
            repsDiff > 0 && rirRise < RIR_SIGNIFICANT_RISE ->
                ProgressionClassification.POSITIVE_PROGRESSION
            else -> ProgressionClassification.MAINTENANCE
        }
    }

    private fun classifyIsometric(
        current: ExerciseSessionData,
        previous: ExerciseSessionData,
    ): ProgressionClassification {
        val secondsDiff = current.totalReps - previous.totalReps
        val rirRise = current.avgRir - previous.avgRir

        return when {
            secondsDiff < 0 -> ProgressionClassification.REGRESSION
            rirRise >= RIR_SIGNIFICANT_RISE && secondsDiff <= 0 ->
                ProgressionClassification.REGRESSION
            secondsDiff > 0 && rirRise < RIR_SIGNIFICANT_RISE ->
                ProgressionClassification.POSITIVE_PROGRESSION
            else -> ProgressionClassification.MAINTENANCE
        }
    }

    private fun isWeightEqual(a: Double, b: Double): Boolean =
        abs(a - b) < WEIGHT_TOLERANCE

    private fun isWeightHigher(a: Double, b: Double): Boolean =
        a - b >= WEIGHT_TOLERANCE

    private fun isWeightLower(a: Double, b: Double): Boolean =
        b - a >= WEIGHT_TOLERANCE
}
```

Funci√≥n pura, testeable unitariamente sin emulador (ADR-06, RNF29, RNF30). Opera sobre modelos de dominio (`ExerciseSessionData`), no sobre entities o DTOs de Room. Las comparaciones de peso usan tolerancia para evitar errores de punto flotante.

### Componentes Modificados

**4. `SessionExerciseDao`** ‚Äî agregar queries

Nuevo DTO para la query de progresi√≥n:

```kotlin
data class SessionExerciseForProgression(
    val sessionExerciseId: Long,
    val exerciseId: Long,
    val isBodyweight: Int,
    val isIsometric: Int,
    val moduleCode: String,
)
```

Nuevas queries:

```kotlin
@Query(
    """
    SELECT 
        se.id AS sessionExerciseId,
        se.exercise_id AS exerciseId,
        e.is_bodyweight AS isBodyweight,
        e.is_isometric AS isIsometric,
        e.module_code AS moduleCode
    FROM session_exercise se
    INNER JOIN exercise e ON se.exercise_id = e.id
    WHERE se.session_id = :sessionId
    """,
)
suspend fun getSessionExercisesForProgression(sessionId: Long): List<SessionExerciseForProgression>

@Query(
    """
    UPDATE session_exercise
    SET progression_classification = :classification
    WHERE id = :sessionExerciseId
    """,
)
suspend fun updateProgressionClassification(sessionExerciseId: Long, classification: String?)
```

La primera query obtiene los metadatos de cada ejercicio en la sesi√≥n (flags de tipo + m√≥dulo). `moduleCode` se incluye proactivamente para HU-11 (incremento diferenciado por m√≥dulo). La segunda query persiste la clasificaci√≥n (CA-10.09).

**5. `ExerciseSetDao`** ‚Äî agregar queries

Nuevo DTO:

```kotlin
data class ExerciseSetData(
    val weightKg: Double,
    val reps: Int,
    val rir: Int,
)
```

Nuevas queries:

```kotlin
@Query(
    """
    SELECT weight_kg AS weightKg, reps, rir
    FROM exercise_set
    WHERE session_exercise_id = :sessionExerciseId
    ORDER BY set_number
    """,
)
suspend fun getSetsForSessionExercise(sessionExerciseId: Long): List<ExerciseSetData>

@Query(
    """
    SELECT es.weight_kg AS weightKg, es.reps, es.rir
    FROM exercise_set es
    WHERE es.session_exercise_id = (
        SELECT se2.id
        FROM session_exercise se2
        INNER JOIN session s2 ON se2.session_id = s2.id
        WHERE se2.exercise_id = :exerciseId
          AND s2.id != :currentSessionId
          AND s2.status IN ('COMPLETED', 'INCOMPLETE')
        ORDER BY s2.date DESC, s2.id DESC
        LIMIT 1
    )
    ORDER BY es.set_number
    """,
)
suspend fun getLastHistoricalSets(exerciseId: Long, currentSessionId: Long): List<ExerciseSetData>
```

`getLastHistoricalSets` implementa ADR D-06: busca el √∫ltimo registro del mismo `exercise_id` independiente de versi√≥n/m√≥dulo, en sesiones cerradas (`COMPLETED` o `INCOMPLETE`), excluyendo la sesi√≥n actual. La subconsulta ordena por `date DESC, id DESC` para determinismo cuando las fechas coinciden.

**6. `SessionRepositoryImpl.closeSession()`** ‚Äî integrar evaluaci√≥n de progresi√≥n

```kotlin
override suspend fun closeSession(sessionId: Long) {
    database.withTransaction {
        // Step 1: Determine and update session status (HU-09)
        val sessionInfo = sessionDao.getActiveSessionWithModuleVersion().first()
            ?: throw IllegalStateException("No active session found")
        if (sessionInfo.sessionId != sessionId) {
            throw IllegalStateException("Session $sessionId is not the active session")
        }
        val status = if (sessionInfo.completedExercises == sessionInfo.totalExercises) {
            "COMPLETED"
        } else {
            "INCOMPLETE"
        }
        sessionDao.updateStatus(sessionId, status)

        // Step 2: Evaluate progression (HU-10)
        evaluateProgression(sessionId)

        // Step 3: Advance rotation (HU-09)
        val rotationEntity = rotationStateDao.getRotationState().first()
            ?: throw IllegalStateException("Rotation state not found")
        val currentRotation = RotationState(
            microcyclePosition = rotationEntity.microcyclePosition,
            currentVersionModuleA = rotationEntity.currentVersionModuleA,
            currentVersionModuleB = rotationEntity.currentVersionModuleB,
            currentVersionModuleC = rotationEntity.currentVersionModuleC,
            microcycleCount = rotationEntity.microcycleCount,
        )
        val newRotation = RotationResolver.advanceRotation(currentRotation)
        rotationStateDao.update(
            rotationEntity.copy(
                microcyclePosition = newRotation.microcyclePosition,
                currentVersionModuleA = newRotation.currentVersionModuleA,
                currentVersionModuleB = newRotation.currentVersionModuleB,
                currentVersionModuleC = newRotation.currentVersionModuleC,
                microcycleCount = newRotation.microcycleCount,
            ),
        )
    }
}

private suspend fun evaluateProgression(sessionId: Long) {
    val exercises = sessionExerciseDao.getSessionExercisesForProgression(sessionId)

    for (exercise in exercises) {
        val currentSetDtos = exerciseSetDao.getSetsForSessionExercise(exercise.sessionExerciseId)
        if (currentSetDtos.isEmpty()) continue

        val currentData = ExerciseSessionData(
            sets = currentSetDtos.map { SetData(it.weightKg, it.reps, it.rir) },
        )

        val previousSetDtos = exerciseSetDao.getLastHistoricalSets(
            exercise.exerciseId,
            sessionId,
        )
        val previousData = if (previousSetDtos.isNotEmpty()) {
            ExerciseSessionData(
                sets = previousSetDtos.map { SetData(it.weightKg, it.reps, it.rir) },
            )
        } else {
            null
        }

        val isBodyweight = exercise.isBodyweight == 1
        val isIsometric = exercise.isIsometric == 1

        val classification = ProgressionClassificationRule.classify(
            current = currentData,
            previous = previousData,
            isBodyweight = isBodyweight,
            isIsometric = isIsometric,
        )

        sessionExerciseDao.updateProgressionClassification(
            exercise.sessionExerciseId,
            classification?.name,
        )

        val isMastered = isIsometric &&
            ProgressionClassificationRule.isIsometricMastered(currentData)

        val currentProgression = exerciseProgressionDao
            .getByExerciseId(exercise.exerciseId).first()
            ?: ExerciseProgressionEntity(exerciseId = exercise.exerciseId)

        val (newStatus, newCounter) = ProgressionClassificationRule.resolveNewProgressionState(
            currentStatus = currentProgression.status,
            currentCounter = currentProgression.sessionsWithoutProgression,
            classification = classification,
            isIsometric = isIsometric,
            isMastered = isMastered,
        )

        exerciseProgressionDao.update(
            currentProgression.copy(
                status = newStatus,
                sessionsWithoutProgression = newCounter,
            ),
        )
    }
}
```

La evaluaci√≥n se ejecuta dentro de la transacci√≥n existente de `closeSession()`. Si falla, todo se revierte (incluido el `updateStatus`), preservando la sesi√≥n como `IN_PROGRESS` (CA-09.08). El m√©todo privado `evaluateProgression` sigue el patr√≥n de N queries simples dentro de la transacci√≥n ‚Äî aceptable para 11-16 ejercicios por sesi√≥n en una BD local SQLite.

### Verificaci√≥n Exhaustiva CA por CA

**CA-10.01 ‚Äî Comparaci√≥n contra √∫ltimo registro hist√≥rico:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| DAO | `getLastHistoricalSets(exerciseId, currentSessionId)` | Subconsulta: √∫ltimo `session_exercise` del mismo `exercise_id` en sesi√≥n cerrada |
| Domain | `ProgressionClassificationRule.classify(current, previous, ...)` | Comparaci√≥n de `ExerciseSessionData` |
| ADR | D-06: "independiente de versi√≥n" | Query no filtra por `module_version_id` |

**CA-10.02 ‚Äî Clasificaci√≥n como Progresi√≥n positiva:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | Est√°ndar: peso subi√≥ con RIR estable ‚Üí `POSITIVE_PROGRESSION` | `isWeightHigher && rirRise < 1.5` |
| Rule | Est√°ndar: mismo peso + reps subieron con RIR estable ‚Üí `POSITIVE_PROGRESSION` | `isWeightEqual && repsDiff > 0 && rirRise < 1.5` |
| Rule | Bodyweight: total reps subi√≥ con RIR estable ‚Üí `POSITIVE_PROGRESSION` | `repsDiff > 0 && rirRise < 1.5` |
| Rule | Isom√©trico: segundos subieron con RIR estable ‚Üí `POSITIVE_PROGRESSION` | `secondsDiff > 0 && rirRise < 1.5` |

**CA-10.03 ‚Äî Clasificaci√≥n como Mantenimiento:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `else` fallthrough en `classifyStandard/Bodyweight/Isometric` | Cualquier caso que no sea progresi√≥n ni regresi√≥n |
| Definici√≥n | Mismo peso, mismas reps, RIR estable | `!isWeightChanged && repsDiff == 0 && rirRise < 1.5` ‚Üí cae en `else` |

**CA-10.04 ‚Äî Clasificaci√≥n como Regresi√≥n:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | Peso baj√≥ ‚Üí `REGRESSION` | `isWeightLower` |
| Rule | Mismo peso + reps totales bajaron ‚Üí `REGRESSION` | `isWeightEqual && repsDiff < 0` |
| Rule | Mismo peso + RIR subi√≥ ‚â• 1.5 ‚Üí `REGRESSION` | `isWeightEqual && rirRise >= 1.5` |
| Nota | Usa `totalReps` (simplificaci√≥n); RF29 per-series es responsabilidad de HU-12 | Ver Nota T√©cnica 8 |

**CA-10.05 ‚Äî C√°lculo y almacenamiento del RIR promedio:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Domain | `ExerciseSessionData.avgRir` ‚Äî propiedad derivada | `sets.sumOf { it.rir.toDouble() } / sets.size` |
| Storage | NO se almacena (Modelo de Datos ¬ß2) | Derivable: `AVG(exercise_set.rir) WHERE session_exercise_id = ?` |
| Uso | Comparaci√≥n in-memory durante clasificaci√≥n | `current.avgRir - previous.avgRir` |

**CA-10.06 ‚Äî RIR promedio con series parciales:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Domain | `avgRir` calcula con sets disponibles (1, 2 o 3) | `sum / size` opera con cualquier cantidad |
| "Parcial" | El status de sesi√≥n `INCOMPLETE` ya indica datos parciales | No se requiere flag adicional |

**CA-10.07 ‚Äî Ejercicio sin historial previo:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| DAO | `getLastHistoricalSets` retorna lista vac√≠a ‚Üí `previousData = null` | Sin sets hist√≥ricos = sin comparaci√≥n |
| Rule | `if (previous == null) return null` | No emite clasificaci√≥n |
| Entity | `session_exercise.progression_classification` queda `NULL` | Persistido v√≠a `updateProgressionClassification(id, null)` |
| Estado | `exercise_progression.status` se mantiene `NO_HISTORY` | `resolveNewProgressionState` con `null` retorna `currentStatus` |

**CA-10.08 ‚Äî Actualizaci√≥n del estado persistente de progresi√≥n:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `resolveNewProgressionState()` ‚Äî m√°quina de estados pura | Funci√≥n en `ProgressionClassificationRule` |
| NO_HISTORY + clasificaci√≥n | ‚Üí `IN_PROGRESSION` | `currentStatus == "NO_HISTORY" ‚Üí "IN_PROGRESSION"` |
| POSITIVE_PROGRESSION | ‚Üí `IN_PROGRESSION`, counter = 0 | Reset del contador |
| MAINTENANCE/REGRESSION | Counter++ ; si ‚â• 3 ‚Üí `IN_PLATEAU` | Transici√≥n de meseta (HU-14 agregar√° alertas) |
| IN_DELOAD | Se mantiene (HU-17 gestiona salida) | Guard: `currentStatus == "IN_DELOAD"` ‚Üí no change |
| MASTERED | Se mantiene (terminal) | Guard: `currentStatus == "MASTERED"` ‚Üí no change |

**CA-10.09 ‚Äî Almacenamiento de la clasificaci√≥n por sesi√≥n:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| DAO | `updateProgressionClassification(sessionExerciseId, classification)` | UPDATE en `session_exercise` |
| Persistencia | `"POSITIVE_PROGRESSION"`, `"MAINTENANCE"`, `"REGRESSION"`, o `NULL` | `.name` del enum o null |
| Consulta futura | E5 (HU-13), F2 (HU-24), F3 (HU-23) | Columna ya existe desde HU-05 |

**CA-10.10 ‚Äî Progresi√≥n de peso corporal por repeticiones totales:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `classifyBodyweight()` ‚Äî compara `totalReps` | `current.totalReps - previous.totalReps` |
| RF31 | No aplica Doble Umbral (HU-11 lo excluir√°) | Clasificaci√≥n independiente de carga |
| Regla 6 MDS | "progresi√≥n por repeticiones logradas" | `repsDiff > 0 ‚Üí POSITIVE_PROGRESSION` |

**CA-10.11 ‚Äî Progresi√≥n de isom√©tricos por tiempo sostenido:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `classifyIsometric()` ‚Äî compara `totalReps` (= segundos) | `current.totalReps - previous.totalReps` |
| RF32 | Segundos en campo `reps` (Modelo de Datos ¬ß3.12) | Interpretaci√≥n por flags del ejercicio |
| Regla 7 MDS | "progresi√≥n por segundos sostenidos" | `secondsDiff > 0 ‚Üí POSITIVE_PROGRESSION` |

**CA-10.12 ‚Äî Marcado de isom√©trico como "dominado":**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `isIsometricMastered()` ‚Äî 4/4 sets ‚â• 45s | `setCount >= 4 && sets.all { it.reps >= 45 }` |
| Estado | `resolveNewProgressionState` ‚Üí `"MASTERED"` si mastered | Prioridad m√°xima en la funci√≥n |
| Modelo de Datos | ¬ß3.13 CHECK: `MASTERED` es valor v√°lido | `CHECK(status IN (..., 'MASTERED'))` |
| RF33 | "las 4 series alcancen ‚â• 45 segundos" | Match exacto |

### Validaci√≥n de Impacto

**Archivos nuevos:**

| Archivo | Prop√≥sito |
|---|---|
| `domain/model/ProgressionClassification.kt` | Enum con los 3 valores de clasificaci√≥n |
| `domain/model/ExerciseSessionData.kt` | Modelos de dominio para la regla (`SetData` + `ExerciseSessionData`) |
| `domain/rules/ProgressionClassificationRule.kt` | Regla pura: clasificaci√≥n + mastered + m√°quina de estados |
| `test/.../domain/rules/ProgressionClassificationRuleTest.kt` | Tests unitarios de la regla |

**Archivos modificados:**

| Archivo | Acci√≥n | Secci√≥n |
|---|---|---|
| `SessionExerciseDao.kt` | Agregar DTO `SessionExerciseForProgression` + 2 queries | DAO |
| `ExerciseSetDao.kt` | Agregar DTO `ExerciseSetData` + 2 queries | DAO |
| `SessionRepositoryImpl.kt` | Agregar `evaluateProgression()` + modificar `closeSession()` | Repository |

**Archivos NO tocados:**

| Archivo | Raz√≥n |
|---|---|
| `SessionRepository.kt` | `closeSession()` mantiene misma firma ‚Äî evaluaci√≥n es detalle interno |
| `CloseSessionUseCase.kt` | Sigue delegando a `closeSession()` ‚Äî sin cambios |
| `ActiveSessionViewModel.kt` | HU-10 no tiene UI ‚Äî sin cambios |
| `ActiveSessionScreen.kt` | Sin cambios |
| `ExerciseProgressionDao.kt` | M√©todos existentes (`getByExerciseId`, `update`) son suficientes |
| `ExerciseProgressionEntity.kt` | Schema ya tiene campos necesarios (`status`, `sessionsWithoutProgression`) |
| `SessionExerciseEntity.kt` | Columna `progression_classification` ya existe |

### Notas T√©cnicas

1. **Patr√≥n N+1 dentro de transacci√≥n.** `evaluateProgression` ejecuta 2-3 queries por ejercicio (sets actuales, sets hist√≥ricos, progression entity) dentro de la transacci√≥n. Para 11-16 ejercicios √ó 3 queries = ~45 queries m√°ximo. En SQLite local con √≠ndices, esto toma < 50ms. No se justifica optimizaci√≥n batch para este volumen.

2. **El `ProgressionClassificationRule` es el PRIMER archivo en `domain/rules/`.** Este paquete no existe a√∫n. Se crea con HU-10, estableciendo el precedente para `DoubleThresholdRule` (HU-11), `RegressionDetectionRule` (HU-12), y `PlateauDetectionRule` (HU-14).

3. **Tolerancia en comparaci√≥n de pesos.** `WEIGHT_TOLERANCE = 0.01` Kg. Los incrementos m√≠nimos reales son 1.25 Kg (microincremento) o 2.5 Kg (est√°ndar). Una tolerancia de 0.01 Kg absorbe errores de punto flotante sin confundir cambios reales de carga.

4. **La comparaci√≥n usa `totalReps` para bodyweight e isom√©tricos.** CA-10.10 dice "total de repeticiones logradas en las 4 series". Cuando ambas sesiones tienen el mismo n√∫mero de sets (caso normal: 4 y 4), el total es directamente comparable. Para sesiones con diferente cantidad de sets (raro, solo en incompletas), el total refleja la realidad (menos sets = menos reps). Esto es admisible porque CA-10.06 indica que los datos parciales se marcan como tales (la sesi√≥n `INCOMPLETE` sirve como indicador).

5. **La propiedad `moduleCode` en `SessionExerciseForProgression` se incluye proactivamente.** HU-10 no la usa, pero HU-11 la necesitar√° para determinar el incremento por m√≥dulo (+2.5 Kg para A/B, +5 Kg para C). Incluirla ahora (costo marginal cero ‚Äî el JOIN ya existe) evita crear otra query id√©ntica en HU-11.

6. **Deload awareness en la m√°quina de estados.** `resolveNewProgressionState` respeta `IN_DELOAD`: si el ejercicio est√° en descarga, la clasificaci√≥n se persiste pero el estado no cambia. HU-17 gestionar√° la entrada/salida de `IN_DELOAD`. Esta guard previene que una regresi√≥n durante descarga (esperada ‚Äî cargas al 60%) active falsamente el contador de meseta.

7. **La evaluaci√≥n opera sobre TODOS los ejercicios con sets, incluidos los sustituidos.** `session_exercise.exercise_id` apunta al ejercicio ejecutado (sustituto si lo hay), no al original. La comparaci√≥n hist√≥rica busca el √∫ltimo registro del `exercise_id` real (ADR D-06, HU-07). Sustituciones son transparentes ‚Äî no requieren l√≥gica condicional.

8. **Simplificaci√≥n deliberada de la detecci√≥n de regresi√≥n por repeticiones (CA-10.04 vs RF29).** CA-10.04 dice *"disminuy√≥ las repeticiones"* sin especificar per-serie. RF29 (scoped a HU-12) dice *"las repeticiones caen en ‚â• 2 de las 4 series"* ‚Äî un criterio per-serie m√°s estricto. HU-10 usa `totalReps` (comparaci√≥n de suma) porque: (a) CA-10.04 no exige per-serie, (b) es computacionalmente m√°s simple, (c) cubre la mayor√≠a de los casos. **Frontera con HU-12:** Los CAs de HU-12 (CA-12.01/02/03) usan el verbo *"clasifica"*, lo que sugiere que HU-12 podr√≠a reevaluar la regresi√≥n con criterio per-serie m√°s estricto. HU-10 no pretende reemplazar la detecci√≥n de HU-12 ‚Äî solo persiste una clasificaci√≥n base en `session_exercise.progression_classification`. Cuando HU-12 se analice, deber√° definir expl√≠citamente si: (a) consume el flag `REGRESSION` de HU-10 para conteo de fatiga acumulada (CA-12.04), o (b) reclasifica independientemente con l√≥gica per-serie. En caso (b), puede haber ejercicios donde HU-10 clasifica `MAINTENANCE` (total reps subi√≥) pero HU-12 detecta regresi√≥n per-serie (reps cayeron en ‚â•2 series individuales) ‚Äî el an√°lisis de HU-12 deber√° resolver este conflicto.

9. **El conteo de meseta es global por ejercicio, no por versi√≥n de m√≥dulo.** MDS ¬ß6-A R3 dice *"en la misma versi√≥n del m√≥dulo"*, pero RF34, Modelo de Datos ¬ß3.13 y ADR D-06 omiten esta restricci√≥n. La decisi√≥n de implementaci√≥n sigue el Modelo de Datos (columna √∫nica `sessions_without_progression` sin partici√≥n por versi√≥n) y RF34. Justificaci√≥n: un ejercicio que no progresa durante 3 sesiones indica meseta independientemente de qu√© versi√≥n del m√≥dulo se ejecut√≥ ‚Äî el est√≠mulo diferente de cada versi√≥n deber√≠a producir progreso si no hay meseta real. **Frontera con HU-14:** Los CAs de HU-14 (CA-14.01, CA-14.08) usan *"marca el ejercicio"* y *"el estado cambia de 'En Progresi√≥n' a 'En Meseta'"*, sugiriendo que HU-14 realiza la transici√≥n. Sin embargo, el Modelo de Datos ¬ß3.13 paso 3 ubica esta transici√≥n en la l√≥gica de cierre de sesi√≥n (HU-10). **HU-10 transiciona el estado; HU-14 emite alertas y an√°lisis causal.** El verbo *"marca"* en HU-14 se interpreta como *"detecta y alerta"*, no como *"cambia estado"*. **Continuidad del contador:** `sessions_without_progression` NO tiene cap en 3 ‚Äî sigue increment√°ndose (4, 5, 6...) para soportar la l√≥gica de acci√≥n escalonada de HU-15 (CA-15.01: sesi√≥n 4, CA-15.02: sesi√≥n 6). El c√≥digo no guarda `IN_PLATEAU` en `resolveNewProgressionState`, por lo que el ejercicio en meseta sigue acumulando sesiones sin progresi√≥n.

### Historias Relacionadas

**Predecesoras (datos que HU-10 consume):**

- HU-05: Cre√≥ `ExerciseProgressionEntity` con `status`, `prescribedLoadKg`, `sessionsWithoutProgression`. Cre√≥ `SessionExerciseEntity` con `progressionClassification`. Proporcion√≥ `RotationStateDao.update()`.
- HU-06: Persisti√≥ datos de `exercise_set` (peso, reps, RIR) que HU-10 compara. `registerSet()` crea `ExerciseProgressionEntity` con `insertIfNotExists()`.
- HU-07: Sustituciones apuntan `exercise_id` al ejercicio real ejecutado ‚Äî transparente para la comparaci√≥n.
- HU-08: Defini√≥ CAs de progresi√≥n de bodyweight (CA-08.02 ‚Üí CA-10.10) e isom√©tricos (CA-08.06 ‚Üí CA-10.11, CA-08.07 ‚Üí CA-10.12). Infraestructura de datos ya implementada.
- HU-09: Proporcion√≥ `closeSession()` con el punto de extensi√≥n para progression evaluation. Transacci√≥n at√≥mica.

**Sucesoras (dependen de HU-10):**

- HU-11: Doble Umbral ‚Äî usar√° la clasificaci√≥n de HU-10 y extender√° `evaluateProgression()` para calcular `prescribed_load_kg`. Usar√° `moduleCode` de `SessionExerciseForProgression`.
- HU-12: Detecci√≥n de regresi√≥n/fatiga ‚Äî puede consumir clasificaciones `REGRESSION` de HU-10 para detectar fatiga acumulada (‚â• 50% del m√≥dulo), o reevaluar con criterio per-serie (ver Nota T√©cnica 8). Se integra despu√©s de HU-10 en el flujo de cierre.
- HU-13: E5 (Resumen Post-Sesi√≥n) ‚Äî leer√° `session_exercise.progression_classification` para mostrar clasificaci√≥n visual por ejercicio.
- HU-14: Detecci√≥n de meseta ‚Äî emitir√° alertas con an√°lisis causal cuando `exercise_progression.status == IN_PLATEAU` (transici√≥n ya realizada por HU-10).
- HU-15: Recomendaciones escalonadas ‚Äî usar√° `sessions_without_progression` (sesiones 4 y 6) para acciones escalonadas.
- HU-16: Se√±al de descarga ‚Äî usar√° `exercise_progression.status == IN_PLATEAU` y/o clasificaciones `REGRESSION` para evaluar si activar descarga.
- HU-19: Tasa de progresi√≥n ‚Äî contar√° `POSITIVE_PROGRESSION` en `session_exercise.progression_classification` para calcular (sesiones con progresi√≥n / total sesiones).
- HU-23: Historial de ejercicio (F3) ‚Äî leer√° `session_exercise.progression_classification` para mostrar clasificaci√≥n por sesi√≥n.
- HU-24: Detalle de sesi√≥n pasada (F2) ‚Äî leer√° `session_exercise.progression_classification`.

**Consumidoras indirectas:**

- HU-17: Protocolo de descarga ‚Äî establecer√° `exercise_progression.status = IN_DELOAD`. HU-10 ya respeta este estado (no modifica durante deload).
- HU-20: M√©tricas globales ‚Äî usar√° clasificaciones para calcular tasa de progresi√≥n.
- HU-22: KPIs por ejercicio ‚Äî usar√° `sessions_without_progression` y clasificaciones.

### Referencias y Validaci√≥n

**Documentaci√≥n consultada:**

- Modelo de Datos ¬ß2 (Convenciones): "Datos calculados: No se almacenan en base de datos" ‚Äî RIR promedio es derivable.
- Modelo de Datos ¬ß3.11 (`session_exercise`): columna `progression_classification` con CHECK constraint.
- Modelo de Datos ¬ß3.12 (`exercise_set`): campo `reps` almacena repeticiones o segundos.
- Modelo de Datos ¬ß3.13 (`exercise_progression`): m√°quina de estados completa con l√≥gica de actualizaci√≥n.
- MDS ¬ß5.C: Ciclo de vida de progresi√≥n: `NO_HISTORY ‚Üí IN_PROGRESSION ‚áÑ IN_PLATEAU ‚Üí IN_DELOAD ‚Üí IN_PROGRESSION`.
- MDS ¬ß6-A Reglas 1-7: Doble Umbral, Mantenimiento, Meseta, Regresi√≥n, Descarga, Peso Corporal, Isom√©tricos.
- ADR-06: Motor de reglas como Kotlin puro en `domain.rules`.
- ADR D-06: Comparaci√≥n independiente de versi√≥n.
- ADR D-07: Incremento diferenciado por m√≥dulo (preparaci√≥n para HU-11).
- HU-08 an√°lisis: CAs de progresi√≥n redistribuidos a HU-10 (CA-08.02‚Üí10.10, CA-08.06‚Üí10.11, CA-08.07‚Üí10.12).
- HU-09 an√°lisis: Punto de extensi√≥n en `closeSession()`, entre `updateStatus` y `advanceRotation`.
- Arquitectura T√©cnica ¬ß5.2: Naming `{Nombre}Rule` para reglas del motor.
- Requerimientos: RF23, RF24, RF28, RF31, RF32, RF33, RF43.

### Verificaci√≥n Cruzada de CAs

| CA | Estado | Mecanismo | Implementado en |
|---|---|---|---|
| CA-10.01 | üî® Por implementar | `getLastHistoricalSets()` + `classify()` | HU-10 (DAO + Rule) |
| CA-10.02 | üî® Por implementar | `classifyStandard/Bodyweight/Isometric` ‚Üí `POSITIVE_PROGRESSION` | HU-10 (Rule) |
| CA-10.03 | üî® Por implementar | `else` fallthrough ‚Üí `MAINTENANCE` | HU-10 (Rule) |
| CA-10.04 | üî® Por implementar | Peso ‚Üì / Reps ‚Üì / RIR ‚Üë ‚â• 1.5 ‚Üí `REGRESSION` | HU-10 (Rule) |
| CA-10.05 | ‚è≥ Parcial | `avgRir` in-memory (no almacenado ‚Äî Modelo de Datos ¬ß2) | HU-10 (c√°lculo); consulta futura por KPIs |
| CA-10.06 | üî® Por implementar | `avgRir` calcula con sets disponibles; sesi√≥n `INCOMPLETE` indica parcial | HU-10 (Rule) |
| CA-10.07 | üî® Por implementar | `previous == null ‚Üí return null`; status queda `NO_HISTORY` | HU-10 (Rule) |
| CA-10.08 | üî® Por implementar | `resolveNewProgressionState()` ‚Äî m√°quina de estados | HU-10 (Rule + Repository) |
| CA-10.09 | üî® Por implementar | `updateProgressionClassification()` en `session_exercise` | HU-10 (DAO) |
| CA-10.10 | üî® Por implementar | `classifyBodyweight()` ‚Äî `totalReps` | HU-10 (Rule) |
| CA-10.11 | üî® Por implementar | `classifyIsometric()` ‚Äî `totalReps` (= segundos) | HU-10 (Rule) |
| CA-10.12 | üî® Por implementar | `isIsometricMastered()` ‚Üí `MASTERED` | HU-10 (Rule) |

### Hitos de implementaci√≥n

| # | Entregable | Archivos | CAs |
|---|---|---|---|
| 1 | Modelos de dominio ‚Äî `ProgressionClassification` enum + `ExerciseSessionData` / `SetData` | `ProgressionClassification.kt`, `ExerciseSessionData.kt` | ‚Äî (infraestructura) |
| 2 | Regla pura ‚Äî `ProgressionClassificationRule` + tests unitarios exhaustivos | `ProgressionClassificationRule.kt`, `ProgressionClassificationRuleTest.kt` | CA-10.02, CA-10.03, CA-10.04, CA-10.07, CA-10.08, CA-10.10, CA-10.11, CA-10.12 |
| 3 | Queries DAO ‚Äî DTOs + queries en `SessionExerciseDao` y `ExerciseSetDao` | `SessionExerciseDao.kt`, `ExerciseSetDao.kt` | CA-10.01, CA-10.09 |
| 4 | Integraci√≥n ‚Äî `evaluateProgression()` en `SessionRepositoryImpl.closeSession()` | `SessionRepositoryImpl.kt` | CA-10.01 a CA-10.12 (todos) |
---

## Refinamiento T√©cnico (Developer)

<!-- ============================================================================ -->
<!-- SECCI√ìN AGREGADA POR: Workflow refinamiento-tecnico                         -->
<!-- ETAPA: Refinamiento T√©cnico                                                  -->
<!-- RESPONSABLE: Developer                                                       -->
<!-- BASE: An√°lisis Arquitect√≥nico (Arquitecto) - Ver secci√≥n arriba             -->
<!-- FECHA: 2026-02-15                                                            -->
<!-- ESTADO: Refinado (Developer) - Basado en An√°lisis Arquitect√≥nico             -->
<!-- ============================================================================ -->

### Consideraciones Generales

**Basado en an√°lisis arquitect√≥nico:**
An√°lisis Arquitect√≥nico de HU-10 con 10 decisiones de dise√±o, 4 hitos de implementaci√≥n, 7 componentes (4 nuevos + 3 modificados). Hallazgos principales: (1) HU-10 es l√≥gica pura de backend ‚Äî no hay UI, ViewModel ni pantalla nueva. (2) La clasificaci√≥n es funci√≥n pura en `domain/rules/ProgressionClassificationRule.kt` (ADR-06). (3) RIR promedio NO se almacena ‚Äî derivable on-demand (Modelo de Datos ¬ß2). (4) Comparaci√≥n independiente de versi√≥n (ADR D-06). (5) 3 tipos de ejercicio con l√≥gica diferenciada: est√°ndar, peso corporal, isom√©trico. (6) `evaluateProgression()` se inserta dentro de la transacci√≥n existente de `closeSession()` (HU-09 punto de extensi√≥n). (7) `MASTERED` es estado terminal para isom√©tricos. (8) El paquete `domain/rules/` se crea por primera vez con esta HU.

**Nivel de complejidad:**
MEDIA-ALTA ‚Äî HU-10 toca 7 archivos (4 nuevos + 3 modificados) pero la complejidad reside en la regla pura con 3 clasificadores diferenciados (est√°ndar/bodyweight/isom√©trico), una m√°quina de estados de progresi√≥n con 5 estados, y ~30 escenarios de test combinatorios. La integraci√≥n es directa (1 m√©todo privado dentro de transacci√≥n existente), pero la cobertura de testing es extensiva. No hay componentes UI.

**Riesgos t√©cnicos conocidos:**

1. **N+1 queries en `evaluateProgression()`:** El m√©todo ejecuta 2-3 queries por ejercicio √ó ~11-16 ejercicios = ~45 queries dentro de la transacci√≥n. Para SQLite local con √≠ndices, esto es < 50ms. No se justifica optimizaci√≥n batch para este volumen (Nota T√©cnica 1 del arquitecto). El dise√±o prioriza claridad sobre optimizaci√≥n prematura.
2. **`.first()` en `ExerciseProgressionDao.getByExerciseId()`:** Este m√©todo retorna `Flow<ExerciseProgressionEntity?>`. Dentro de la transacci√≥n se invoca con `.first()`, mismo patr√≥n ya validado en `startSession()` (L67 SessionRepositoryImpl) y `closeSession()` (L285 rotationStateDao). Room garantiza snapshot transaccional.
3. **Comparaciones de punto flotante:** Pesos kg son `Double`. Diferencias menores que 0.01 Kg podr√≠an causar clasificaciones incorrectas. Mitigado con `WEIGHT_TOLERANCE = 0.01` ‚Äî los incrementos m√≠nimos reales son 1.25 Kg o 2.5 Kg, muy por encima de la tolerancia.

**Patrones y convenciones del equipo (establecidos en HU-01‚ÄîHU-09):**

- C√≥digo fuente en ingl√©s, UI y datos de dominio en espa√±ol (Arquitectura T√©cnica ¬ß5.1)
- Naming: `{Nombre}Rule` para reglas del motor (¬ß5.2, ¬ß2.5) ‚Äî ej: `ProgressionClassificationRule`
- DTOs de DAO como `data class` nombrados con sufijo descriptivo (`SessionExerciseForProgression`, `ExerciseSetData`)
- Funciones puras en `domain/rules/` sin dependencias Android (ADR-06, RNF29)
- Transacciones at√≥micas con `database.withTransaction` ‚Äî ya establecido en `closeSession()` (HU-09)
- Tests unitarios con JUnit 4 + MockK + kotlinx-coroutines-test ‚Äî patr√≥n existente en UseCase tests
- `object` singletons para reglas (patr√≥n `RotationResolver` en `domain/model/`)

**Dependencias nuevas a instalar:**
Ninguna.

**Estrategia de testing:**
JUnit 4 (sin MockK para la regla ‚Äî es funci√≥n pura) | `ProgressionClassificationRuleTest` con ~30 escenarios: classify() √ó 3 tipos √ó (progresi√≥n/mantenimiento/regresi√≥n/sin historial) + isIsometricMastered() √ó (cumple/no cumple) + resolveNewProgressionState() √ó (5 estados √ó clasificaciones) | Foco en la regla pura porque es la pieza con mayor densidad l√≥gica; la integraci√≥n en `evaluateProgression()` se valida manualmente.

### Historias Relacionadas Consultadas

**Implementaciones similares analizadas:**

- HU-09 (CloseSession) ‚Äî Implement√≥ `closeSession()` con transacci√≥n at√≥mica (`updateStatus` + `advanceRotation`). HU-10 extiende esta transacci√≥n insertando `evaluateProgression()` entre el paso 1 (updateStatus) y el paso 3 (advanceRotation). El patr√≥n de m√©todo privado dentro de `SessionRepositoryImpl` ya fue establecido.
- HU-06 (RegisterSet) ‚Äî Cre√≥ `ExerciseProgressionEntity` con `insertIfNotExists()` durante el registro de series. HU-10 lee y actualiza estas entidades (`getByExerciseId().first()` + `update()`). El campo `sessionsWithoutProgression` (HU-06, L18) es el contador que HU-10 incrementa/resetea.
- HU-05 (StartSession) ‚Äî Cre√≥ `SessionExerciseEntity` con `progressionClassification: String? = null` (L52-53). HU-10 escribe sobre esta columna con `updateProgressionClassification()`. Tambi√©n estableci√≥ el patr√≥n de DTOs de DAO (`SessionExerciseWithDetails`, `SessionExerciseForSubstitution`).

**Patrones de c√≥digo reutilizados:**

- `object` singleton con funciones puras: `RotationResolver` (domain/model) ‚Üí `ProgressionClassificationRule` (domain/rules)
- DTO de DAO con `suspend fun`: `SessionExerciseForSubstitution` ‚Üí `SessionExerciseForProgression` (misma convenci√≥n de nombres y estructura)
- M√©todo privado transaccional en `SessionRepositoryImpl`: patr√≥n nuevo pero coherente con la clase (ya tiene 5 m√©todos override, agregar 1 privado)
- `.first()` dentro de `withTransaction`: patr√≥n `startSession()` L67, `closeSession()` L285

**Mejores pr√°cticas aplicadas:**

- Regla pura `ProgressionClassificationRule` testeable sin emulador, mocks, ni coroutines (solo JUnit `@Test` + `assertEquals`)
- `moduleCode` incluido proactivamente en `SessionExerciseForProgression` para HU-11 (costo marginal cero ‚Äî JOIN ya existe)
- Tolerancia de 0.01 Kg para comparaciones de peso ‚Äî absorbe errores de punto flotante sin afectar cambios reales (incremento m√≠nimo 1.25 Kg)
- Separaci√≥n clara: HU-10 clasifica y transiciona estados; HU-14 emite alertas y an√°lisis causal

---

## Tareas de Implementaci√≥n (Developer)

### Fase 1: Domain ‚Äî Modelos de dominio puros

<!-- Basado en Hito #1 del An√°lisis Arquitect√≥nico -->

#### üì¶ Domain Model

- [ ] **Crear `ProgressionClassification` enum** (infraestructura)
  - [ ] Crear archivo: `domain/model/ProgressionClassification.kt`
  - [ ] Enum con 3 valores: `POSITIVE_PROGRESSION`, `MAINTENANCE`, `REGRESSION`
  - [ ] `.name` produce strings exactos para persistencia en `session_exercise.progression_classification`
- [ ] **Crear `ExerciseSessionData` y `SetData`** (infraestructura)
  - [ ] Crear archivo: `domain/model/ExerciseSessionData.kt`
  - [ ] `data class SetData(val weightKg: Double, val reps: Int, val rir: Int)`
  - [ ] `data class ExerciseSessionData(val sets: List<SetData>)` con propiedades derivadas: `setCount`, `avgWeightKg`, `totalReps`, `avgRir`

### Fase 2: Domain ‚Äî Regla pura + tests exhaustivos

<!-- Basado en Hito #2 del An√°lisis Arquitect√≥nico -->

#### üì¶ Domain Rules

- [ ] **Crear `ProgressionClassificationRule`** (AC: 2, 3, 4, 7, 8, 10, 11, 12)
  - [ ] Crear directorio: `domain/rules/` (primer archivo del paquete)
  - [ ] Crear archivo: `domain/rules/ProgressionClassificationRule.kt`
  - [ ] Constantes: `RIR_SIGNIFICANT_RISE = 1.5`, `ISOMETRIC_MASTERED_THRESHOLD = 45`, `PLATEAU_THRESHOLD = 3`, `WEIGHT_TOLERANCE = 0.01`
  - [ ] `fun classify(current, previous, isBodyweight, isIsometric): ProgressionClassification?` ‚Äî dispatcher principal
  - [ ] `private fun classifyStandard(current, previous)` ‚Äî peso promedio + reps totales + RIR
  - [ ] `private fun classifyBodyweight(current, previous)` ‚Äî solo reps totales + RIR
  - [ ] `private fun classifyIsometric(current, previous)` ‚Äî solo segundos totales + RIR
  - [ ] `fun isIsometricMastered(current): Boolean` ‚Äî 4/4 sets ‚â• 45s
  - [ ] `fun resolveNewProgressionState(currentStatus, currentCounter, classification, isIsometric, isMastered): Pair<String, Int>` ‚Äî m√°quina de estados
  - [ ] helpers: `isWeightEqual`, `isWeightHigher`, `isWeightLower` con tolerancia
- [ ] **Test unitario `ProgressionClassificationRuleTest`** (AC: 2, 3, 4, 7, 8, 10, 11, 12)
  - [ ] Crear directorio: `src/test/java/com/estebancoloradogonzalez/tension/domain/rules/`
  - [ ] Crear archivo: `src/test/java/com/estebancoloradogonzalez/tension/domain/rules/ProgressionClassificationRuleTest.kt`
  - [ ] **classifyStandard tests (~8):**
    - [ ] Peso subi√≥ + RIR estable ‚Üí `POSITIVE_PROGRESSION`
    - [ ] Mismo peso + reps subieron + RIR estable ‚Üí `POSITIVE_PROGRESSION`
    - [ ] Peso subi√≥ + RIR subi√≥ ‚â• 1.5 ‚Üí `MAINTENANCE` (no regresi√≥n, el peso est√° mejor)
    - [ ] Mismo peso + mismas reps + RIR estable ‚Üí `MAINTENANCE`
    - [ ] Peso baj√≥ ‚Üí `REGRESSION`
    - [ ] Mismo peso + reps bajaron ‚Üí `REGRESSION`
    - [ ] Mismo peso + RIR subi√≥ ‚â• 1.5 ‚Üí `REGRESSION`
    - [ ] Peso subi√≥ + reps bajaron + RIR estable ‚Üí `POSITIVE_PROGRESSION` (peso domina)
  - [ ] **classifyBodyweight tests (~5):**
    - [ ] Reps totales subieron + RIR estable ‚Üí `POSITIVE_PROGRESSION`
    - [ ] Reps totales iguales + RIR estable ‚Üí `MAINTENANCE`
    - [ ] Reps totales bajaron ‚Üí `REGRESSION`
    - [ ] RIR subi√≥ ‚â• 1.5 + reps iguales ‚Üí `REGRESSION`
    - [ ] Reps subieron + RIR subi√≥ ‚â• 1.5 ‚Üí `MAINTENANCE` (RIR penaliza pese a m√°s reps)
  - [ ] **classifyIsometric tests (~5):**
    - [ ] Segundos subieron + RIR estable ‚Üí `POSITIVE_PROGRESSION`
    - [ ] Segundos iguales + RIR estable ‚Üí `MAINTENANCE`
    - [ ] Segundos bajaron ‚Üí `REGRESSION`
    - [ ] RIR subi√≥ ‚â• 1.5 + segundos iguales ‚Üí `REGRESSION`
    - [ ] Segundos subieron + RIR subi√≥ ‚â• 1.5 ‚Üí `MAINTENANCE` (RIR penaliza pese a m√°s segundos)
  - [ ] **classify dispatcher tests (~4):**
    - [ ] `previous == null` ‚Üí `null` (CA-10.07)
    - [ ] `previous.sets` vac√≠o ‚Üí `null`
    - [ ] `current.sets` vac√≠o ‚Üí `null`
    - [ ] Prioridad: isIsometric > isBodyweight > est√°ndar
  - [ ] **isIsometricMastered tests (~3):**
    - [ ] 4 sets todos ‚â• 45s ‚Üí `true`
    - [ ] 4 sets con 1 < 45s ‚Üí `false`
    - [ ] 3 sets (incompleto) ‚Üí `false`
  - [ ] **resolveNewProgressionState tests (~8):**
    - [ ] Isom√©trico mastered ‚Üí `MASTERED`, counter 0
    - [ ] `null` classification ‚Üí no change (CA-10.07)
    - [ ] `IN_DELOAD` + any classification ‚Üí no change
    - [ ] `MASTERED` + any classification ‚Üí no change (terminal)
    - [ ] `POSITIVE_PROGRESSION` ‚Üí `IN_PROGRESSION`, counter 0
    - [ ] `NO_HISTORY` + `MAINTENANCE` ‚Üí `IN_PROGRESSION`, counter 1 (primera transici√≥n)
    - [ ] `IN_PROGRESSION` + `MAINTENANCE` √ó 2 ‚Üí counter 2, status unchanged
    - [ ] `IN_PROGRESSION` + `REGRESSION` √ó 3 ‚Üí `IN_PLATEAU`, counter 3

### Fase 3: Data ‚Äî DAO queries + DTOs

<!-- Basado en Hito #3 del An√°lisis Arquitect√≥nico -->

#### üì¶ Data Layer

- [ ] **Agregar DTO + queries en `SessionExerciseDao`** (AC: 1, 9)
  - [ ] Agregar `data class SessionExerciseForProgression(sessionExerciseId, exerciseId, isBodyweight, isIsometric, moduleCode)` en `data/local/dao/SessionExerciseDao.kt`
  - [ ] Agregar `suspend fun getSessionExercisesForProgression(sessionId: Long): List<SessionExerciseForProgression>` ‚Äî query JOIN session_exercise + exercise
  - [ ] Agregar `suspend fun updateProgressionClassification(sessionExerciseId: Long, classification: String?)` ‚Äî UPDATE session_exercise SET progression_classification
- [ ] **Agregar DTO + queries en `ExerciseSetDao`** (AC: 1)
  - [ ] Agregar `data class ExerciseSetData(weightKg, reps, rir)` en `data/local/dao/ExerciseSetDao.kt`
  - [ ] Agregar `suspend fun getSetsForSessionExercise(sessionExerciseId: Long): List<ExerciseSetData>` ‚Äî SELECT weight_kg, reps, rir ORDER BY set_number
  - [ ] Agregar `suspend fun getLastHistoricalSets(exerciseId: Long, currentSessionId: Long): List<ExerciseSetData>` ‚Äî subconsulta: √∫ltimo session_exercise del mismo exercise_id en sesi√≥n cerrada, ORDER BY date DESC, id DESC LIMIT 1

### Fase 4: Data ‚Äî Integraci√≥n en closeSession()

<!-- Basado en Hito #4 del An√°lisis Arquitect√≥nico -->

#### üì¶ Repository

- [ ] **Integrar `evaluateProgression()` en `SessionRepositoryImpl`** (AC: 1-12, todos)
  - [ ] Agregar imports: `ExerciseSessionData`, `SetData`, `ProgressionClassification`, `ProgressionClassificationRule` - Archivo: `data/repository/SessionRepositoryImpl.kt`
  - [ ] Agregar m√©todo `private suspend fun evaluateProgression(sessionId: Long)` despu√©s de `closeSession()`
  - [ ] L√≥gica: iterar ejercicios ‚Üí fetch sets actuales ‚Üí fetch sets hist√≥ricos ‚Üí mapear a `ExerciseSessionData` ‚Üí `classify()` ‚Üí `updateProgressionClassification()` ‚Üí `isIsometricMastered()` ‚Üí `resolveNewProgressionState()` ‚Üí `exerciseProgressionDao.update()`
  - [ ] Insertar llamada `evaluateProgression(sessionId)` en `closeSession()` entre `sessionDao.updateStatus()` y `rotationStateDao.getRotationState()` (despu√©s del paso 1, antes del paso 3)

### Fase N: QA y Deployment

- [ ] **Ejecutar Agente Peer Review** (MANUAL)
- [ ] **Resolver incidentes del Peer Review** (MANUAL, condicional)
- [ ] **Crear Pull Request** (MANUAL)
- [ ] **Ejecutar pipeline deployment DEV** (MANUAL)
- [ ] **Dise√±ar set de pruebas manuales** (MANUAL)
- [ ] **Ejecutar pruebas manuales** (MANUAL)

---

**Notas sobre vinculaci√≥n con Criterios de Aceptaci√≥n:**

- CA-10.01 ‚Üí Fase 3 (`getLastHistoricalSets()` independiente de versi√≥n, ADR D-06) + Fase 4 (`evaluateProgression()` invoca `classify()`)
- CA-10.02 ‚Üí Fase 2 (`classifyStandard/Bodyweight/Isometric` ‚Üí `POSITIVE_PROGRESSION`) + tests
- CA-10.03 ‚Üí Fase 2 (`else` fallthrough ‚Üí `MAINTENANCE`) + tests
- CA-10.04 ‚Üí Fase 2 (peso ‚Üì / reps ‚Üì / RIR ‚Üë ‚â• 1.5 ‚Üí `REGRESSION`) + tests
- CA-10.05 ‚Üí Fase 1 (`ExerciseSessionData.avgRir` derivada in-memory) + Fase 2 (usada en comparaci√≥n) ‚Äî NO almacenado (Modelo de Datos ¬ß2)
- CA-10.06 ‚Üí Fase 1 (`avgRir` calcula con sets disponibles ‚Äî `sum/size` opera con cualquier cantidad) + la sesi√≥n `INCOMPLETE` indica datos parciales
- CA-10.07 ‚Üí Fase 2 (`previous == null ‚Üí return null`) + Fase 2 (`resolveNewProgressionState` con `null` ‚Üí no change) + tests
- CA-10.08 ‚Üí Fase 2 (`resolveNewProgressionState()` ‚Äî m√°quina de estados completa: NO_HISTORY‚ÜíIN_PROGRESSION, counter++, ‚â•3‚ÜíIN_PLATEAU, IN_DELOAD/MASTERED guards) + tests
- CA-10.09 ‚Üí Fase 3 (`updateProgressionClassification()` persiste en `session_exercise`) + Fase 4 (invocaci√≥n dentro de loop)
- CA-10.10 ‚Üí Fase 2 (`classifyBodyweight()` ‚Äî `totalReps` sin Doble Umbral) + tests
- CA-10.11 ‚Üí Fase 2 (`classifyIsometric()` ‚Äî `totalReps` = segundos) + tests
- CA-10.12 ‚Üí Fase 2 (`isIsometricMastered()` ‚Äî 4/4 ‚â• 45s ‚Üí `MASTERED`) + Fase 2 (`resolveNewProgressionState` prioriza mastered) + tests

<!-- AUDITOR√çA PROFUNDA (2026-02-15):

=== SCOPE ===
7 docs arquitectura + 5 docs business + 32 HUs + Mapa de Historias + 10 archivos de c√≥digo fuente verificados.

=== DOCUMENTOS CRUZADOS ===
Arquitectura: Modelo de Datos ¬ß2 (datos calculados no almacenados ‚Äî avgRir no persistido ‚úÖ), ¬ß3.11 (session_exercise.progression_classification CHECK: POSITIVE_PROGRESSION/MAINTENANCE/REGRESSION/NULL ‚Äî enum .name coincide ‚úÖ), ¬ß3.12 (exercise_set.reps = repeticiones o segundos seg√∫n tipo ‚úÖ), ¬ß3.13 (exercise_progression: m√°quina 5 estados, l√≥gica 6 pasos ‚Äî pasos 1-5 en HU-10, paso 6 prescribedLoadKg diferido a HU-11 ‚úÖ), ADR-06 (reglas puras en domain.rules sin dependencias Android ‚úÖ), ADR D-06 (comparaci√≥n independiente de versi√≥n ‚Äî query sin filtro module_version_id ‚úÖ), Arquitectura T√©cnica ¬ß2.5 (Motor de Reglas R1-R7 como funciones puras ‚úÖ), ¬ß5.2 ({Nombre}Rule naming convention ‚úÖ), Wireframes E5 (clasificaci√≥n visual por ejercicio ‚Äî consumidor HU-13 ‚úÖ), Mapa de Navegaci√≥n ¬ß5 (HU-10 "representaci√≥n indirecta" en E5/F2/F3 ‚úÖ).
Business: Requerimientos RF23 (comparar √∫ltimo registro, independiente versi√≥n ‚úÖ), RF24 (clasificar PP/M/R, RIR‚â•1.5 ‚úÖ), RF28 (RIR promedio ‚Äî calculado in-memory, no persistido per MdD¬ß2 ‚úÖ), RF29 (per-series ‚â•2 series ‚Äî scoped a HU-12, documentado Nota 8 ‚úÖ), RF31 (bodyweight por totalReps, sin Doble Umbral ‚úÖ), RF32 (isom√©tricos por segundos en campo reps ‚úÖ), RF33 (dominado 4√ó‚â•45s ‚Üí MASTERED ‚úÖ), RF34 (meseta 3 sesiones ‚Äî global por exercise_id, no por versi√≥n per ADR D-06 y MdD¬ß3.13 ‚úÖ), RF43 (estado persistente lifecycle completo ‚úÖ).
MDS: ¬ß5.C (ciclo vida: NO_HISTORY‚ÜíIN_PROGRESSION‚áÑIN_PLATEAU‚ÜíIN_DELOAD‚ÜíIN_PROGRESSION ‚úÖ), ¬ß6-A R3 (meseta "en la misma versi√≥n" ‚Äî divergencia deliberada, se sigue RF34/MdD¬ß3.13 global por ejercicio, Nota 9 ‚úÖ), R4 (regresi√≥n "‚â•2 series" ‚Äî simplificado a totalReps, per-series diferido a HU-12, Nota 8 ‚úÖ), R6 (bodyweight por repeticiones totales ‚úÖ), R7 (isom√©tricos por segundos, dominado 4√ó‚â•45s ‚úÖ).

=== HUs CRUZADAS (17 con referencias) ===
Predecesoras (5): HU-05 (14 refs: ExerciseProgressionEntity infra L120-125, progressionClassification column L113/L116, ExerciseProgressionDao.getByExerciseId/update L211/L213, prescribed_load_kg L121, declarada sucesor L719/L790/L835 ‚úÖ), HU-06 (3 refs: insertIfNotExists crea ExerciseProgressionEntity L151/L153, CA redistribution L451 ‚úÖ), HU-07 (6 refs: progression_classification protegida en updateExerciseId L136/L694, sustituci√≥n transparente para comparaci√≥n L475/L558/L645 ‚úÖ), HU-08 (19 refs: CA-08.02‚ÜíCA-10.10, CA-08.06‚ÜíCA-10.11, CA-08.07‚ÜíCA-10.12, redistribuci√≥n confirmada en L7/L13/L65/L113-137, GAP L185 resuelto con CA-10.10/11/12, infraestructura MASTERED L157/L199/L218/L302/L324/L334/L379 ‚úÖ), HU-09 (3 refs: punto extensi√≥n en transacci√≥n closeSession() L474/L488, ExerciseProgressionDao disponible L462 ‚úÖ).
Sucesoras (9): HU-11 (2 refs: CA-10.10 exclusi√≥n Doble Umbral L59, moduleCode proactivo en DTO ‚úÖ), HU-12 (8 refs: regresi√≥n per-series L13-L29, fatiga acumulada L34, boundary con HU-10 Nota 8 ‚úÖ), HU-13 (6 refs: E5 muestra clasificaci√≥n L9/L31/L35/L41/L45/L53 ‚úÖ), HU-14 (5 refs: meseta 3 sesiones L13/L17, estado En Meseta L29/L53/L59, boundary Nota 9 ‚úÖ), HU-15 (4 refs: sesi√≥n 4/6 sin progreso L13/L19/L27/L29, counter sin cap ‚úÖ), HU-16 (4 refs: regresi√≥n/meseta como triggers L9/L17/L23/L35 ‚úÖ), HU-19 (3 refs: Tasa Progresi√≥n L13/L16/L41 ‚úÖ), HU-23 (1 ref: clasificaci√≥n en historial L17 ‚úÖ), HU-24 (1 ref: clasificaci√≥n en detalle sesi√≥n L23 ‚úÖ).
Indirectas (3): HU-17 (3 refs: deload L9/L15/L29, IN_DELOAD guard en resolveNewProgressionState ‚úÖ), HU-20 (0 refs directas ‚Äî consumidor indirecto via HU-19 ‚úÖ), HU-22 (3 refs: tendencia progresi√≥n L1/L17/L23 ‚Äî consumidor indirecto ‚úÖ).
Sin referencias (14): HU-01, HU-02, HU-03, HU-04, HU-18, HU-21, HU-25-HU-32 ‚Äî confirmado 0 matches ‚úÖ.

=== C√ìDIGO VERIFICADO (10 archivos) ===
Modificados (3): SessionExerciseDao.kt (132 l√≠neas ‚Äî DTOs existentes SessionExerciseWithDetails/SetExerciseInfo/SessionExerciseForSubstitution como patrones, moduleCode ya existe en SessionExerciseForSubstitution L110 para validar patr√≥n del nuevo DTO ‚úÖ), ExerciseSetDao.kt (34 l√≠neas ‚Äî queries suspendidas simples como patr√≥n, ExerciseSetEntity schema confirmado: weight_kg REAL, reps INTEGER, rir INTEGER ‚úÖ), SessionRepositoryImpl.kt (305 l√≠neas ‚Äî closeSession() L268-305 con extensi√≥n point entre updateStatus L281 y rotationStateDao L283, imports de ExerciseProgressionDao/ExerciseSetDao ya presentes L4-10, constructor tiene todos los DAOs inyectados L33-41 ‚úÖ).
Infraestructura (5): ExerciseProgressionDao.kt (26 l√≠neas ‚Äî getByExerciseId() retorna Flow<Entity?> necesita .first(), update() suspendida, insertIfNotExists() con IGNORE ‚úÖ), ExerciseProgressionEntity.kt (33 l√≠neas ‚Äî PK=exercise_id, status default "NO_HISTORY", sessionsWithoutProgression default 0, prescribedLoadKg nullable ‚úÖ), SessionExerciseEntity.kt (55 l√≠neas ‚Äî progressionClassification: String? = null en L52-53, UNIQUE(session_id, exercise_id) L36 ‚úÖ), ExerciseEntity.kt (module_code L39, is_bodyweight L45, is_isometric L48 ‚Äî todas las columnas del DTO join confirmadas ‚úÖ), SessionEntity.kt (status default "IN_PROGRESS" L40, date String L37-38 ‚Äî getLastHistoricalSets filter/order confirmado ‚úÖ).
Referencia (2): RotationResolver.kt (40 l√≠neas ‚Äî object singleton patr√≥n exacto para ProgressionClassificationRule ‚úÖ), ExerciseSetEntity.kt (weight_kg REAL, reps INTEGER, rir INTEGER, set_number INTEGER CHECK 1-4 ‚úÖ).
Nuevos (4 ‚Äî confirmado que NO existen): ProgressionClassification.kt ‚úÖ, ExerciseSessionData.kt ‚úÖ, ProgressionClassificationRule.kt ‚úÖ, ProgressionClassificationRuleTest.kt ‚úÖ. domain/rules/ directorio no existe a√∫n ‚úÖ.

=== VERIFICACI√ìN L√ìGICA EXHAUSTIVA ===
classifyStandard: 18/18 escenarios verificados vs CAs (3 pesos √ó 3 reps √ó 2 RIR). Hallazgos notables: Row#8 (Equal weight + reps UP + RIR‚â•1.5 ‚Üí REGRESSION) correcto per CA-10.04 literal "RIR subi√≥ ‚â•1.5 con misma carga" sin excepci√≥n por reps. Row#17 (Higher weight + reps DOWN + RIR stable ‚Üí POSITIVE_PROGRESSION) correcto per CA-10.02 "y/o" hace peso solo suficiente. Row#14/16/18 (Higher weight + RIR‚â•1.5 ‚Üí MAINTENANCE) correcto ‚Äî CA-10.04 condiciona RIR a "misma carga", peso mayor no aplica.
classifyBodyweight: 6/6 escenarios verificados. Row#2 (reps UP + RIR‚â•1.5 ‚Üí MAINTENANCE) correcto ‚Äî RIR inestable penaliza pese a mejora de reps.
classifyIsometric: 6/6 escenarios verificados. Estructuralmente id√©ntico a bodyweight. Row#2 (seconds UP + RIR‚â•1.5 ‚Üí MAINTENANCE) correcto.
isIsometricMastered: 7 edge cases verificados (4√ó45s true, 4√ó44s false, 3√ó45s false, 0 sets false).
classify() dispatcher: Prioridad isIsometric > isBodyweight > est√°ndar correcta ‚Äî is_isometric=1 implica is_bodyweight=1 en seed data.
resolveNewProgressionState: 18 combinaciones status√óclassification verificadas. Traces: NO_HISTORY null‚Üísin cambio ‚úÖ, 3-session plateau path (sessions 2,3,4 ‚Üí counter 1,2,3 ‚Üí IN_PLATEAU) ‚úÖ, recovery IN_PLATEAU+PP‚ÜíIN_PROGRESSION counter=0 ‚úÖ, counter sin cap para HU-15 (4,5,6...) ‚úÖ, MASTERED terminal ‚úÖ, IN_DELOAD guard ‚úÖ.
avgWeightKg como m√©trica: Correcto ‚Äî sistema prescribe peso fijo por ejercicio (Doble Umbral HU-11), avg = peso real en operaci√≥n normal. Tolerancia 0.01 absorbe errores FP, incremento m√≠nimo 1.25Kg.
ExerciseProgressionEntity null safety: evaluateProgression() procesa solo ejercicios con sets ‚Üí HU-06 insertIfNotExists() garantiza existencia ‚Üí fallback ?: new entity es defensivo, update() ser√≠a no-op si triggerea ‚Üí aceptable.

=== CHECKLIST FORMAL (23 items) ===
1-DoD: dod-pivots.md no existe (N/A), Phase N tasks todas MANUAL ‚úÖ.
2-Archivos: 3 modificados existen ‚úÖ, 4 nuevos marcados "Crear archivo" ‚úÖ, patrones coinciden ‚úÖ, dependencias existentes ‚úÖ, extensi√≥n point existe ‚úÖ.
3-Testing: JUnit 4.13.2 en libs.versions.toml ‚úÖ, test path convenci√≥n ‚úÖ, no E2E ‚úÖ.
4-Arquitectura: 10 decisiones consumidas ‚úÖ, 4 fases = 4 hitos ‚úÖ, est√°ndares incorporados ‚úÖ.
5-Eficiencia: N+1 justificado <50ms ‚úÖ, sin integraciones externas (N/A) ‚úÖ.
6-Completitud: 12 CAs mapeadas ‚úÖ, fases completas ‚úÖ, archivos espec√≠ficos ‚úÖ, complejidad justificada ‚úÖ, riesgos documentados ‚úÖ.
7-Fallos: ninguno detectado ‚úÖ.

=== CONTRADICCIONES DOCUMENTALES (3 analizadas) ===
C1-BAJA: MDS R3 "misma versi√≥n del m√≥dulo" vs RF34 "3 sesiones consecutivas" sin versi√≥n vs MdD¬ß3.13 contador global. Divergencia DELIBERADA documentada en Nota 9. Se sigue RF34 + MdD¬ß3.13. ‚úÖ
C2-BAJA: RF28 "almacenarlo" vs MdD¬ß2 "no se almacenan datos calculados". Resuelto como CA-09.04 (tonelaje) ‚Äî avgRir in-memory, derivable por query. ‚úÖ
C3-MEDIA: CA-10.04 totalReps vs RF29/MDS R4 per-series "‚â•2 series". Boundary documentado en Nota 8, per-series diferido a HU-12. Pregunta abierta: ¬øHU-12 reclasifica o consume? Correctamente diferido al an√°lisis de HU-12. ‚úÖ

=== CORRECCIONES APLICADAS ===
1. Test bodyweight: "reps‚Üë + RIR‚Üë‚â•1.5 ‚Üí POSITIVE_PROGRESSION" corregido a "‚Üí MAINTENANCE (RIR penaliza pese a m√°s reps)". C√≥digo classifyBodyweight retorna MAINTENANCE cuando rirRise‚â•1.5, condici√≥n repsDiff>0 requiere rirRise<1.5 para PP.
2. Test isometric: "segundos‚Üë + RIR‚Üë‚â•1.5 ‚Üí POSITIVE_PROGRESSION" corregido a "‚Üí MAINTENANCE (RIR penaliza pese a m√°s segundos)". Misma l√≥gica que bodyweight.

=== RESULTADO FINAL ===
0 HIGH, 0 MEDIUM (1 MEDIUM corregido pre-auditor√≠a), 1 LOW (boundary HU-12 ‚Äî no requiere acci√≥n, correctamente diferido), 0 INFO.
Totales verificados: 32 HUs, 7 RFs, 4 reglas MDS, 12 CAs, 30 escenarios de clasificaci√≥n, 18 transiciones de estado, 10 archivos de c√≥digo, 23 items de checklist.
Refinamiento t√©cnico APROBADO. -->
