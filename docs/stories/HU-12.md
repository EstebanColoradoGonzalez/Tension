# HU-12 ‚Äî Motor de Detecci√≥n: Regresi√≥n, Meseta y Necesidad de Descarga

## Requisitos relacionados

RF29, RF30, RF34, RF35, RF36, RF37, RNF05

## Descripci√≥n

Como ejecutante, quiero que el sistema detecte autom√°ticamente regresiones en mis ejercicios, identifique fatiga acumulada del m√≥dulo, diagnostique mesetas con an√°lisis causal, me recomiende acciones correctivas escalonadas y se√±ale cuando un m√≥dulo completo necesita descarga, para tener un diagn√≥stico integral y objetivo de mi estado de entrenamiento que me permita tomar decisiones informadas antes de que la acumulaci√≥n de fatiga comprometa mi progreso.

## Historias originales consolidadas

Esta historia consolida las siguientes historias del dise√±o original, que forman una cadena de decisi√≥n inseparable (detectar ‚Üí diagnosticar ‚Üí prescribir ‚Üí escalar):

- **HU-12 original** ‚Äî Detectar regresi√≥n y fatiga acumulada (RF29, RF30)
- **HU-14 original** ‚Äî Detectar y alertar meseta en ejercicios (RF34, RF35)
- **HU-15 original** ‚Äî Recomendar acciones correctivas escalonadas ante meseta (RF36)
- **HU-16 original** ‚Äî Detectar necesidad de descarga por m√≥dulo (RF37)

---

## Criterios de Aceptaci√≥n

### Bloque A ‚Äî Detecci√≥n de Regresi√≥n (RF29)

#### CA-12.01 ‚Äî Detecci√≥n de regresi√≥n por ca√≠da de repeticiones

**Dado que** el sistema compara un ejercicio contra su √∫ltimo registro hist√≥rico al cerrar una sesi√≥n,
**cuando** detecta que el peso utilizado es igual al de la sesi√≥n anterior pero las repeticiones cayeron en ‚â• 2 de las 4 series,
**entonces** clasifica al ejercicio con "Regresi√≥n" para esta sesi√≥n.

#### CA-12.02 ‚Äî Detecci√≥n de regresi√≥n por aumento de RIR

**Dado que** el sistema compara un ejercicio contra su √∫ltimo registro hist√≥rico al cerrar una sesi√≥n,
**cuando** detecta que la carga es la misma, las repeticiones son similares a la sesi√≥n anterior, pero el RIR promedio subi√≥ en ‚â• 1.5 puntos,
**entonces** clasifica al ejercicio con "Regresi√≥n" para esta sesi√≥n, interpretando que el ejecutante necesit√≥ m√°s esfuerzo percibido para mantener el mismo rendimiento.

#### CA-12.03 ‚Äî Regresi√≥n por ca√≠da de carga

**Dado que** el sistema compara un ejercicio contra su √∫ltimo registro hist√≥rico,
**cuando** detecta que el peso utilizado es menor al de la sesi√≥n anterior,
**entonces** clasifica al ejercicio con "Regresi√≥n" para esta sesi√≥n.

### Bloque B ‚Äî Detecci√≥n de Fatiga Acumulada del M√≥dulo (RF30)

#### CA-12.04 ‚Äî Detecci√≥n de fatiga acumulada del m√≥dulo

**Dado que** el sistema ha clasificado la progresi√≥n de todos los ejercicios registrados en la sesi√≥n,
**cuando** identifica regresi√≥n simult√°nea en ‚â• 50% de los ejercicios de esa sesi√≥n,
**entonces** detecta y registra "Fatiga acumulada del m√≥dulo" para el m√≥dulo de la sesi√≥n.

#### CA-12.05 ‚Äî Umbral del 50% calculado sobre ejercicios registrados

**Dado que** una sesi√≥n se cierra como Incompleta con menos ejercicios registrados que los prescritos,
**cuando** el sistema eval√∫a fatiga acumulada,
**entonces** calcula el umbral del 50% sobre los ejercicios que efectivamente tienen registros en la sesi√≥n, no sobre el total de ejercicios prescritos.

#### CA-12.06 ‚Äî Registro de las detecciones

**Dado que** el sistema detecta regresi√≥n en un ejercicio o fatiga acumulada en un m√≥dulo,
**cuando** completa el an√°lisis post-sesi√≥n,
**entonces** persiste las detecciones vinculadas a la sesi√≥n para su uso en reglas de decisi√≥n posteriores (mesetas, alertas de descarga, KPIs).

### Bloque C ‚Äî Detecci√≥n de Meseta (RF34, RF35)

#### CA-12.07 ‚Äî Detecci√≥n de meseta por 3 sesiones sin progresi√≥n

**Dado que** el sistema eval√∫a la progresi√≥n de un ejercicio al cerrar una sesi√≥n,
**cuando** detecta que el ejercicio no ha registrado progresi√≥n positiva (ni aumento de carga ni aumento de repeticiones) durante 3 sesiones consecutivas del mismo ejercicio,
**entonces** marca el ejercicio con estado "En Meseta".

#### CA-12.08 ‚Äî Sesiones consecutivas del mismo ejercicio

**Dado que** el sistema eval√∫a si un ejercicio est√° en meseta,
**cuando** cuenta las sesiones consecutivas sin progresi√≥n,
**entonces** solo cuenta sesiones que incluyen ese ejercicio espec√≠fico, sin importar cu√°ntas sesiones de otros m√≥dulos hayan ocurrido entre ellas; la consecutividad es del ejercicio, no del calendario.

#### CA-12.09 ‚Äî Alerta de meseta al ejecutante

**Dado que** un ejercicio entra en estado de "En Meseta",
**cuando** el sistema completa la detecci√≥n,
**entonces** emite una alerta visible al ejecutante indicando el nombre del ejercicio en meseta y que lleva 3 sesiones sin progresi√≥n.

#### CA-12.10 ‚Äî An√°lisis causal: RIR bajo indica l√≠mite de carga

**Dado que** un ejercicio entra en meseta,
**cuando** el sistema analiza los datos de las √∫ltimas 3 sesiones y el RIR promedio es consistentemente bajo (0-1),
**entonces** la alerta incluye el an√°lisis causal: "El ejecutante est√° entrenando cerca del fallo t√©cnico ‚Äî posible l√≠mite de carga con este peso. El cuerpo no tiene reserva suficiente para progresar."

#### CA-12.11 ‚Äî An√°lisis causal: RIR alto indica carga conservadora

**Dado que** un ejercicio entra en meseta,
**cuando** el sistema analiza los datos de las √∫ltimas 3 sesiones y el RIR promedio es alto (3+),
**entonces** la alerta incluye el an√°lisis causal: "El ejecutante mantiene reserva alta ‚Äî posible carga conservadora. El est√≠mulo puede ser insuficiente para generar adaptaci√≥n."

#### CA-12.12 ‚Äî An√°lisis causal: estancamiento grupal indica fatiga sist√©mica

**Dado que** un ejercicio entra en meseta,
**cuando** el sistema detecta que otros ejercicios del mismo grupo muscular tambi√©n est√°n estancados o en meseta,
**entonces** la alerta incluye el an√°lisis causal: "M√∫ltiples ejercicios del mismo grupo muscular estancados ‚Äî posible fatiga sist√©mica del grupo muscular."

#### CA-12.13 ‚Äî Se√±ales visuales diferenciadas

**Dado que** el sistema emite una alerta de meseta,
**cuando** el ejecutante visualiza la alerta,
**entonces** la alerta es visualmente distinguible mediante colores e iconograf√≠a espec√≠fica para meseta, diferenci√°ndose de las se√±ales de progresi√≥n positiva y regresi√≥n, sin depender √∫nicamente del texto.

#### CA-12.14 ‚Äî Actualizaci√≥n del estado del ejercicio

**Dado que** un ejercicio entra en meseta,
**cuando** el sistema actualiza el estado persistente de progresi√≥n,
**entonces** el estado del ejercicio cambia de "En Progresi√≥n" a "En Meseta" y permanece as√≠ hasta que se registre progresi√≥n positiva o se active una descarga.

### Bloque D ‚Äî Acciones Correctivas Escalonadas ante Meseta (RF36)

#### CA-12.15 ‚Äî Recomendaci√≥n en sesi√≥n 4 sin progreso

**Dado que** un ejercicio lleva 4 sesiones consecutivas sin progresi√≥n positiva (1 sesi√≥n m√°s all√° de la detecci√≥n de meseta),
**cuando** el sistema emite la recomendaci√≥n,
**entonces** recomienda al ejecutante: aplicar un microincremento de carga (la menor carga posible disponible) o intentar extender las repeticiones dentro del rango (buscar llegar a 12 reps antes de subir carga), presentando ambas opciones como alternativas.

#### CA-12.16 ‚Äî Recomendaci√≥n en sesi√≥n 6 sin progreso

**Dado que** un ejercicio lleva 6 sesiones consecutivas sin progresi√≥n positiva,
**cuando** el sistema emite la recomendaci√≥n,
**entonces** recomienda al ejecutante: rotar a otra versi√≥n del m√≥dulo para cambiar el patr√≥n de est√≠mulo muscular, indicando que la versi√≥n actual puede haber agotado su efecto adaptativo para ese ejercicio.

#### CA-12.17 ‚Äî Escalonamiento acumulativo

**Dado que** un ejercicio alcanza la sesi√≥n 6 sin progreso,
**cuando** el sistema presenta la recomendaci√≥n,
**entonces** muestra la recomendaci√≥n de sesi√≥n 6 (rotar versi√≥n) como complemento a la de sesi√≥n 4 (microincremento o extensi√≥n de reps), indicando que ambas estrategias pueden combinarse.

#### CA-12.18 ‚Äî Recomendaciones informativas, no bloqueantes

**Dado que** el sistema emite una recomendaci√≥n correctiva,
**cuando** el ejecutante visualiza la recomendaci√≥n,
**entonces** la recomendaci√≥n es informativa: el ejecutante puede seguirla o ignorarla. El sistema no impide iniciar ni completar una sesi√≥n por existir una recomendaci√≥n pendiente.

#### CA-12.19 ‚Äî Vinculaci√≥n con la alerta de meseta

**Dado que** un ejercicio est√° en meseta y el sistema ha emitido una alerta,
**cuando** el sistema emite las recomendaciones correctivas,
**entonces** las presenta asociadas a la alerta de meseta del ejercicio, permitiendo al ejecutante ver el diagn√≥stico (an√°lisis causal) y la prescripci√≥n (acci√≥n correctiva) de forma conjunta.

### Bloque E ‚Äî Detecci√≥n de Necesidad de Descarga por M√≥dulo (RF37)

#### CA-12.20 ‚Äî Detecci√≥n por meseta/regresi√≥n simult√°nea

**Dado que** el sistema eval√∫a el estado de los ejercicios de un m√≥dulo al cerrar una sesi√≥n,
**cuando** detecta que ‚â• 50% de los ejercicios del m√≥dulo est√°n simult√°neamente en estado de "En Meseta" o clasificados con "Regresi√≥n" en la sesi√≥n actual,
**entonces** marca el m√≥dulo como "Requiere descarga" y emite una se√±al al ejecutante.

#### CA-12.21 ‚Äî Detecci√≥n por fatiga acumulada del m√≥dulo

**Dado que** el sistema ha detectado fatiga acumulada del m√≥dulo en la sesi√≥n actual (regresi√≥n simult√°nea en ‚â• 50% de los ejercicios ‚Äî CA-12.04),
**cuando** completa el an√°lisis post-sesi√≥n,
**entonces** marca el m√≥dulo como "Requiere descarga" y emite una se√±al al ejecutante, independientemente del estado de meseta de los ejercicios individuales.

#### CA-12.22 ‚Äî C√°lculo del umbral del 50%

**Dado que** el sistema eval√∫a si un m√≥dulo requiere descarga,
**cuando** calcula el porcentaje de ejercicios en meseta/regresi√≥n,
**entonces** lo calcula sobre el total de ejercicios prescritos para la versi√≥n del m√≥dulo actualmente en ejecuci√≥n (11 para A, 11 para B, 9 para C).

#### CA-12.23 ‚Äî Se√±al informativa, no bloqueante

**Dado que** el sistema detecta que un m√≥dulo requiere descarga,
**cuando** emite la se√±al al ejecutante,
**entonces** la se√±al es informativa y recomienda activar el modo de descarga (HU-14), pero no impide al ejecutante continuar entrenando con la carga normal si as√≠ lo decide.

#### CA-12.24 ‚Äî Registro de la detecci√≥n

**Dado que** el sistema detecta que un m√≥dulo requiere descarga,
**cuando** completa la evaluaci√≥n,
**entonces** persiste la detecci√≥n con la fecha y el m√≥dulo afectado, disponible para consulta en el historial.

---

## An√°lisis Arquitect√≥nico (Arquitecto)

### Decisiones de Dise√±o

**Patr√≥n Arquitect√≥nico:** Extensi√≥n del pipeline de cierre de sesi√≥n (HU-10/HU-11) + reglas puras en `domain/rules/` (ADR-06) + nueva capa de persistencia de alertas.

**Justificaci√≥n:** HU-12 sigue la cadena establecida por HU-10 y HU-11: l√≥gica de backend sin pantalla propia, ejecutada dentro de la transacci√≥n de `closeSession()`, con funciones puras en `domain/rules/` testeables sin emulador. HU-12 agrega una dimensi√≥n nueva: la evaluaci√≥n a **nivel de m√≥dulo** (post-loop), que opera DESPU√âS de que el loop per-ejercicio actualice todos los estados. Adem√°s, establece la **infraestructura de alertas** (`AlertEntity` + `AlertDao`) que HU-17 (Sistema de Alertas) reutilizar√°.

**1. HU-12 es l√≥gica pura de backend ‚Äî no tiene pantalla propia.**

Mapa de Navegaci√≥n: E5 (HU-13) consume se√±ales de regresi√≥n/descarga, H1/H2 (HU-17) consume alertas de meseta, B1 muestra badge de alertas activas. HU-12 produce datos, no los visualiza. Todo ocurre dentro de la transacci√≥n de `closeSession()`.

**2. Siete de los 24 CAs ya est√°n cubiertos por HU-10 ‚Üí HU-12 no los reimplementa.**

| CA ya cubierto | Mecanismo existente (HU-10) |
|---|---|
| CA-12.01 (regresi√≥n por reps) | `classifyStandard()` ‚Üí `totalReps < previous ‚Üí REGRESSION` |
| CA-12.02 (regresi√≥n por RIR) | `classifyStandard()` ‚Üí `rirRise >= 1.5 ‚Üí REGRESSION` |
| CA-12.03 (regresi√≥n por carga) | `classifyStandard()` ‚Üí `weightLower ‚Üí REGRESSION` |
| CA-12.07 (meseta a 3 sesiones) | `resolveNewProgressionState()` ‚Üí `counter >= 3 ‚Üí IN_PLATEAU` |
| CA-12.08 (consecutividad por ejercicio) | Dise√±o inherente ‚Äî `sessionsWithoutProgression` solo se incrementa cuando ESE ejercicio se eval√∫a |
| CA-12.14 (actualizaci√≥n de estado) | `resolveNewProgressionState()` ‚Üí `status = IN_PLATEAU` |
| CA-12.18 (no bloqueante) | Las alertas y recomendaciones son informativas por dise√±o ‚Äî no alteran ning√∫n flujo |

**Nota sobre CA-12.01:** El MDS R4 define regresi√≥n como "reps caen en ‚â• 2 de las 4 series" (criterio per-serie). HU-10 implementa un criterio agregado (`totalReps < previous ‚Üí REGRESSION`). Ambos convergen en la pr√°ctica: si las repeticiones totales bajan, al menos algunas series individuales bajaron. El edge case (series individuales cambian pero total se mantiene) es un patr√≥n at√≠pico de entrenamiento real. Se mantiene el enfoque agregado como suficiente para el MVP.

**3. Cuatro reglas puras nuevas en `domain/rules/` (ADR-06).**

Cada regla es un `object` Kotlin con funciones puras, sin dependencias Android, testeable con JUnit:

| Regla | MDS | Invocaci√≥n | Responsabilidad |
|---|---|---|---|
| `ModuleFatigueRule` | R4 (m√≥dulo) | Write-time (cierre de sesi√≥n) | Detectar fatiga acumulada del m√≥dulo (‚â•50% regresiones en sesi√≥n) |
| `DeloadNeedRule` | R3 ¬ß3·µÉ intervenci√≥n + R4 | Write-time (cierre de sesi√≥n) | Detectar si m√≥dulo requiere descarga |
| `PlateauCausalAnalysisRule` | R3 (an√°lisis) | Read-time (detalle de alerta) | Analizar causa de meseta (RIR bajo/alto, estancamiento grupal) |
| `CorrectiveActionRule` | R3 ¬ß1·µÉ/2·µÉ intervenci√≥n | Read-time (detalle de alerta) | Recomendar acciones correctivas escalonadas (sesi√≥n 4/6) |

**4. HU-12 establece la infraestructura de alertas que HU-17 reutiliza.**

El Modelo de Datos ¬ß3.16 define la tabla `alert` con 7 tipos. HU-12 crea `AlertEntity` + `AlertDao` (la infraestructura completa) pero solo escribe 2 tipos: `PLATEAU` y `MODULE_REQUIRES_DELOAD`. HU-17 agregar√° los otros 5 tipos (`LOW_PROGRESSION_RATE`, `RIR_OUT_OF_RANGE`, `LOW_ADHERENCE`, `TONNAGE_DROP`, `MODULE_INACTIVITY`) y construir√° las pantallas H1/H2. Esto sigue el principio de extensi√≥n incremental: HU-12 introduce la tabla y los primeros consumidores; HU-17 ampl√≠a.

**5. Separaci√≥n de responsabilidades WRITE-TIME vs READ-TIME.**

- **Write-time** (cierre de sesi√≥n): Detecci√≥n de condiciones + creaci√≥n/resoluci√≥n de alertas en tabla `alert`. Datos persistidos: tipo, nivel, entidad afectada, mensaje, estado activo/resuelto.
- **Read-time** (detalle de alerta en H2): An√°lisis causal y recomendaciones correctivas. Computados din√°micamente desde datos crudos (series, sesiones).
- **Justificaci√≥n:** El Modelo de Datos ¬ß3.16 es expl√≠cito: *"Los datos que dispararon la alerta y las recomendaciones escalonadas no se almacenan ‚Äî se recalculan din√°micamente en la capa de aplicaci√≥n a partir de las series, sesiones y la l√≥gica del motor de reglas. Dado que las sesiones cerradas son inmutables, el rec√°lculo siempre produce el mismo resultado."*

**6. El an√°lisis causal (CA-12.10-12.12) recibe datos pre-computados.**

`PlateauCausalAnalysisRule.analyze()` recibe: (a) lista de avgRIR de las √∫ltimas 3 sesiones del ejercicio, (b) flag de estancamiento grupal. La obtenci√≥n de estos datos (queries hist√≥ricas + JOINs de `exercise_muscle_zone`) la hace el Repository/UseCase que sirve H2 ‚Äî no la regla. La regla solo clasifica.

**7. Las recomendaciones correctivas (CA-12.15-12.17) se derivan del contador existente.**

`exercise_progression.sessions_without_progression` ya se mantiene por HU-10. `CorrectiveActionRule.recommend(counter)` aplica umbrales: `‚â• 4` ‚Üí microincremento/extensi√≥n de reps, `‚â• 6` ‚Üí rotar versi√≥n (acumulativo, CA-12.17). No requiere persistencia adicional ‚Äî la informaci√≥n se computa al renderizar H2.

**8. Deduplicaci√≥n y resoluci√≥n autom√°tica de alertas.**

- **Deduplicaci√≥n:** Antes de insertar un `PLATEAU` alert, verificar que no exista uno activo para el mismo `exercise_id`. Antes de insertar `MODULE_REQUIRES_DELOAD`, verificar que no exista uno activo para el mismo `module_code`.
- **Resoluci√≥n autom√°tica (CA-12.14 impl√≠cito):** Cuando un ejercicio sale de `IN_PLATEAU` (progresi√≥n positiva ‚Üí `IN_PROGRESSION`, counter reset a 0), la alerta PLATEAU se resuelve (`is_active = 0`, `resolved_at = hoy`). Cuando el m√≥dulo ya no cumple el umbral de descarga, la alerta MODULE_REQUIRES_DELOAD se resuelve.

**9. El umbral del 50% tiene denominadores diferentes seg√∫n el contexto.**

| Detecci√≥n | Denominador | CA |
|---|---|---|
| Fatiga acumulada del m√≥dulo | Ejercicios **con registros** en la sesi√≥n (no prescritos totales) | CA-12.05 |
| Necesidad de descarga | Total de ejercicios **prescritos** para la versi√≥n del m√≥dulo | CA-12.22 |

**10. `moduleVersionId` se obtiene de la tabla `session` y se pasa como par√°metro.**

`ActiveSessionInfo` no incluye `moduleVersionId` ‚Äî solo `moduleCode` y `versionNumber`. Para las queries de deload need (CA-12.22), se necesita `moduleVersionId`. Se obtiene directamente de `session.module_version_id` mediante una nueva query en `SessionDao` y se pasa como par√°metro a `evaluateProgression()`.

**11. Los mensajes de alerta son gen√©ricos; el nombre de ejercicio/m√≥dulo se resuelve por JOIN.**

`alert.message` almacena texto descriptivo gen√©rico ("3 sesiones sin progresi√≥n", "‚â•50% ejercicios en meseta/regresi√≥n"). Los nombres se obtienen al leer la alerta v√≠a FKs (`exercise_id` ‚Üí `exercise.name`, `module_code` ‚Üí `module.name`). Esto evita denormalizaci√≥n y mantiene los mensajes actualizables.

**12. Guardia de descarga: la detecci√≥n de m√≥dulo-nivel se omite durante sesiones de descarga.**

Si la sesi√≥n que se cierra pertenece a un ciclo de descarga activo (`session.deload_id != null`), el paso 6 (detecci√≥n de fatiga/deload del m√≥dulo) se omite completamente. Justificaci√≥n: durante la descarga, la carga se reduce al 60% ‚Äî las regresiones en ese contexto son esperadas y no representan fatiga real. Emitir una alerta `MODULE_REQUIRES_DELOAD` durante una descarga que ya est√° en curso ser√≠a parad√≥jico. La guardia usa `session.deload_id` que ya existe en `SessionEntity`. El paso 5d (alertas per-ejercicio de meseta) tambi√©n se omite durante descarga porque `resolveNewProgressionState()` de HU-10 ya tiene guardia `IN_DELOAD`: no modifica estado ni contador durante descarga.

**13. E5 (HU-13) deriva "Considerar descarga" combinando clasificaci√≥n y alertas.**

CA-13.05 espera una se√±al "Considerar descarga" por ejercicio en el resumen post-sesi√≥n (E5). La ruta de derivaci√≥n es: E5 muestra "Considerar descarga" cuando `session_exercise.progression_classification == 'REGRESSION'` en la sesi√≥n actual **Y** existe una alerta activa `MODULE_REQUIRES_DELOAD` para el m√≥dulo del ejercicio. Si solo hay regresi√≥n aislada sin alerta de m√≥dulo, E5 muestra "‚Üì Regresi√≥n" pero no "Considerar descarga". La implementaci√≥n de esta l√≥gica de derivaci√≥n es responsabilidad de HU-13, pero HU-12 provee los datos subyacentes.

**Componentes Afectados:**

**Componentes nuevos:**

| # | Componente | Capa | Responsabilidad |
|---|---|---|---|
| 1 | `AlertEntity` | Data (entity) | Entity Room para tabla `alert` (Modelo de Datos ¬ß3.16) |
| 2 | `AlertDao` | Data (DAO) | Insert, query activas, resolve, existsActive, countActive |
| 3 | `ModuleFatigueRule` | Domain (rules) | R4 m√≥dulo: `detectFatigue(regressionCount, exercisesWithRecords) ‚Üí Boolean` |
| 4 | `DeloadNeedRule` | Domain (rules) | R3 ¬ß3·µÉ intervenci√≥n + R4: `needsDeload(affectedCount, totalCount, fatigueDetected) ‚Üí Boolean` |
| 5 | `PlateauCausalAnalysisRule` | Domain (rules) | R3 an√°lisis: `analyze(avgRirs, isGroupStagnant) ‚Üí PlateauCause` |
| 6 | `CorrectiveActionRule` | Domain (rules) | R3 ¬ß1·µÉ/2·µÉ intervenci√≥n: `recommend(sessionsWithoutProgression) ‚Üí List<CorrectiveAction>` |
| 7 | `PlateauCause` | Domain (model) | Enum: `LOW_RIR_LIMIT`, `HIGH_RIR_CONSERVATIVE`, `GROUP_STAGNATION`, `MIXED` |
| 8 | `CorrectiveAction` | Domain (model) | Enum: `MICRO_INCREMENT_OR_EXTEND_REPS`, `ROTATE_VERSION` |

**Componentes modificados:**

| # | Componente | Cambio | Nivel |
|---|---|---|---|
| 1 | `TensionDatabase` | Agregar `AlertEntity` a entities, agregar `alertDao()`, version 4 ‚Üí 5, migraci√≥n | Mayor |
| 2 | `DatabaseModule` | Agregar `provideAlertDao()` | Menor |
| 3 | `SessionRepositoryImpl` | Inyectar `AlertDao`; extender `evaluateProgression()` con gesti√≥n de alertas post-loop + guardia de descarga | Mayor |
| 4 | `SessionDao` | Agregar queries `getModuleVersionIdBySessionId()`, `getDeloadIdBySessionId()` | Menor |
| 5 | `PlanAssignmentDao` | Agregar queries: `countExercisesForModuleVersion()`, `countAffectedForDeload()` | Menor |

**Componentes nuevos ‚Äî Especificaciones:**

#### `ModuleFatigueRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

object ModuleFatigueRule {

    const val FATIGUE_THRESHOLD = 0.50

    fun detectFatigue(regressionCount: Int, exercisesWithRecords: Int): Boolean {
        if (exercisesWithRecords == 0) return false
        return regressionCount.toDouble() / exercisesWithRecords >= FATIGUE_THRESHOLD
    }
}
```

#### `DeloadNeedRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

object DeloadNeedRule {

    const val DELOAD_THRESHOLD = 0.50

    fun needsDeload(
        affectedCount: Int,
        totalCount: Int,
        fatigueDetected: Boolean,
    ): Boolean {
        if (fatigueDetected) return true // CA-12.21
        if (totalCount == 0) return false
        return affectedCount.toDouble() / totalCount >= DELOAD_THRESHOLD // CA-12.20
    }
}
```

#### `PlateauCausalAnalysisRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

import com.estebancoloradogonzalez.tension.domain.model.PlateauCause

object PlateauCausalAnalysisRule {

    const val LOW_RIR_THRESHOLD = 1.0
    const val HIGH_RIR_THRESHOLD = 3.0

    fun analyze(
        lastSessionsAvgRir: List<Double>,
        isGroupStagnant: Boolean,
    ): PlateauCause {
        if (isGroupStagnant) return PlateauCause.GROUP_STAGNATION // CA-12.12
        if (lastSessionsAvgRir.isEmpty()) return PlateauCause.MIXED
        val overallAvg = lastSessionsAvgRir.average()
        return when {
            overallAvg <= LOW_RIR_THRESHOLD -> PlateauCause.LOW_RIR_LIMIT // CA-12.10
            overallAvg >= HIGH_RIR_THRESHOLD -> PlateauCause.HIGH_RIR_CONSERVATIVE // CA-12.11
            else -> PlateauCause.MIXED
        }
    }
}
```

#### `CorrectiveActionRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

import com.estebancoloradogonzalez.tension.domain.model.CorrectiveAction

object CorrectiveActionRule {

    const val MICRO_INCREMENT_THRESHOLD = 4
    const val ROTATE_VERSION_THRESHOLD = 6

    fun recommend(sessionsWithoutProgression: Int): List<CorrectiveAction> {
        if (sessionsWithoutProgression < MICRO_INCREMENT_THRESHOLD) return emptyList()
        val actions = mutableListOf(CorrectiveAction.MICRO_INCREMENT_OR_EXTEND_REPS) // CA-12.15
        if (sessionsWithoutProgression >= ROTATE_VERSION_THRESHOLD) {
            actions.add(CorrectiveAction.ROTATE_VERSION) // CA-12.16, CA-12.17
        }
        return actions
    }
}
```

#### `PlateauCause.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.model

enum class PlateauCause {
    LOW_RIR_LIMIT,         // CA-12.10: RIR 0-1, entrenando cerca del fallo
    HIGH_RIR_CONSERVATIVE, // CA-12.11: RIR 3+, carga conservadora
    GROUP_STAGNATION,      // CA-12.12: m√∫ltiples ejercicios del grupo muscular estancados
    MIXED,                 // Ning√∫n patr√≥n claro dominante
}
```

#### `CorrectiveAction.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.model

enum class CorrectiveAction {
    MICRO_INCREMENT_OR_EXTEND_REPS, // CA-12.15: sesi√≥n 4+, microincremento o extensi√≥n de reps
    ROTATE_VERSION,                 // CA-12.16: sesi√≥n 6+, rotar a otra versi√≥n del m√≥dulo
}
```

#### `AlertEntity.kt`

```kotlin
package com.estebancoloradogonzalez.tension.data.local.entity

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "alert",
    foreignKeys = [
        ForeignKey(
            entity = ExerciseEntity::class,
            parentColumns = ["id"],
            childColumns = ["exercise_id"],
            onDelete = ForeignKey.RESTRICT,
        ),
        ForeignKey(
            entity = ModuleEntity::class,
            parentColumns = ["code"],
            childColumns = ["module_code"],
            onDelete = ForeignKey.RESTRICT,
        ),
    ],
    indices = [
        Index(value = ["is_active"]),
        Index(value = ["type"]),
        Index(value = ["exercise_id"]),
        Index(value = ["module_code"]),
    ],
)
data class AlertEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0,

    @ColumnInfo(name = "type")
    val type: String,

    @ColumnInfo(name = "level")
    val level: String,

    @ColumnInfo(name = "exercise_id")
    val exerciseId: Long? = null,

    @ColumnInfo(name = "module_code")
    val moduleCode: String? = null,

    @ColumnInfo(name = "muscle_group")
    val muscleGroup: String? = null,

    @ColumnInfo(name = "message")
    val message: String,

    @ColumnInfo(name = "is_active", defaultValue = "1")
    val isActive: Int = 1,

    @ColumnInfo(name = "created_at")
    val createdAt: String,

    @ColumnInfo(name = "resolved_at")
    val resolvedAt: String? = null,
)
```

#### `AlertDao.kt`

```kotlin
package com.estebancoloradogonzalez.tension.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.Query
import com.estebancoloradogonzalez.tension.data.local.entity.AlertEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface AlertDao {

    @Insert
    suspend fun insert(alert: AlertEntity): Long

    @Query(
        """
        SELECT EXISTS(
            SELECT 1 FROM alert
            WHERE exercise_id = :exerciseId AND type = :type AND is_active = 1
        )
        """,
    )
    suspend fun existsActiveByExercise(exerciseId: Long, type: String): Boolean

    @Query(
        """
        SELECT EXISTS(
            SELECT 1 FROM alert
            WHERE module_code = :moduleCode AND type = :type AND is_active = 1
        )
        """,
    )
    suspend fun existsActiveByModule(moduleCode: String, type: String): Boolean

    @Query(
        """
        UPDATE alert
        SET is_active = 0, resolved_at = :resolvedAt
        WHERE exercise_id = :exerciseId AND type = :type AND is_active = 1
        """,
    )
    suspend fun resolveByExerciseAndType(exerciseId: Long, type: String, resolvedAt: String)

    @Query(
        """
        UPDATE alert
        SET is_active = 0, resolved_at = :resolvedAt
        WHERE module_code = :moduleCode AND type = :type AND is_active = 1
        """,
    )
    suspend fun resolveByModuleAndType(moduleCode: String, type: String, resolvedAt: String)

    @Query("SELECT COUNT(*) FROM alert WHERE is_active = 1")
    fun countActive(): Flow<Int>

    @Query("SELECT * FROM alert WHERE is_active = 1 ORDER BY level ASC, created_at DESC")
    fun getActiveAlerts(): Flow<List<AlertEntity>>
}
```

**Componentes modificados ‚Äî Especificaciones:**

#### Modificaci√≥n #1 ‚Äî `SessionExerciseForProgression` (agregar `moduleCode`)

El DTO ya tiene `moduleCode: String` desde HU-10. No se requiere modificaci√≥n adicional.

#### Modificaci√≥n #2 ‚Äî `SessionDao` (queries nuevas)

```kotlin
@Query("SELECT module_version_id FROM session WHERE id = :sessionId")
suspend fun getModuleVersionIdBySessionId(sessionId: Long): Long

@Query("SELECT deload_id FROM session WHERE id = :sessionId")
suspend fun getDeloadIdBySessionId(sessionId: Long): Long?
```

#### Modificaci√≥n #3 ‚Äî `PlanAssignmentDao` (queries nuevas)

```kotlin
@Query("SELECT COUNT(*) FROM plan_assignment WHERE module_version_id = :moduleVersionId")
suspend fun countExercisesForModuleVersion(moduleVersionId: Long): Int

@Query(
    """
    SELECT COUNT(DISTINCT pa.exercise_id)
    FROM plan_assignment pa
    LEFT JOIN exercise_progression ep ON pa.exercise_id = ep.exercise_id
    LEFT JOIN session_exercise se ON pa.exercise_id = se.exercise_id
        AND se.session_id = :sessionId
    WHERE pa.module_version_id = :moduleVersionId
    AND (ep.status = 'IN_PLATEAU' OR se.progression_classification = 'REGRESSION')
    """,
)
suspend fun countAffectedForDeload(moduleVersionId: Long, sessionId: Long): Int
```

#### Modificaci√≥n #4 ‚Äî `evaluateProgression()` en `SessionRepositoryImpl`

Cambio de firma: `private suspend fun evaluateProgression(sessionId: Long)` ‚Üí `private suspend fun evaluateProgression(sessionId: Long, moduleVersionId: Long, isDeloadSession: Boolean)`

Extensi√≥n del loop existente (despu√©s de HU-11, antes del `exerciseProgressionDao.update()`):

```kotlin
private suspend fun evaluateProgression(
    sessionId: Long,
    moduleVersionId: Long,
    isDeloadSession: Boolean,
) {
    val exercises = sessionExerciseDao.getSessionExercisesForProgression(sessionId)
    val today = LocalDate.now().toString()

    // HU-12: Accumulators for module-level analysis
    var regressionCount = 0
    var exercisesWithRecords = 0

    for (exercise in exercises) {
        // === Existing HU-10 code: fetch sets, build currentData/previousData, classify ===
        // === Existing HU-11 code: prescribe load ===

        // HU-12 Step 5c: Collect classification for module-level analysis (CA-12.04, CA-12.05)
        if (classification != null) {
            exercisesWithRecords++
            if (classification == ProgressionClassification.REGRESSION) regressionCount++
        }

        // HU-12 Step 5d: Plateau alert management (CA-12.09, CA-12.06)
        // Guarded by deload: IN_DELOAD guard in resolveNewProgressionState() prevents
        // status/counter changes during deload, so no plateau transitions occur.
        val previousStatus = currentProgression.status
        if (previousStatus != "IN_PLATEAU" && newStatus == "IN_PLATEAU") {
            if (!alertDao.existsActiveByExercise(exercise.exerciseId, "PLATEAU")) {
                alertDao.insert(
                    AlertEntity(
                        type = "PLATEAU",
                        level = "HIGH_ALERT",
                        exerciseId = exercise.exerciseId,
                        message = "3 sesiones sin progresi√≥n",
                        isActive = 1,
                        createdAt = today,
                    ),
                )
            }
        } else if (previousStatus == "IN_PLATEAU" && newStatus != "IN_PLATEAU") {
            alertDao.resolveByExerciseAndType(exercise.exerciseId, "PLATEAU", today)
        }

        exerciseProgressionDao.update(
            currentProgression.copy(
                status = newStatus,
                sessionsWithoutProgression = newCounter,
                prescribedLoadKg = prescribedLoadKg,
            ),
        )
    }

    // HU-12 Step 6: Module-level detection (post-loop)
    // DELOAD GUARD: Skip module-level detection during deload sessions (Decision 12)
    if (isDeloadSession) return

    val moduleCode = exercises.firstOrNull()?.moduleCode ?: return

    // CA-12.04, CA-12.05: Module fatigue detection
    val fatigueDetected = ModuleFatigueRule.detectFatigue(regressionCount, exercisesWithRecords)

    // CA-12.20, CA-12.21, CA-12.22: Deload need detection
    val totalExercises = planAssignmentDao.countExercisesForModuleVersion(moduleVersionId)
    val affectedCount = planAssignmentDao.countAffectedForDeload(moduleVersionId, sessionId)
    val deloadNeeded = DeloadNeedRule.needsDeload(affectedCount, totalExercises, fatigueDetected)

    if (deloadNeeded) {
        // CA-12.20, CA-12.21, CA-12.23, CA-12.24
        if (!alertDao.existsActiveByModule(moduleCode, "MODULE_REQUIRES_DELOAD")) {
            alertDao.insert(
                AlertEntity(
                    type = "MODULE_REQUIRES_DELOAD",
                    level = "HIGH_ALERT",
                    moduleCode = moduleCode,
                    message = "‚â•50% ejercicios en meseta/regresi√≥n",
                    isActive = 1,
                    createdAt = today,
                ),
            )
        }
    } else {
        alertDao.resolveByModuleAndType(moduleCode, "MODULE_REQUIRES_DELOAD", today)
    }
}
```

Cambio en `closeSession()` que invoca `evaluateProgression()`:

```kotlin
// Before (HU-10):
evaluateProgression(sessionId)

// After (HU-12):
val moduleVersionId = sessionDao.getModuleVersionIdBySessionId(sessionId)
val deloadId = sessionDao.getDeloadIdBySessionId(sessionId)
evaluateProgression(sessionId, moduleVersionId, isDeloadSession = deloadId != null)
```

#### Modificaci√≥n #5 ‚Äî `TensionDatabase` (versi√≥n + entity + DAO)

```kotlin
// entities: agregar AlertEntity::class
// version: 4 ‚Üí 5
// agregar: abstract fun alertDao(): AlertDao
```

#### Modificaci√≥n #6 ‚Äî `DatabaseModule` (provider)

```kotlin
@Provides
fun provideAlertDao(database: TensionDatabase): AlertDao {
    return database.alertDao()
}
```

**Hitos de Implementaci√≥n:**

| # | Entregable | Archivos | CAs |
|---|---|---|---|
| 1 | Infraestructura de alertas ‚Äî `AlertEntity` + `AlertDao` + migraci√≥n DB v4‚Üív5 + DI | `AlertEntity.kt`, `AlertDao.kt`, `TensionDatabase.kt`, `DatabaseModule.kt` | CA-12.06, CA-12.24 |
| 2 | Reglas write-time ‚Äî `ModuleFatigueRule` + `DeloadNeedRule` + tests unitarios | `ModuleFatigueRule.kt`, `DeloadNeedRule.kt`, `ModuleFatigueRuleTest.kt`, `DeloadNeedRuleTest.kt` | CA-12.04, CA-12.05, CA-12.20, CA-12.21, CA-12.22 |
| 3 | Reglas read-time ‚Äî `PlateauCausalAnalysisRule` + `CorrectiveActionRule` + enums + tests | `PlateauCausalAnalysisRule.kt`, `CorrectiveActionRule.kt`, `PlateauCause.kt`, `CorrectiveAction.kt`, `PlateauCausalAnalysisRuleTest.kt`, `CorrectiveActionRuleTest.kt` | CA-12.10, CA-12.11, CA-12.12, CA-12.15, CA-12.16, CA-12.17 |
| 4 | Queries de agregaci√≥n ‚Äî `SessionDao`, `PlanAssignmentDao` | `SessionDao.kt`, `PlanAssignmentDao.kt` | CA-12.22, Decisi√≥n 12 (deload guard) |
| 5 | Integraci√≥n ‚Äî extender `evaluateProgression()` con alertas per-ejercicio + detecci√≥n m√≥dulo-nivel | `SessionRepositoryImpl.kt` | CA-12.09, CA-12.13, CA-12.19, CA-12.23 |

### Validaci√≥n de Impacto

**C√≥digo real verificado (paso 1.5):**

- `ProgressionClassificationRule.kt`: `classify()` ya implementa CA-12.01 (regresi√≥n por reps), CA-12.02 (por RIR), CA-12.03 (por carga) mediante `classifyStandard()`, `classifyBodyweight()`, `classifyIsometric()`. `resolveNewProgressionState()` ya implementa CA-12.07 (meseta a 3) y CA-12.14 (actualizaci√≥n de estado) con constante `PLATEAU_THRESHOLD = 3`.
- `DoubleThresholdRule.kt`: No afectado por HU-12. Funciona independientemente.
- `ExerciseProgressionEntity.kt`: Campo `sessionsWithoutProgression` ya existe y se mantiene por HU-10. HU-12 lo consume sin modificar (read-time para recomendaciones correctivas).
- `SessionRepositoryImpl.evaluateProgression()`: El loop actual genera `classification` (per-ejercicio), `newStatus` y `newCounter` ‚Äî exactamente los datos que HU-12 consume para acumuladores de m√≥dulo y alertas de meseta.
- `SessionExerciseDao.getSessionExercisesForProgression()`: Devuelve `SessionExerciseForProgression` con `moduleCode`, `isBodyweight`, `isIsometric`. Suficiente para el loop HU-12.
- `SessionDao`: `ActiveSessionInfo` NO tiene `moduleVersionId`. Se agrega `getModuleVersionIdBySessionId()` para obtenerlo.
- `TensionDatabase`: Versi√≥n actual = 4. `fallbackToDestructiveMigration()` configurado. No existe `AlertEntity` ni `alertDao()`.
- `DatabaseModule`: No tiene `provideAlertDao()`.
- `PlanAssignmentDao`: No tiene queries de conteo por module_version.

**An√°lisis de dependencias:**

- HU-12 depende de: HU-10 (clasificaci√≥n, estados, contadores), HU-11 (carga prescrita ‚Äî no modificada).
- HU-12 alimenta: HU-13 (E5 ‚Äî se√±ales de regresi√≥n/descarga), HU-14 (protocolo de descarga ‚Äî lee `MODULE_REQUIRES_DELOAD`), HU-17 (H1/H2 ‚Äî lee alertas activas, an√°lisis causal, acciones correctivas).

**Impacto en performance:**

- 4 reglas puras: operaciones O(1) o O(n) con n ‚â§ 11 ejercicios. Despreciable.
- 2 INSERTs condicionales + 2 UPDATEs condicionales en `alert`: m√°ximo 2 alertas por sesi√≥n. Despreciable.
- `countAffectedForDeload`: JOIN triple sobre m√°ximo 11 filas. Despreciable.
- Todo dentro de `database.withTransaction {}`: atomicidad garantizada.

### Notas T√©cnicas

**Nota 1 ‚Äî CA-12.06 (registro de detecciones) se resuelve por la tabla `alert`.**

Los CAs de registro (CA-12.06, CA-12.24) son cubiertos por la inserci√≥n de alertas en la tabla `alert`. La alerta persiste la detecci√≥n vinculada a la sesi√≥n (fecha de creaci√≥n), al ejercicio o m√≥dulo afectado, y queda disponible para consulta futura. No se requiere una tabla de "detecciones" separada.

**Nota 2 ‚Äî CA-12.09 y CA-12.13 (se√±ales visuales) son responsabilidad de HU-17 (H1/H2).**

HU-12 produce los datos (alertas en tabla `alert`); HU-17 los consume y aplica las se√±ales visuales diferenciadas (colores, iconograf√≠a, RNF05). La alerta `PLATEAU` tiene `level = "HIGH_ALERT"`, que H1 renderizar√° con el estilo visual correspondiente. CA-12.13 se cubre transitivamente: HU-12 provee el tipo + nivel, HU-17 aplica la diferenciaci√≥n visual.

**Nota 3 ‚Äî CA-12.19 (vinculaci√≥n alerta + recomendaci√≥n) se resuelve en H2.**

La pantalla H2 (Detalle de Alerta) de HU-17 leer√° la alerta PLATEAU, computar√° el an√°lisis causal via `PlateauCausalAnalysisRule` y las acciones correctivas via `CorrectiveActionRule`, y los presentar√° juntos. HU-12 provee ambas reglas + la alerta persistida; HU-17 orquesta la presentaci√≥n conjunta.

**Nota 4 ‚Äî Resoluci√≥n autom√°tica de `MODULE_REQUIRES_DELOAD` tiene dos v√≠as.**

V√≠a 1 (HU-12): Si en una sesi√≥n posterior el m√≥dulo ya no cumple el umbral ‚â•50%, la alerta se resuelve autom√°ticamente en `evaluateProgression()`. V√≠a 2 (HU-14): Cuando el ejecutante activa el protocolo de descarga, HU-14 resolver√° expl√≠citamente la alerta como parte del flujo de activaci√≥n. Ambas v√≠as son complementarias.

**Nota 5 ‚Äî La detecci√≥n de estancamiento grupal (CA-12.12) requiere query de `exercise_muscle_zone`.**

Para determinar si hay estancamiento grupal, el consumidor read-time (H2 en HU-17) necesitar√°: (a) obtener las zonas musculares del ejercicio en meseta, (b) consultar si otros ejercicios del mismo `muscle_group` tambi√©n est√°n en `IN_PLATEAU` o `REGRESSION`. Esta query la implementar√° el Repository que sirve H2. La regla `PlateauCausalAnalysisRule` recibe el resultado como boolean `isGroupStagnant`.

**Nota 6 ‚Äî Se√±ales visuales diferenciadas (CA-12.13, RNF05) y orden de prioridad.**

`alert.level` distingue severidades: `CRISIS` > `HIGH_ALERT` > `MEDIUM_ALERT`. Las alertas de HU-12 son todas `HIGH_ALERT`. La diferenciaci√≥n por color/icono seg√∫n `level` es responsabilidad de HU-17 (H1/H2). HU-12 solo garantiza que el campo `level` est√© correctamente asignado.

**Nota 7 ‚Äî La alerta de fatiga acumulada del m√≥dulo (CA-12.04) no tiene tipo propio.**

La fatiga acumulada del m√≥dulo se detecta (CA-12.04) y se usa como input para `DeloadNeedRule` (CA-12.21). Si hay fatiga ‚Üí autom√°ticamente se marca `MODULE_REQUIRES_DELOAD`. No se crea una alerta separada de tipo "FATIGA" porque el Modelo de Datos ¬ß3.16 no define ese tipo, y funcionalmente es un escalamiento directo a "requiere descarga".

**Nota 8 ‚Äî Guardia de descarga: sesiones de deload no generan alertas de m√≥dulo (Auditor√≠a).**

Durante la descarga, las cargas se reducen al 60% (MDS R5), lo que produce regresiones naturales en los datos crudos. Si no se guarda esta distinci√≥n, `ModuleFatigueRule` detectar√≠a fatiga falsa y `DeloadNeedRule` emitir√≠a `MODULE_REQUIRES_DELOAD` durante una descarga activa ‚Äî resultado parad√≥jico. La guardia se implementa con `session.deload_id != null` para omitir el paso 6. A nivel per-ejercicio (paso 5d), `resolveNewProgressionState()` de HU-10 ya tiene una guardia `IN_DELOAD` que impide transiciones de estado/contador, por lo que no se generar√°n alertas PLATEAU falsas durante descarga.

**Nota 9 ‚Äî Los nombres de reglas HU-10 anticip√≥ no aplican en la estructura consolidada (Auditor√≠a).**

HU-10 Nota T√©cnica 2 anticip√≥ `RegressionDetectionRule` y `PlateauDetectionRule` como futuros archivos en `domain/rules/`. En la estructura consolidada de HU-12, la detecci√≥n de regresi√≥n ya est√° resuelta por `ProgressionClassificationRule.classify()` (HU-10), y el an√°lisis de meseta se divide en dos responsabilidades distintas (`PlateauCausalAnalysisRule` para an√°lisis causal, `CorrectiveActionRule` para acciones correctivas). La fatiga de m√≥dulo y necesidad de descarga se resuelven con `ModuleFatigueRule` y `DeloadNeedRule`. No se crean reglas con los nombres originalmente anticipados.

**Nota 10 ‚Äî RF29 define regresi√≥n per-serie pero la implementaci√≥n usa criterio agregado (Auditor√≠a).**

RF29 establece: "las repeticiones caen en ‚â• 2 de las 4 series". HU-10 implementa un criterio agregado (`totalReps < previous ‚Üí REGRESSION`). CA-12.01 hereda este criterio por reutilizaci√≥n. Discrepancia aceptable para MVP: si totalReps baja, al menos 1 serie baj√≥; el edge case donde series individuales cambian pero el total se mantiene es at√≠pico en entrenamiento real. Un refinamiento futuro podr√≠a agregar l√≥gica per-serie, pero no es necesario para la primera iteraci√≥n.

### Referencias y Validaci√≥n

**Documentaci√≥n consultada:**

- Manifiesto de Dominio Sist√©mico ¬ß6-A ‚Äî Reglas R3 (Detecci√≥n de Meseta), R4 (Regresi√≥n y Fatiga Acumulada)
- Modelo de Datos ¬ß3.13 (`exercise_progression`), ¬ß3.11 (`session_exercise`), ¬ß3.16 (`alert`), ¬ß3.15 (`deload`)
- ADR-06 ‚Äî Motor de reglas Kotlin puro en `domain/rules/`
- Arquitectura T√©cnica ¬ß5.2 ‚Äî Naming `{Nombre}Rule`
- Wireframes E5, B1, H1, H2
- Mapa de Navegaci√≥n ¬ß4 ‚Äî HU-12 outputs en E5/H1/H2
- Requerimientos ‚Äî RF29, RF30, RF34, RF35, RF36, RF37, RNF05

**Historias relacionadas:**

- HU-10: Establece `evaluateProgression()`, `ProgressionClassificationRule`, estados de progresi√≥n, contadores ‚Äî todo reutilizado por HU-12
- HU-11: Establece prescripci√≥n de carga en el mismo loop ‚Äî no afectada por HU-12
- HU-13: Consume se√±ales de regresi√≥n/descarga en E5
- HU-14: Consume alerta `MODULE_REQUIRES_DELOAD` para activar protocolo de descarga
- HU-17: Consume toda la infraestructura de alertas (`AlertEntity`, `AlertDao`) y las reglas read-time

### Verificaci√≥n Cruzada de CAs

| CA | Estado | Mecanismo | Implementado en |
|---|---|---|---|
| CA-12.01 | ‚úÖ Ya cubierto | `ProgressionClassificationRule.classifyStandard()` ‚Üí `REGRESSION` por reps | HU-10 |
| CA-12.02 | ‚úÖ Ya cubierto | `ProgressionClassificationRule.classifyStandard()` ‚Üí `REGRESSION` por RIR | HU-10 |
| CA-12.03 | ‚úÖ Ya cubierto | `ProgressionClassificationRule.classifyStandard()` ‚Üí `REGRESSION` por carga | HU-10 |
| CA-12.04 | üî® Por implementar | `ModuleFatigueRule.detectFatigue()` ‚Äî acumuladores post-loop | HU-12 (Rule + Repository) |
| CA-12.05 | üî® Por implementar | Denominador = `exercisesWithRecords` (no prescritos) | HU-12 (Rule) |
| CA-12.06 | üî® Por implementar | `alertDao.insert()` ‚Äî alerta PLATEAU o MODULE_REQUIRES_DELOAD | HU-12 (Repository) |
| CA-12.07 | ‚úÖ Ya cubierto | `resolveNewProgressionState()` ‚Üí `counter >= 3 ‚Üí IN_PLATEAU` | HU-10 |
| CA-12.08 | ‚úÖ Ya cubierto | Dise√±o inherente ‚Äî `sessionsWithoutProgression` del ejercicio | HU-10 |
| CA-12.09 | üî® Por implementar | Insert alerta PLATEAU al transicionar a `IN_PLATEAU` | HU-12 (Repository) |
| CA-12.10 | üî® Por implementar | `PlateauCausalAnalysisRule.analyze()` ‚Üí `LOW_RIR_LIMIT` | HU-12 (Rule) |
| CA-12.11 | üî® Por implementar | `PlateauCausalAnalysisRule.analyze()` ‚Üí `HIGH_RIR_CONSERVATIVE` | HU-12 (Rule) |
| CA-12.12 | üî® Por implementar | `PlateauCausalAnalysisRule.analyze()` ‚Üí `GROUP_STAGNATION` | HU-12 (Rule) |
| CA-12.13 | üî® Parcial HU-12 + HU-17 | `alert.level = "HIGH_ALERT"` (HU-12) + renderizado visual (HU-17) | HU-12 (Rule) + HU-17 (UI) |
| CA-12.14 | ‚úÖ Ya cubierto | `resolveNewProgressionState()` ‚Üí `status = IN_PLATEAU` | HU-10 |
| CA-12.15 | üî® Por implementar | `CorrectiveActionRule.recommend(4+)` ‚Üí `MICRO_INCREMENT_OR_EXTEND_REPS` | HU-12 (Rule) |
| CA-12.16 | üî® Por implementar | `CorrectiveActionRule.recommend(6+)` ‚Üí `ROTATE_VERSION` | HU-12 (Rule) |
| CA-12.17 | üî® Por implementar | Retorno acumulativo de `recommend()` ‚Äî ambas acciones si ‚â•6 | HU-12 (Rule) |
| CA-12.18 | ‚úÖ Ya cubierto | Dise√±o inherente ‚Äî alertas y recomendaciones no alteran flujos | ‚Äî |
| CA-12.19 | üî® Parcial HU-12 + HU-17 | Reglas proveen datos; H2 los presenta juntos | HU-12 (Rules) + HU-17 (UI) |
| CA-12.20 | üî® Por implementar | `DeloadNeedRule.needsDeload()` ‚Äî umbral ‚â•50% meseta/regresi√≥n | HU-12 (Rule + Repository) |
| CA-12.21 | üî® Por implementar | `DeloadNeedRule.needsDeload(fatigueDetected = true)` ‚Üí `true` | HU-12 (Rule) |
| CA-12.22 | üî® Por implementar | `countExercisesForModuleVersion()` ‚Äî denominador sobre prescritos | HU-12 (DAO) |
| CA-12.23 | üî® Por implementar | `alert.type = "MODULE_REQUIRES_DELOAD"` ‚Äî se√±al informativa | HU-12 (Repository) |
| CA-12.24 | üî® Por implementar | `alertDao.insert()` con `moduleCode`, `createdAt` | HU-12 (Repository) |

**Validado por:** esteban.colorado | **Fecha:** 2026-02-16 | **Enfoque:** Exploratorio

### Auditor√≠a Post-An√°lisis

**Fecha:** 2026-02-16

**Documentaci√≥n auditada:** MDS ¬ß6-A (R1-R7), Modelo de Datos (¬ß3.10-3.16), ADR (01-18), Arquitectura T√©cnica (¬ß2.5, ¬ß5.2), Requerimientos (RF29-RF37, RNF05, RNF29, RNF30), Mapa de Historias de Usuario, 18 HUs (HU-01 a HU-18).

**C√≥digo auditado:** `ProgressionClassificationRule.kt`, `DoubleThresholdRule.kt`, `SessionRepositoryImpl.kt` (`evaluateProgression()`, `closeSession()`), `SessionDao.kt`, `SessionExerciseDao.kt`, `PlanAssignmentDao.kt`, `ExerciseProgressionDao.kt`, `ExerciseProgressionEntity.kt`, `SessionEntity.kt`, `ModuleEntity.kt`, `TensionDatabase.kt`, `DatabaseModule.kt`.

**Hallazgos y correcciones aplicadas:**

| # | Severidad | Hallazgo | Correcci√≥n |
| --- | --- | --- | --- |
| 1 | CR√çTICO | Sesiones de descarga (`session.deload_id != null`) producir√≠an falsos positivos en `ModuleFatigueRule`/`DeloadNeedRule` porque las cargas al 60% generan regresiones esperadas | Agregada Decisi√≥n 12 (guardia de descarga), `isDeloadSession` como par√°metro de `evaluateProgression()`, `getDeloadIdBySessionId()` en `SessionDao`, `if (isDeloadSession) return` antes del paso 6 |
| 2 | MEDIO | CA-13.05 (E5 "Considerar descarga") no tiene ruta de derivaci√≥n documentada desde HU-12 | Agregada Decisi√≥n 13 con la ruta de derivaci√≥n: `REGRESSION` + alerta activa `MODULE_REQUIRES_DELOAD`. Responsabilidad de implementaci√≥n de HU-13 |
| 3 | BAJO | HU-10 anticip√≥ nombres `RegressionDetectionRule` y `PlateauDetectionRule` que no se crearon | Agregada Nota 9 documentando la divergencia y justificaci√≥n |
| 4 | BAJO | RF29 define regresi√≥n per-serie pero HU-10/HU-12 usan criterio agregado | Agregada Nota 10 documentando la discrepancia aceptable para MVP |
| 5 | VERIFICADO | Modelo de Datos ¬ß3.16 `alert.level` CHECK values (`CRISIS`, `HIGH_ALERT`, `MEDIUM_ALERT`) alineados con el an√°lisis | Sin correcci√≥n ‚Äî ya correcto |
| 6 | VERIFICADO | ADR-06 naming `{Nombre}Rule` alineado con las 4 reglas propuestas | Sin correcci√≥n ‚Äî ya correcto |
| 7 | VERIFICADO | `SessionEntity.deloadId` nullable ya existe en el c√≥digo ‚Äî disponible para guardia | Sin correcci√≥n ‚Äî dato confirmado |
| 8 | VERIFICADO | `exercise_progression.sessions_without_progression` no tiene tope (sigue incrementando a 4, 5, 6...) compatible con `CorrectiveActionRule` thresholds | Sin correcci√≥n ‚Äî ya correcto |
