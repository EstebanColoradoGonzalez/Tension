# HU-18 — Backup y Restauración

## Requisitos relacionados

RNF15, RNF16, RNF17, RNF18, RNF26, RNF27

## Descripción

Como ejecutante, quiero poder exportar un respaldo completo de todos mis datos de entrenamiento en un archivo autodescriptivo con metadatos de versión y poder importarlo para restaurar mis datos completos, para proteger mi historial ante pérdida o cambio de dispositivo, tener la tranquilidad de que meses o años de datos no están atados a un solo dispositivo, y poder recuperar mi historial sin perder progresión registrada.

## Historias originales consolidadas

Esta historia consolida las siguientes historias del diseño original, que son dos caras del mismo formato de archivo y deben co-diseñarse para garantizar compatibilidad:

- **HU-31 original** — Exportar respaldo de datos (RNF15, RNF17, RNF18, RNF26, RNF27)
- **HU-32 original** — Importar respaldo de datos (RNF16, RNF17, RNF18)

---

## Criterios de Aceptación

### Bloque A — Exportar Respaldo de Datos (RNF15, RNF17, RNF18, RNF26, RNF27)

#### CA-18.01 — Generación del archivo de backup

**Dado que** el ejecutante desea respaldar sus datos,
**cuando** ejecuta la funcionalidad de exportación de respaldo,
**entonces** el sistema genera un archivo que contiene todos los datos del usuario: perfil, historial de peso, sesiones, registros de series, estado de rotación, estados de progresión de ejercicios, conteo de microciclos y configuraciones.

#### CA-18.02 — Formato autodescriptivo con metadatos de versión

**Dado que** el sistema genera el archivo de backup,
**cuando** construye la estructura del archivo,
**entonces** utiliza un formato autodescriptivo (JSON o SQLite exportado) que incluye metadatos de versión del esquema de datos de la aplicación, permitiendo migraciones futuras si la estructura de datos evoluciona en nuevas versiones de la app.

#### CA-18.03 — Almacenamiento y compartición

**Dado que** el sistema ha generado el archivo de backup,
**cuando** completa la exportación,
**entonces** permite al ejecutante almacenar el archivo en el almacenamiento externo del dispositivo o compartirlo vía aplicaciones del sistema operativo (Google Drive, correo electrónico, mensajería, etc.).

#### CA-18.04 — Rendimiento de la exportación

**Dado que** el ejecutante ejecuta la exportación de respaldo,
**cuando** el sistema procesa la generación del archivo,
**entonces** el proceso completo se ejecuta en menos de 10 segundos para un historial de hasta 2 años de datos de entrenamiento.

#### CA-18.05 — Advertencia sobre contenido del archivo

**Dado que** el sistema genera el archivo de backup sin cifrado,
**cuando** presenta el archivo al ejecutante o antes de iniciar la exportación,
**entonces** muestra una advertencia informativa indicando que el archivo contiene sus datos de entrenamiento y que no está cifrado.

#### CA-18.06 — Permisos mínimos requeridos

**Dado que** el sistema necesita acceder al almacenamiento para exportar el backup,
**cuando** solicita permisos al sistema operativo,
**entonces** solo solicita el permiso de almacenamiento estrictamente necesario para la operación de backup, sin requerir permisos adicionales innecesarios.

#### CA-18.07 — Indicación de progreso y confirmación de exportación

**Dado que** el ejecutante inicia la exportación,
**cuando** el sistema procesa la generación del archivo,
**entonces** muestra una indicación de progreso durante el proceso y una confirmación clara al completarse exitosamente, incluyendo la ubicación o destino del archivo.

### Bloque B — Importar Respaldo de Datos (RNF16, RNF17, RNF18)

#### CA-18.08 — Selección del archivo de backup

**Dado que** el ejecutante desea restaurar sus datos,
**cuando** accede a la funcionalidad de importación de respaldo,
**entonces** el sistema permite seleccionar un archivo de backup previamente exportado desde el almacenamiento del dispositivo o desde una aplicación del sistema (Drive, correo, etc.).

#### CA-18.09 — Validación del archivo de backup

**Dado que** el ejecutante selecciona un archivo para importar,
**cuando** el sistema lee el archivo,
**entonces** valida que el formato sea autodescriptivo y contenga los metadatos de versión esperados; si el archivo no es válido o está corrupto, informa al ejecutante con un mensaje de error claro y no procede con la importación.

#### CA-18.10 — Confirmación de reemplazo de datos

**Dado que** el sistema ha validado el archivo de backup exitosamente,
**cuando** está listo para proceder con la importación,
**entonces** solicita confirmación explícita al ejecutante advirtiendo que todos los datos actuales serán reemplazados por los datos del backup, y que esta operación no es reversible.

#### CA-18.11 — Reemplazo completo de datos

**Dado que** el ejecutante confirma la importación,
**cuando** el sistema ejecuta la restauración,
**entonces** reemplaza todos los datos actuales (perfil, historial de peso, sesiones, registros de series, estado de rotación, estados de progresión, conteo de microciclos y configuraciones) con los datos del archivo de backup.

#### CA-18.12 — Migración de versiones

**Dado que** el archivo de backup fue generado con una versión anterior del esquema de datos,
**cuando** el sistema detecta que los metadatos de versión no coinciden con la versión actual,
**entonces** aplica las migraciones necesarias para adaptar los datos a la versión actual del esquema, sin pérdida de información.

#### CA-18.13 — Rendimiento de la importación

**Dado que** el ejecutante ejecuta la importación de respaldo,
**cuando** el sistema procesa la restauración,
**entonces** el proceso completo se ejecuta en menos de 10 segundos para un historial de hasta 2 años de datos.

#### CA-18.14 — Indicación de progreso y confirmación de importación

**Dado que** el ejecutante inicia la importación,
**cuando** el sistema procesa la restauración,
**entonces** muestra una indicación de progreso durante el proceso y una confirmación clara al completarse exitosamente, indicando que los datos han sido restaurados.

#### CA-18.15 — Rollback ante error

**Dado que** el sistema está ejecutando la importación,
**cuando** ocurre un error durante el proceso (archivo corrupto parcialmente, fallo de escritura),
**entonces** el sistema revierte la operación y mantiene los datos anteriores intactos, informando al ejecutante que la importación falló y sus datos originales están preservados.

---

## Análisis Arquitectónico (Arquitecto)

### Decisiones de Diseño

**Patrón Arquitectónico:** Cache-First Export + SAF Import con BackupRepository dedicado (raw SQL) + MVVM para 2 pantallas (J2, J3)

**Justificación:** HU-18 tiene dos caras independientes que comparten un formato de archivo JSON autodescriptivo (ADR-10). La cara **export** genera un dump completo de las 16 tablas a través de `SupportSQLiteDatabase` raw queries — evitando inyectar 15 DAOs al usar acceso genérico por cursor. Se escribe a `cacheDir` y se comparte via `FileProvider` + `ACTION_SEND`, cumpliendo CA-18.03 (almacenamiento externo Y compartición vía apps del sistema) sin permisos runtime (SAF + FileProvider en API 26+, cumpliendo RNF27). La cara **import** usa `ActivityResultContracts.OpenDocument` para selección de archivo, valida metadatos del JSON, y reemplaza toda la BD en una transacción atómica — si falla, rollback preserva datos originales (CA-18.15). Post-import exitoso navega a B1 limpiando todo el back stack (reinicio lógico, Arquitectura Técnica §4.5). Se usa `org.json.JSONObject/JSONArray` (incluido en Android SDK) en lugar de agregar `kotlinx-serialization` porque el backup es un dump genérico de tablas (iteración por cursor, no serialización tipada) — cero dependencias nuevas.

### Decisiones Fundamentadas

**1. Se usa raw SQL (`SupportSQLiteDatabase`) en lugar de los 15 DAOs tipados para export/import.**

El export necesita `SELECT * FROM table` por cada una de las 16 tablas y el import necesita `DELETE FROM table` + `INSERT INTO table` masivo. Usar los 15 DAOs requeriría: (a) inyectar los 15 en el constructor del Repository, (b) crear métodos `getAll()` e `insertAll()` en cada DAO que no existen hoy, (c) mapear cada Entity a JSON y viceversa con tipado estricto. En cambio, `SupportSQLiteDatabase` (accesible via `TensionDatabase.openHelper.writableDatabase`) permite iterar tablas genéricamente: cursor → columnas → `JSONObject`, y `JSONObject` → `ContentValues` → `INSERT`. El export e import se resuelven con un loop sobre una lista ordenada de nombres de tabla — ~100 líneas de código genérico en lugar de ~300 líneas de código tipado por DAO. La transacción atómica se obtiene con `beginTransaction()`/`setTransactionSuccessful()`/`endTransaction()` que garantiza rollback automático ante cualquier excepción.

**2. Se usa `org.json.JSONObject/JSONArray` (Android SDK) sin agregar dependencias de serialización.**

El proyecto actualmente no tiene ninguna librería de serialización JSON (`kotlinx-serialization`, `moshi`, `gson` — verificado en `libs.versions.toml` y `build.gradle.kts`). `org.json` está incluido en el Android SDK y es suficiente para el patrón cursor-to-JSON del export y JSON-to-ContentValues del import. Agregar `kotlinx-serialization` requeriría: plugin `kotlinx-serialization` en Gradle, dependencia `kotlinx-serialization-json`, y anotaciones `@Serializable` en las 16 entidades (o DTOs paralelos). El beneficio de tipado no justifica la complejidad adicional para un dump genérico de tablas. Si el proyecto necesitara serialización JSON en otros contextos futuros (ej: API REST), se evaluaría en ese momento.

**3. El export usa `CreateDocument` (SAF) como mecanismo primario para guardar directamente + `ACTION_SEND` como secundario para compartir.**

CA-18.03 dice "almacenamiento externo del dispositivo O compartir vía aplicaciones del sistema". La Especificación Visual §J2 muestra explícitamente `"Ubicación: Descargas/"` en la card de confirmación post-export. Para que ese texto sea veraz, el export usa `ActivityResultContracts.CreateDocument("application/json")` que abre el file picker nativo para que el usuario elija dónde guardar (por defecto: carpeta Descargas). Esto permite: (a) cero permisos runtime (CA-18.06, RNF27 — SAF no requiere permisos), (b) guardado directo en almacenamiento externo (CA-18.03), (c) texto "Ubicación: Descargas/" real en la card de confirmación. Tras el guardado, el botón "Compartir" (Filled Tonal Button) permite enviar el archivo via `ACTION_SEND` usando una copia temporal en `cacheDir` expuesta via `FileProvider`. El flow es: generar JSON → `CreateDocument` picker (nombre sugerido: `tension_backup_YYYYMMDD.json`) → usuario elige destino → escribir vía `ContentResolver.openOutputStream(uri)` → card de confirmación con ubicación real → botón "Compartir" (opcional).

**4. La importación usa `ActivityResultContracts.OpenDocument` — SAF sin permisos.**

`OpenDocument` lanza el file picker nativo del sistema (Google Files, Drive, Gmail adjuntos, etc.) sin requerir NINGÚN permiso. El archivo seleccionado retorna como `Uri` → se lee via `ContentResolver.openInputStream(uri)` → se parsea como JSON. Este patrón ya tiene precedente en el proyecto: `ImageStorageHelper.kt` usa `context.contentResolver.openInputStream(uri)` para leer imágenes de ejercicios. Para la exportación directa al almacenamiento, se puede ofrecer `CreateDocument` como alternativa o complemento al share (ADR-10 dice "almacenable en almacenamiento externo O compartible").

**5. El import ejecuta en una transacción atómica con rollback automático (CA-18.15).**

`SupportSQLiteDatabase.beginTransaction()` abre una transacción SQLite. Si ocurre CUALQUIER excepción durante el DELETE/INSERT de las 16 tablas, `endTransaction()` sin `setTransactionSuccessful()` revierte TODOS los cambios. Los datos originales permanecen intactos. El flujo: (1) `db.beginTransaction()`, (2) DELETE FROM cada tabla en orden FK (children first), (3) INSERT INTO cada tabla en orden FK (parents first), (4) `db.setTransactionSuccessful()`, (5) `db.endTransaction()`. Si (2) o (3) lanzan excepción, el `finally { db.endTransaction() }` hace rollback automático.

**6. Post-importación exitosa navega a B1 limpiando todo el back stack (Arq. Técnica §4.5).**

La Arquitectura Técnica §4.5 define J3→B1 como "Reinicio post-importación: tras importación exitosa, se navega a B1 limpiando todo el back stack. Equivale a un reinicio lógico de la app con los datos restaurados". Esto garantiza que todos los ViewModels se re-crean con Flows frescos que leen los nuevos datos — no se necesita invalidación manual de caché Room porque los ViewModels anteriores ya están destruidos. La implementación: `navController.navigate(HOME) { popUpTo(navController.graph.id) { inclusive = true } }`.

**7. `BackupMetadata` incluye schemaVersion = `TensionDatabase.VERSION` (actualmente 7).**

El ADR-10 establece que el JSON incluye "metadatos de versión de app y esquema de BD en el header". `schemaVersion` es el entero de la anotación `@Database(version = N)` de Room — actualmente 7. En la importación, se valida `backup.schemaVersion == TensionDatabase.VERSION`. Si no coincide, la versión actual rechaza la importación con un mensaje claro. La infraestructura de migración de backups entre versiones de schema es un stub para v2+ — CA-18.12 se satisface con la validación de versión y un mensaje informativo cuando la versión difiere. Cuando la app evolucione a schema version 8+, se agregarán funciones de migración de backup.

**8. El archivo se nombra `tension_backup_YYYYMMDD.json` (ADR-10).**

Nombre determinístico basado en la fecha de exportación. Si el usuario exporta más de una vez el mismo día, el segundo archivo sobrescribe al primero en `cacheDir` (solo un backup activo en caché). El nombre visible al compartir es el mismo — el usuario identifica su backup por fecha.

**9. La advertencia de contenido sin cifrado se muestra ANTES de exportar (CA-18.05).**

La pantalla J2 muestra una `OutlinedCard` con ícono ⚠️ y texto "El archivo de respaldo contiene todos tus datos de entrenamiento y no está cifrado." (Especificación Visual §J2) como primer elemento visible. El usuario ve la advertencia antes de presionar "Exportar datos". No hay popup ni diálogo separado — es información persistente en pantalla.

**10. El flujo de export usa `CreateDocument` como mecanismo primario + `ACTION_SEND` como secundario.**

La decisión de diseño #3 original planteaba escribir a `cacheDir` y compartir via `FileProvider`. Sin embargo, la Especificación Visual §J2 muestra explícitamente `"Ubicación: Descargas/"` en la card de confirmación post-export (Body Small, On Tertiary Container). Para que la ubicación mostrada sea veraz, el export usa `ActivityResultContracts.CreateDocument("application/json")` como mecanismo primario: el usuario elige dónde guardar (por defecto Descargas → "Ubicación: Descargas/" en la card coincide con la spec). Tras guardar, el botón "Compartir" (Filled Tonal Button, Secondary Container) lanza `ACTION_SEND` con la URI del archivo guardado. Si el dispositivo no soporta `CreateDocument` (raro en API 26+), se cae al fallback de `cacheDir` + `FileProvider`. Este diseño cumple simultáneamente: CA-18.03 (almacenamiento externo O compartir), CA-18.06 (cero permisos — `CreateDocument` no requiere permisos), y la Especificación Visual §J2 (texto "Descargas/" real).

**11. La confirmación de reemplazo destructivo usa botón estilo Error (CA-18.10).**

J3 paso 3 muestra una `FilledCard` con fondo Error Container, texto "ATENCIÓN: Todos los datos actuales serán reemplazados. Esta operación no es reversible" y botón "Restaurar datos" de color `Error (#BA1A1A)` on `OnError (#FFFFFF)`. Esto cumple el wireframe y la Especificación Visual §J3 — el patrón destructivo es inconfundible.

### Componentes Afectados

**Componentes nuevos:**

| # | Componente | Tipo | Paquete | Responsabilidad |
|---|-----------|------|---------|-----------------|
| 1 | `BackupMetadata` | Nuevo (domain model) | `domain.model` | Metadatos del backup: `appVersion: String`, `schemaVersion: Int`, `exportDate: String`, `recordCount: Int` |
| 2 | `BackupValidationResult` | Nuevo (domain model) | `domain.model` | Resultado de validación de archivo: `isValid: Boolean`, `metadata: BackupMetadata?`, `sessionCount: Int`, `errorMessage: String?` |
| 3 | `BackupRepository` | Nuevo (interfaz) | `domain.repository` | Contrato: `suspend fun exportToJson(): String`, `fun validateBackup(json: String): BackupValidationResult`, `suspend fun importFromJson(json: String)` |
| 4 | `BackupRepositoryImpl` | Nuevo (impl) | `data.repository` | Inyecta `TensionDatabase`. Export: raw SQL `SELECT * FROM table` por cada tabla → `JSONArray` de `JSONObject`. Import: transacción atómica DELETE all → INSERT all sobre las 16 tablas. Valida `schemaVersion` contra `TensionDatabase.VERSION`. Orden FK estricto para delete (children first) e insert (parents first) |
| 5 | `BackupFileManager` | Nuevo (helper) | `data.local.storage` | Inyecta `@ApplicationContext`. `writeToUri(json, uri)` escribe JSON al `Uri` devuelto por `CreateDocument` via `ContentResolver.openOutputStream()`. `readFromUri(uri): String` lee JSON via `ContentResolver.openInputStream()`. `writeToCacheForShare(json, fileName): File` escribe copia temporal a `cacheDir` para compartir via `FileProvider`. `getShareableUri(file): Uri` genera URI compartible via `FileProvider`. `extractDisplayPath(uri): String` extrae ruta legible del URI para mostrar en la card de confirmación |
| 6 | `ExportBackupUseCase` | Nuevo (UseCase) | `domain.usecase.backup` | `operator fun invoke(): String` — delega a `backupRepository.exportToJson()` |
| 7 | `ValidateBackupUseCase` | Nuevo (UseCase) | `domain.usecase.backup` | `operator fun invoke(json: String): BackupValidationResult` — delega a `backupRepository.validateBackup()` |
| 8 | `ImportBackupUseCase` | Nuevo (UseCase) | `domain.usecase.backup` | `operator fun invoke(json: String)` — delega a `backupRepository.importFromJson()` |
| 9 | `ExportBackupScreen` | Nuevo (Composable) | `ui.settings` | Pantalla J2 — 3 fases: IDLE (advertencia sin cifrado + botón "Exportar datos" que lanza `CreateDocument` picker con nombre sugerido `tension_backup_YYYYMMDD.json`), EXPORTING (LinearProgressIndicator indeterminate), SUCCESS (confirmación con nombre + ubicación real extraída del URI + botón "Compartir" que lanza `ACTION_SEND`). Botón retorno → J1 |
| 10 | `ExportBackupViewModel` | Nuevo (HiltViewModel) | `ui.settings` | Estado reactivo para J2. Inyecta `ExportBackupUseCase`, `BackupFileManager`. `export(uri)`: genera JSON → escribe al URI devuelto por `CreateDocument` → actualiza estado con fileName y displayPath. `share(context)`: copia JSON a cache → construye `ACTION_SEND` con `FileProvider` URI |
| 11 | `ExportBackupUiState` | Nuevo (data class) | `ui.settings` | `phase: ExportPhase` (IDLE, EXPORTING, SUCCESS, ERROR — ver Nota 10), `fileName: String?`, `displayPath: String?`, `errorMessage: String?` |
| 12 | `ImportBackupScreen` | Nuevo (Composable) | `ui.settings` | Pantalla J3 — 5 fases: IDLE (botón "Seleccionar archivo" con `OpenDocument` launcher), VALIDATED (card éxito con metadata + advertencia reemplazo + botón destructivo "Restaurar datos" + link "Cancelar"), INVALID (card error), IMPORTING (progreso), SUCCESS (ícono ✅ + texto éxito → auto-navega B1 tras 2s), ERROR (card rollback + botón "Volver a Configuración" → J1) |
| 13 | `ImportBackupViewModel` | Nuevo (HiltViewModel) | `ui.settings` | Estado reactivo para J3. Inyecta `ValidateBackupUseCase`, `ImportBackupUseCase`, `BackupFileManager`. `selectFile(uri)`: lee JSON → valida → almacena JSON en memoria para reutilizar en import. `confirmImport()`: ejecuta `importFromJson()`. `cancel()`: resetea estado |
| 14 | `ImportBackupUiState` | Nuevo (data class) | `ui.settings` | `phase: ImportPhase` (IDLE, VALIDATING, VALIDATED, INVALID, IMPORTING, SUCCESS, ERROR), `validationResult: BackupValidationResult?`, `errorMessage: String?` |

**Componentes modificados:**

| # | Componente | Modificación | Nivel |
|---|-----------|-------------|-------|
| 1 | `SettingsScreen` | Agregar la sección "Datos" al final del body (debajo de la sección "Entrenamiento" que define el selector de frecuencia semanal — HU-15/HU-21, aún no implementado). La sección incluye: encabezado "Datos" (`Label Large, On Surface Variant`), `ListItem` "Exportar respaldo" (clickable → J2, trailing `ChevronRight`), `ListItem` "Importar respaldo" (clickable → J3, trailing `ChevronRight`). Separar de la sección anterior con `Divider` M3 (Especificación Visual §J1). HU-18 solo agrega la sección "Datos" — el encabezado "Entrenamiento" y el selector de frecuencia NO se implementan en esta HU. Agregar 2 lambdas al composable: `onNavigateToExportBackup: () -> Unit` y `onNavigateToImportBackup: () -> Unit` | Medio |
| 2 | `NavigationRoutes` | Agregar `const val EXPORT_BACKUP = "export-backup"` y `const val IMPORT_BACKUP = "import-backup"` | Menor |
| 3 | `TensionNavHost` | Registrar `ExportBackupScreen` y `ImportBackupScreen` como composables en rutas `EXPORT_BACKUP` e `IMPORT_BACKUP`. Conectar lambdas de `SettingsScreen` con `navController.navigate()`. En J3 post-import exitoso: `navController.navigate(HOME) { popUpTo(navController.graph.id) { inclusive = true } }` para limpiar todo el back stack (reinicio lógico) | Medio |
| 4 | `BottomNavigationBar` | Agregar `NavigationRoutes.EXPORT_BACKUP` y `NavigationRoutes.IMPORT_BACKUP` a `childRoutes` del `BottomNavItem` de SETTINGS (que ya contiene `PROFILE` y `WEIGHT_HISTORY`) para que el tab "Configuración" quede seleccionado en J2 y J3 | Menor |
| 5 | `RepositoryModule` | Agregar binding: `@Binds @Singleton abstract fun bindBackupRepository(impl: BackupRepositoryImpl): BackupRepository` | Menor |
| 6 | `AndroidManifest.xml` | Agregar `<provider android:name="androidx.core.content.FileProvider" android:authorities="\${applicationId}.fileprovider" android:exported="false" android:grantUriPermissions="true"><meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" /></provider>`. Cero permisos runtime — SAF + FileProvider no los requieren en API 26+ (CA-18.06, RNF27) | Menor |
| 7 | `strings.xml` | Agregar ~25 strings: títulos J2/J3, texto advertencia sin cifrado, botones "Exportar datos"/"Compartir"/"Seleccionar archivo"/"Restaurar datos"/"Cancelar", estados de progreso ("Exportando datos..."/"Restaurando datos..."), confirmación éxito, textos de validación OK/error, advertencia destructiva de reemplazo, texto de rollback, ubicación del archivo | Menor |

**Recurso nuevo:**

| # | Recurso | Tipo | Ubicación | Contenido |
|---|---------|------|-----------|-----------|
| 1 | `file_paths.xml` | XML resource | `res/xml/` | `<paths><cache-path name="backups" path="." /></paths>` — expone `cacheDir` al `FileProvider` para que `ACTION_SEND` pueda compartir el archivo JSON exportado |

**Componentes reutilizados (existentes, sin modificación):**

| # | Componente | Paquete | Uso en HU-18 |
|---|-----------|---------|---------------|
| R1 | `TensionDatabase` | `data.local.database` | Inyectado en `BackupRepositoryImpl` para acceso a `openHelper.writableDatabase` (raw SQL export/import). No se modifica — versión se mantiene en 7 |
| R2 | `TensionTopAppBar` | `ui.components` | Barra superior reutilizada en J2 y J3 (CenterAligned con ArrowBack → J1) |
| R3 | `ImageStorageHelper` | `data.local.storage` | Precedente arquitectónico para `BackupFileManager` — mismo patrón de inyección de `@ApplicationContext` y uso de `ContentResolver` |

**Componentes NO tocados (verificado en código):**

- Las 16 entidades (`*Entity.kt`) — cero cambios de esquema, cero migraciones. La versión de la BD permanece en 7
- Los 15 DAOs — el backup usa raw SQL, no queries tipadas de DAO
- `TensionDatabase.kt` — no se modifica (version = 7, exportSchema = false, PrepopulateCallback intacto)
- `DatabaseModule.kt` — `TensionDatabase` ya es `@Singleton` inyectable, no necesita nuevo provider
- Seeders (`ModuleSeeder`, `ExerciseSeeder`, `PlanSeeder`) — no se tocan; los datos seed se incluyen en el dump JSON como cualquier otra tabla
- Todos los flujos UI existentes: B (Home), C (Perfil), D (Catálogo), E (Sesión), F (Historial), G (Métricas), H (Alertas), I (Descarga)
- `Converters.kt` — no se modifica; el backup exporta fechas como strings tal como Room las almacena

### Hitos de Implementación

| # | Componente(s) | Descripción | Dependencias |
|---|--------------|-------------|--------------|
| 1 | Domain Models | Crear `BackupMetadata` y `BackupValidationResult` en `domain.model` | Ninguna |
| 2 | BackupRepository | Crear interfaz `BackupRepository` (en `domain.repository`) y `BackupRepositoryImpl` (en `data.repository`). El Impl inyecta `TensionDatabase`, accede a `openHelper.writableDatabase` para raw SQL. Export: loop sobre 16 tablas en orden, cursor → JSONArray. Import: transacción atómica, DELETE children-first, INSERT parents-first. Validate: parsea header JSON, verifica schemaVersion. Agregar binding en `RepositoryModule` | Hito 1 |
| 3 | BackupFileManager + FileProvider | Crear `BackupFileManager` en `data.local.storage` con inyección de `@ApplicationContext`. Métodos: `writeToCache()`, `readFromUri()`, `getShareableUri()`. Crear `file_paths.xml` en `res/xml/`. Agregar `<provider>` en `AndroidManifest.xml` | Ninguna |
| 4 | Use Cases | Crear `ExportBackupUseCase`, `ValidateBackupUseCase`, `ImportBackupUseCase` en `domain.usecase.backup` | Hito 2 |
| 5 | J2 — Exportar Respaldo | Crear `ExportBackupScreen`, `ExportBackupViewModel`, `ExportBackupUiState`. 3 fases visuales (IDLE/EXPORTING/SUCCESS). Botón "Exportar datos" lanza `CreateDocument` picker. Post-guardado: card con ubicación real. Botón "Compartir" construye `Intent.ACTION_SEND` con copia en cache via `FileProvider`. Agregar ruta `EXPORT_BACKUP` en `NavigationRoutes` | Hitos 3, 4 |
| 6 | J3 — Importar Respaldo | Crear `ImportBackupScreen`, `ImportBackupViewModel`, `ImportBackupUiState`. 5 fases visuales (IDLE/VALIDATED~INVALID/IMPORTING/SUCCESS~ERROR). `rememberLauncherForActivityResult(OpenDocument)`. Botón destructivo "Restaurar datos". Post-éxito: delay 2s → navegar a B1 limpiando back stack. Agregar ruta `IMPORT_BACKUP` en `NavigationRoutes` | Hitos 3, 4 |
| 7 | Settings + Navegación | Modificar `SettingsScreen` (agregar 2 ListItems con lambdas). Registrar J2/J3 en `TensionNavHost`. Conectar lambdas. Agregar `EXPORT_BACKUP` e `IMPORT_BACKUP` a `childRoutes` del tab SETTINGS en `BottomNavigationBar` | Hitos 5, 6 |
| 8 | Strings | Agregar ~25 strings en `strings.xml` para títulos, advertencias, botones, estados, validación, rollback | Hitos 5, 6 |
| 9 | Tests unitarios | Tests para `BackupRepositoryImpl` (export/import/validate con Room in-memory DB), `BackupFileManager` (write/read mock), Use Cases, boundary cases: JSON corrupto, schemaVersion diferente, rollback ante excepción, export vacío (sin sesiones) | Todos |

### Validación de Impacto

**Código real verificado (paso 1.5):**

- `TensionDatabase.kt`: version = 7, exportSchema = false, 16 entities, 15 abstract DAO methods. `openHelper.writableDatabase` es accesible para raw SQL. `PrepopulateCallback` se ejecuta en `onCreate` y `onDestructiveMigration` — no interfiere con import (el import no destruye la BD, solo reemplaza datos dentro de la transacción existente).
- `DatabaseModule.kt`: `TensionDatabase` ya es `@Singleton` provisto por Hilt vía `provideTensionDatabase()`. No necesita nuevo provider — se inyecta directamente en `BackupRepositoryImpl`.
- `RepositoryModule.kt` (67 líneas): 6 bindings existentes (`Profile`, `Exercise`, `Plan`, `Session`, `Metrics`, `Alert`). Se agrega el 7mo: `BackupRepository` → `BackupRepositoryImpl`.
- `NavigationRoutes.kt` (38 líneas): 25 rutas definidas. No hay `EXPORT_BACKUP` ni `IMPORT_BACKUP`. Se agregan 2 rutas nuevas (sin argumentos).
- `TensionNavHost.kt` (422 líneas): `SettingsScreen` en L155 solo tiene `onNavigateToProfile`. No hay J2/J3 ni TODOs de backup. Se agregan 2 lambdas (`onNavigateToExportBackup`, `onNavigateToImportBackup`) y 2 composables nuevos.
- `SettingsScreen.kt` (50 líneas): Scaffold + TopBar + 1 ListItem "Editar perfil" + Divider. No hay items de backup ni sección "Entrenamiento" (frecuencia semanal — pendiente de HU-15). Se agrega la sección "Datos" con Divider + encabezado + 2 ListItems de backup + 2 lambdas.
- `BottomNavigationBar.kt` (148 líneas): Tab SETTINGS tiene `childRoutes = setOf(PROFILE, WEIGHT_HISTORY)`. Se agregan `EXPORT_BACKUP` e `IMPORT_BACKUP`.
- `ImageStorageHelper.kt` (41 líneas): Usa `context.contentResolver.openInputStream(uri)` — precedente exacto para `BackupFileManager`. Está en `data.local.storage`.
- `AndroidManifest.xml`: No hay `FileProvider` declarado ni permisos. Se agrega `<provider>` para `FileProvider`.
- `libs.versions.toml` / `build.gradle.kts`: No hay `kotlinx-serialization`, `moshi`, ni `gson`. Se confirma uso de `org.json` (Android SDK built-in).
- `Migrations.kt`: Solo `MIGRATION_6_7` (reasignación de ejercicios entre módulos). No hay migraciones de backup.
- `Converters.kt`: Convierte `LocalDate ↔ String`. Las fechas en la BD ya son Text (ISO format) — el backup las exporta tal cual como strings.

**Estructura JSON del backup (ADR-10):**

```json
{
  "metadata": {
    "appVersion": "1.0",
    "schemaVersion": 7,
    "exportDate": "2026-02-20T14:30:00",
    "recordCount": 30247
  },
  "data": {
    "profile": [{ "id": 1, "height_m": 1.75, ... }],
    "weight_record": [...],
    "module": [...],
    "muscle_zone": [...],
    "equipment_type": [...],
    "exercise": [...],
    "exercise_muscle_zone": [...],
    "module_version": [...],
    "plan_assignment": [...],
    "rotation_state": [...],
    "session": [...],
    "session_exercise": [...],
    "exercise_set": [...],
    "exercise_progression": [...],
    "alert": [...],
    "deload": [...]
  }
}
```

**Orden FK para DELETE (children first):**

`exercise_set` → `session_exercise` → `session` → `exercise_progression` → `alert` → `plan_assignment` → `exercise_muscle_zone` → `exercise` → `module_version` → `deload` → `equipment_type` → `muscle_zone` → `module` → `weight_record` → `rotation_state` → `profile`

**Orden FK para INSERT (parents first):**

`profile` → `rotation_state` → `weight_record` → `module` → `muscle_zone` → `equipment_type` → `deload` → `exercise` → `exercise_muscle_zone` → `module_version` → `plan_assignment` → `session` → `session_exercise` → `exercise_set` → `exercise_progression` → `alert`

**Análisis de dependencias:**

- HU-18 depende de: Todas las HUs anteriores (HU-01 a HU-17) en el sentido de que las 16 tablas que exporta fueron definidas y pobladas por esas HUs. Sin embargo, HU-18 no modifica ningún componente de datos — solo lee y escribe la BD completa como bloque.
- HU-18 NO introduce nuevas entidades ni migraciones — la tabla `alert` (HU-12/HU-17) con alertas resueltas se exporta como histórico dentro del dump JSON.
- HU-18 es la **última HU** del sistema (consolidación de HU-31 y HU-32 originales). No habilita historias futuras.

**Impacto en performance:**

- Export: Raw SQL `SELECT * FROM table` × 16 tablas + serialización a JSON string. Para el caso típico de 2 años (~730 sesiones × 10 ejercicios × 4 series = ~30,000 registros de `exercise_set`), el JSON resultante es ~5-15 MB. La escritura a `cacheDir` y la serialización ejecutan en < 5 segundos. Cumple CA-18.04 (< 10s).
- Import: Lectura JSON desde URI (~5-15 MB) + parseo + transacción DELETE/INSERT × 16 tablas. Total < 8 segundos para datos máximos. Cumple CA-18.13.
- Memoria: El JSON se mantiene in-memory como `String` durante la importación. Para 15 MB, esto es trivial (~4+ GB RAM en dispositivos Android modernos).
- Post-import: La navegación a B1 limpia todo el back stack — los ViewModels se recrean con Flows frescos. No se necesita invalidación manual del cache de Room.

### Notas Técnicas

**Nota 1 — `FileProvider` para compartir como acción secundaria.**

Android requiere `FileProvider` para compartir archivos desde `cacheDir` con otras apps vía `Intent.ACTION_SEND`. Se usa como acción secundaria DESPUÉS del guardado primario con `CreateDocument`. La configuración requiere: (a) `<provider>` en `AndroidManifest.xml` con `android:authorities="${applicationId}.fileprovider"`, `android:exported="false"`, `android:grantUriPermissions="true"`, y un `<meta-data>` apuntando a `@xml/file_paths`, (b) `file_paths.xml` en `res/xml/` con `<cache-path name="backups" path="." />` que expone el `cacheDir`. El `Intent` para compartir: `Intent(ACTION_SEND).setType("application/json").putExtra(EXTRA_STREAM, FileProvider.getUriForFile(ctx, authority, file)).addFlags(FLAG_GRANT_READ_URI_PERMISSION)`. Este pattern es estándar en Android y no requiere permisos runtime.

**Nota 2 — `ActivityResultContracts.OpenDocument` para selección de archivo.**

En J3, se usa `rememberLauncherForActivityResult(ActivityResultContracts.OpenDocument())` con MIME type `"application/json"`. Esto lanza el picker nativo del sistema que permite seleccionar archivos desde almacenamiento local, Google Drive, Gmail (adjuntos), etc. El archivo retorna como `Uri` → `ContentResolver.openInputStream(uri)` → `BufferedReader.readText()` → JSON string. Si el usuario cancela el picker, el launcher retorna `null` y no se hace nada.

**Nota 3 — Transacción atómica SQLite garantiza rollback (CA-18.15).**

El pattern:
```kotlin
val db = database.openHelper.writableDatabase
db.beginTransaction()
try {
    // DELETE all tables (children first)
    TABLE_ORDER_DELETE.forEach { table -> db.execSQL("DELETE FROM $table") }
    // INSERT all data (parents first)
    TABLE_ORDER_INSERT.forEach { table ->
        val rows = jsonData.getJSONArray(table)
        for (i in 0 until rows.length()) {
            db.insert(table, CONFLICT_REPLACE, rows.getJSONObject(i).toContentValues())
        }
    }
    db.setTransactionSuccessful()
} finally {
    db.endTransaction()
}
```
Si CUALQUIER excepción ocurre entre `beginTransaction()` y `setTransactionSuccessful()`, el `finally { endTransaction() }` revierte TODAS las operaciones. Los datos originales se preservan intactos.

**Nota 4 — Validación del backup antes de importar (CA-18.09).**

La validación ocurre ANTES de la confirmación destructiva. Se verifica: (a) el string es JSON válido (`JSONObject(json)` no lanza `JSONException`), (b) existe el campo `metadata` con `appVersion`, `schemaVersion`, `exportDate`, (c) `schemaVersion == TensionDatabase.VERSION` (actualmente 7), (d) existe el campo `data` con al menos las tablas obligatorias. Si alguna verificación falla, se muestra la card de error (Especificación Visual §J3, paso 2 inválido) y no se procede. Si es válido, se muestra la card de validación OK con metadata + conteo de sesiones extraído de `data.session.length()`.

**Nota 5 — Post-import navegación con delay de 2 segundos.**

La Especificación Visual §J3 resultado OK dice "Navegación automática a B1 tras 2 segundos". Esto se implementa con `LaunchedEffect(Unit) { delay(2000L); onNavigateToHome() }` en el composable de la fase SUCCESS. El ViewModel expone un navigation event one-shot. La lambda `onNavigateToHome` ejecuta `navController.navigate(HOME) { popUpTo(navController.graph.id) { inclusive = true } }` — limpia TODA la pila de navegación, reiniciando la app lógicamente con los datos restaurados.

**Nota 6 — Seed data se incluye en el backup.**

Las tablas `module`, `muscle_zone`, `equipment_type`, `exercise`, `exercise_muscle_zone`, `module_version`, `plan_assignment` contienen datos de seed prepopulados. El backup las exporta como cualquier otra tabla. Al importar, se reemplazan completas (DELETE + INSERT). Esto es correcto porque: (a) el usuario puede haber creado ejercicios custom (`is_custom = true`) que están mezclados con los seed, (b) el seed podría diferir entre versiones de la app, (c) la integridad referencial se mantiene porque se importan todas las tablas como bloque atómico.

**Nota 7 — `CreateDocument` como mecanismo primario de guardado.**

El flujo de export usa `ActivityResultContracts.CreateDocument("application/json")` que abre el file picker nativo para elegir dónde guardar. El nombre de archivo sugerido es `tension_backup_YYYYMMDD.json`. El picker por defecto abre la carpeta Descargas. El usuario puede cambiar la ubicación (Drive, otra carpeta, etc.). Tras confirmar, `CreateDocument` retorna un `Uri` → se escribe el JSON via `ContentResolver.openOutputStream(uri)`. La card de confirmación muestra la ubicación real extraída del URI. El botón "Compartir" (secundario) copia el JSON a `cacheDir` y lo comparte via `FileProvider` + `ACTION_SEND` para enviar a Drive, correo, mensajería. Si el usuario cancela el `CreateDocument` picker, se retorna al estado IDLE sin cambios.

**Nota 8 — Bottom Navigation en J2 y J3.**

La Arquitectura Técnica §4.5.1 lista J2 y J3 en el grupo "Siempre visible" para Bottom Nav. El `showBottomBar` en `TensionNavHost.kt` usa un blocklist — como `export-backup` e `import-backup` no están bloqueados, Bottom Nav se muestra automáticamente. Para que el tab "Configuración" quede seleccionado, se agregan ambas rutas a `childRoutes` del tab SETTINGS en `BottomNavigationBar.kt` (que ya contiene `PROFILE` y `WEIGHT_HISTORY`).

**Nota 9 — Texto "Ubicación: Descargas/" en la card de confirmación J2.**

La Especificación Visual §J2 define explícitamente que la card de confirmación post-export muestra `"Ubicación: Descargas/"` como texto fijo (Body Small, On Tertiary Container). Sin embargo, la decisión de diseño #3 establece que el archivo se escribe a `cacheDir` (no directamente a Descargas) y se comparte via `FileProvider` + `ACTION_SEND`. Para resolver esta discrepancia: el export usa `ActivityResultContracts.CreateDocument("application/json")` como mecanismo primario, que permite al usuario elegir la carpeta de destino (por defecto Descargas). El texto de la card se actualiza dinámicamente con la URI de destino devuelta por `CreateDocument`. Si el usuario confirma guardar en Descargas (el comportamiento por defecto), el texto mostrado será "Ubicación: Descargas/" — coincidiendo con la spec. El botón "Compartir" (Filled Tonal Button) se ofrece como acción secundaria post-guardado para enviar el archivo vía apps del sistema (Drive, correo, mensajería). Esto cumple simultáneamente CA-18.03 ("almacenar en almacenamiento externo O compartir vía apps") y la Especificación Visual §J2.

**Nota 10 — `ExportBackupUiState` incluye fase ERROR como adición defensiva.**

Ni el wireframe §J2 ni la Especificación Visual §J2 definen un estado de error para la exportación — el flujo documentado es lineal: pre-export → durante → post-export. Sin embargo, `ExportBackupUiState` incluye la fase ERROR como protección ante fallos inesperados (disco lleno, error de I/O, JSON generation failure). En caso de error, se muestra un `Snackbar` con mensaje descriptivo y el botón "Exportar datos" se rehabilita para reintentar. Esta es una adición defensiva de implementación que no contradice la spec.

**Nota 11 — Sección "Entrenamiento" en J1 (frecuencia semanal) NO implementada por HU-18.**

El wireframe §J1 y la Especificación Visual §J1 definen 3 secciones en la pantalla de Configuración: (1) Perfil — "Editar perfil" → C1, (2) Entrenamiento — selector de frecuencia semanal (4/5/6 chips, CA-21.05/HU-15), (3) Datos — "Exportar respaldo" → J2, "Importar respaldo" → J3. La sección "Entrenamiento" con el selector de frecuencia pertenece a HU-15 (consolidación de HU-21 original) y NO fue implementada por HU-15 (que se enfocó en las pantallas de métricas G1-G3 y usó `profile.weekly_frequency` como lectura). HU-18 solo agrega la sección "Datos" — el selector de frecuencia queda pendiente como deuda visual de HU-15. El `SettingsScreen.kt` actual (50 líneas) solo contiene el ListItem "Editar perfil", y HU-18 agrega debajo un Divider + encabezado "Datos" + 2 ListItems de backup.

### Verificación Cruzada de CAs

| CA | Mecanismo | Componente |
|----|-----------|------------|
| CA-18.01 | Raw SQL `SELECT * FROM table` × 16 tablas → `JSONObject` con metadata header + `data` object con 16 arrays | `BackupRepositoryImpl.exportToJson()` |
| CA-18.02 | JSON raíz con `metadata: { appVersion, schemaVersion, exportDate }` + `data: { table: [...] }`. `schemaVersion` = `TensionDatabase.VERSION` (7) | `BackupRepositoryImpl.exportToJson()` — estructura dictada por ADR-10 |
| CA-18.03 | `CreateDocument("application/json")` como mecanismo primario: el usuario elige dónde guardar (por defecto Descargas). Post-guardado, botón "Compartir" envía copia via `ACTION_SEND` + `FileProvider`. El share sheet permite: Drive, Correo, Mensajería | `BackupFileManager.writeToUri()` + `ExportBackupViewModel.share()` |
| CA-18.04 | Raw SQL sequencial sobre 16 tablas + serialización JSON. ~30K registros → ~5-15 MB JSON. Ejecuta en `Dispatchers.IO`. Total < 5s | `BackupRepositoryImpl.exportToJson()` ejecutado en coroutine IO |
| CA-18.05 | `OutlinedCard` con ícono ⚠️ y texto "El archivo de respaldo contiene todos tus datos de entrenamiento y no está cifrado" visible ANTES del botón "Exportar datos" | `ExportBackupScreen` — card pre-export (Especificación Visual §J2) |
| CA-18.06 | Cero permisos runtime. SAF (`OpenDocument`) y `FileProvider` no requieren permisos en API 26+. `AndroidManifest.xml` sin `<uses-permission>` | Toda la cadena: sin `WRITE_EXTERNAL_STORAGE` ni `READ_EXTERNAL_STORAGE` |
| CA-18.07 | `LinearProgressIndicator` indeterminate durante export. Post-export: `FilledCard` Tertiary Container con ✅, "Respaldo exportado" (Title Medium), "Archivo: tension_backup_YYYYMMDD.json" (Body Medium), "Ubicación: Descargas/" (Body Small) — ver Nota 9 sobre la resolución de ubicación. Botón "Compartir" (Filled Tonal Button) abre share sheet nativo | `ExportBackupScreen` fases EXPORTING y SUCCESS |
| CA-18.08 | `rememberLauncherForActivityResult(OpenDocument("application/json"))`. Lanza file picker nativo que muestra archivos locales, Drive, Gmail, etc. | `ImportBackupScreen` — `OpenDocument` launcher |
| CA-18.09 | Parseo JSON → verificar `metadata.schemaVersion` == `TensionDatabase.VERSION`, verificar estructura `data` con tablas esperadas. Si inválido: card Error Container con ❌ y mensaje claro | `BackupRepositoryImpl.validateBackup()` → `ImportBackupScreen` fase INVALID |
| CA-18.10 | `FilledCard` Error Container + texto "ATENCIÓN: Todos los datos actuales serán reemplazados. Esta operación no es reversible." + botón destructivo Error (#BA1A1A) "Restaurar datos" + link "Cancelar" → J1 | `ImportBackupScreen` fase VALIDATED, paso 3 |
| CA-18.11 | Transacción atómica: DELETE FROM × 16 tablas (children first) + INSERT INTO × 16 tablas (parents first). Cubre: profile, weight_record, session, exercise_set, rotation_state, exercise_progression, deload, alert, y todas las tablas de seed | `BackupRepositoryImpl.importFromJson()` |
| CA-18.12 | Validación de `schemaVersion`. Si versión anterior/posterior ≠ actual (7), la importación se rechaza con mensaje informativo. Infraestructura de migración de backups como stub para v2+ | `BackupRepositoryImpl.validateBackup()` — `schemaVersion != VERSION → invalid` |
| CA-18.13 | Same análisis que CA-18.04. Lectura URI + parseo JSON + transacción DELETE/INSERT. Total < 8s para ~30K registros | `BackupRepositoryImpl.importFromJson()` en `Dispatchers.IO` |
| CA-18.14 | `LinearProgressIndicator` indeterminate durante import. Post-import éxito: ícono ✅ 48dp + "Datos restaurados exitosamente." → auto-navegación a B1 tras 2 segundos | `ImportBackupScreen` fases IMPORTING y SUCCESS |
| CA-18.15 | `db.beginTransaction()` / `db.setTransactionSuccessful()` / `finally { db.endTransaction() }`. Si excepción en DELETE o INSERT, `endTransaction()` revierte automáticamente. Card error: "La importación falló. Tus datos originales han sido preservados." + botón "Volver a Configuración" → J1 | `BackupRepositoryImpl.importFromJson()` + `ImportBackupScreen` fase ERROR |

### Referencias y Validación

**Documentación consultada:**

- Wireframes — [Wireframes.md](docs/architecture/Wireframes.md) (§J2 Exportar Respaldo 8 elementos, §J3 Importar Respaldo 11 elementos)
- Mapa de Navegación — [Mapa de Navegación.md](docs/architecture/Mapa%20de%20Navegación.md) (§J1 transiciones J1↔J2/J3, §J2 retorno J1, §J3 éxito→B1 + cancelar→J1)
- Especificación Visual — [Especificación Visual.md](docs/architecture/Especificación%20Visual.md) (§J2 component specs pre/durante/post, §J3 5-step specs con card destructiva)
- Modelo de Datos — [Modelo de Datos.md](docs/architecture/Modelo%20de%20Datos.md) (16 tablas §3.1-§3.16, orden FK, columnas por tabla)
- Arquitectura Técnica — [Arquitectura Técnica.md](docs/architecture/Arquitectura%20Técnica.md) (§3.2 paquete ui.settings, §4.3 rutas J2/J3, §4.4 settings-graph, §4.5 showBottomBar "Siempre visible", §4.5.1 J3→B1 reinicio post-importación, §5.2 naming BackupRepository)
- ADR — [ADR.md](docs/architecture/ADR.md) (ADR-10 JSON como formato de backup, ADR-15 sin cifrado, ADR-03 Room, ADR-05 MVVM Domain)
- Requerimientos — [Requerimientos.md](docs/business_definition/Requerimientos.md) (RNF15, RNF16, RNF17, RNF18, RNF26, RNF27)

**Historias relacionadas:**

- Historia #17 (HU-17): Sistema de Alertas — la tabla `alert` con alertas activas y resueltas se incluye en el backup como histórico
- Todas las HUs #01-#17: Definen las 16 tablas que componen el modelo de datos completo exportado por HU-18. Ningún componente de las HUs anteriores se modifica.

**Validado por:** esteban.colorado | **Fecha:** 2026-02-20 | **Enfoque:** Exploratorio