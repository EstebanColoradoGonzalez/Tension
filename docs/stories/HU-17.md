# HU-17 ‚Äî Sistema de Alertas

## Requisitos relacionados

RF53, RF54, RF55, RF56, RF57, RF58, RNF05

## Descripci√≥n

Como ejecutante, quiero que el sistema emita alertas proactivas con dos niveles de severidad (alerta y crisis) cuando detecte condiciones que requieran mi atenci√≥n ‚Äî tasa de progresi√≥n baja, RIR fuera de rango por m√≥dulo, adherencia semanal insuficiente, ca√≠da de tonelaje por grupo muscular o inactividad prolongada por m√≥dulo ‚Äî para recibir se√±ales tempranas y objetivas de problemas antes de que comprometan mis adaptaciones, sin que estas se√±ales bloqueen mi autonom√≠a de entrenamiento.

## Historias originales consolidadas

Esta historia consolida las siguientes historias del dise√±o original, que comparten la misma tabla (`alert`), las mismas pantallas (H1/H2), el mismo patr√≥n (alerta vs. crisis, informativo, no bloqueante, retiro autom√°tico) y la misma infraestructura visual (RNF05):

- **HU-26 original** ‚Äî Alertas de tasa de progresi√≥n baja (RF53)
- **HU-27 original** ‚Äî Alertas de RIR por m√≥dulo (RF54, RF55)
- **HU-28 original** ‚Äî Alertas de adherencia baja (RF56)
- **HU-29 original** ‚Äî Alertas de ca√≠da de tonelaje por grupo muscular (RF57)
- **HU-30 original** ‚Äî Alertas de inactividad por m√≥dulo (RF58)

---

## Criterios de Aceptaci√≥n

### Bloque A ‚Äî Alertas de Tasa de Progresi√≥n Baja (RF53)

#### CA-17.01 ‚Äî Alerta por tasa de progresi√≥n < 40%

**Dado que** el sistema calcula la Tasa de Progresi√≥n de un ejercicio en un per√≠odo de 4 semanas,
**cuando** el resultado es menor al 40%,
**entonces** emite una alerta informativa indicando el nombre del ejercicio, su tasa de progresi√≥n actual y que est√° por debajo del umbral de alerta.

#### CA-17.02 ‚Äî Alerta de crisis por tasa de progresi√≥n < 20%

**Dado que** el sistema calcula la Tasa de Progresi√≥n de un ejercicio en un per√≠odo de 4 semanas,
**cuando** el resultado es menor al 20%,
**entonces** emite una alerta de crisis con mayor urgencia visual, indicando el nombre del ejercicio, su tasa de progresi√≥n actual y que est√° en estado cr√≠tico de estancamiento.

#### CA-17.03 ‚Äî Diferenciaci√≥n visual entre alerta y crisis de progresi√≥n

**Dado que** el sistema emite una alerta de tasa de progresi√≥n,
**cuando** el ejecutante visualiza la alerta,
**entonces** la alerta de nivel normal (< 40%) y la de crisis (< 20%) son visualmente distinguibles entre s√≠ mediante colores e iconograf√≠a diferenciada, sin depender √∫nicamente del texto.

#### CA-17.04 ‚Äî Alertas de progresi√≥n informativas, no bloqueantes

**Dado que** el sistema emite una alerta de tasa de progresi√≥n baja,
**cuando** el ejecutante interact√∫a con el sistema,
**entonces** la alerta es informativa y no impide iniciar sesiones, registrar series ni cerrar sesiones; el ejecutante mantiene autonom√≠a total.

#### CA-17.05 ‚Äî Evaluaci√≥n peri√≥dica de progresi√≥n

**Dado que** el sistema eval√∫a la tasa de progresi√≥n,
**cuando** se completa un per√≠odo de 4 semanas o un microciclo,
**entonces** recalcula la tasa y emite o retira alertas seg√∫n corresponda al estado actual de cada ejercicio.

### Bloque B ‚Äî Alertas de RIR por M√≥dulo (RF54, RF55)

#### CA-17.06 ‚Äî Alerta por RIR Promedio < 1.5 (intensidad excesiva)

**Dado que** el sistema calcula el RIR Promedio de un m√≥dulo,
**cuando** el resultado es < 1.5 de forma sostenida durante 2 o m√°s sesiones del mismo m√≥dulo,
**entonces** emite una alerta al ejecutante indicando: el m√≥dulo afectado, el RIR Promedio actual, que est√° entrenando demasiado cerca del fallo t√©cnico de forma sostenida, y recomienda prescribir una descarga para permitir recuperaci√≥n del SNC.

#### CA-17.07 ‚Äî Alerta por RIR Promedio > 3.5 (intensidad insuficiente)

**Dado que** el sistema calcula el RIR Promedio de un m√≥dulo,
**cuando** el resultado es > 3.5 de forma sostenida durante 2 o m√°s sesiones del mismo m√≥dulo,
**entonces** emite una alerta al ejecutante indicando: el m√≥dulo afectado, el RIR Promedio actual, que el est√≠mulo puede ser insuficiente para generar adaptaci√≥n, y recomienda incrementar la carga de los ejercicios del m√≥dulo.

#### CA-17.08 ‚Äî Condici√≥n de "sostenido" durante 2+ sesiones

**Dado que** el sistema eval√∫a si el RIR Promedio est√° fuera de rango de forma sostenida,
**cuando** determina si emitir la alerta,
**entonces** verifica que la condici√≥n (< 1.5 o > 3.5) se cumple en las √∫ltimas 2 o m√°s sesiones consecutivas del mismo m√≥dulo; una sola sesi√≥n fuera de rango no dispara la alerta.

#### CA-17.09 ‚Äî Diferenciaci√≥n visual entre alertas de RIR

**Dado que** el sistema emite alertas de RIR por m√≥dulo,
**cuando** el ejecutante visualiza las alertas,
**entonces** la alerta por RIR bajo (< 1.5, riesgo de fatiga) y la alerta por RIR alto (> 3.5, est√≠mulo insuficiente) son visualmente distinguibles entre s√≠ mediante colores e iconograf√≠a diferenciada.

#### CA-17.10 ‚Äî Alertas de RIR informativas, no bloqueantes

**Dado que** el sistema emite una alerta de RIR por m√≥dulo,
**cuando** el ejecutante interact√∫a con el sistema,
**entonces** la alerta es informativa; no impide entrenar ni fuerza una descarga autom√°tica. El ejecutante decide si seguir la recomendaci√≥n.

#### CA-17.11 ‚Äî Retiro autom√°tico de alerta de RIR

**Dado que** el sistema ha emitido una alerta de RIR por m√≥dulo,
**cuando** las sesiones posteriores del m√≥dulo retornan el RIR Promedio a la zona √≥ptima (1.5-3.5),
**entonces** el sistema retira la alerta activa para ese m√≥dulo.

### Bloque C ‚Äî Alertas de Adherencia Baja (RF56)

#### CA-17.12 ‚Äî Alerta informativa por adherencia < 60% en una semana

**Dado que** el sistema calcula el √çndice de Adherencia al finalizar una semana natural,
**cuando** el resultado es < 60%,
**entonces** emite una alerta informativa indicando la adherencia de la semana, cu√°ntas sesiones se completaron respecto al objetivo, y que la baja frecuencia puede afectar la resoluci√≥n temporal de las se√±ales del sistema.

#### CA-17.13 ‚Äî Alerta de crisis por adherencia < 60% durante 2+ semanas consecutivas

**Dado que** el sistema calcula el √çndice de Adherencia semanal,
**cuando** el resultado es < 60% durante 2 o m√°s semanas consecutivas,
**entonces** emite una alerta de crisis con mayor urgencia visual, indicando la racha de semanas con baja adherencia y advirtiendo que las comparaciones entre sesiones pierden validez por el excesivo tiempo entre ellas.

#### CA-17.14 ‚Äî Diferenciaci√≥n visual entre alerta y crisis de adherencia

**Dado que** el sistema emite alertas de adherencia,
**cuando** el ejecutante visualiza las alertas,
**entonces** la alerta informativa (1 semana < 60%) y la de crisis (2+ semanas < 60%) son visualmente distinguibles mediante colores e iconograf√≠a diferenciada.

#### CA-17.15 ‚Äî Alertas de adherencia informativas, no bloqueantes

**Dado que** el sistema emite una alerta de adherencia baja,
**cuando** el ejecutante interact√∫a con el sistema,
**entonces** la alerta es informativa; no impide entrenar, registrar sesiones ni acceder a ninguna funcionalidad. El ejecutante es aut√≥nomo.

#### CA-17.16 ‚Äî Retiro de alerta de crisis de adherencia

**Dado que** el sistema ha emitido una alerta de crisis por adherencia,
**cuando** el ejecutante completa una semana con adherencia ‚â• 60%,
**entonces** el sistema retira la alerta de crisis, manteniendo el registro hist√≥rico de las semanas con baja adherencia.

### Bloque D ‚Äî Alertas de Ca√≠da de Tonelaje por Grupo Muscular (RF57)

#### CA-17.17 ‚Äî Alerta por ca√≠da de tonelaje > 10%

**Dado que** el sistema calcula el Tonelaje por Grupo Muscular al completar un microciclo,
**cuando** el tonelaje de un grupo muscular cae m√°s del 10% respecto al microciclo anterior,
**entonces** emite una alerta indicando el grupo muscular afectado, el porcentaje de ca√≠da y el tonelaje comparado de ambos microciclos.

#### CA-17.18 ‚Äî Alerta de crisis por ca√≠da de tonelaje > 20%

**Dado que** el sistema calcula el Tonelaje por Grupo Muscular al completar un microciclo,
**cuando** el tonelaje de un grupo muscular cae m√°s del 20% respecto al microciclo anterior,
**entonces** emite una alerta de crisis con mayor urgencia visual, indicando que la p√©rdida de volumen es severa y puede comprometer las adaptaciones del grupo muscular.

#### CA-17.19 ‚Äî Verificaci√≥n de descarga planificada

**Dado que** el sistema detecta una ca√≠da de tonelaje en un grupo muscular,
**cuando** analiza la causa de la ca√≠da,
**entonces** verifica si el microciclo evaluado corresponde a un per√≠odo de descarga activa (HU-14); si es descarga planificada, la alerta se contextualiza como "Ca√≠da esperada por descarga" y no se clasifica como crisis.

#### CA-17.20 ‚Äî Diferenciaci√≥n entre descarga y regresi√≥n

**Dado que** el sistema emite una alerta de ca√≠da de tonelaje,
**cuando** la ca√≠da corresponde a una descarga planificada,
**entonces** la alerta indica claramente "Descarga planificada ‚Äî ca√≠da de tonelaje esperada y controlada", diferenci√°ndola de una regresi√≥n no intencional.

#### CA-17.21 ‚Äî Diferenciaci√≥n visual entre alerta y crisis de tonelaje

**Dado que** el sistema emite alertas de tonelaje,
**cuando** el ejecutante visualiza las alertas,
**entonces** la alerta de nivel normal (> 10%) y la de crisis (> 20%) son visualmente distinguibles mediante colores e iconograf√≠a diferenciada.

#### CA-17.22 ‚Äî Alertas de tonelaje informativas, no bloqueantes

**Dado que** el sistema emite una alerta de ca√≠da de tonelaje,
**cuando** el ejecutante interact√∫a con el sistema,
**entonces** la alerta es informativa y no impide ninguna operaci√≥n del ejecutante.

### Bloque E ‚Äî Alertas de Inactividad por M√≥dulo (RF58)

#### CA-17.23 ‚Äî Alerta por inactividad > 10 d√≠as naturales

**Dado que** el sistema monitorea la √∫ltima fecha de ejecuci√≥n de cada m√≥dulo,
**cuando** transcurren m√°s de 10 d√≠as naturales sin que se ejecute un m√≥dulo espec√≠fico (A, B o C),
**entonces** emite una alerta indicando el m√≥dulo inactivo, la cantidad de d√≠as transcurridos desde su √∫ltima ejecuci√≥n y los grupos musculares asociados que pueden verse afectados.

#### CA-17.24 ‚Äî Alerta de crisis por inactividad > 14 d√≠as naturales

**Dado que** el sistema monitorea la √∫ltima fecha de ejecuci√≥n de cada m√≥dulo,
**cuando** transcurren m√°s de 14 d√≠as naturales sin que se ejecute un m√≥dulo espec√≠fico,
**entonces** emite una alerta de crisis con mayor urgencia visual, informando al ejecutante que el grupo muscular asociado puede estar perdiendo adaptaciones musculares y que se recomienda priorizar ese m√≥dulo.

#### CA-17.25 ‚Äî Referencia a los grupos musculares afectados

**Dado que** el sistema emite una alerta de inactividad por m√≥dulo,
**cuando** presenta la alerta al ejecutante,
**entonces** detalla los grupos musculares asociados al m√≥dulo inactivo: M√≥dulo A = Espalda, B√≠ceps, Abdomen; M√≥dulo B = Pecho, Hombro, Tr√≠ceps; M√≥dulo C = Cu√°driceps, Isquiotibiales, Gl√∫teos, Aductores, Abductores, Gemelos.

#### CA-17.26 ‚Äî Conteo basado en d√≠as naturales

**Dado que** el sistema eval√∫a la inactividad de un m√≥dulo,
**cuando** cuenta los d√≠as transcurridos,
**entonces** utiliza d√≠as naturales del calendario (no sesiones ni microciclos), ya que la p√©rdida de adaptaciones musculares se correlaciona con el tiempo absoluto sin est√≠mulo.

#### CA-17.27 ‚Äî Diferenciaci√≥n visual entre alerta y crisis de inactividad

**Dado que** el sistema emite alertas de inactividad,
**cuando** el ejecutante visualiza las alertas,
**entonces** la alerta de nivel normal (> 10 d√≠as) y la de crisis (> 14 d√≠as) son visualmente distinguibles mediante colores e iconograf√≠a diferenciada.

#### CA-17.28 ‚Äî Alertas de inactividad informativas, no bloqueantes

**Dado que** el sistema emite una alerta de inactividad por m√≥dulo,
**cuando** el ejecutante interact√∫a con el sistema,
**entonces** la alerta es informativa; no altera la rotaci√≥n c√≠clica ni fuerza un cambio de m√≥dulo. El ejecutante sigue la rotaci√≥n normal.

#### CA-17.29 ‚Äî Retiro autom√°tico de alerta de inactividad

**Dado que** el sistema ha emitido una alerta de inactividad para un m√≥dulo,
**cuando** el ejecutante completa una sesi√≥n de ese m√≥dulo,
**entonces** el sistema retira la alerta de inactividad y reinicia el conteo de d√≠as para ese m√≥dulo.

---

## An√°lisis Arquitect√≥nico (Arquitecto)

### Decisiones de Dise√±o

**Patr√≥n Arquitect√≥nico:** Motor de Alertas Write-Time en Pipeline Existente + MVVM Read-Only para 2 pantallas (H1, H2) con AlertRepository dedicado

**Justificaci√≥n:** HU-17 tiene dos caras. La cara **write-side** extiende el pipeline transaccional existente (`SessionRepositoryImpl.evaluateProgression()`) con 5 bloques de evaluaci√≥n nuevos que crean/resuelven alertas al cierre de cada sesi√≥n ‚Äî reutilizando las Rules ya implementadas por HU-15 (`ProgressionRateRule`, `AvgRirRule`, `AdherenceRule`, `TonnageRule`). La infraestructura de alertas (tabla `alert`, `AlertEntity`, `AlertDao`, patr√≥n insert/resolve) ya existe por HU-12 ‚Äî solo se ampl√≠a. La cara **read-side** crea 2 pantallas nuevas (H1 Centro de Alertas, H2 Detalle de Alerta) que son de solo lectura y recalculan datos din√°micamente. El rec√°lculo es seguro porque las sesiones cerradas son inmutables (Modelo de Datos ¬ß3.10). Se crea un `AlertRepository` dedicado como nuevo dominio funcional de lectura/resoluci√≥n, separado de `SessionRepository` (que solo escribe alertas). Las alertas de tipo `MODULE_INACTIVITY` se eval√∫an al cerrar sesi√≥n comparando la fecha de √∫ltima sesi√≥n de cada m√≥dulo contra today ‚Äî no requieren background job porque el usuario no consulta la app entre sesiones.

### Decisiones Fundamentadas

**1. Se crea `AlertRepository` (interfaz + impl) como nuevo dominio funcional de lectura.**

`AlertDao` actualmente se inyecta directamente en `SessionRepositoryImpl` para operaciones de escritura (insert/resolve de alertas PLATEAU y MODULE_REQUIRES_DELOAD). Para H1 y H2 se necesitan operaciones de lectura (listado de alertas activas, detalle por ID, conteo reactivo, datos de contexto para rec√°lculo). Estas responsabilidades de lectura no pertenecen a `SessionRepository` ‚Äî son un dominio funcional separado. `AlertRepository` encapsula: lectura de alertas, construcci√≥n de datos de contexto para H2, y el conteo reactivo para el badge de B1. La escritura de alertas permanece en `SessionRepositoryImpl` (ya tiene `AlertDao` en su constructor y todas las dependencias transaccionales). Sigue el patr√≥n de la Arquitectura T√©cnica ¬ß5.2: `AlertRepository` / `AlertRepositoryImpl`.

**2. La evaluaci√≥n de los 5 nuevos tipos de alerta extiende `evaluateProgression()` con bloques post-loop.**

El pipeline actual ejecuta un loop de ejercicios (clasificaci√≥n + plateau alerts) seguido de un deload guard (`if (isDeloadSession) return` en l√≠nea 536) y an√°lisis a nivel de m√≥dulo (MODULE_REQUIRES_DELOAD). Los 5 nuevos tipos se agregan DESPU√âS del bloque MODULE_REQUIRES_DELOAD, como Steps 7-11 del pipeline. El deload guard existente en l√≠nea 536 ya protege los 5 nuevos Steps ‚Äî durante sesiones de descarga, `evaluateProgression()` retorna antes de alcanzarlos, lo cual es correcto: la progresi√≥n, RIR, adherencia, tonelaje e inactividad no deben evaluarse durante descarga controlada. Los DAOs necesarios (`sessionDao`, `exerciseSetDao`, `sessionExerciseDao`, `alertDao`) ya est√°n inyectados en `SessionRepositoryImpl` ‚Äî solo se necesita agregar `ProfileDao` al constructor para obtener `weekly_frequency` (adherencia, Step 9). Cada bloque sigue el patr√≥n existente: calcular ‚Üí evaluar umbral ‚Üí if(supera && !existsActive) ‚Üí insert | if(!supera && existsActive) ‚Üí resolve. Los Steps 8 (RIR) y 11 (inactividad) iteran sobre los 3 m√≥dulos (A, B, C), no solo el m√≥dulo de la sesi√≥n actual. El Step 7 (progresi√≥n) eval√∫a todos los ejercicios activos, el Step 9 (adherencia) es global, y el Step 10 (tonelaje) eval√∫a todos los grupos musculares.

**3. No se crean nuevas Rules de c√°lculo ‚Äî se reutilizan las existentes de HU-15.**

`ProgressionRateRule.calculate(positiveCount, totalCount)` ya calcula la tasa exacta que necesitan CA-17.01/CA-17.02. `AvgRirRule.calculate(rirValues)` ya calcula el RIR promedio de CA-17.06/CA-17.07. `AdherenceRule.calculate(completed, planned)` ya calcula la adherencia de CA-17.12/CA-17.13. `TonnageRule.calculateForMuscleGroup(sets)` ya calcula el tonelaje por grupo muscular de CA-17.17/CA-17.18. Solo se crea `AlertThresholdRule` ‚Äî un objeto con funciones puras que eval√∫an si un valor calculado supera umbrales de alerta o crisis (ej: `isProgressionCrisis(rate) = rate < 20.0`, `isProgressionAlert(rate) = rate < 40.0`). Esto centraliza los umbrales m√°gicos en un solo lugar testeable.

**4. `AlertThresholdRule` centraliza todos los umbrales de los 5 bloques de alerta.**

Los umbrales est√°n definidos en los CAs: progresi√≥n < 40% (alerta) / < 20% (crisis), RIR < 1.5 o > 3.5 (sostenido 2+ sesiones), adherencia < 60% (alerta) / 2+ semanas (crisis), tonelaje > 10% ca√≠da (alerta) / > 20% (crisis), inactividad > 10 d√≠as (alerta) / > 14 d√≠as (crisis). Todos se codifican como constantes y funciones puras en `AlertThresholdRule`. Testear umbrales es trivial ‚Äî un test unitario por funci√≥n con boundary values.

**5. MODULE_INACTIVITY se eval√∫a al cerrar sesi√≥n, no como background job.**

CA-17.26 dice que el conteo es en d√≠as naturales. Sin embargo, un WorkManager/AlarmManager requerir√≠a permisos adicionales (RNF30: permisos m√≠nimos) y complejidad de infraestructura innecesaria. La evaluaci√≥n al cierre de sesi√≥n es suficiente: (a) el ejecutante entrena 3-6 sesiones/semana ‚Üí eval√∫a inactividad de los otros m√≥dulos cada 1-2 d√≠as, (b) entre sesiones el usuario no ve la app, (c) el umbral m√≠nimo es 10 d√≠as ‚Äî si entrena al menos cada 2-3 d√≠as, la evaluaci√≥n del cierre detecta la inactividad a tiempo. Si el usuario deja de entrenar 14+ d√≠as, la alerta se crear√° al reabrir la app y cerrar su primera sesi√≥n de vuelta. Se necesita un nuevo query `SessionDao.getLastSessionDateByModule()` que retorne la fecha de la √∫ltima sesi√≥n cerrada de cada m√≥dulo.

**6. H2 recalcula datos din√°micamente ‚Äî no se almacenan en la tabla `alert`.**

El Modelo de Datos ¬ß3.16 dice: "Los datos que dispararon la alerta y las recomendaciones escalonadas no se almacenan ‚Äî se recalculan din√°micamente". Para cada tipo de alerta, H2 recalcula usando las mismas Rules y DAOs: (a) mesetas: `PlateauCausalAnalysisRule` + `CorrectiveActionRule` (ya existentes, HU-12), (b) progresi√≥n baja: `GetProgressionRateUseCase` con los datos del ejercicio, (c) RIR: `GetAvgRirByModuleUseCase` con las sesiones del m√≥dulo, (d) adherencia: `GetAdherenceUseCase` con la semana actual, (e) tonelaje: `GetTonnageByMuscleGroupUseCase` con los microciclos, (f) inactividad: `SessionDao.getLastSessionDateByModule()`. Las sesiones cerradas son inmutables ‚Üí el rec√°lculo siempre produce el mismo resultado.

**7. CA-17.19/CA-17.20: La verificaci√≥n de descarga planificada para ca√≠das de tonelaje usa `deload_id`.**

Cuando se detecta una ca√≠da de tonelaje en un grupo muscular, el pipeline verifica si las sesiones del microciclo evaluado tienen `deload_id IS NOT NULL`. Si es descarga planificada, la alerta se crea con nivel `MEDIUM_ALERT` y mensaje contextualizado ("Descarga planificada ‚Äî ca√≠da de tonelaje esperada y controlada") en lugar de `CRISIS`. Esto cumple CA-17.19 y CA-17.20 sin l√≥gica adicional ‚Äî solo un condicional en el bloque de evaluaci√≥n de tonelaje.

**8. CA-17.08: La condici√≥n "sostenido 2+ sesiones" para RIR usa el query `getSessionIdsByModuleInRange()` existente.**

`SessionDao.getSessionIdsByModuleInRange(moduleCode, limit=2)` ya obtiene las √∫ltimas N sesiones de un m√≥dulo. Se calcula el RIR promedio de cada una de las 2 √∫ltimas sesiones por separado usando `ExerciseSetDao.getRirValuesBySessionIds()`. Si ambas sesiones cumplen la condici√≥n (< 1.5 o > 3.5), se emite la alerta. Una sola sesi√≥n fuera de rango no la dispara. El retiro autom√°tico (CA-17.11) ocurre cuando las 2 √∫ltimas sesiones del m√≥dulo retornan a la zona √≥ptima (1.5-3.5).

**9. CA-17.05/CA-17.13: La adherencia usa semanas naturales y se eval√∫a al cierre de sesi√≥n.**

La adherencia semanal se calcula con `AdherenceRule.calculate()` usando `SessionDao.countSessionsInWeek()` (ya existente) comparado con el `weekly_frequency` del perfil. Para la crisis de 2+ semanas consecutivas (CA-17.13), se necesita verificar la semana anterior tambi√©n. Si ambas semanas est√°n por debajo del 60%, se crea/escala a CRISIS. Para el retiro (CA-17.16), basta con una semana ‚â• 60% para resolver la alerta.

**10. El badge de alertas en B1 se conecta con un `Flow<Int>` reactivo.**

`AlertDao.countActive()` ya retorna `Flow<Int>`. El `HomeViewModel` actualmente hardcodea `alertCount = 0`. Se inyecta `GetActiveAlertCountUseCase` que expone el Flow del conteo. El `combine()` existente del ViewModel se extiende con un cuarto Flow. El Badge M3 en HomeScreen ya renderiza el conteo ‚Äî solo cambia la fuente de datos.

### Componentes Afectados

**Componentes nuevos:**

| # | Componente | Tipo | Paquete | Responsabilidad |
|---|-----------|------|---------|-----------------|
| 1 | `AlertThresholdRule` | Nuevo (Rule) | `domain.rules` | Funciones puras con umbrales de los 5 tipos de alerta. Constantes: PROGRESSION_ALERT=40, PROGRESSION_CRISIS=20, RIR_LOW=1.5, RIR_HIGH=3.5, ADHERENCE_THRESHOLD=60, TONNAGE_ALERT=10, TONNAGE_CRISIS=20, INACTIVITY_ALERT=10, INACTIVITY_CRISIS=14 |
| 2 | `AlertRepository` | Nuevo (interfaz) | `domain.repository` | Contrato para operaciones de lectura de alertas: `countActive(): Flow<Int>`, `getActiveAlerts(): Flow<List<AlertItem>>`, `getAlertDetail(alertId: Long): AlertDetail` |
| 3 | `AlertRepositoryImpl` | Nuevo (impl) | `data.repository` | Implementaci√≥n con `AlertDao` para lectura + DAOs auxiliares para rec√°lculo de datos de H2 (ejercicios, sesiones, series, progresi√≥n) |
| 4 | `GetActiveAlertCountUseCase` | Nuevo (UseCase) | `domain.usecase.alerts` | Retorna `Flow<Int>` del conteo de alertas activas para badge de B1 |
| 5 | `GetActiveAlertsUseCase` | Nuevo (UseCase) | `domain.usecase.alerts` | Retorna `Flow<List<AlertItem>>` de alertas activas agrupadas por nivel para H1 |
| 6 | `GetAlertDetailUseCase` | Nuevo (UseCase) | `domain.usecase.alerts` | Carga detalle completo de una alerta para H2: tipo, nivel, datos que la dispararon, an√°lisis causal, recomendaciones. Recalcula datos din√°micamente |
| 7 | `AlertItem` | Nuevo (domain model) | `domain.model` | Modelo para cada fila de H1: alertId, type, level, entityName (ejercicio/m√≥dulo/grupo muscular), message, createdAt |
| 8 | `AlertDetail` | Nuevo (domain model) | `domain.model` | Modelo compuesto para H2: type, level, entityName, triggerData (datos que dispararon), causalAnalysis (texto), recommendations (lista), showExerciseHistoryLink (Boolean), showDeloadLink (Boolean), exerciseId (Long?), isDeloadContextualized (Boolean) |
| 9 | `AlertTriggerData` | Nuevo (domain model) | `domain.model` | Modelo sellado para los datos que dispararon la alerta por tipo: sesiones con peso/reps (meseta), tasa de progresi√≥n (progresi√≥n baja), valor RIR promedio (RIR), porcentaje adherencia (adherencia), porcentaje ca√≠da tonelaje (tonelaje), d√≠as de inactividad (inactividad) |
| 10 | `AlertCenterScreen` | Nuevo (Composable) | `ui.alerts` | Pantalla H1 ‚Äî Listado de alertas activas agrupadas: secci√≥n Crisis (üî¥) + secci√≥n Alertas (üü†üü°). Estado vac√≠o. Acceso desde B1 |
| 11 | `AlertCenterViewModel` | Nuevo (HiltViewModel) | `ui.alerts` | Estado reactivo para H1 ‚Äî carga lista de alertas activas v√≠a Flow |
| 12 | `AlertCenterUiState` | Nuevo (data class) | `ui.alerts` | Estado UI para H1 ‚Äî Loading/Empty/Loaded con crisisAlerts + regularAlerts + totalCount (para subt√≠tulo "N alertas activas" en Top Bar) |
| 13 | `AlertDetailScreen` | Nuevo (Composable) | `ui.alerts` | Pantalla H2 ‚Äî Detalle con card de tipo/nivel, datos disparadores, an√°lisis causal, recomendaciones, enlaces condicionales a F3/I1 |
| 14 | `AlertDetailViewModel` | Nuevo (HiltViewModel) | `ui.alerts` | Estado reactivo para H2 ‚Äî carga detalle completo de una alerta con rec√°lculo din√°mico |
| 15 | `AlertDetailUiState` | Nuevo (data class) | `ui.alerts` | Estado UI para H2 ‚Äî Loading/Loaded con AlertDetail |
| 16 | `AlertLevelIndicator` | Nuevo (Composable) | `ui.components` | Indicador circular relleno de nivel de alerta (12dp para H1, 16dp para H2). Color: rojo crisis, naranja alta, amarillo media. Reutilizable en H1 y H2 |
| 17 | `AlertCard` | Nuevo (Composable) | `ui.alerts` | Card de alerta con fondo por nivel (Error Container / naranja / amarillo), leading indicator, t√≠tulo tipo, entidad, dato clave. Clickable ‚Üí H2 |
| 18 | `ModuleInactivityData` | Nuevo (domain model) | `domain.model` | Modelo para inactividad por m√≥dulo: moduleCode, lastSessionDate, daysSinceLastSession, muscleGroups (lista) |

**Componentes modificados:**

| # | Componente | Modificaci√≥n | Nivel |
|---|-----------|-------------|-------|
| 1 | `SessionRepositoryImpl` | Agregar 5 bloques de evaluaci√≥n post-loop en `evaluateProgression()` (Steps 7-11): LOW_PROGRESSION_RATE, RIR_OUT_OF_RANGE, LOW_ADHERENCE, TONNAGE_DROP, MODULE_INACTIVITY. Cada bloque: calcular KPI ‚Üí evaluar umbral ‚Üí crear/resolver alerta. Inyectar `ProfileDao` para obtener `weekly_frequency` (adherencia). Los dem√°s DAOs ya est√°n inyectados | Mayor |
| 2 | `AlertDao` | Agregar 4 queries nuevos: `getAlertById(alertId): AlertEntity?` para H2, `resolveByMuscleGroupAndType(muscleGroup, type, resolvedAt)` para resolver TONNAGE_DROP, `existsActiveByMuscleGroup(muscleGroup, type): Boolean` para deduplicar TONNAGE_DROP, `getActiveAlertsFull(): Flow<List<AlertWithEntityName>>` con JOIN a `exercise`/`module` para obtener nombre de la entidad afectada | Medio |
| 3 | `SessionDao` | Agregar `getLastSessionDateByModule(moduleCode): String?` ‚Äî retorna `MAX(date)` de sesiones cerradas filtradas por m√≥dulo. Reutiliza JOIN con `module_version` | Menor |
| 4 | `HomeViewModel` | Inyectar `GetActiveAlertCountUseCase`. Reemplazar `alertCount = 0` hardcoded con `getActiveAlertCountUseCase()` como cuarto Flow en el `combine()`. El badge M3 se actualiza reactivamente | Menor |
| 5 | `NavigationRoutes` | Agregar `ALERT_CENTER = "alert-center"` y `ALERT_DETAIL = "alert-detail/{alertId}"` con funci√≥n factory `alertDetailRoute(alertId: Long)` | Menor |
| 6 | `TensionNavHost` | Registrar `AlertCenterScreen` y `AlertDetailScreen` composables. Conectar `onNavigateToAlerts` de HomeScreen con `navController.navigate(NavigationRoutes.ALERT_CENTER)`. Registrar navegaci√≥n H1‚ÜíH2, H2‚ÜíF3, H2‚ÜíI1 | Medio |
| 7 | `RepositoryModule` | Agregar binding `AlertRepository` ‚Üí `AlertRepositoryImpl` | Menor |
| 8 | `DatabaseModule` | Sin cambio ‚Äî `AlertDao` ya est√° provisto por `provideAlertDao()` | Sin cambio |
| 9 | `strings.xml` | Agregar ~30 strings: t√≠tulos de pantallas, nombres de tipos de alerta, etiquetas de nivel, textos de an√°lisis causal por tipo, textos de recomendaciones, estado vac√≠o, formatos de datos disparadores, enlaces de acci√≥n | Menor |
| 10 | `BottomNavigationBar` | Agregar `childRoutePrefixes = setOf("alert-center", "alert-detail")` al `BottomNavItem` de HOME para que el tab Inicio aparezca seleccionado en H1 y H2 | Menor |

**Componentes reutilizados (existentes, sin modificaci√≥n):**

| # | Componente | Paquete | Uso en HU-17 |
|---|-----------|---------|---------------|
| R1 | `ProgressionRateRule` | `domain.rules` | C√°lculo de tasa de progresi√≥n para alertas LOW_PROGRESSION_RATE (write-side) y rec√°lculo en H2 (read-side) |
| R2 | `AvgRirRule` | `domain.rules` | C√°lculo de RIR promedio por m√≥dulo para alertas RIR_OUT_OF_RANGE (write-side) y rec√°lculo en H2 |
| R3 | `AdherenceRule` | `domain.rules` | C√°lculo de adherencia semanal para alertas LOW_ADHERENCE (write-side) y rec√°lculo en H2 |
| R4 | `TonnageRule` | `domain.rules` | C√°lculo de tonelaje por grupo muscular para alertas TONNAGE_DROP (write-side) y rec√°lculo en H2 |
| R5 | `PlateauCausalAnalysisRule` | `domain.rules` | An√°lisis causal de mesetas en H2 (read-side) ‚Äî CA-12.10 a CA-12.12. Ya existente por HU-12 |
| R6 | `CorrectiveActionRule` | `domain.rules` | Recomendaciones escalonadas en H2 (read-side) ‚Äî CA-12.16, CA-12.17. Ya existente por HU-12 |
| R7 | `ModuleFatigueRule` | `domain.rules` | Detecci√≥n de fatiga acumulada en m√≥dulo ‚Äî contextualiza alertas de meseta grupal. Ya existente por HU-12 |
| R8 | `AlertEntity` | `data.local.entity` | Entidad Room para la tabla `alert`. Ya existente por HU-12 |
| R9 | `AlertDao.insert()` | `data.local.dao` | Inserci√≥n de alertas nuevas. Ya existente por HU-12 |
| R10 | `AlertDao.existsActiveByExercise()` | `data.local.dao` | Verificaci√≥n de deduplicaci√≥n por ejercicio. Ya existente por HU-12 |
| R11 | `AlertDao.existsActiveByModule()` | `data.local.dao` | Verificaci√≥n de deduplicaci√≥n por m√≥dulo. Ya existente por HU-12 |
| R12 | `AlertDao.resolveByExerciseAndType()` | `data.local.dao` | Resoluci√≥n de alertas por ejercicio. Ya existente por HU-12 |
| R13 | `AlertDao.resolveByModuleAndType()` | `data.local.dao` | Resoluci√≥n de alertas por m√≥dulo. Ya existente por HU-12 |
| R14 | `AlertDao.countActive()` | `data.local.dao` | Conteo reactivo de alertas activas para badge B1. Ya existente por HU-12 |
| R15 | `AlertDao.getActiveAlerts()` | `data.local.dao` | Lista de alertas activas ordenadas. Ya existente por HU-12 |
| R16 | `SessionDao.getSessionIdsByModuleInRange()` | `data.local.dao` | √öltimas N sesiones de un m√≥dulo para evaluaci√≥n sostenida de RIR |
| R17 | `SessionDao.countSessionsInWeek()` | `data.local.dao` | Sesiones completadas en una semana para adherencia |
| R18 | `ExerciseSetDao.getRirValuesBySessionIds()` | `data.local.dao` | Valores RIR de sesiones espec√≠ficas para c√°lculo de RIR promedio |
| R19 | `TensionTopAppBar` | `ui.components` | Barra superior reutilizada en H1 y H2 |

**Componentes NO tocados (verificado en c√≥digo):**

- Toda la capa `domain/rules/` existente ‚Äî ninguna Rule se modifica, solo se agregan constantes en `AlertThresholdRule`
- `data/local/entity/` ‚Äî `AlertEntity` no se modifica (0 cambios de esquema, 0 migraciones)
- `data/local/database/TensionDatabase.kt` ‚Äî no se modifica (versi√≥n se mantiene, `AlertDao` ya est√° registrado)
- `data/local/seed/` ‚Äî no se toca ning√∫n seeder
- Flujos E (sesi√≥n activa), C (perfil), D (cat√°logo), F (historial), G (m√©tricas), I (descarga), J (configuraci√≥n) ‚Äî no se modifican sus pantallas
- `MetricsRepository`/`MetricsRepositoryImpl` ‚Äî no se modifican. Los DAOs subyacentes se invocan directamente en `SessionRepositoryImpl` y `AlertRepositoryImpl`
- `ExerciseRepository`, `PlanRepository`, `ProfileRepository` ‚Äî no participan

### Hitos de Implementaci√≥n

| # | Componente(s) | Descripci√≥n | Dependencias |
|---|--------------|-------------|--------------|
| 1 | Domain Models + Rule | Crear `AlertItem`, `AlertDetail`, `AlertTriggerData`, `ModuleInactivityData` en `domain.model`. Crear `AlertThresholdRule` en `domain.rules` con todos los umbrales y funciones de evaluaci√≥n | Ninguna |
| 2 | DAO Queries | Agregar queries nuevos en `AlertDao` (4 queries: getById, resolveByMuscleGroup, existsActiveByMuscleGroup, getActiveAlertsFull), `SessionDao` (1 query: getLastSessionDateByModule) | Ninguna |
| 3 | AlertRepository | Crear `AlertRepository` (interfaz en `domain.repository`) y `AlertRepositoryImpl` (en `data.repository`). Agregar binding en `RepositoryModule` | Hitos 1, 2 |
| 4 | Pipeline de Alertas | Agregar 5 bloques de evaluaci√≥n al final de `evaluateProgression()` en `SessionRepositoryImpl`: LOW_PROGRESSION_RATE (Step 7), RIR_OUT_OF_RANGE (Step 8), LOW_ADHERENCE (Step 9), TONNAGE_DROP (Step 10), MODULE_INACTIVITY (Step 11). Inyectar `ProfileDao` en constructor | Hitos 1, 2 |
| 5 | Use Cases | Crear `GetActiveAlertCountUseCase`, `GetActiveAlertsUseCase`, `GetAlertDetailUseCase` en `domain.usecase.alerts` | Hito 3 |
| 6 | B1 Badge | Inyectar `GetActiveAlertCountUseCase` en `HomeViewModel`. Reemplazar `alertCount = 0` con Flow reactivo en `combine()` | Hito 5 |
| 7 | H1 ‚Äî Centro de Alertas | Crear `AlertCenterScreen`, `AlertCenterViewModel`, `AlertCenterUiState`, `AlertCard`, `AlertLevelIndicator`. Agregar ruta ALERT_CENTER en NavigationRoutes y TensionNavHost. Conectar onNavigateToAlerts de HomeScreen. Agregar `childRoutePrefixes` de alertas al tab HOME en `BottomNavigationBar` | Hito 5 |
| 8 | H2 ‚Äî Detalle de Alerta | Crear `AlertDetailScreen`, `AlertDetailViewModel`, `AlertDetailUiState`. Agregar ruta ALERT_DETAIL y navegaci√≥n H1‚ÜíH2, H2‚ÜíF3, H2‚ÜíI1 | Hito 5 |
| 9 | Strings + Navegaci√≥n final | Agregar ~30 strings en `strings.xml`. Verificar navegaci√≥n completa: B1‚ÜíH1‚ÜíH2‚ÜíF3, B1‚ÜíH1‚ÜíH2‚ÜíI1. Verificar badge reactivo | Hitos 6, 7, 8 |
| 10 | Tests unitarios | Tests para `AlertThresholdRule` (boundary values de todos los umbrales), tests para los 3 Use Cases, tests para los 5 bloques del pipeline en `SessionRepositoryImpl` | Hitos 4, 5, 6, 7, 8 |

### Validaci√≥n de Impacto

**C√≥digo real verificado (paso 1.5):**

- `SessionRepositoryImpl.kt` (749 l√≠neas): `evaluateProgression()` actualmente tiene Steps 1-6 (loop de ejercicios + PLATEAU + deload guard + MODULE_REQUIRES_DELOAD). El deload guard (`if (isDeloadSession) return`) est√° en la l√≠nea 536 y protege autom√°ticamente todo el c√≥digo posterior ‚Äî incluidos los 5 nuevos Steps (7-11) que se agregan al final del m√©todo, despu√©s del bloque MODULE_REQUIRES_DELOAD. El constructor ya inyecta `sessionDao`, `exerciseSetDao`, `sessionExerciseDao`, `alertDao`, `moduleDao` ‚Äî solo falta `ProfileDao` para `weekly_frequency` (adherencia). `ProfileDao` ya est√° provisto por `DatabaseModule` (usado por `ProfileRepositoryImpl`), Hilt lo resolver√° autom√°ticamente. `ProfileDao.getProfile()` retorna `Flow<ProfileEntity?>` ‚Äî se usa `.first()` para obtener el valor s√≠ncrono dentro de la transacci√≥n.
- `AlertDao.kt` (80 l√≠neas): Tiene `insert()`, `existsActiveByExercise()`, `existsActiveByModule()`, `resolveByExerciseAndType()`, `resolveByModuleAndType()`, `countActive(): Flow<Int>`, `getActiveAlerts(): Flow<List<AlertEntity>>`, `getActiveAlertsByType()`, `resolveAllByType()`. Faltan: `getAlertById()`, `resolveByMuscleGroupAndType()`, `existsActiveByMuscleGroup()`, `getActiveAlertsFull()` (con JOIN para nombre de entidad).
- `AlertEntity.kt` (63 l√≠neas): Completo con todos los campos necesarios. Los 7 tipos ya est√°n definidos: PLATEAU, LOW_PROGRESSION_RATE, RIR_OUT_OF_RANGE, LOW_ADHERENCE, TONNAGE_DROP, MODULE_INACTIVITY, MODULE_REQUIRES_DELOAD. Los 3 niveles: CRISIS, HIGH_ALERT, MEDIUM_ALERT. No requiere modificaci√≥n.
- `HomeViewModel.kt` (97 l√≠neas): `alertCount = 0` hardcoded en l√≠nea 51. El `combine()` tiene 3 Flows ‚Äî se agrega un 4to: `getActiveAlertCountUseCase()`. El constructor necesita un nuevo par√°metro `GetActiveAlertCountUseCase`.
- `TensionNavHost.kt`: `onNavigateToAlerts = { /* TODO: HU-17 */ }` en l√≠nea 128. Se reemplaza con `navController.navigate(NavigationRoutes.ALERT_CENTER)`. No hay rutas ALERT_CENTER ni ALERT_DETAIL definidas.
- `NavigationRoutes.kt` (36 l√≠neas): No tiene rutas de alertas. Se agregan `ALERT_CENTER = "alert-center"` y `ALERT_DETAIL = "alert-detail/{alertId}"`.
- `RepositoryModule.kt` (55 l√≠neas): Tiene 5 bindings (Profile, Exercise, Plan, Session, Metrics). Se agrega el 6to: `AlertRepository` ‚Üí `AlertRepositoryImpl`.
- `DatabaseModule.kt`: Ya provee `AlertDao` v√≠a `provideAlertDao()`. No requiere modificaci√≥n.
- `ProgressionRateRule.kt`: `calculate(positiveCount, totalCount): Double` ‚Äî retorna porcentaje. Reutilizable directamente.
- `AvgRirRule.kt`: `calculate(rirValues: List<Int>): Double` ‚Äî retorna promedio con 1 decimal. Reutilizable directamente.
- `AdherenceRule.kt`: `calculate(completedSessions, plannedSessions): Double` ‚Äî retorna porcentaje. Reutilizable directamente.
- `TonnageRule.kt`: `calculateForMuscleGroup(sets): Map<String, Double>` ‚Äî retorna tonelaje por grupo muscular. Reutilizable directamente.
- `PlateauCausalAnalysisRule.kt`: `analyze(lastSessionsAvgRir, isGroupStagnant): PlateauCause` ‚Äî retorna causa. Reutilizable en H2 para mesetas.
- `CorrectiveActionRule.kt`: `recommend(sessionsWithoutProgression): List<CorrectiveAction>` ‚Äî retorna acciones sugeridas. Reutilizable en H2 para mesetas.
- `SessionDao.kt`: Tiene `getSessionIdsByModuleInRange(moduleCode, limit)`, `countSessionsInWeek(weekStartDate, weekEndDate)`, `getClosedSessionsOrdered()`. Falta `getLastSessionDateByModule()`.
- `ExerciseSetDao.kt`: Tiene `getRirValuesBySessionIds(sessionIds)`, `getTonnageDataBySessionIds(sessionIds)`. Suficiente para los c√°lculos.
- `strings.xml`: Tiene `home_alert_badge_description`. Faltan ~30 strings para H1/H2 (t√≠tulos, tipos de alerta, niveles, textos de an√°lisis, recomendaciones, estado vac√≠o, formatos).
- `BottomNavigationBar.kt` (144 l√≠neas): H1 y H2 se acceden desde B1 badge. Bottom Nav debe mostrar "Inicio" como activo (Wireframe H1: "Inicio marcado como activo"). El tab HOME actualmente no tiene `childRoutePrefixes` ‚Äî se debe agregar `setOf("alert-center", "alert-detail")` para que el tab quede seleccionado al navegar a H1/H2. Sin este cambio, ning√∫n tab se resaltar√≠a. La l√≥gica de `showBottomBar` (blocklist en `TensionNavHost.kt`) ya muestra el Bottom Nav en H1/H2 sin cambios.

**An√°lisis de dependencias:**

- HU-17 depende de: HU-12 (infraestructura de alertas: `AlertEntity`, `AlertDao`, patr√≥n insert/resolve, alertas PLATEAU y MODULE_REQUIRES_DELOAD), HU-14 (descarga: `deload_id` en session para contextualizar ca√≠das de tonelaje, resoluci√≥n de MODULE_REQUIRES_DELOAD), HU-15 (Rules de KPIs: `ProgressionRateRule`, `AvgRirRule`, `AdherenceRule`, `TonnageRule`, `GetMicrocycleMapUseCase`), HU-16 (F3: navegaci√≥n H2‚ÜíF3 para historial de ejercicio ya implementada).
- HU-17 NO introduce nuevas entidades ni migraciones ‚Äî usa la tabla `alert` existente con los 7 tipos ya definidos en el CHECK constraint.
- HU-17 habilita: HU-18 (backup ‚Äî la tabla `alert` con alertas resueltas se exporta como hist√≥rico).

**Impacto en performance:**

- Pipeline write-side: Los 5 bloques agregan ~5-8 queries adicionales al cierre de sesi√≥n (√∫ltima fecha por m√≥dulo √ó3, RIR por m√≥dulo √ó3, progresi√≥n rate √ó1, adherencia √ó1, tonelaje √ó1). Cada query usa √≠ndices existentes. El cierre de sesi√≥n pasa de ~200ms a ~350ms estimados ‚Äî aceptable dado que ocurre m√°ximo una vez al d√≠a.
- H1 read-side: `getActiveAlerts()` con Flow reactivo. Con < 20 alertas activas simult√°neas (caso t√≠pico), la lectura es instant√°nea.
- H2 read-side: Rec√°lculo din√°mico de datos disparadores. Para mesetas: 2-3 queries (√∫ltimas sesiones, RIR, ejercicios en meseta). Para tonelaje: query de microciclo + tonelaje. Total < 100ms.
- Badge B1: `countActive()` es un `SELECT COUNT(*) WHERE is_active = 1` con √≠ndice en `is_active`. Pr√°cticamente instant√°neo.

### Notas T√©cnicas

**Nota 1 ‚Äî Mapeo tipo de alerta ‚Üí nivel visual (H1).**

El wireframe define 3 niveles visuales: üî¥ Crisis (rojo/Error Container), üü† Alerta alta (naranja), üü° Alerta media (amarillo). El mapeo desde `alert.level` es: `CRISIS` ‚Üí üî¥, `HIGH_ALERT` ‚Üí üü†, `MEDIUM_ALERT` ‚Üí üü°. En H1, las alertas se agrupan en 2 secciones: "Crisis" (solo üî¥) y "Alertas" (üü† + üü°), ordenadas internamente por `created_at DESC`. La secci√≥n "Crisis" solo es visible si hay alertas de nivel CRISIS.

**Nota 2 ‚Äî H2: An√°lisis causal var√≠a por tipo de alerta.**

Para alertas de tipo PLATEAU: usa `PlateauCausalAnalysisRule.analyze()` y `CorrectiveActionRule.recommend()` ya existentes (HU-12 CA-12.10 a CA-12.12). Para LOW_PROGRESSION_RATE: texto fijo seg√∫n nivel ("Tasa de progresi√≥n por debajo del umbral de alerta/crisis"). Para RIR_OUT_OF_RANGE: texto condicional (< 1.5 ‚Üí "entrenando demasiado cerca del fallo t√©cnico", > 3.5 ‚Üí "est√≠mulo insuficiente para generar adaptaci√≥n"). Para LOW_ADHERENCE: texto con datos de semana(s) afectada(s). Para TONNAGE_DROP: texto condicional (descarga planificada ‚Üí azul "Ca√≠da esperada", regresi√≥n ‚Üí "Ca√≠da no intencional, evaluar causas"). Para MODULE_INACTIVITY: texto con d√≠as transcurridos y grupos musculares afectados (CA-17.25). Los textos se almacenan en `strings.xml` con placeholders `%s`/`%d`.

**Nota 3 ‚Äî H2: Links de acci√≥n condicionales.**

"Ver historial del ejercicio ‚Üí" (navega a F3): visible solo si `alert.type ‚àà {PLATEAU, LOW_PROGRESSION_RATE}` y `alert.exercise_id != null`. "Gestionar descarga ‚Üí" (navega a I1): visible solo si `alert.type ‚àà {MODULE_REQUIRES_DELOAD}` o si la alerta de RIR_OUT_OF_RANGE recomienda descarga (RIR < 1.5 sostenido). Estos condicionales se eval√∫an en el ViewModel y se exponen como booleanos en `AlertDetail`.

**Nota 4 ‚Äî Deduplicaci√≥n de alertas.**

El bloque de evaluaci√≥n verifica `existsActiveByExercise/Module/MuscleGroup()` antes de insertar. No se crean alertas duplicadas por la misma condici√≥n. Si una alerta CRISIS ya existe para un ejercicio/m√≥dulo/grupo, no se crea una segunda. Si la condici√≥n cambia de nivel (ej: inactividad pasa de 10 a 14 d√≠as), la alerta MEDIUM_ALERT se resuelve y se crea una nueva CRISIS. Esto se maneja con resolve + insert en el bloque correspondiente.

**Nota 5 ‚Äî Escalamiento de nivel (MEDIUM_ALERT ‚Üí CRISIS).**

Para tipos con 2 niveles (TONNAGE_DROP, LOW_ADHERENCE, MODULE_INACTIVITY, LOW_PROGRESSION_RATE), cuando la condici√≥n escala de alerta a crisis, el pipeline: (1) resuelve la alerta MEDIUM_ALERT existente, (2) crea una nueva de nivel CRISIS. Cuando la condici√≥n baja de crisis a alerta normal, la CRISIS se resuelve y se crea una MEDIUM_ALERT. Cuando la condici√≥n desaparece, se resuelven todas las alertas activas de ese tipo para la entidad.

**Nota 6 ‚Äî Grupos musculares por m√≥dulo para CA-17.25.**

Los grupos musculares asociados a cada m√≥dulo est√°n definidos en el Modelo de Datos como datos de seed: A = Espalda, B√≠ceps, Abdomen; B = Pecho, Hombro, Tr√≠ceps; C = Cu√°driceps, Isquiotibiales, Gl√∫teos, Aductores, Abductores, Gemelos. Para H2 y para el mensaje de la alerta de inactividad, se codifican como constante en `AlertThresholdRule` (o `AlertRepositoryImpl`) porque son datos fijos del dominio que no cambian en runtime.

**Nota 7 ‚Äî Bottom Navigation en H1 y H2.**

El wireframe muestra "Inicio marcado como activo" en H1/H2. La Arquitectura T√©cnica ¬ß4.5.1 confirma que H1 y H2 est√°n en el grupo "Siempre visible" para Bottom Nav. En el c√≥digo actual, `showBottomBar` usa un blocklist (oculta solo A1, E1-E5, y condicionales D2/F3) ‚Äî como `alert-center` y `alert-detail` no est√°n en el blocklist, el Bottom Nav se muestra autom√°ticamente. Sin embargo, el `BottomNavItem` del tab HOME actualmente no tiene `childRoutePrefixes` ‚Äî cuando el usuario est√° en H1 o H2, ning√∫n tab quedar√° seleccionado (sin highlight). Para que "Inicio" aparezca como activo, se debe agregar `childRoutePrefixes = setOf("alert-center", "alert-detail")` al `BottomNavItem` de HOME en `BottomNavigationBar.kt`.

**Nota 8 ‚Äî La evaluaci√≥n de tonelaje por microciclo reutiliza `GetMicrocycleMapUseCase`.**

CA-17.17/CA-17.18 comparan tonelaje entre el microciclo actual y el anterior. En `evaluateProgression()`, se obtienen los sessionIds del microciclo actual vs anterior usando la l√≥gica de `SessionDao.getClosedSessionsOrdered()` + agrupaci√≥n por posiciones (6 sesiones = 1 microciclo). Se calcula el tonelaje por grupo muscular de cada microciclo con `TonnageRule.calculateForMuscleGroup()` y se compara la variaci√≥n porcentual. Si la ca√≠da > 10% (alerta) o > 20% (crisis), se emite. La verificaci√≥n de descarga planificada (CA-17.19) se hace comprobando `deload_id IS NOT NULL` en las sesiones del microciclo evaluado.

**Nota 9 ‚Äî `getSessionIdsByModuleInRange()` ya filtra sesiones de descarga.**

El query existente `SessionDao.getSessionIdsByModuleInRange()` incluye `AND s.deload_id IS NULL`, lo cual excluye sesiones de descarga de la evaluaci√≥n de RIR. Esto garantiza que CA-17.08 (sostenido 2+ sesiones) eval√∫e solo sesiones normales ‚Äî el RIR durante descarga no contamina la evaluaci√≥n.

**Nota 10 ‚Äî Navegaci√≥n H2‚ÜíF3: Bottom Nav condicional en F3 para origen H2.**

La Arquitectura T√©cnica ¬ß4.5.1 define que F3 es "Condicional" ‚Äî **Visible** si el origen es F2, G1, H2 o D2; **Oculta** si el origen es E5. El c√≥digo actual en `TensionNavHost.kt` ya implementa la l√≥gica condicional para F3 (oculta solo cuando viene de `session-summary`). Como H2 no es `session-summary`, F3 mostrar√° Bottom Nav cuando se navega desde H2. No se necesita cambio adicional.

### Verificaci√≥n Cruzada de CAs

| CA | Mecanismo | Componente |
|----|-----------|------------|
| CA-17.01 | `ProgressionRateRule.calculate()` ‚Üí si < 40% y no existe activa ‚Üí insert MEDIUM_ALERT | `SessionRepositoryImpl` Step 7 + `AlertThresholdRule.isProgressionAlert()` |
| CA-17.02 | Si < 20% ‚Üí insert CRISIS (o escalar MEDIUM‚ÜíCRISIS) | `SessionRepositoryImpl` Step 7 + `AlertThresholdRule.isProgressionCrisis()` |
| CA-17.03 | Card crisis (üî¥ Error Container) vs card media (üü° amarillo) con indicador circular diferenciado | `AlertCard` + `AlertLevelIndicator` + Especificaci√≥n Visual ¬ßH1 |
| CA-17.04 | No hay l√≥gica de bloqueo ‚Äî alertas son informativas de solo lectura | Todo el flujo es read-only excepto la creaci√≥n/resoluci√≥n autom√°tica |
| CA-17.05 | Evaluaci√≥n al cierre de cada sesi√≥n ‚Äî recalcula tasa y crea/resuelve seg√∫n estado actual | `SessionRepositoryImpl` Step 7 ejecuta en cada `evaluateProgression()` |
| CA-17.06 | `AvgRirRule.calculate()` por cada una de las 2 √∫ltimas sesiones del m√≥dulo ‚Üí si ambas < 1.5 ‚Üí insert MEDIUM_ALERT con recomendaci√≥n de descarga | `SessionRepositoryImpl` Step 8 |
| CA-17.07 | Mismo mecanismo pero si ambas > 3.5 ‚Üí insert MEDIUM_ALERT con recomendaci√≥n de incrementar carga | `SessionRepositoryImpl` Step 8 |
| CA-17.08 | `getSessionIdsByModuleInRange(moduleCode, 2)` ‚Üí RIR por cada sesi√≥n individual ‚Üí ambas fuera de rango = sostenido | `SessionRepositoryImpl` Step 8 |
| CA-17.09 | Card media (üü°) con indicador circular diferente al de alertas de progresi√≥n (üü†/üî¥). RIR bajo vs RIR alto diferenciados por mensaje y tipo de recomendaci√≥n | `AlertCard` con contenido din√°mico |
| CA-17.10 | Sin l√≥gica de bloqueo ‚Äî solo lectura | Mismo que CA-17.04 |
| CA-17.11 | Si las 2 √∫ltimas sesiones del m√≥dulo retornan a zona √≥ptima (1.5-3.5) ‚Üí `resolveByModuleAndType(moduleCode, "RIR_OUT_OF_RANGE")` | `SessionRepositoryImpl` Step 8 bloque else |
| CA-17.12 | `AdherenceRule.calculate()` con semana actual ‚Üí si < 60% y no existe activa ‚Üí insert MEDIUM_ALERT | `SessionRepositoryImpl` Step 9 |
| CA-17.13 | Verificar semana anterior tambi√©n: si ambas semanas < 60% ‚Üí escalar a CRISIS | `SessionRepositoryImpl` Step 9 |
| CA-17.14 | Card media (üü° 1 semana) vs card crisis (üî¥ 2+ semanas) | `AlertCard` + `AlertLevelIndicator` |
| CA-17.15 | Sin l√≥gica de bloqueo | Mismo que CA-17.04 |
| CA-17.16 | Si semana actual ‚â• 60% ‚Üí `resolveByModuleAndType(null, "LOW_ADHERENCE")` ‚Äî resuelve crisis y alerta | `SessionRepositoryImpl` Step 9 bloque else. `LOW_ADHERENCE` no tiene `module_code` ‚Äî se necesita `resolveAllByType("LOW_ADHERENCE")` |
| CA-17.17 | `TonnageRule.calculateForMuscleGroup()` con microciclo actual vs anterior ‚Üí si ca√≠da > 10% ‚Üí insert MEDIUM_ALERT con grupo muscular afectado | `SessionRepositoryImpl` Step 10 |
| CA-17.18 | Si ca√≠da > 20% ‚Üí insert CRISIS (o escalar) | `SessionRepositoryImpl` Step 10 |
| CA-17.19 | Si sesiones del microciclo tienen `deload_id IS NOT NULL` ‚Üí contextualizar como descarga planificada, no crisis | `SessionRepositoryImpl` Step 10 ‚Äî condicional sobre `deload_id` |
| CA-17.20 | Mensaje: "Descarga planificada ‚Äî ca√≠da de tonelaje esperada y controlada" en nivel MEDIUM_ALERT, no CRISIS | Condicional en Step 10 que modifica mensaje y nivel |
| CA-17.21 | Card media (üü° > 10%) vs card crisis (üî¥ > 20%) | `AlertCard` + `AlertLevelIndicator` |
| CA-17.22 | Sin l√≥gica de bloqueo | Mismo que CA-17.04 |
| CA-17.23 | `getLastSessionDateByModule()` ‚Üí `ChronoUnit.DAYS.between(lastDate, today)` ‚Üí si > 10 ‚Üí insert MEDIUM_ALERT | `SessionRepositoryImpl` Step 11 |
| CA-17.24 | Si > 14 d√≠as ‚Üí insert CRISIS (o escalar) | `SessionRepositoryImpl` Step 11 |
| CA-17.25 | Mensaje incluye grupos musculares: c√≥digo harcoded M√≥dulo A = Espalda, B√≠ceps, Abdomen; B = Pecho, Hombro, Tr√≠ceps; C = Cu√°driceps, Isquiotibiales, Gl√∫teos, Aductores, Abductores, Gemelos | `AlertThresholdRule` constante + `strings.xml` |
| CA-17.26 | `ChronoUnit.DAYS.between(LocalDate.parse(lastDate), today)` ‚Äî calcula d√≠as naturales | `SessionRepositoryImpl` Step 11 |
| CA-17.27 | Card media (üü° > 10 d√≠as) vs card crisis (üî¥ > 14 d√≠as) | `AlertCard` + `AlertLevelIndicator` |
| CA-17.28 | Sin l√≥gica de bloqueo ‚Äî no altera rotaci√≥n ni fuerza cambio de m√≥dulo | La rotaci√≥n sigue la secuencia A‚ÜíB‚ÜíC independientemente |
| CA-17.29 | Al cerrar sesi√≥n del m√≥dulo, si alerta de inactividad activa para ese m√≥dulo ‚Üí `resolveByModuleAndType(moduleCode, "MODULE_INACTIVITY")` | `SessionRepositoryImpl` Step 11 (resolve al inicio si la sesi√≥n actual es del m√≥dulo) |

### Referencias y Validaci√≥n

**Documentaci√≥n consultada:**

- Wireframes ‚Äî [Wireframes.md](docs/architecture/Wireframes.md) (¬ßH1 Centro de Alertas, ¬ßH2 Detalle de Alerta)
- Mapa de Navegaci√≥n ‚Äî [Mapa de Navegaci√≥n.md](docs/architecture/Mapa%20de%20Navegaci√≥n.md) (¬ßH1 transiciones B1‚ÜîH1‚ÜîH2‚ÜîF3/I1)
- Especificaci√≥n Visual ‚Äî [Especificaci√≥n Visual.md](docs/architecture/Especificaci√≥n%20Visual.md) (¬ßH1, ¬ßH2 component specs con colores por nivel)
- Modelo de Datos ‚Äî [Modelo de Datos.md](docs/architecture/Modelo%20de%20Datos.md) (¬ß3.16 alert, ¬ß3.1 module, ¬ß3.3 muscle_zone)
- Arquitectura T√©cnica ‚Äî [Arquitectura T√©cnica.md](docs/architecture/Arquitectura%20T√©cnica.md) (¬ß3.2 paquete ui.alerts, ¬ß4.3 rutas H1/H2, ¬ß4.4 alerts-graph, ¬ß5.2 naming AlertRepository)
- ADR ‚Äî [ADR.md](docs/architecture/ADR.md) (ADR-05 MVVM con capa Domain, ADR-03 Room, ADR-09 StateFlow)
- Requerimientos ‚Äî [Requerimientos.md](docs/business_definition/Requerimientos.md) (RF53-RF58, RNF05)

**Historias relacionadas:**

- Historia #12 (HU-12): Infraestructura de alertas (AlertEntity, AlertDao, patr√≥n insert/resolve, alertas PLATEAU y MODULE_REQUIRES_DELOAD) ‚Äî base sobre la que HU-17 construye
- Historia #13 (HU-13): Resumen post-sesi√≥n ‚Äî `existsActiveByModule("MODULE_REQUIRES_DELOAD")` para se√±al "Considerar descarga" ya implementado
- Historia #14 (HU-14): Protocolo de descarga ‚Äî `deload_id` en session, guard de alertas PLATEAU durante deload, resoluci√≥n de MODULE_REQUIRES_DELOAD al activar descarga
- Historia #15 (HU-15): KPIs y m√©tricas ‚Äî Rules (`ProgressionRateRule`, `AvgRirRule`, `AdherenceRule`, `TonnageRule`), Use Cases (`GetProgressionRateUseCase`, `GetAvgRirByModuleUseCase`, `GetAdherenceUseCase`, `GetTonnageByMuscleGroupUseCase`, `GetMicrocycleMapUseCase`), MetricsRepository con DAOs subyacentes
- Historia #16 (HU-16): Historial de ejercicios y sesiones ‚Äî F3 ya implementado con navegaci√≥n desde m√∫ltiples or√≠genes (H2‚ÜíF3 navega al historial del ejercicio afectado)

**Validado por:** esteban.colorado | **Fecha:** 2026-02-19 | **Enfoque:** Exploratorio
---

## Refinamiento T√©cnico (Developer)

<!-- ============================================================================ -->
<!-- SECCI√ìN AGREGADA POR: Workflow refinamiento-tecnico                         -->
<!-- ETAPA: Refinamiento T√©cnico                                                  -->
<!-- RESPONSABLE: Developer                                                       -->
<!-- BASE: An√°lisis Arquitect√≥nico (Arquitecto) - Ver secci√≥n arriba             -->
<!-- FECHA: 2026-02-19                                                            -->
<!-- ESTADO: Refinado (Developer) - Basado en An√°lisis Arquitect√≥nico            -->
<!-- ============================================================================ -->

### Consideraciones Generales

**Basado en an√°lisis arquitect√≥nico:**
S√≠ ‚Äî An√°lisis Arquitect√≥nico del Arquitecto con 10 decisiones fundamentadas, 18 componentes nuevos, 10 componentes modificados, 19 componentes reutilizados y 10 hitos de implementaci√≥n. Patr√≥n: Motor de Alertas Write-Time en Pipeline Existente + MVVM Read-Only para 2 pantallas (H1, H2) con `AlertRepository` dedicado.

**Nivel de complejidad:**
ALTA ‚Äî HU-17 tiene dos caras de complejidad significativa. El **write-side** extiende `evaluateProgression()` (ya 335 l√≠neas) con 5 bloques de evaluaci√≥n que ejecutan c√°lculos contra m√∫ltiples DAOs dentro de una transacci√≥n existente. El **read-side** crea 2 pantallas con rec√°lculo din√°mico de datos ‚Äî H2 especialmente complejo porque el an√°lisis causal var√≠a por tipo de alerta (7 tipos √ó 3 niveles = ~15 variantes de contenido). La complejidad real reside en: (1) la orquestaci√≥n correcta de Insert/Resolve de alertas con deduplicaci√≥n y escalamiento de nivel, (2) la l√≥gica condicional de H2 que recalcula datos usando 6 Rules distintas, (3) el acoplamiento transitivo con `SessionRepositoryImpl` que ya es el componente m√°s largo del proyecto (749 l√≠neas ‚Üí ~950 estimadas post-HU-17), (4) la correcta verificaci√≥n de descarga planificada para CA-17.19/CA-17.20.

**Riesgos t√©cnicos conocidos:**

1. **`evaluateProgression()` crece significativamente:** Actualmente tiene Steps 1-6 (~180 l√≠neas dentro de la funci√≥n). Agregar 5 Steps m√°s puede llevarla a ~280 l√≠neas. Mitigaci√≥n: extraer cada Step como m√©todo privado (`evaluateLowProgressionRate()`, `evaluateRirOutOfRange()`, etc.) siguiendo el patr√≥n ya establecido por `evaluateProgression()` como orquestador. Esto mantiene el m√©todo principal legible.
2. **`SessionRepositoryImpl` constructor ya tiene 12 par√°metros:** Agregar `ProfileDao` lo lleva a 13. No es ideal pero es aceptable dado que Room + Hilt resuelven la inyecci√≥n autom√°ticamente. Refactorizar a un patr√≥n con menos inyecciones (ej: Repository intermedio) introducir√≠a m√°s complejidad de la que resuelve.
3. **Transacci√≥n anidada en `evaluateProgression()`:** Los 5 nuevos Steps se ejecutan dentro del `database.withTransaction` de `closeSession()`. Si alg√∫n Step falla, toda la transacci√≥n de cierre de sesi√≥n se revierte. Mitigaci√≥n: cada Step usa try-catch individual para errores no cr√≠ticos (c√°lculos de alertas), asegurando que un fallo en alertas no revierta el cierre de sesi√≥n.
4. **`getRirValuesBySessionIds` retorna RIR de TODOS los ejercicios de la sesi√≥n combinados:** Para CA-17.08 se necesita evaluar el RIR de cada sesi√≥n individual. Soluci√≥n: invocar `getRirValuesBySessionIds(listOf(singleSessionId))` por separado para cada una de las 2 √∫ltimas sesiones del m√≥dulo, y calcular el promedio por sesi√≥n con `AvgRirRule.calculate()`. Esto es correcto porque el CA eval√∫a "RIR Promedio del m√≥dulo en cada sesi√≥n", no del m√≥dulo globalmente.
5. **`getClassificationCountsByPeriod` excluye sesiones de descarga (`deload_id IS NULL`):** Correcto para CA-17.05 ‚Äî las sesiones de descarga no cuentan para la tasa de progresi√≥n. Pero el `startDate` es un par√°metro de 4 semanas. En `evaluateProgression()`, calcular `startDate = LocalDate.now().minusWeeks(4).toString()`. Este c√°lculo es determinista y testeable.
6. **Deload guard NO debe proteger Steps 9 y 11:** El An√°lisis Arquitect√≥nico asume que los 5 nuevos tipos "no deben evaluarse durante descarga controlada", pero esto es incorrecto para adherencia e inactividad. CA-17.12 mide frecuencia semanal ‚Äî una sesi√≥n de descarga ES una sesi√≥n completada que cuenta. CA-17.29 resuelve inactividad al completar "una sesi√≥n de ese m√≥dulo" ‚Äî incluyendo sesiones de descarga. Mitigaci√≥n: mover `val moduleCode` antes del deload guard, invocar Steps 9/11 antes del guard, y dejar Steps 7/8/10 protegidos por el guard. Esto contradice la Nota de la Decisi√≥n #2 del Arquitecto ‚Äî la correcci√≥n est√° justificada por los CAs.

**Patrones y convenciones del equipo (establecidos en HU-01‚ÄîHU-16):**

- ViewModels: `@HiltViewModel` con `SavedStateHandle` para argumentos de navegaci√≥n, `MutableStateFlow<UiState>` + `asStateFlow()`, carga en `init {}` via `viewModelScope.launch`
- UiState: `sealed interface` con variantes `Loading`, `Empty`, `Loaded` (o `Success`/`Error` para operaciones con fallback)
- Use Cases: `class XxxUseCase @Inject constructor(private val repo: XxxRepository)` con `operator fun invoke()` delegando al Repository
- Use Cases en paquete: `domain.usecase.{feature}/` (ej: `session/`, `catalog/`, `metrics/`, `profile/`, `deload/`, `history/`)
- Domain Models: `data class` en `domain.model/` ‚Äî mapeo Entity‚ÜíModel en el Repository
- Rules: `object` en `domain.rules/` con funciones puras, constantes como `const val`, testeable sin mocks
- DAO DTOs: `data class` definida en el mismo archivo del DAO cuando es retorno de `@Query`
- Screens: `@Composable fun XxxScreen(...)` con patr√≥n `val uiState by viewModel.uiState.collectAsStateWithLifecycle()`
- Componentes Compose reutilizables: en `ui.components/` (ej: `ProgressionIndicator`, `TensionTopAppBar`, `BottomNavigationBar`)
- Navegaci√≥n: `NavigationRoutes` con `const val` + funciones factory `xxxRoute(id)`, composables en `TensionNavHost` con `navArgument`
- Strings: en `strings.xml`, agrupados por pantalla con comentarios `<!-- Secci√≥n -->`, formato `snake_case`
- Pipeline alertas existente: patr√≥n `if (!alertDao.existsActiveByXxx()) { alertDao.insert(...) } else { alertDao.resolveByXxxAndType(...) }` ‚Äî establecido por HU-12

**Dependencias nuevas a instalar:**
Ninguna.

**Estrategia de testing:**
JUnit 4 + MockK + Kotlin Coroutines Test | Tests unitarios para `AlertThresholdRule` (boundary values de todos los umbrales), 3 Use Cases (delegaci√≥n), pipeline Steps 7-11 de `SessionRepositoryImpl` (mocking DAOs + Rules), 2 ViewModels (transformaci√≥n de datos y estados) | Cobertura: 29 CAs cubiertos por ~12 archivos de test | Builders: no se requieren ‚Äî los tests usan domain models directos (data classes inmutables) con constructores expl√≠citos

### Historias Relacionadas Consultadas

**Implementaciones similares analizadas:**

- HU-12 ([HU-12.md](HU-12.md)): Cre√≥ la infraestructura de alertas completa: `AlertEntity`, `AlertDao` (insert, existsActive, resolve), patr√≥n PLATEAU alert en `evaluateProgression()` Steps 5d y 6, `PlateauCausalAnalysisRule`, `CorrectiveActionRule`. Este es el patr√≥n base para los 5 nuevos bloques de HU-17. Se reutiliza completamente.
- HU-14 ([HU-14.md](HU-14.md)): Cre√≥ el deload guard (`if (isDeloadSession) return` en l√≠nea 536 de `evaluateProgression()`), `DeloadLoadRule`, y la resoluci√≥n de `MODULE_REQUIRES_DELOAD` al activar descarga. Relevante para CA-17.19/CA-17.20 (verificaci√≥n de descarga planificada en ca√≠das de tonelaje).
- HU-15 ([HU-15.md](HU-15.md)): Cre√≥ las 4 Rules reutilizables: `ProgressionRateRule.calculate()`, `AvgRirRule.calculate()`, `AdherenceRule.calculate()`, `TonnageRule.calculateForMuscleGroup()`. Tambi√©n cre√≥ DAOs/queries de soporte: `getClassificationCountsByPeriod()`, `getRirValuesBySessionIds()`, `getTonnageDataBySessionIds()`, `countSessionsInWeek()`, `getSessionIdsByModuleInRange()`. **Todas reutilizables directamente sin modificaci√≥n.**
- HU-16 ([HU-16.md](HU-16.md)): Implement√≥ F3 (Historial de Ejercicio) con navegaci√≥n desde m√∫ltiples or√≠genes. H2‚ÜíF3 ser√° un nuevo origen ‚Äî la pantalla F3 ya acepta `exerciseId` como argumento de ruta y muestra Bottom Nav condicionalmente.
- HU-13 ([HU-13.md](HU-13.md)): Verific√≥ `existsActiveByModule("MODULE_REQUIRES_DELOAD")` para se√±al "Considerar descarga" en resumen post-sesi√≥n. Relevante como ejemplo del patr√≥n de lectura de alertas.

**Patrones de c√≥digo reutilizados:**

- Pipeline alert management: `if (!alertDao.existsActiveByXxx()) { alertDao.insert(...) } else if (condition_resolved) { alertDao.resolveByXxxAndType(...) }` (de `evaluateProgression()` Step 5d y Step 6)
- `object Rule` con funciones puras y constantes `const val` (de `ProgressionRateRule`, `AvgRirRule`, `PlateauCausalAnalysisRule`)
- `@HiltViewModel` con `sealed interface UiState` + `StateFlow` (de todos los ViewModels existentes)
- `CenterAlignedTopAppBar` con subt√≠tulo din√°mico (de `SessionSummaryScreen`, `SessionDetailScreen`)
- `combine()` con m√∫ltiples Flows para estado reactivo (de `HomeViewModel`)
- `LazyColumn` con secciones agrupadas y headers (de `ExerciseDictionaryScreen`, `SessionHistoryScreen`)
- `AssistChip` M3 read-only con colores por estado (de `ExerciseHistoryScreen`)
- `Text Button` con navegaci√≥n condicional (de `ExerciseHistoryScreen` ‚Äî "Ver t√©cnica de ejecuci√≥n ‚Üí")

**Mejores pr√°cticas aplicadas:**

- Centralizaci√≥n de umbrales m√°gicos en `AlertThresholdRule` ‚Äî evita dispersi√≥n de constantes por el c√≥digo
- Extracci√≥n de Steps como m√©todos privados dentro de `SessionRepositoryImpl` ‚Äî mantiene legibilidad del orquestador
- Deduplicaci√≥n de alertas con `existsActive*` antes de `insert` ‚Äî evita alertas duplicadas
- Escalamiento de nivel (MEDIUM_ALERT ‚Üí CRISIS) mediante resolve + insert ‚Äî no se modifica la alerta existente
- Rec√°lculo din√°mico en H2 (no almacenamiento) ‚Äî las sesiones cerradas son inmutables, el resultado es determinista
- `Flow<Int>` reactivo para badge de B1 ‚Äî el conteo se actualiza autom√°ticamente sin polling
- try-catch individual por Step en pipeline ‚Äî un fallo en alertas no revierte el cierre de sesi√≥n

---

## Tareas de Implementaci√≥n (Developer)

### Fase 1: Domain Models + AlertThresholdRule

<!-- Basado en Hito #1 del An√°lisis Arquitect√≥nico -->
<!-- AC: Infraestructura ‚Äî Modelos compartidos por pipeline, H1, H2 -->

#### üì¶ Domain Layer ‚Äî Modelos

- [ ] **Crear `AlertItem`** (usado por H1)
  - [ ] Crear archivo: `domain/model/AlertItem.kt`
  - [ ] Campos: `alertId: Long`, `type: String`, `level: String`, `entityName: String` (ejercicio/m√≥dulo/grupo muscular), `message: String`, `createdAt: String`

- [ ] **Crear `AlertTriggerData`** (usado por H2)
  - [ ] Crear archivo: `domain/model/AlertTriggerData.kt`
  - [ ] `sealed interface AlertTriggerData` con variantes:
    - `data class PlateauTrigger(val sessions: List<PlateauSession>)` con `data class PlateauSession(val date: String, val weightKg: Double, val totalReps: Int)`
    - `data class ProgressionRateTrigger(val rate: Double, val exerciseName: String)`
    - `data class RirTrigger(val avgRir: Double, val moduleCode: String, val isLow: Boolean)`
    - `data class AdherenceTrigger(val percentage: Double, val completedSessions: Int, val plannedSessions: Int, val consecutiveWeeks: Int)`
    - `data class TonnageDropTrigger(val muscleGroup: String, val dropPercentage: Double, val previousTonnage: Double, val currentTonnage: Double, val isDeloadContextualized: Boolean)`
    - `data class InactivityTrigger(val moduleCode: String, val daysSinceLastSession: Long, val muscleGroups: List<String>)`

- [ ] **Crear `AlertDetail`** (usado por H2)
  - [ ] Crear archivo: `domain/model/AlertDetail.kt`
  - [ ] Campos: `alertId: Long`, `type: String`, `level: String`, `entityName: String`, `message: String`, `createdAt: String`, `triggerData: AlertTriggerData`, `causalAnalysis: String`, `recommendations: List<String>`, `showExerciseHistoryLink: Boolean`, `showDeloadLink: Boolean`, `exerciseId: Long?`

- [ ] **Crear `ModuleInactivityData`** (usado por Step 11 del pipeline)
  - [ ] Crear archivo: `domain/model/ModuleInactivityData.kt`
  - [ ] Campos: `moduleCode: String`, `lastSessionDate: String?`, `daysSinceLastSession: Long`, `muscleGroups: List<String>`

#### üì¶ Domain Layer ‚Äî Rule

- [ ] **Crear `AlertThresholdRule`** (AC: 1, 2, 6, 7, 12, 13, 17, 18, 23, 24)
  - [ ] Crear archivo: `domain/rules/AlertThresholdRule.kt`
  - [ ] `object AlertThresholdRule` con constantes:
    - `const val PROGRESSION_ALERT_THRESHOLD = 40.0`
    - `const val PROGRESSION_CRISIS_THRESHOLD = 20.0`
    - `const val RIR_LOW_THRESHOLD = 1.5`
    - `const val RIR_HIGH_THRESHOLD = 3.5`
    - `const val RIR_SUSTAINED_SESSIONS = 2`
    - `const val ADHERENCE_THRESHOLD = 60.0`
    - `const val ADHERENCE_CRISIS_WEEKS = 2`
    - `const val TONNAGE_ALERT_THRESHOLD = 10.0`
    - `const val TONNAGE_CRISIS_THRESHOLD = 20.0`
    - `const val INACTIVITY_ALERT_DAYS = 10L`
    - `const val INACTIVITY_CRISIS_DAYS = 14L`
  - [ ] Funciones puras:
    - `fun isProgressionAlert(rate: Double): Boolean = rate < PROGRESSION_ALERT_THRESHOLD`
    - `fun isProgressionCrisis(rate: Double): Boolean = rate < PROGRESSION_CRISIS_THRESHOLD`
    - `fun isRirLow(avgRir: Double): Boolean = avgRir < RIR_LOW_THRESHOLD`
    - `fun isRirHigh(avgRir: Double): Boolean = avgRir > RIR_HIGH_THRESHOLD`
    - `fun isRirOutOfRange(avgRir: Double): Boolean = isRirLow(avgRir) || isRirHigh(avgRir)`
    - `fun isAdherenceLow(percentage: Double): Boolean = percentage < ADHERENCE_THRESHOLD`
    - `fun isTonnageAlert(dropPercentage: Double): Boolean = dropPercentage > TONNAGE_ALERT_THRESHOLD`
    - `fun isTonnageCrisis(dropPercentage: Double): Boolean = dropPercentage > TONNAGE_CRISIS_THRESHOLD`
    - `fun isInactivityAlert(days: Long): Boolean = days > INACTIVITY_ALERT_DAYS`
    - `fun isInactivityCrisis(days: Long): Boolean = days > INACTIVITY_CRISIS_DAYS`
    - `fun progressionLevel(rate: Double): String?` ‚Üí "CRISIS" si < 20%, "MEDIUM_ALERT" si < 40%, null si ‚â• 40%
    - `fun tonnageLevel(dropPercentage: Double, isDeloadSession: Boolean): String?` ‚Üí si isDeload: "MEDIUM_ALERT" si > 10% (nunca CRISIS); si no: "CRISIS" si > 20%, "MEDIUM_ALERT" si > 10%, null si ‚â§ 10%
    - `fun inactivityLevel(days: Long): String?` ‚Üí "CRISIS" si > 14, "MEDIUM_ALERT" si > 10, null si ‚â§ 10
  - [ ] Constante de grupos musculares por m√≥dulo (CA-17.25):
    - `val MUSCLE_GROUPS_BY_MODULE: Map<String, List<String>>` ‚Üí `"A" to listOf("Espalda", "B√≠ceps", "Abdomen")`, `"B" to listOf("Pecho", "Hombro", "Tr√≠ceps")`, `"C" to listOf("Cu√°driceps", "Isquiotibiales", "Gl√∫teos", "Aductores", "Abductores", "Gemelos")`

### Fase 2: DAO Queries

<!-- Basado en Hito #2 del An√°lisis Arquitect√≥nico -->
<!-- AC: CA-17.23, CA-17.26 (inactividad), CA-17.17/18 (tonelaje), lectura de alertas para H1/H2 -->

#### üì¶ Data Layer ‚Äî DAO

- [ ] **Agregar query `getAlertById()`** en `AlertDao` (para H2)
  - [ ] Modificar archivo: `data/local/dao/AlertDao.kt`
  - [ ] SQL: `SELECT * FROM alert WHERE id = :alertId`
  - [ ] Retorno: `suspend fun getAlertById(alertId: Long): AlertEntity?`

- [ ] **Agregar query `existsActiveByMuscleGroup()`** en `AlertDao` (para deduplicaci√≥n TONNAGE_DROP)
  - [ ] Modificar archivo: `data/local/dao/AlertDao.kt`
  - [ ] SQL: `SELECT EXISTS(SELECT 1 FROM alert WHERE muscle_group = :muscleGroup AND type = :type AND is_active = 1)`
  - [ ] Retorno: `suspend fun existsActiveByMuscleGroup(muscleGroup: String, type: String): Boolean`

- [ ] **Agregar query `resolveByMuscleGroupAndType()`** en `AlertDao` (para resolver TONNAGE_DROP)
  - [ ] Modificar archivo: `data/local/dao/AlertDao.kt`
  - [ ] SQL: `UPDATE alert SET is_active = 0, resolved_at = :resolvedAt WHERE muscle_group = :muscleGroup AND type = :type AND is_active = 1`
  - [ ] Retorno: `suspend fun resolveByMuscleGroupAndType(muscleGroup: String, type: String, resolvedAt: String)`

- [ ] **Agregar query `getLastSessionDateByModule()`** en `SessionDao` (CA: 23, 24, 26)
  - [ ] Modificar archivo: `data/local/dao/SessionDao.kt`
  - [ ] SQL: `SELECT MAX(s.date) FROM session s INNER JOIN module_version mv ON s.module_version_id = mv.id WHERE mv.module_code = :moduleCode AND s.status IN ('COMPLETED', 'INCOMPLETE')`
  - [ ] Retorno: `suspend fun getLastSessionDateByModule(moduleCode: String): String?`

- [ ] **Agregar queries para adherencia semanal anterior** en `SessionDao` (CA: 13)
  - [ ] Modificar archivo: `data/local/dao/SessionDao.kt`
  - [ ] Nota: `countSessionsInWeek(weekStartDate, weekEndDate)` ya existe. Para CA-17.13 (2+ semanas consecutivas) se invoca 2 veces: semana actual y semana anterior. No se necesita query nuevo ‚Äî solo calcular los rangos de fecha en el pipeline.

### Fase 3: AlertRepository

<!-- Basado en Hito #3 del An√°lisis Arquitect√≥nico -->
<!-- AC: Lectura de alertas para H1, H2 y badge B1 -->

#### üì¶ Domain Layer ‚Äî Interface

- [ ] **Crear interfaz `AlertRepository`**
  - [ ] Crear archivo: `domain/repository/AlertRepository.kt`
  - [ ] M√©todos:
    - `fun countActive(): Flow<Int>`
    - `fun getActiveAlerts(): Flow<List<AlertItem>>`
    - `suspend fun getAlertDetail(alertId: Long): AlertDetail`

#### üì¶ Data Layer ‚Äî Implementation

- [ ] **Crear `AlertRepositoryImpl`**
  - [ ] Crear archivo: `data/repository/AlertRepositoryImpl.kt`
  - [ ] Constructor `@Inject constructor`: `alertDao: AlertDao`, `sessionDao: SessionDao`, `exerciseDao: ExerciseDao`, `exerciseSetDao: ExerciseSetDao`, `sessionExerciseDao: SessionExerciseDao`, `exerciseProgressionDao: ExerciseProgressionDao`, `profileDao: ProfileDao`
  - [ ] **`countActive()`:** delega a `alertDao.countActive()` ‚Äî ya retorna `Flow<Int>`
  - [ ] **`getActiveAlerts()`:** mapea `alertDao.getActiveAlerts()` (retorna `Flow<List<AlertEntity>>`) a `Flow<List<AlertItem>>`. Para obtener `entityName`: si `exerciseId != null` ‚Üí `exerciseDao.getByIdOnce(exerciseId)?.name`; si `moduleCode != null` ‚Üí usar moduleCode directamente (ej: "M√≥dulo A"); si `muscleGroup != null` ‚Üí usar muscleGroup directamente. Nota: el mapeo requiere transformar cada entity con suspend calls ‚Äî usar `map { entities -> entities.map { mapToAlertItem(it) } }` dentro del Flow
  - [ ] **`getAlertDetail(alertId)`:** construye `AlertDetail` completo:
    - Carga `alertDao.getAlertById(alertId)` ‚Äî si null, throw `IllegalArgumentException`
    - Construye `triggerData` seg√∫n `alert.type`:
      - **PLATEAU:** obtener √∫ltimas 3 sesiones del ejercicio via `sessionExerciseDao.getExerciseHistoryEntries(exerciseId)` (reusar query HU-16), tomar las 3 primeras, mapear a `PlateauTrigger`
      - **LOW_PROGRESSION_RATE:** calcular tasa con `sessionExerciseDao.getClassificationCountsByPeriod(startDate)` para el ejercicio espec√≠fico, mapear a `ProgressionRateTrigger`
      - **RIR_OUT_OF_RANGE:** obtener RIR de las 2 √∫ltimas sesiones del m√≥dulo con `sessionDao.getSessionIdsByModuleInRange(moduleCode, 2)` + `exerciseSetDao.getRirValuesBySessionIds()` por sesi√≥n, mapear a `RirTrigger`
      - **LOW_ADHERENCE:** `sessionDao.countSessionsInWeek()` + `profileDao.getProfile().first()?.weeklyFrequency`, mapear a `AdherenceTrigger`
      - **TONNAGE_DROP:** recalcular tonelaje de los √∫ltimos 2 microciclos con `sessionDao.getClosedSessionsOrdered()` + `exerciseSetDao.getTonnageDataBySessionIds()` + `TonnageRule.calculateForMuscleGroup()`, mapear a `TonnageDropTrigger`. Verificar `deload_id` en las sesiones del microciclo para CA-17.19/CA-17.20
      - **MODULE_INACTIVITY:** `sessionDao.getLastSessionDateByModule()` + `ChronoUnit.DAYS.between()`, mapear a `InactivityTrigger` con `AlertThresholdRule.MUSCLE_GROUPS_BY_MODULE[moduleCode]`
      - **MODULE_REQUIRES_DELOAD:** an√°lisis causal existente con `PlateauCausalAnalysisRule` + `CorrectiveActionRule` (HU-12)
    - Construye `causalAnalysis` y `recommendations` seg√∫n tipo (Nota 2 del arquitecto)
    - Determina `showExerciseHistoryLink` = tipo ‚àà {PLATEAU, LOW_PROGRESSION_RATE} && exerciseId != null
    - Determina `showDeloadLink` = tipo ‚àà {MODULE_REQUIRES_DELOAD} || (tipo == RIR_OUT_OF_RANGE && isRirLow)

#### üì¶ DI Layer

- [ ] **Agregar binding en `RepositoryModule`**
  - [ ] Modificar archivo: `di/RepositoryModule.kt`
  - [ ] Agregar: `@Binds @Singleton abstract fun bindAlertRepository(impl: AlertRepositoryImpl): AlertRepository`

### Fase 4: Pipeline de Alertas (Write-Side)

<!-- Basado en Hito #4 del An√°lisis Arquitect√≥nico -->
<!-- AC: CA-17.01 a CA-17.29 (los 5 bloques de evaluaci√≥n) -->

#### üì¶ Data Layer ‚Äî SessionRepositoryImpl

- [ ] **Inyectar `ProfileDao` en constructor de `SessionRepositoryImpl`** (AC: 12)
  - [ ] Modificar archivo: `data/repository/SessionRepositoryImpl.kt`
  - [ ] Agregar `private val profileDao: ProfileDao` al constructor
  - [ ] Hilt lo resuelve autom√°ticamente ‚Äî `ProfileDao` ya est√° provisto por `DatabaseModule.provideProfileDao()`

- [ ] **Agregar Step 7: LOW_PROGRESSION_RATE** (AC: 1, 2, 3, 4, 5)
  - [ ] Modificar archivo: `data/repository/SessionRepositoryImpl.kt`
  - [ ] Crear m√©todo privado `evaluateLowProgressionRate(today: String)`
  - [ ] L√≥gica:
    1. `val startDate = LocalDate.now().minusWeeks(4).toString()`
    2. `val counts = sessionExerciseDao.getClassificationCountsByPeriod(startDate)`
    3. Para cada ejercicio en `counts`: `val rate = ProgressionRateRule.calculate(it.positiveCount, it.totalCount)`
    4. `val level = AlertThresholdRule.progressionLevel(rate)` ‚Üí si null, resolver cualquier alerta activa; si no null, verificar existencia y escalamiento
    5. Si `level != null`:
       - Si `alertDao.existsActiveByExercise(exerciseId, "LOW_PROGRESSION_RATE")` ‚Üí resolver alerta existente primero (puede ser de nivel distinto): `alertDao.resolveByExerciseAndType(exerciseId, "LOW_PROGRESSION_RATE", today)` y luego crear nueva con nivel correcto (patr√≥n resolve + re-insert para soportar escalamiento MEDIUM_ALERT ‚Üí CRISIS y de-escalamiento CRISIS ‚Üí MEDIUM_ALERT)
       - Si no existe alerta ‚Üí crear directamente
       - `alertDao.insert(AlertEntity(type = "LOW_PROGRESSION_RATE", level = level, exerciseId = exerciseId, message = "Tasa: ${rate.roundToInt()}%", createdAt = today))`
    6. Si `level == null` ‚Üí resolver cualquier alerta activa:
       - `alertDao.resolveByExerciseAndType(exerciseId, "LOW_PROGRESSION_RATE", today)`
  - [ ] Invocar al final de `evaluateProgression()`, despu√©s del bloque MODULE_REQUIRES_DELOAD

- [ ] **Agregar Step 8: RIR_OUT_OF_RANGE** (AC: 6, 7, 8, 9, 10, 11)
  - [ ] Modificar archivo: `data/repository/SessionRepositoryImpl.kt`
  - [ ] Crear m√©todo privado `evaluateRirOutOfRange(today: String)`
  - [ ] L√≥gica:
    1. Para cada m√≥dulo en `listOf("A", "B", "C")`:
    2. `val sessionIds = sessionDao.getSessionIdsByModuleInRange(moduleCode, 2)`
    3. Si `sessionIds.size < 2` ‚Üí skip (no hay suficientes sesiones para evaluar sostenimiento)
    4. Para cada sessionId individual: `val rirValues = exerciseSetDao.getRirValuesBySessionIds(listOf(sessionId))` ‚Üí `val avgRir = AvgRirRule.calculate(rirValues)`
    5. Si **ambas** sesiones cumplen `isRirLow(avgRir)` O ambas cumplen `isRirHigh(avgRir)`:
       - Determinar tipo: `isLow = isRirLow(firstAvg) && isRirLow(secondAvg)`
       - Si no existe alerta activa ‚Üí `alertDao.insert(AlertEntity(type = "RIR_OUT_OF_RANGE", level = "MEDIUM_ALERT", moduleCode = moduleCode, message = "RIR ${if(isLow) "<1.5" else ">3.5"} sostenido", createdAt = today))`
    6. Si ambas sesiones est√°n en rango √≥ptimo (1.5-3.5) y existe alerta activa ‚Üí `alertDao.resolveByModuleAndType(moduleCode, "RIR_OUT_OF_RANGE", today)` (CA-17.11)

- [ ] **Agregar Step 9: LOW_ADHERENCE** (AC: 12, 13, 14, 15, 16)
  - [ ] Modificar archivo: `data/repository/SessionRepositoryImpl.kt`
  - [ ] Crear m√©todo privado `evaluateLowAdherence(today: String)`
  - [ ] L√≥gica:
    1. `val profile = profileDao.getProfile().first() ?: return`
    2. `val weeklyFrequency = profile.weeklyFrequency`
    3. Calcular rangos de semana actual: `val todayDate = LocalDate.now()`, `val weekStart = todayDate.with(DayOfWeek.MONDAY).toString()`, `val weekEnd = todayDate.with(DayOfWeek.SUNDAY).toString()`
    4. `val currentWeekSessions = sessionDao.countSessionsInWeek(weekStart, weekEnd)`
    5. `val currentAdherence = AdherenceRule.calculate(currentWeekSessions, weeklyFrequency)`
    6. Si `isAdherenceLow(currentAdherence)`:
       - Calcular semana anterior: `val prevWeekStart = todayDate.minusWeeks(1).with(DayOfWeek.MONDAY).toString()`, `val prevWeekEnd = todayDate.minusWeeks(1).with(DayOfWeek.SUNDAY).toString()`
       - `val prevWeekSessions = sessionDao.countSessionsInWeek(prevWeekStart, prevWeekEnd)`
       - `val prevAdherence = AdherenceRule.calculate(prevWeekSessions, weeklyFrequency)`
       - Si `isAdherenceLow(prevAdherence)` ‚Üí nivel CRISIS (2+ semanas consecutivas, CA-17.13)
       - Si no ‚Üí nivel MEDIUM_ALERT (1 semana, CA-17.12)
       - Si alerta activa ya existe ‚Üí resolver primero (patr√≥n resolve + re-insert): `alertDao.resolveAllByType("LOW_ADHERENCE", today)` y luego crear nueva con nivel correcto (soporta escalamiento MEDIUM_ALERT ‚Üí CRISIS)
       - Si no existe ‚Üí crear directamente con nivel calculado
    7. Si `!isAdherenceLow(currentAdherence)` ‚Üí `alertDao.resolveAllByType("LOW_ADHERENCE", today)` (CA-17.16 ‚Äî resuelve crisis y alerta)

- [ ] **Agregar Step 10: TONNAGE_DROP** (AC: 17, 18, 19, 20, 21, 22)
  - [ ] Modificar archivo: `data/repository/SessionRepositoryImpl.kt`
  - [ ] Crear m√©todo privado `evaluateTonnageDrop(today: String)`
  - [ ] L√≥gica:
    1. `val closedSessions = sessionDao.getClosedSessionsOrdered()` (orden ASC por fecha)
    2. `val microcycles = closedSessions.chunked(6)` ‚Äî agrupar en microciclos de 6
    3. Si `microcycles.size < 2` ‚Üí return (no hay microciclo anterior para comparar)
    4. `val currentMicrocycle = microcycles.last()`, `val previousMicrocycle = microcycles[microcycles.size - 2]`
    5. Verificar si el microciclo actual es de descarga: `val isDeloadMicrocycle = currentMicrocycle.any { it.deloadId != null }`
    6. `val currentSessionIds = currentMicrocycle.map { it.id }`, `val previousSessionIds = previousMicrocycle.map { it.id }`
    7. `val currentTonnageData = exerciseSetDao.getTonnageDataBySessionIds(currentSessionIds)` ‚Üí mapear a `List<SetForTonnage>` ‚Üí `TonnageRule.calculateForMuscleGroup(currentTonnageSets)`
    8. `val previousTonnageData = exerciseSetDao.getTonnageDataBySessionIds(previousSessionIds)` ‚Üí idem
    9. Para cada grupo muscular en la uni√≥n de ambos mapas:
       - Calcular `dropPercentage = ((previous - current) / previous) * 100.0` (si previous > 0)
       - `val level = AlertThresholdRule.tonnageLevel(dropPercentage, isDeloadMicrocycle)` (CA-17.19/CA-17.20)
       - Si `level != null`:
         - Si `alertDao.existsActiveByMuscleGroup(muscleGroup, "TONNAGE_DROP")` ‚Üí resolver primero (patr√≥n resolve + re-insert): `alertDao.resolveByMuscleGroupAndType(muscleGroup, "TONNAGE_DROP", today)` y luego crear nueva con nivel correcto (soporta escalamiento MEDIUM_ALERT ‚Üí CRISIS)
         - Si no existe ‚Üí crear directamente
         - Insert alerta con mensaje contextualizado (si descarga ‚Üí "Descarga planificada ‚Äî ca√≠da esperada", si no ‚Üí "Ca√≠da de tonelaje ‚àíXX%")
       - Si `level == null` ‚Üí resolver alerta activa: `alertDao.resolveByMuscleGroupAndType(muscleGroup, "TONNAGE_DROP", today)`
  - [ ] Nota: `ExerciseSetDao.getTonnageDataBySessionIds()` retorna `List<SetTonnageData>` pero `TonnageRule.calculateForMuscleGroup()` requiere `List<SetForTonnage>`. Ambos tienen los mismos campos (`weightKg`, `reps`, `muscleGroup`) pero son clases distintas. Mapear expl√≠citamente: `tonnageData.map { SetForTonnage(it.weightKg, it.reps, it.muscleGroup) }` ‚Äî patr√≥n ya establecido en `GetTonnageByMuscleGroupUseCase.kt`

- [ ] **Agregar Step 11: MODULE_INACTIVITY** (AC: 23, 24, 25, 26, 27, 28, 29)
  - [ ] Modificar archivo: `data/repository/SessionRepositoryImpl.kt`
  - [ ] Crear m√©todo privado `evaluateModuleInactivity(today: String, currentModuleCode: String)`
  - [ ] L√≥gica:
    1. Para cada m√≥dulo en `listOf("A", "B", "C")`:
    2. Si `moduleCode == currentModuleCode` ‚Üí la sesi√≥n actual es de este m√≥dulo ‚Üí resolver alerta si existe (CA-17.29) y skip evaluaci√≥n
    3. `val lastDate = sessionDao.getLastSessionDateByModule(moduleCode)`
    4. Si `lastDate == null` ‚Üí skip (nunca ha entrenado ese m√≥dulo, no activar alerta)
    5. `val daysSince = ChronoUnit.DAYS.between(LocalDate.parse(lastDate), LocalDate.now())`
    6. `val level = AlertThresholdRule.inactivityLevel(daysSince)` ‚Üí si null, resolver alerta activa; si no null, insert/escalar
    7. Si `level != null`:
       - `val muscleGroups = AlertThresholdRule.MUSCLE_GROUPS_BY_MODULE[moduleCode] ?: emptyList()`
       - Si `alertDao.existsActiveByModule(moduleCode, "MODULE_INACTIVITY")` ‚Üí resolver primero (patr√≥n resolve + re-insert): `alertDao.resolveByModuleAndType(moduleCode, "MODULE_INACTIVITY", today)` y luego crear nueva con nivel correcto (soporta escalamiento MEDIUM_ALERT ‚Üí CRISIS cuando pasa de >10 a >14 d√≠as)
       - Si no existe ‚Üí crear directamente
       - Insert nueva con `level`, `muscleGroup = muscleGroups.joinToString(", ")`
       - Mensaje: "M√≥dulo $moduleCode: $daysSince d√≠as sin sesi√≥n ‚Äî ${muscleGroups.joinToString(", ")}"
    8. Si `level == null` ‚Üí `alertDao.resolveByModuleAndType(moduleCode, "MODULE_INACTIVITY", today)`
  - [ ] Par√°metro `currentModuleCode`: obtener del `moduleCode` ya disponible en `evaluateProgression()` (variable `moduleCode` extra√≠da ANTES del deload guard ‚Äî ver tarea "Extraer `moduleCode` ANTES del deload guard")

- [ ] **Extraer `moduleCode` ANTES del deload guard** (prerequisito de reestructuraci√≥n)
  - [ ] Modificar archivo: `data/repository/SessionRepositoryImpl.kt`
  - [ ] Mover `val moduleCode = exercises.firstOrNull()?.moduleCode ?: return` de la l√≠nea 538 (despu√©s del deload guard) a ANTES de la l√≠nea 536 (antes del deload guard). Esto permite que Steps 9 y 11 accedan a `moduleCode` durante sesiones de descarga.

- [ ] **Invocar Steps 9 y 11 ANTES del deload guard** (correcci√≥n cr√≠tica ‚Äî CA-17.12, CA-17.29)
  - [ ] Modificar archivo: `data/repository/SessionRepositoryImpl.kt`
  - [ ] ANTES de la l√≠nea 536 (`if (isDeloadSession) return`), agregar:
    ```kotlin
    // Step 9 & 11: Adherence + Inactivity (HU-17)
    // These steps evaluate regardless of deload status because:
    // - Adherence measures weekly training frequency ‚Äî deload sessions count as completed sessions
    // - Inactivity measures calendar days without a module ‚Äî deload sessions of a module resolve inactivity
    try { evaluateLowAdherence(today) } catch (_: Exception) { }
    try { evaluateModuleInactivity(today, moduleCode) } catch (_: Exception) { }
    ```
  - [ ] Justificaci√≥n: CA-17.12 eval√∫a adherencia "al finalizar una semana natural" ‚Äî una sesi√≥n de descarga S√ç es una sesi√≥n completada que cuenta para la frecuencia semanal. CA-17.29 dice que completar "una sesi√≥n de ese m√≥dulo" resuelve la inactividad ‚Äî una sesi√≥n de descarga del m√≥dulo A S√ç resuelve la inactividad de A.

- [ ] **Invocar Steps 7, 8, 10 DESPU√âS del deload guard y MODULE_REQUIRES_DELOAD**
  - [ ] Modificar archivo: `data/repository/SessionRepositoryImpl.kt`
  - [ ] Despu√©s del bloque MODULE_REQUIRES_DELOAD (l√≠nea ~575), agregar:
    ```kotlin
    // Step 7, 8, 10: Progression Rate, RIR, Tonnage (HU-17)
    // These steps are correctly guarded by deload because:
    // - Progression: deload sessions use IN_DELOAD classification, not meant for progression evaluation
    // - RIR: deload sessions target RIR 4-5 intentionally, would trigger false RIR_HIGH alerts
    // - Tonnage: deload sessions use 60% load, drops are expected and handled at microcycle level by CA-17.19/CA-17.20
    try { evaluateLowProgressionRate(today) } catch (_: Exception) { }
    try { evaluateRirOutOfRange(today) } catch (_: Exception) { }
    try { evaluateTonnageDrop(today) } catch (_: Exception) { }
    ```
  - [ ] Nota: el deload guard existente (`if (isDeloadSession) return` en l√≠nea 536) protege correctamente Steps 7, 8, 10 ‚Äî la progresi√≥n, RIR y tonelaje individual NO deben evaluarse durante descarga controlada. Steps 9 y 11 se ejecutan antes del guard.

### Fase 5: Use Cases

<!-- Basado en Hito #5 del An√°lisis Arquitect√≥nico -->
<!-- AC: Lectura para badge B1, lista H1, detalle H2 -->

#### üì¶ Domain Layer ‚Äî Use Cases

- [ ] **Crear `GetActiveAlertCountUseCase`** (AC: badge B1)
  - [ ] Crear archivo: `domain/usecase/alerts/GetActiveAlertCountUseCase.kt`
  - [ ] `class GetActiveAlertCountUseCase @Inject constructor(private val alertRepository: AlertRepository)`
  - [ ] `operator fun invoke(): Flow<Int> = alertRepository.countActive()`

- [ ] **Crear `GetActiveAlertsUseCase`** (AC: H1)
  - [ ] Crear archivo: `domain/usecase/alerts/GetActiveAlertsUseCase.kt`
  - [ ] `class GetActiveAlertsUseCase @Inject constructor(private val alertRepository: AlertRepository)`
  - [ ] `operator fun invoke(): Flow<List<AlertItem>> = alertRepository.getActiveAlerts()`

- [ ] **Crear `GetAlertDetailUseCase`** (AC: H2)
  - [ ] Crear archivo: `domain/usecase/alerts/GetAlertDetailUseCase.kt`
  - [ ] `class GetAlertDetailUseCase @Inject constructor(private val alertRepository: AlertRepository)`
  - [ ] `suspend operator fun invoke(alertId: Long): AlertDetail = alertRepository.getAlertDetail(alertId)`

### Fase 6: B1 Badge Reactivo

<!-- Basado en Hito #6 del An√°lisis Arquitect√≥nico -->
<!-- AC: Infraestructura ‚Äî Badge refleja conteo real de alertas activas -->

#### üì¶ UI Layer ‚Äî HomeViewModel

- [ ] **Inyectar `GetActiveAlertCountUseCase` en `HomeViewModel`**
  - [ ] Modificar archivo: `ui/home/HomeViewModel.kt`
  - [ ] Agregar al constructor: `private val getActiveAlertCountUseCase: GetActiveAlertCountUseCase`
  - [ ] Reemplazar el `combine(3 flows)` con `combine(4 flows)`:
    - Antes: `combine(getNextSessionInfoUseCase(), getActiveSessionUseCase(), getMicrocycleCountUseCase()) { nextSession, activeSession, microcycleCount -> HomeUiState(..., alertCount = 0) }`
    - Despu√©s: `combine(getNextSessionInfoUseCase(), getActiveSessionUseCase(), getMicrocycleCountUseCase(), getActiveAlertCountUseCase()) { nextSession, activeSession, microcycleCount, alertCount -> HomeUiState(..., alertCount = alertCount) }`
  - [ ] Nota: `combine` con 4 par√°metros usa el overload destructurado (soporta hasta 5 flows sin array): `combine(flow1, flow2, flow3, flow4) { nextSession, activeSession, microcycleCount, alertCount -> ... }`

### Fase 7: H1 ‚Äî Centro de Alertas (Screen + ViewModel + Componentes)

<!-- Basado en Hito #7 del An√°lisis Arquitect√≥nico -->
<!-- AC: Diferenciaci√≥n visual (CA-17.03, 09, 14, 21, 27), estado vac√≠o, agrupaci√≥n -->

#### üì¶ UI Layer ‚Äî Componente reutilizable

- [ ] **Crear `AlertLevelIndicator`** (reutilizable en H1 y H2)
  - [ ] Crear archivo: `ui/components/AlertLevelIndicator.kt`
  - [ ] Par√°metros: `level: String` ("CRISIS" / "HIGH_ALERT" / "MEDIUM_ALERT"), `size: Dp` (12dp para H1, 16dp para H2)
  - [ ] Renderiza un `Box` circular (`clip(CircleShape)`) con color de fondo seg√∫n level:
    - CRISIS ‚Üí `Color(0xFFC62828)` (claro) / `Color(0xFFEF9A9A)` (oscuro)
    - HIGH_ALERT ‚Üí `Color(0xFFE65100)` (claro) / `Color(0xFFFFB74D)` (oscuro)
    - MEDIUM_ALERT ‚Üí `Color(0xFF8D6E00)` (claro) / `Color(0xFFFFD54F)` (oscuro)
  - [ ] Usar `isSystemInDarkTheme()` para seleccionar paleta

#### üì¶ UI Layer ‚Äî ViewModel

- [ ] **Crear `AlertCenterUiState`**
  - [ ] Crear archivo: `ui/alerts/AlertCenterUiState.kt`
  - [ ] `sealed interface AlertCenterUiState` con variantes:
    - `data object Loading`
    - `data object Empty`
    - `data class Loaded(val crisisAlerts: List<AlertItem>, val regularAlerts: List<AlertItem>, val totalCount: Int)`

- [ ] **Crear `AlertCenterViewModel`**
  - [ ] Crear archivo: `ui/alerts/AlertCenterViewModel.kt`
  - [ ] `@HiltViewModel class AlertCenterViewModel @Inject constructor(private val getActiveAlertsUseCase: GetActiveAlertsUseCase)`
  - [ ] `init {}`: launch ‚Üí collect Flow ‚Üí si lista vac√≠a ‚Üí `Empty`; si no ‚Üí separar en `crisisAlerts` (level == "CRISIS") y `regularAlerts` (level != "CRISIS"), crear `Loaded`
  - [ ] StateFlow: `MutableStateFlow<AlertCenterUiState>(Loading)` + `asStateFlow()`

#### üì¶ UI Layer ‚Äî Pantalla

- [ ] **Crear `AlertCenterScreen`** (H1)
  - [ ] Crear archivo: `ui/alerts/AlertCenterScreen.kt`
  - [ ] Par√°metros: `onNavigateBack: () -> Unit`, `onNavigateToAlertDetail: (Long) -> Unit`, `viewModel: AlertCenterViewModel = hiltViewModel()`
  - [ ] Scaffold con `CenterAlignedTopAppBar`: t√≠tulo "Alertas", subt√≠tulo "N alertas activas" (din√°mico), navigationIcon ArrowBack ‚Üí `onNavigateBack`
  - [ ] Body `when (uiState)`:
    - `Loading`: `CircularProgressIndicator` centrado
    - `Empty`: Column centrada ‚Äî √≠cono ‚úÖ 48dp verde `#2E7D32`, texto "No hay alertas activas. Todo en orden." Body Large On Surface Variant, padding 48dp
    - `Loaded`: `LazyColumn` con:
      1. **Secci√≥n "Crisis"** (si `crisisAlerts.isNotEmpty()`): header Row con Title Small Error `#BA1A1A`, Divider Error 1dp, margin bottom 12dp, luego `AlertCard` por cada alerta crisis con fondo Error Container ‚Üí clickable ‚Üí `onNavigateToAlertDetail(alertId)`
      2. **Secci√≥n "Alertas"** (si `regularAlerts.isNotEmpty()`): header Row con Title Small On Surface Variant, Divider Outline Variant, margin top 16dp si hay crisis arriba, luego `AlertCard` por cada alerta regular ‚Üí clickable ‚Üí `onNavigateToAlertDetail(alertId)`
  - [ ] Cada `AlertCard`: Filled/Elevated Card seg√∫n nivel, leading `AlertLevelIndicator(level, 12.dp)`, t√≠tulo tipo (Title Medium), entidad afectada (Body Medium), dato clave (Body Small). Colores de fondo/texto por nivel seg√∫n Especificaci√≥n Visual ¬ßH1

- [ ] **Crear `AlertCard` composable** (componente local de H1)
  - [ ] Crear archivo: `ui/alerts/AlertCard.kt`
  - [ ] Par√°metros: `alert: AlertItem`, `onClick: () -> Unit`
  - [ ] Determinar fondo/texto por level:
    - CRISIS ‚Üí Elevated Card, fondo Error Container (`#FFDAD6`/`#930009`), texto On Error Container, Elevation 2
    - HIGH_ALERT ‚Üí Filled Card, fondo `#FFF3E0`/`#4E2600`, texto On Surface
    - MEDIUM_ALERT ‚Üí Filled Card, fondo `#FFF8E1`/`#4A3800`, texto On Surface
  - [ ] Layout: Row con `AlertLevelIndicator` leading + Column (tipo alerta Title Medium + entidad Body Medium + dato clave Body Small)
  - [ ] `clickable(onClick = onClick)`

### Fase 8: H2 ‚Äî Detalle de Alerta (Screen + ViewModel)

<!-- Basado en Hito #8 del An√°lisis Arquitect√≥nico -->
<!-- AC: Datos disparadores, an√°lisis causal, recomendaciones, links condicionales -->

#### üì¶ UI Layer ‚Äî ViewModel

- [ ] **Crear `AlertDetailUiState`**
  - [ ] Crear archivo: `ui/alerts/AlertDetailUiState.kt`
  - [ ] `sealed interface AlertDetailUiState` con variantes: `data object Loading`, `data class Loaded(val detail: AlertDetail)`

- [ ] **Crear `AlertDetailViewModel`**
  - [ ] Crear archivo: `ui/alerts/AlertDetailViewModel.kt`
  - [ ] `@HiltViewModel class AlertDetailViewModel @Inject constructor(private val getAlertDetailUseCase: GetAlertDetailUseCase, savedStateHandle: SavedStateHandle)`
  - [ ] `val alertId: Long = savedStateHandle.get<Long>("alertId") ?: throw IllegalArgumentException("alertId is required")`
  - [ ] `init {}`: launch ‚Üí invoke use case ‚Üí `Loaded(detail)`

#### üì¶ UI Layer ‚Äî Pantalla

- [ ] **Crear `AlertDetailScreen`** (H2)
  - [ ] Crear archivo: `ui/alerts/AlertDetailScreen.kt`
  - [ ] Par√°metros: `onNavigateBack: () -> Unit`, `onNavigateToExerciseHistory: (Long) -> Unit`, `onNavigateToDeloadManagement: () -> Unit`, `viewModel: AlertDetailViewModel = hiltViewModel()`
  - [ ] Scaffold con `CenterAlignedTopAppBar`: t√≠tulo "Detalle de Alerta", navigationIcon ArrowBack ‚Üí `onNavigateBack`
  - [ ] Body `when (uiState)`:
    - `Loading`: `CircularProgressIndicator` centrado
    - `Loaded`: `LazyColumn` con:
      1. **Card tipo y nivel** ‚Äî Filled Card con fondo por nivel (mismos colores que H1), leading `AlertLevelIndicator(level, 16.dp)`, t√≠tulo tipo alerta (Title Medium), entidad afectada (Body Medium), dato resumen (Body Small)
      2. **Divider**
      3. **Datos que dispararon la alerta** ‚Äî Filled Card Surface Container High (`#F2E5DA`), corner 12dp. Contenido var√≠a por tipo de `triggerData`:
         - `PlateauTrigger` ‚Üí lista de sesiones: "Sesi√≥n N: X Kg ¬∑ Y reps" Body Medium + per√≠odo Body Small
         - `ProgressionRateTrigger` ‚Üí "Tasa de progresi√≥n: XX%" Body Medium
         - `RirTrigger` ‚Üí "RIR promedio: X.X ‚Äî M√≥dulo Y" Body Medium
         - `AdherenceTrigger` ‚Üí "Adherencia: XX% (N/M sesiones)" + "N semanas consecutivas" Body Medium
         - `TonnageDropTrigger` ‚Üí "Grupo: X ‚Äî Ca√≠da: XX%" + tonelaje anterior vs actual Body Medium. Si `isDeloadContextualized` ‚Üí texto azul "Descarga planificada ‚Äî ca√≠da esperada"
         - `InactivityTrigger` ‚Üí "M√≥dulo X: N d√≠as sin sesi√≥n" + "Grupos afectados: ..." Body Medium
      4. **Divider**
      5. **An√°lisis causal** ‚Äî Column sin card, padding 16dp. Body Large On Surface. Texto de `detail.causalAnalysis`
      6. **Divider**
      7. **Recomendaciones** ‚Äî Column con header Title Small "Recomendaciones". Cada recomendaci√≥n: Row con leading "‚ñ∏" Primary + Body Medium On Surface. Spacing 8dp
      8. **Divider** (si hay links)
      9. **Links condicionales:**
         - Si `showExerciseHistoryLink` ‚Üí Text Button "Ver historial del ejercicio ‚Üí" Primary ‚Üí `onNavigateToExerciseHistory(exerciseId!!)`
         - Si `showDeloadLink` ‚Üí Text Button "Gestionar descarga ‚Üí" Primary ‚Üí `onNavigateToDeloadManagement()`

### Fase 9: Navegaci√≥n y Strings

<!-- Basado en Hito #9 del An√°lisis Arquitect√≥nico -->
<!-- AC: Navegaci√≥n B1‚ÜíH1‚ÜíH2‚ÜíF3/I1, badge reactivo, Bottom Nav -->

#### üì¶ Navigation Layer

- [ ] **Agregar rutas en `NavigationRoutes`**
  - [ ] Modificar archivo: `ui/navigation/NavigationRoutes.kt`
  - [ ] Agregar: `const val ALERT_CENTER = "alert-center"`
  - [ ] Agregar: `const val ALERT_DETAIL = "alert-detail/{alertId}"`
  - [ ] Agregar: `fun alertDetailRoute(alertId: Long) = "alert-detail/$alertId"`

- [ ] **Actualizar `TensionNavHost`**
  - [ ] Modificar archivo: `ui/navigation/TensionNavHost.kt`
  - [ ] Reemplazar `onNavigateToAlerts = { /* TODO: HU-17 */ }` con:
    `onNavigateToAlerts = { navController.navigate(NavigationRoutes.ALERT_CENTER) }`
  - [ ] Agregar composable `ALERT_CENTER`:
    ```
    composable(NavigationRoutes.ALERT_CENTER) {
        AlertCenterScreen(
            onNavigateBack = { navController.popBackStack() },
            onNavigateToAlertDetail = { alertId ->
                navController.navigate(NavigationRoutes.alertDetailRoute(alertId))
            },
        )
    }
    ```
  - [ ] Agregar composable `ALERT_DETAIL`:
    ```
    composable(
        route = NavigationRoutes.ALERT_DETAIL,
        arguments = listOf(navArgument("alertId") { type = NavType.LongType }),
    ) {
        AlertDetailScreen(
            onNavigateBack = { navController.popBackStack() },
            onNavigateToExerciseHistory = { exerciseId ->
                navController.navigate(NavigationRoutes.exerciseHistoryRoute(exerciseId))
            },
            onNavigateToDeloadManagement = {
                navController.navigate(NavigationRoutes.DELOAD_MANAGEMENT)
            },
        )
    }
    ```

- [ ] **Actualizar `BottomNavigationBar`** (Nota 7 del arquitecto)
  - [ ] Modificar archivo: `ui/components/BottomNavigationBar.kt`
  - [ ] Agregar `childRoutePrefixes` al `BottomNavItem` de HOME:
    - Antes: no tiene `childRoutePrefixes`
    - Despu√©s: `childRoutePrefixes = setOf("alert-center", "alert-detail")`
  - [ ] Esto asegura que el tab "Inicio" aparezca seleccionado en H1 y H2

#### üì¶ Resources

- [ ] **Agregar strings en `strings.xml`**
  - [ ] Modificar archivo: `res/values/strings.xml`
  - [ ] Agregar secci√≥n `<!-- Alert Center H1 -->`:
    - `alert_center_title` = "Alertas"
    - `alert_center_subtitle` = "%1$d alertas activas"
    - `alert_center_empty` = "No hay alertas activas. Todo en orden."
    - `alert_center_section_crisis` = "Crisis"
    - `alert_center_section_alerts` = "Alertas"
  - [ ] Agregar secci√≥n `<!-- Alert Detail H2 -->`:
    - `alert_detail_title` = "Detalle de Alerta"
    - `alert_detail_recommendations_title` = "Recomendaciones"
    - `alert_detail_view_history` = "Ver historial del ejercicio \u2192"
    - `alert_detail_manage_deload` = "Gestionar descarga \u2192"
    - `alert_detail_period_format` = "Per√≠odo: %1$s ‚Äî %2$s"
  - [ ] Agregar secci√≥n `<!-- Alert Types -->`:
    - `alert_type_plateau` = "Meseta detectada"
    - `alert_type_low_progression` = "Tasa de progresi√≥n baja"
    - `alert_type_rir_out_of_range` = "RIR fuera de rango"
    - `alert_type_low_adherence` = "Adherencia baja"
    - `alert_type_tonnage_drop` = "Ca√≠da de tonelaje"
    - `alert_type_module_inactivity` = "Inactividad por m√≥dulo"
    - `alert_type_module_requires_deload` = "M√≥dulo requiere descarga"
  - [ ] Agregar secci√≥n `<!-- Alert Causal Analysis -->`:
    - `alert_analysis_rir_low` = "El ejecutante est√° entrenando demasiado cerca del fallo t√©cnico de forma sostenida. Se recomienda prescribir una descarga para permitir recuperaci√≥n del SNC."
    - `alert_analysis_rir_high` = "El est√≠mulo puede ser insuficiente para generar adaptaci√≥n. Se recomienda incrementar la carga de los ejercicios del m√≥dulo."
    - `alert_analysis_adherence_single` = "Adherencia por debajo del 60%% esta semana. La baja frecuencia puede afectar la resoluci√≥n temporal de las se√±ales del sistema."
    - `alert_analysis_adherence_consecutive` = "Adherencia por debajo del 60%% durante %1$d semanas consecutivas. Las comparaciones entre sesiones pierden validez por el excesivo tiempo entre ellas."
    - `alert_analysis_tonnage_deload` = "Descarga planificada ‚Äî ca√≠da de tonelaje esperada y controlada."
    - `alert_analysis_tonnage_regression` = "Ca√≠da no intencional de tonelaje. Evaluar causas y considerar ajustar el volumen de entrenamiento."
    - `alert_analysis_inactivity` = "M√≥dulo %1$s lleva %2$d d√≠as sin sesi√≥n. Los grupos musculares asociados (%3$s) pueden estar perdiendo adaptaciones."
    - `alert_analysis_progression_low` = "Tasa de progresi√≥n por debajo del umbral de alerta. El ejercicio muestra estancamiento sostenido."
    - `alert_analysis_progression_crisis` = "Tasa de progresi√≥n en estado cr√≠tico. El ejercicio muestra estancamiento prolongado que compromete las adaptaciones."
  - [ ] Agregar secci√≥n `<!-- Alert Recommendations -->`:
    - `alert_recommendation_deload` = "Considerar prescribir una descarga para permitir recuperaci√≥n"
    - `alert_recommendation_increase_load` = "Incrementar la carga de los ejercicios del m√≥dulo"
    - `alert_recommendation_increase_frequency` = "Incrementar la frecuencia de entrenamiento semanal"
    - `alert_recommendation_prioritize_module` = "Priorizar el m√≥dulo %1$s en las pr√≥ximas sesiones"

### Fase 10: Tests Unitarios

<!-- Basado en Hito #10 del An√°lisis Arquitect√≥nico -->
<!-- AC: Todos los CAs cubiertos por tests del pipeline y UI -->

#### üß™ Tests ‚Äî AlertThresholdRule

- [ ] **Test `AlertThresholdRuleTest`** (AC: 1, 2, 6, 7, 12, 17, 18, 23, 24)
  - [ ] Crear archivo: `test/.../domain/rules/AlertThresholdRuleTest.kt`
  - [ ] Caso 1: `isProgressionAlert returns true for rate below 40` ‚Äî assert `isProgressionAlert(39.9) == true`, `isProgressionAlert(40.0) == false`
  - [ ] Caso 2: `isProgressionCrisis returns true for rate below 20` ‚Äî assert `isProgressionCrisis(19.9) == true`, `isProgressionCrisis(20.0) == false`
  - [ ] Caso 3: `isRirLow returns true for avgRir below 1_5` ‚Äî assert `isRirLow(1.4) == true`, `isRirLow(1.5) == false`
  - [ ] Caso 4: `isRirHigh returns true for avgRir above 3_5` ‚Äî assert `isRirHigh(3.6) == true`, `isRirHigh(3.5) == false`
  - [ ] Caso 5: `isAdherenceLow returns true for percentage below 60` ‚Äî assert boundary values
  - [ ] Caso 6: `isTonnageAlert returns true for drop above 10 percent` ‚Äî assert boundary values
  - [ ] Caso 7: `isTonnageCrisis returns true for drop above 20 percent` ‚Äî assert boundary values
  - [ ] Caso 8: `isInactivityAlert returns true for days above 10` ‚Äî assert `isInactivityAlert(11) == true`, `isInactivityAlert(10) == false`
  - [ ] Caso 9: `isInactivityCrisis returns true for days above 14` ‚Äî assert boundary values
  - [ ] Caso 10: `progressionLevel returns CRISIS for rate below 20, MEDIUM_ALERT for below 40, null for 40 or above`
  - [ ] Caso 11: `tonnageLevel with deload always returns MEDIUM_ALERT never CRISIS` ‚Äî assert `tonnageLevel(25.0, true) == "MEDIUM_ALERT"` (CA-17.19/CA-17.20)
  - [ ] Caso 12: `inactivityLevel returns correct level for boundary values`
  - [ ] Caso 13: `MUSCLE_GROUPS_BY_MODULE contains correct groups for A B C` ‚Äî verify CA-17.25

#### üß™ Tests ‚Äî Use Cases

- [ ] **Test `GetActiveAlertCountUseCaseTest`**
  - [ ] Crear archivo: `test/.../domain/usecase/alerts/GetActiveAlertCountUseCaseTest.kt`
  - [ ] Caso 1: `invoke returns flow with count from repository` ‚Äî mock repository, assert flow emits value

- [ ] **Test `GetActiveAlertsUseCaseTest`**
  - [ ] Crear archivo: `test/.../domain/usecase/alerts/GetActiveAlertsUseCaseTest.kt`
  - [ ] Caso 1: `invoke returns flow with alerts from repository` ‚Äî mock repository, assert flow emits list

- [ ] **Test `GetAlertDetailUseCaseTest`**
  - [ ] Crear archivo: `test/.../domain/usecase/alerts/GetAlertDetailUseCaseTest.kt`
  - [ ] Caso 1: `invoke returns alert detail from repository` ‚Äî mock repository, assert correct detail returned

#### üß™ Tests ‚Äî ViewModels

- [ ] **Test `AlertCenterViewModelTest`** (AC: 3, 9, 14, 21, 27)
  - [ ] Crear archivo: `test/.../ui/alerts/AlertCenterViewModelTest.kt`
  - [ ] Caso 1: `initial state is Loading`
  - [ ] Caso 2: `state transitions to Loaded with crisis and regular alerts separated` ‚Äî mock UseCase returns mixed list, assert crisis/regular separation
  - [ ] Caso 3: `state transitions to Empty when no alerts` ‚Äî mock UseCase returns empty list
  - [ ] Caso 4: `totalCount reflects total number of alerts`

- [ ] **Test `AlertDetailViewModelTest`**
  - [ ] Crear archivo: `test/.../ui/alerts/AlertDetailViewModelTest.kt`
  - [ ] Caso 1: `loads alert detail on init` ‚Äî mock UseCase + SavedStateHandle with alertId, assert `Loaded`
  - [ ] Caso 2: `throws when alertId missing` ‚Äî empty SavedStateHandle, assert `IllegalArgumentException`

#### üß™ Tests ‚Äî Pipeline Steps

- [ ] **Test `EvaluateLowProgressionRateTest`** (AC: 1, 2, 5)
  - [ ] Crear archivo: `test/.../data/repository/EvaluateLowProgressionRateTest.kt`
  - [ ] Caso 1: `creates MEDIUM_ALERT when progression rate below 40 percent` ‚Äî mock DAOs, verify `alertDao.insert` called with level MEDIUM_ALERT
  - [ ] Caso 2: `creates CRISIS when progression rate below 20 percent` ‚Äî verify level CRISIS
  - [ ] Caso 3: `resolves alert when progression rate recovers above 40 percent` ‚Äî verify `resolveByExerciseAndType` called
  - [ ] Caso 4: `escalates from MEDIUM_ALERT to CRISIS when rate drops further` ‚Äî mock `existsActiveByExercise = true` + rate 15% ‚Üí verify `resolveByExerciseAndType` called AND then `insert` called with level CRISIS (patr√≥n resolve + re-insert)
  - [ ] Caso 5: `skips resolve and re-insert when level has not changed` ‚Äî mock `existsActiveByExercise = true` + rate 35% (still MEDIUM_ALERT) ‚Üí verify optimization: either skip entirely (no unnecessary DB churn) or accept resolve+re-insert as idempotent

- [ ] **Test `EvaluateRirOutOfRangeTest`** (AC: 6, 7, 8, 11)
  - [ ] Crear archivo: `test/.../data/repository/EvaluateRirOutOfRangeTest.kt`
  - [ ] Caso 1: `creates alert when both sessions have RIR below 1_5` ‚Äî verify insert called
  - [ ] Caso 2: `creates alert when both sessions have RIR above 3_5` ‚Äî verify insert called
  - [ ] Caso 3: `does not create alert when only one session is out of range` ‚Äî verify insert NOT called (CA-17.08)
  - [ ] Caso 4: `resolves alert when RIR returns to optimal range` ‚Äî verify resolve called (CA-17.11)
  - [ ] Caso 5: `skips module with fewer than 2 sessions` ‚Äî verify no action

- [ ] **Test `EvaluateLowAdherenceTest`** (AC: 12, 13, 16)
  - [ ] Crear archivo: `test/.../data/repository/EvaluateLowAdherenceTest.kt`
  - [ ] Caso 1: `creates MEDIUM_ALERT when single week below 60 percent` ‚Äî verify level MEDIUM_ALERT
  - [ ] Caso 2: `creates CRISIS when two consecutive weeks below 60 percent` ‚Äî verify level CRISIS (CA-17.13)
  - [ ] Caso 3: `resolves all adherence alerts when current week is 60 percent or above` ‚Äî verify `resolveAllByType` called (CA-17.16)
  - [ ] Caso 4: `evaluates even during deload session` ‚Äî verify adherence evaluation runs when `isDeloadSession = true` (Step 9 is before deload guard)

- [ ] **Test `EvaluateTonnageDropTest`** (AC: 17, 18, 19, 20)
  - [ ] Crear archivo: `test/.../data/repository/EvaluateTonnageDropTest.kt`
  - [ ] Caso 1: `creates MEDIUM_ALERT when tonnage drops more than 10 percent`
  - [ ] Caso 2: `creates CRISIS when tonnage drops more than 20 percent`
  - [ ] Caso 3: `creates MEDIUM_ALERT instead of CRISIS during deload microcycle` ‚Äî CA-17.19/CA-17.20
  - [ ] Caso 4: `skips when fewer than 2 microcycles exist`
  - [ ] Caso 5: `resolves alert when tonnage recovers`

- [ ] **Test `EvaluateModuleInactivityTest`** (AC: 23, 24, 26, 29)
  - [ ] Crear archivo: `test/.../data/repository/EvaluateModuleInactivityTest.kt`
  - [ ] Caso 1: `creates MEDIUM_ALERT when module inactive for more than 10 days` ‚Äî CA-17.23
  - [ ] Caso 2: `creates CRISIS when module inactive for more than 14 days` ‚Äî CA-17.24
  - [ ] Caso 3: `resolves alert when session of that module is completed` ‚Äî CA-17.29
  - [ ] Caso 4: `uses calendar days not sessions for counting` ‚Äî CA-17.26
  - [ ] Caso 5: `skips when module has never been trained` ‚Äî no lastDate, no alert
  - [ ] Caso 6: `resolves inactivity alert even during deload session of that module` ‚Äî verify resolve runs when `isDeloadSession = true` (Step 11 is before deload guard, CA-17.29)

### Fase 11: QA y Deployment

<!-- Fase N ‚Äî Tareas manuales -->

#### üìã Code Quality

- [ ] **Ejecutar Agente Peer Review** (MANUAL)
- [ ] **Resolver incidentes del Peer Review** (MANUAL, condicional)

#### üöÄ Deployment DEV

- [ ] **Crear Pull Request** (MANUAL)
- [ ] **Ejecutar pipeline deployment DEV** (MANUAL)

#### üß™ Testing Manual

- [ ] **Dise√±ar set de pruebas manuales** (MANUAL)
  - Pipeline: verificar que cerrar sesi√≥n crea alertas correctas para cada tipo, verificar deduplicaci√≥n, verificar escalamiento de nivel, verificar resoluci√≥n autom√°tica
  - B1: verificar badge se actualiza reactivamente al crear/resolver alertas
  - H1: verificar listado agrupado (crisis vs alertas), estado vac√≠o, navegaci√≥n a H2
  - H2: verificar card de tipo/nivel, datos disparadores por tipo, an√°lisis causal, recomendaciones, link a F3 (solo meseta/progresi√≥n), link a I1 (solo descarga/RIR bajo), solo lectura
  - CA-17.19/CA-17.20: verificar que ca√≠das de tonelaje durante descarga muestran "Ca√≠da esperada" y no nivel CRISIS
  - CA-17.08: verificar que una sola sesi√≥n con RIR fuera de rango no dispara alerta
  - CA-17.29: verificar que completar sesi√≥n del m√≥dulo inactivo resuelve la alerta
  - Navegaci√≥n: bottom bar con "Inicio" activo en H1 y H2, H2‚ÜíF3 muestra bottom bar, H2‚ÜíI1 muestra bottom bar
- [ ] **Ejecutar pruebas manuales** (MANUAL)

---

**Notas sobre vinculaci√≥n con Criterios de Aceptaci√≥n:**

| CA | Fases | Componentes principales |
| --- | --- | --- |
| CA-17.01 | 1, 4 | `AlertThresholdRule.isProgressionAlert()`, `evaluateLowProgressionRate()` Step 7 |
| CA-17.02 | 1, 4 | `AlertThresholdRule.isProgressionCrisis()`, `evaluateLowProgressionRate()` Step 7 |
| CA-17.03 | 7 | `AlertCard` + `AlertLevelIndicator` con colores CRISIS vs MEDIUM_ALERT |
| CA-17.04 | 4 | Sin l√≥gica de bloqueo ‚Äî alertas son insert/resolve autom√°tico |
| CA-17.05 | 4 | `evaluateLowProgressionRate()` ejecuta en cada `evaluateProgression()` |
| CA-17.06 | 1, 4 | `AlertThresholdRule.isRirLow()`, `evaluateRirOutOfRange()` Step 8 |
| CA-17.07 | 1, 4 | `AlertThresholdRule.isRirHigh()`, `evaluateRirOutOfRange()` Step 8 |
| CA-17.08 | 4 | `getSessionIdsByModuleInRange(moduleCode, 2)` + RIR por sesi√≥n individual |
| CA-17.09 | 7 | `AlertCard` diferencia contenido por tipo de alerta RIR |
| CA-17.10 | 4 | Sin l√≥gica de bloqueo |
| CA-17.11 | 4 | `resolveByModuleAndType(moduleCode, "RIR_OUT_OF_RANGE")` en Step 8 |
| CA-17.12 | 1, 4 | `AlertThresholdRule.isAdherenceLow()`, `evaluateLowAdherence()` Step 9 |
| CA-17.13 | 4 | Verificaci√≥n de semana anterior en Step 9 ‚Üí escalamiento a CRISIS |
| CA-17.14 | 7 | `AlertCard` MEDIUM_ALERT (1 semana) vs CRISIS (2+ semanas) |
| CA-17.15 | 4 | Sin l√≥gica de bloqueo |
| CA-17.16 | 4 | `resolveAllByType("LOW_ADHERENCE")` cuando adherencia ‚â• 60% |
| CA-17.17 | 1, 4 | `AlertThresholdRule.isTonnageAlert()`, `evaluateTonnageDrop()` Step 10 |
| CA-17.18 | 1, 4 | `AlertThresholdRule.isTonnageCrisis()`, `evaluateTonnageDrop()` Step 10 |
| CA-17.19 | 4 | Condicional `isDeloadMicrocycle` en Step 10 |
| CA-17.20 | 4, 9 | Mensaje contextualizado "Descarga planificada" + nivel MEDIUM_ALERT |
| CA-17.21 | 7 | `AlertCard` MEDIUM_ALERT vs CRISIS sobre tonelaje |
| CA-17.22 | 4 | Sin l√≥gica de bloqueo |
| CA-17.23 | 1, 2, 4 | `getLastSessionDateByModule()` + `AlertThresholdRule.isInactivityAlert()` |
| CA-17.24 | 1, 4 | `AlertThresholdRule.isInactivityCrisis()` en Step 11 |
| CA-17.25 | 1 | `AlertThresholdRule.MUSCLE_GROUPS_BY_MODULE` |
| CA-17.26 | 4 | `ChronoUnit.DAYS.between(LocalDate.parse(lastDate), LocalDate.now())` |
| CA-17.27 | 7 | `AlertCard` MEDIUM_ALERT (>10 d√≠as) vs CRISIS (>14 d√≠as) |
| CA-17.28 | 4 | Sin alteraci√≥n de rotaci√≥n ‚Äî la rotaci√≥n sigue A‚ÜíB‚ÜíC independientemente |
| CA-17.29 | 4 | Resolve al inicio de Step 11 si `moduleCode == currentModuleCode` |