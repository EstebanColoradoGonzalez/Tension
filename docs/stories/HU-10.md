# HU-10 ‚Äî Evaluar y clasificar progresi√≥n post-sesi√≥n

## Requisitos relacionados

RF23, RF24, RF28, RF31, RF32, RF33, RF43

## Descripci√≥n

Como ejecutante, quiero que el sistema eval√∫e autom√°ticamente la progresi√≥n de cada ejercicio al cerrar una sesi√≥n, comparando mis datos contra el historial, clasificando el resultado y actualizando el estado de progresi√≥n, para tener un diagn√≥stico objetivo de mi rendimiento sin interpretaciones subjetivas.

## Criterios de Aceptaci√≥n

### CA-10.01 ‚Äî Comparaci√≥n contra √∫ltimo registro hist√≥rico

**Dado que** el ejecutante cierra una sesi√≥n (Completada o Incompleta),
**cuando** el sistema ejecuta el an√°lisis de progresi√≥n,
**entonces** compara los datos de cada ejercicio registrado en la sesi√≥n contra su √∫ltimo registro hist√≥rico del mismo ejercicio, independientemente del m√≥dulo-versi√≥n en que se haya ejecutado anteriormente, evaluando: variaci√≥n de carga (peso), variaci√≥n de repeticiones y variaci√≥n del RIR.

### CA-10.02 ‚Äî Clasificaci√≥n como Progresi√≥n positiva

**Dado que** el sistema compara un ejercicio contra su historial,
**cuando** detecta que el ejecutante aument√≥ la carga y/o las repeticiones manteniendo el RIR estable (sin subir significativamente),
**entonces** clasifica la progresi√≥n del ejercicio en esta sesi√≥n como "Progresi√≥n positiva".

### CA-10.03 ‚Äî Clasificaci√≥n como Mantenimiento

**Dado que** el sistema compara un ejercicio contra su historial,
**cuando** detecta que el ejecutante mantuvo la misma carga y las mismas repeticiones con RIR estable,
**entonces** clasifica la progresi√≥n del ejercicio en esta sesi√≥n como "Mantenimiento".

### CA-10.04 ‚Äî Clasificaci√≥n como Regresi√≥n

**Dado que** el sistema compara un ejercicio contra su historial,
**cuando** detecta que el ejecutante disminuy√≥ la carga o las repeticiones, o que el RIR promedio subi√≥ ‚â• 1.5 puntos con la misma carga,
**entonces** clasifica la progresi√≥n del ejercicio en esta sesi√≥n como "Regresi√≥n".

### CA-10.05 ‚Äî C√°lculo y almacenamiento del RIR promedio

**Dado que** el ejecutante ha registrado las 4 series de un ejercicio en la sesi√≥n,
**cuando** el sistema ejecuta el an√°lisis post-sesi√≥n,
**entonces** calcula el RIR promedio aritm√©tico de las 4 series del ejercicio y lo almacena como dato derivado, disponible para reglas de decisi√≥n y c√°lculos de KPIs posteriores.

### CA-10.06 ‚Äî RIR promedio con series parciales

**Dado que** el ejecutante registr√≥ menos de 4 series de un ejercicio (sesi√≥n incompleta),
**cuando** el sistema calcula el RIR promedio,
**entonces** lo calcula con las series efectivamente registradas (promedio de las series disponibles) y lo almacena indicando que es un dato parcial.

### CA-10.07 ‚Äî Ejercicio sin historial previo

**Dado que** un ejercicio registrado en la sesi√≥n no tiene registros hist√≥ricos previos,
**cuando** el sistema ejecuta el an√°lisis de progresi√≥n,
**entonces** no emite clasificaci√≥n de progresi√≥n para ese ejercicio (no hay base de comparaci√≥n) y lo marca con estado "Sin Historial".

### CA-10.08 ‚Äî Actualizaci√≥n del estado persistente de progresi√≥n

**Dado que** el sistema ha clasificado la progresi√≥n de un ejercicio en la sesi√≥n,
**cuando** completa el an√°lisis,
**entonces** actualiza el estado persistente de progresi√≥n del ejercicio seg√∫n la siguiente l√≥gica:
- Si estaba "Sin Historial" y hay clasificaci√≥n ‚Üí pasa a "En Progresi√≥n"
- Si ten√≠a progresi√≥n positiva ‚Üí se mantiene "En Progresi√≥n"
- Si acumula 3 sesiones sin progresi√≥n ‚Üí pasa a "En Meseta"
- Si est√° en per√≠odo de descarga ‚Üí se mantiene "En Descarga"

### CA-10.09 ‚Äî Almacenamiento de la clasificaci√≥n por sesi√≥n

**Dado que** el sistema ha clasificado la progresi√≥n de cada ejercicio,
**cuando** completa el an√°lisis post-sesi√≥n,
**entonces** persiste la clasificaci√≥n (Progresi√≥n positiva, Mantenimiento o Regresi√≥n) vinculada a la sesi√≥n y al ejercicio, para consulta futura en el historial.

### CA-10.10 ‚Äî Progresi√≥n de peso corporal por repeticiones totales

**Dado que** el ejecutante ha completado las 4 series de un ejercicio de peso corporal,
**cuando** el sistema eval√∫a la progresi√≥n de ese ejercicio,
**entonces** mide la progresi√≥n exclusivamente por el total de repeticiones logradas en las 4 series comparado con la sesi√≥n anterior del mismo ejercicio, sin aplicar la Regla de Doble Umbral de carga.

> **Origen:** Redistribuido desde HU-08 (ex CA-08.02). Cubre RF31.

### CA-10.11 ‚Äî Progresi√≥n de isom√©tricos por tiempo sostenido

**Dado que** el ejecutante ha completado las 4 series de un ejercicio isom√©trico,
**cuando** el sistema eval√∫a la progresi√≥n,
**entonces** mide la progresi√≥n por los segundos sostenidos dentro del rango prescrito (30-45 segundos), comparando con la sesi√≥n anterior del mismo ejercicio.

> **Origen:** Redistribuido desde HU-08 (ex CA-08.06). Cubre RF32.

### CA-10.12 ‚Äî Marcado de isom√©trico como "dominado"

**Dado que** el ejecutante completa las 4 series de un ejercicio isom√©trico y las 4 series alcanzaron ‚â• 45 segundos,
**cuando** el sistema eval√∫a la progresi√≥n del ejercicio,
**entonces** marca el ejercicio como "dominado" e indica al ejecutante que el ejercicio ya no ofrece est√≠mulo progresivo suficiente en su forma actual.

> **Origen:** Redistribuido desde HU-08 (ex CA-08.07). Cubre RF33.
---

## An√°lisis Arquitect√≥nico (Arquitecto)

### Decisiones de Dise√±o

**1. HU-10 es l√≥gica pura de backend ‚Äî no tiene pantalla propia.**

Mapa de Navegaci√≥n ¬ß5 (fila HU-10): "representaci√≥n indirecta (output en pantallas existentes)". HU-10 produce datos que consumen E5 (HU-13), F2 (HU-24) y F3 (HU-23). No hay UI ni ViewModel nuevos. Todo ocurre dentro de la transacci√≥n de `closeSession()` (punto de extensi√≥n documentado en HU-09 Nota T√©cnica 4).

**2. La clasificaci√≥n es una funci√≥n pura en `domain.rules` (ADR-06).**

ADR-06 establece que las Reglas R1-R7 del MDS se implementan como funciones puras en `domain.rules`, testeables sin emulador. HU-10 implementa parcialmente R3 (detecci√≥n de meseta: transici√≥n de estado), R4 (regresi√≥n: clasificaci√≥n), R6 (peso corporal: comparaci√≥n por repeticiones totales) y R7 (isom√©tricos: comparaci√≥n por segundos + marcado "dominado"). El archivo es `ProgressionClassificationRule.kt`, siguiendo la convenci√≥n de naming `{Nombre}Rule` (Arquitectura T√©cnica ¬ß5.2).

**3. El RIR promedio NO se almacena en base de datos.**

CA-10.05 y RF28 usan "almacena". Sin embargo, el Modelo de Datos ¬ß2 (Convenciones) establece: *"Datos calculados: No se almacenan en base de datos"*. El Modelo de Datos ¬ß3.13 (`exercise_progression`) no tiene columna `average_rir`. El RIR promedio es derivable en cualquier momento como `AVG(exercise_set.rir) WHERE session_exercise_id = ?`. Para la clasificaci√≥n, se computa in-memory a partir de los sets ya fetched. Para KPIs futuros (HU-20, HU-22), se computar√° por query. **Misma resoluci√≥n que CA-09.04 (tonelaje).**

**4. La comparaci√≥n es contra el √∫ltimo registro del mismo ejercicio, independiente de versi√≥n.**

ADR D-06 es expl√≠cito: *"El query de comparaci√≥n busca la √∫ltima `session_exercise` del mismo `exercise_id`, sin filtrar por `module_version_id`"*. RF23 y CA-10.01 lo confirman. La query usa una subconsulta para encontrar el `session_exercise.id` m√°s reciente del mismo `exercise_id` en una sesi√≥n cerrada distinta (`COMPLETED` o `INCOMPLETE`), y obtiene sus sets.

**5. El umbral de "RIR significativamente elevado" es ‚â• 1.5 puntos.**

CA-10.04 define: regresi√≥n se detecta cuando el RIR promedio sube ‚â• 1.5 puntos con la misma carga. RF24 usa "sin subir significativamente" para progresi√≥n positiva. Se adopta 1.5 como umbral universal para "cambio significativo de RIR" en ambas direcciones. Constante: `RIR_SIGNIFICANT_RISE = 1.5`. RF29 (que pertenece a HU-12) usa el mismo umbral but con criterio per-series ‚Äî ver Nota T√©cnica 8.

**6. La clasificaci√≥n cubre 3 tipos de ejercicio con l√≥gica diferenciada.**

| Tipo | Flag | M√©trica principal | Regla MDS | CA |
|------|------|-------------------|-----------|-----|
| Est√°ndar | `!isBodyweight && !isIsometric` | Peso promedio + repeticiones totales + RIR | R1/R2/R4 | CA-10.02/03/04 |
| Peso corporal | `isBodyweight && !isIsometric` | Repeticiones totales (peso = 0) | R6 | CA-10.10 |
| Isom√©trico | `isIsometric` | Segundos sostenidos (en campo `reps`) | R7 | CA-10.11/12 |

Los isom√©tricos son subconjunto de bodyweight (`is_isometric = 1` implica `is_bodyweight = 1` en seed data). La evaluaci√≥n prioriza `isIsometric` sobre `isBodyweight` (orden: isom√©trico ‚Üí peso corporal ‚Üí est√°ndar).

**7. La transici√≥n a `IN_PLATEAU` se ejecuta en HU-10, las alertas en HU-14.**

CA-10.08 define la m√°quina de estados. El estado `IN_PLATEAU` se activa cuando `sessions_without_progression >= 3`. HU-14 (CA-14.01) emitir√° alertas con an√°lisis causal cuando un ejercicio entre en meseta. HU-10 solo ejecuta la transici√≥n de estado y actualiza el contador ‚Äî no emite alertas.

**Nota sobre MDS R3 vs RF34:** MDS ¬ß6-A R3 dice *"3 sesiones consecutivas del mismo ejercicio en la misma versi√≥n del m√≥dulo"*, pero RF34 dice solo *"3 sesiones consecutivas del mismo ejercicio"* sin constraint de versi√≥n. El Modelo de Datos ¬ß3.13 usa un √∫nico contador `sessions_without_progression` por `exercise_id` (sin partici√≥n por versi√≥n), y ADR D-06 establece comparaci√≥n independiente de versi√≥n. **Se sigue el Modelo de Datos y RF34** ‚Äî el contador es global por ejercicio, no por versi√≥n. Divergencia deliberada del MDS R3.

**8. El estado `MASTERED` es terminal para isom√©tricos.**

CA-10.12: si las 4 series ‚â• 45 segundos, el ejercicio se marca como `MASTERED`. La Modelo de Datos ¬ß3.13 incluye `MASTERED` en los estados v√°lidos. Una vez marcado, no hay transici√≥n de salida ‚Äî el ejercicio permanece "dominado" indefinidamente. El clasificador eval√∫a mastered DESPU√âS de la clasificaci√≥n normal (un ejercicio puede tener progresi√≥n positiva Y estar dominado simult√°neamente).

**9. Ejercicios sin historial reciben `null` como clasificaci√≥n.**

CA-10.07: sin datos previos, no hay base de comparaci√≥n ‚Üí no se emite clasificaci√≥n. La columna `session_exercise.progression_classification` queda `NULL`. El estado en `exercise_progression.status` se mantiene como `NO_HISTORY`. El primer registro hist√≥rico se crea al registrar sets (HU-06: `exerciseProgressionDao.insertIfNotExists()`). La clasificaci√≥n no opera sobre `NO_HISTORY` porque necesita 2 puntos de datos.

**10. La integraci√≥n sigue el patr√≥n de extensi√≥n documentado en HU-09.**

HU-09 Nota T√©cnica 4: *"El punto de extensi√≥n ser√° dentro de la transacci√≥n de `closeSession()`, despu√©s de actualizar el status y antes de avanzar la rotaci√≥n"*. `evaluateProgression()` se inserta exactamente ah√≠ como m√©todo privado de `SessionRepositoryImpl`. La regla pura (`ProgressionClassificationRule`) se importa en el repositorio, igual que `RotationResolver`.

### Componentes Nuevos

**1. `ProgressionClassification`** ‚Äî `domain/model/ProgressionClassification.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.model

enum class ProgressionClassification {
    POSITIVE_PROGRESSION,
    MAINTENANCE,
    REGRESSION,
}
```

Enum que mapea 1:1 con los valores de `session_exercise.progression_classification` (Modelo de Datos ¬ß3.11). El `.name` del enum produce el string exacto para persistencia (`"POSITIVE_PROGRESSION"`, `"MAINTENANCE"`, `"REGRESSION"`).

**2. `ExerciseSessionData` y `SetData`** ‚Äî `domain/model/ExerciseSessionData.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.model

data class SetData(
    val weightKg: Double,
    val reps: Int,
    val rir: Int,
)

data class ExerciseSessionData(
    val sets: List<SetData>,
) {
    val setCount: Int get() = sets.size

    val avgWeightKg: Double
        get() = if (sets.isEmpty()) 0.0 else sets.sumOf { it.weightKg } / sets.size

    val totalReps: Int
        get() = sets.sumOf { it.reps }

    val avgRir: Double
        get() = if (sets.isEmpty()) 0.0 else sets.sumOf { it.rir.toDouble() } / sets.size
}
```

Modelos de dominio puros (sin dependencias Android) que alimentan la regla. `SetData` es la unidad at√≥mica; `ExerciseSessionData` agrega y expone propiedades derivadas. El campo `reps` almacena repeticiones o segundos seg√∫n el tipo de ejercicio (Modelo de Datos ¬ß3.12).

**3. `ProgressionClassificationRule`** ‚Äî `domain/rules/ProgressionClassificationRule.kt`

```kotlin
package com.estebancoloradogonzalez.tension.domain.rules

import com.estebancoloradogonzalez.tension.domain.model.ExerciseSessionData
import com.estebancoloradogonzalez.tension.domain.model.ProgressionClassification
import kotlin.math.abs

object ProgressionClassificationRule {

    const val RIR_SIGNIFICANT_RISE = 1.5
    const val ISOMETRIC_MASTERED_THRESHOLD = 45
    const val PLATEAU_THRESHOLD = 3
    private const val WEIGHT_TOLERANCE = 0.01

    fun classify(
        current: ExerciseSessionData,
        previous: ExerciseSessionData?,
        isBodyweight: Boolean,
        isIsometric: Boolean,
    ): ProgressionClassification? {
        if (previous == null || previous.sets.isEmpty()) return null
        if (current.sets.isEmpty()) return null

        return when {
            isIsometric -> classifyIsometric(current, previous)
            isBodyweight -> classifyBodyweight(current, previous)
            else -> classifyStandard(current, previous)
        }
    }

    fun isIsometricMastered(current: ExerciseSessionData): Boolean {
        return current.setCount >= 4 &&
            current.sets.all { it.reps >= ISOMETRIC_MASTERED_THRESHOLD }
    }

    fun resolveNewProgressionState(
        currentStatus: String,
        currentCounter: Int,
        classification: ProgressionClassification?,
        isIsometric: Boolean,
        isMastered: Boolean,
    ): Pair<String, Int> {
        if (isIsometric && isMastered) return "MASTERED" to 0
        if (classification == null) return currentStatus to currentCounter
        if (currentStatus == "IN_DELOAD") return currentStatus to currentCounter
        if (currentStatus == "MASTERED") return currentStatus to currentCounter

        return when (classification) {
            ProgressionClassification.POSITIVE_PROGRESSION -> "IN_PROGRESSION" to 0

            ProgressionClassification.MAINTENANCE,
            ProgressionClassification.REGRESSION -> {
                val newCounter = currentCounter + 1
                val newStatus = when {
                    newCounter >= PLATEAU_THRESHOLD -> "IN_PLATEAU"
                    currentStatus == "NO_HISTORY" -> "IN_PROGRESSION"
                    else -> currentStatus
                }
                newStatus to newCounter
            }
        }
    }

    private fun classifyStandard(
        current: ExerciseSessionData,
        previous: ExerciseSessionData,
    ): ProgressionClassification {
        val repsDiff = current.totalReps - previous.totalReps
        val rirRise = current.avgRir - previous.avgRir

        return when {
            isWeightLower(current.avgWeightKg, previous.avgWeightKg) ->
                ProgressionClassification.REGRESSION

            isWeightEqual(current.avgWeightKg, previous.avgWeightKg) && repsDiff < 0 ->
                ProgressionClassification.REGRESSION

            isWeightEqual(current.avgWeightKg, previous.avgWeightKg) &&
                rirRise >= RIR_SIGNIFICANT_RISE ->
                ProgressionClassification.REGRESSION

            isWeightHigher(current.avgWeightKg, previous.avgWeightKg) &&
                rirRise < RIR_SIGNIFICANT_RISE ->
                ProgressionClassification.POSITIVE_PROGRESSION

            isWeightEqual(current.avgWeightKg, previous.avgWeightKg) &&
                repsDiff > 0 && rirRise < RIR_SIGNIFICANT_RISE ->
                ProgressionClassification.POSITIVE_PROGRESSION

            else -> ProgressionClassification.MAINTENANCE
        }
    }

    private fun classifyBodyweight(
        current: ExerciseSessionData,
        previous: ExerciseSessionData,
    ): ProgressionClassification {
        val repsDiff = current.totalReps - previous.totalReps
        val rirRise = current.avgRir - previous.avgRir

        return when {
            repsDiff < 0 -> ProgressionClassification.REGRESSION
            rirRise >= RIR_SIGNIFICANT_RISE && repsDiff <= 0 ->
                ProgressionClassification.REGRESSION
            repsDiff > 0 && rirRise < RIR_SIGNIFICANT_RISE ->
                ProgressionClassification.POSITIVE_PROGRESSION
            else -> ProgressionClassification.MAINTENANCE
        }
    }

    private fun classifyIsometric(
        current: ExerciseSessionData,
        previous: ExerciseSessionData,
    ): ProgressionClassification {
        val secondsDiff = current.totalReps - previous.totalReps
        val rirRise = current.avgRir - previous.avgRir

        return when {
            secondsDiff < 0 -> ProgressionClassification.REGRESSION
            rirRise >= RIR_SIGNIFICANT_RISE && secondsDiff <= 0 ->
                ProgressionClassification.REGRESSION
            secondsDiff > 0 && rirRise < RIR_SIGNIFICANT_RISE ->
                ProgressionClassification.POSITIVE_PROGRESSION
            else -> ProgressionClassification.MAINTENANCE
        }
    }

    private fun isWeightEqual(a: Double, b: Double): Boolean =
        abs(a - b) < WEIGHT_TOLERANCE

    private fun isWeightHigher(a: Double, b: Double): Boolean =
        a - b >= WEIGHT_TOLERANCE

    private fun isWeightLower(a: Double, b: Double): Boolean =
        b - a >= WEIGHT_TOLERANCE
}
```

Funci√≥n pura, testeable unitariamente sin emulador (ADR-06, RNF29, RNF30). Opera sobre modelos de dominio (`ExerciseSessionData`), no sobre entities o DTOs de Room. Las comparaciones de peso usan tolerancia para evitar errores de punto flotante.

### Componentes Modificados

**4. `SessionExerciseDao`** ‚Äî agregar queries

Nuevo DTO para la query de progresi√≥n:

```kotlin
data class SessionExerciseForProgression(
    val sessionExerciseId: Long,
    val exerciseId: Long,
    val isBodyweight: Int,
    val isIsometric: Int,
    val moduleCode: String,
)
```

Nuevas queries:

```kotlin
@Query(
    """
    SELECT 
        se.id AS sessionExerciseId,
        se.exercise_id AS exerciseId,
        e.is_bodyweight AS isBodyweight,
        e.is_isometric AS isIsometric,
        e.module_code AS moduleCode
    FROM session_exercise se
    INNER JOIN exercise e ON se.exercise_id = e.id
    WHERE se.session_id = :sessionId
    """,
)
suspend fun getSessionExercisesForProgression(sessionId: Long): List<SessionExerciseForProgression>

@Query(
    """
    UPDATE session_exercise
    SET progression_classification = :classification
    WHERE id = :sessionExerciseId
    """,
)
suspend fun updateProgressionClassification(sessionExerciseId: Long, classification: String?)
```

La primera query obtiene los metadatos de cada ejercicio en la sesi√≥n (flags de tipo + m√≥dulo). `moduleCode` se incluye proactivamente para HU-11 (incremento diferenciado por m√≥dulo). La segunda query persiste la clasificaci√≥n (CA-10.09).

**5. `ExerciseSetDao`** ‚Äî agregar queries

Nuevo DTO:

```kotlin
data class ExerciseSetData(
    val weightKg: Double,
    val reps: Int,
    val rir: Int,
)
```

Nuevas queries:

```kotlin
@Query(
    """
    SELECT weight_kg AS weightKg, reps, rir
    FROM exercise_set
    WHERE session_exercise_id = :sessionExerciseId
    ORDER BY set_number
    """,
)
suspend fun getSetsForSessionExercise(sessionExerciseId: Long): List<ExerciseSetData>

@Query(
    """
    SELECT es.weight_kg AS weightKg, es.reps, es.rir
    FROM exercise_set es
    WHERE es.session_exercise_id = (
        SELECT se2.id
        FROM session_exercise se2
        INNER JOIN session s2 ON se2.session_id = s2.id
        WHERE se2.exercise_id = :exerciseId
          AND s2.id != :currentSessionId
          AND s2.status IN ('COMPLETED', 'INCOMPLETE')
        ORDER BY s2.date DESC, s2.id DESC
        LIMIT 1
    )
    ORDER BY es.set_number
    """,
)
suspend fun getLastHistoricalSets(exerciseId: Long, currentSessionId: Long): List<ExerciseSetData>
```

`getLastHistoricalSets` implementa ADR D-06: busca el √∫ltimo registro del mismo `exercise_id` independiente de versi√≥n/m√≥dulo, en sesiones cerradas (`COMPLETED` o `INCOMPLETE`), excluyendo la sesi√≥n actual. La subconsulta ordena por `date DESC, id DESC` para determinismo cuando las fechas coinciden.

**6. `SessionRepositoryImpl.closeSession()`** ‚Äî integrar evaluaci√≥n de progresi√≥n

```kotlin
override suspend fun closeSession(sessionId: Long) {
    database.withTransaction {
        // Step 1: Determine and update session status (HU-09)
        val sessionInfo = sessionDao.getActiveSessionWithModuleVersion().first()
            ?: throw IllegalStateException("No active session found")
        if (sessionInfo.sessionId != sessionId) {
            throw IllegalStateException("Session $sessionId is not the active session")
        }
        val status = if (sessionInfo.completedExercises == sessionInfo.totalExercises) {
            "COMPLETED"
        } else {
            "INCOMPLETE"
        }
        sessionDao.updateStatus(sessionId, status)

        // Step 2: Evaluate progression (HU-10)
        evaluateProgression(sessionId)

        // Step 3: Advance rotation (HU-09)
        val rotationEntity = rotationStateDao.getRotationState().first()
            ?: throw IllegalStateException("Rotation state not found")
        val currentRotation = RotationState(
            microcyclePosition = rotationEntity.microcyclePosition,
            currentVersionModuleA = rotationEntity.currentVersionModuleA,
            currentVersionModuleB = rotationEntity.currentVersionModuleB,
            currentVersionModuleC = rotationEntity.currentVersionModuleC,
            microcycleCount = rotationEntity.microcycleCount,
        )
        val newRotation = RotationResolver.advanceRotation(currentRotation)
        rotationStateDao.update(
            rotationEntity.copy(
                microcyclePosition = newRotation.microcyclePosition,
                currentVersionModuleA = newRotation.currentVersionModuleA,
                currentVersionModuleB = newRotation.currentVersionModuleB,
                currentVersionModuleC = newRotation.currentVersionModuleC,
                microcycleCount = newRotation.microcycleCount,
            ),
        )
    }
}

private suspend fun evaluateProgression(sessionId: Long) {
    val exercises = sessionExerciseDao.getSessionExercisesForProgression(sessionId)

    for (exercise in exercises) {
        val currentSetDtos = exerciseSetDao.getSetsForSessionExercise(exercise.sessionExerciseId)
        if (currentSetDtos.isEmpty()) continue

        val currentData = ExerciseSessionData(
            sets = currentSetDtos.map { SetData(it.weightKg, it.reps, it.rir) },
        )

        val previousSetDtos = exerciseSetDao.getLastHistoricalSets(
            exercise.exerciseId,
            sessionId,
        )
        val previousData = if (previousSetDtos.isNotEmpty()) {
            ExerciseSessionData(
                sets = previousSetDtos.map { SetData(it.weightKg, it.reps, it.rir) },
            )
        } else {
            null
        }

        val isBodyweight = exercise.isBodyweight == 1
        val isIsometric = exercise.isIsometric == 1

        val classification = ProgressionClassificationRule.classify(
            current = currentData,
            previous = previousData,
            isBodyweight = isBodyweight,
            isIsometric = isIsometric,
        )

        sessionExerciseDao.updateProgressionClassification(
            exercise.sessionExerciseId,
            classification?.name,
        )

        val isMastered = isIsometric &&
            ProgressionClassificationRule.isIsometricMastered(currentData)

        val currentProgression = exerciseProgressionDao
            .getByExerciseId(exercise.exerciseId).first()
            ?: ExerciseProgressionEntity(exerciseId = exercise.exerciseId)

        val (newStatus, newCounter) = ProgressionClassificationRule.resolveNewProgressionState(
            currentStatus = currentProgression.status,
            currentCounter = currentProgression.sessionsWithoutProgression,
            classification = classification,
            isIsometric = isIsometric,
            isMastered = isMastered,
        )

        exerciseProgressionDao.update(
            currentProgression.copy(
                status = newStatus,
                sessionsWithoutProgression = newCounter,
            ),
        )
    }
}
```

La evaluaci√≥n se ejecuta dentro de la transacci√≥n existente de `closeSession()`. Si falla, todo se revierte (incluido el `updateStatus`), preservando la sesi√≥n como `IN_PROGRESS` (CA-09.08). El m√©todo privado `evaluateProgression` sigue el patr√≥n de N queries simples dentro de la transacci√≥n ‚Äî aceptable para 11-16 ejercicios por sesi√≥n en una BD local SQLite.

### Verificaci√≥n Exhaustiva CA por CA

**CA-10.01 ‚Äî Comparaci√≥n contra √∫ltimo registro hist√≥rico:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| DAO | `getLastHistoricalSets(exerciseId, currentSessionId)` | Subconsulta: √∫ltimo `session_exercise` del mismo `exercise_id` en sesi√≥n cerrada |
| Domain | `ProgressionClassificationRule.classify(current, previous, ...)` | Comparaci√≥n de `ExerciseSessionData` |
| ADR | D-06: "independiente de versi√≥n" | Query no filtra por `module_version_id` |

**CA-10.02 ‚Äî Clasificaci√≥n como Progresi√≥n positiva:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | Est√°ndar: peso subi√≥ con RIR estable ‚Üí `POSITIVE_PROGRESSION` | `isWeightHigher && rirRise < 1.5` |
| Rule | Est√°ndar: mismo peso + reps subieron con RIR estable ‚Üí `POSITIVE_PROGRESSION` | `isWeightEqual && repsDiff > 0 && rirRise < 1.5` |
| Rule | Bodyweight: total reps subi√≥ con RIR estable ‚Üí `POSITIVE_PROGRESSION` | `repsDiff > 0 && rirRise < 1.5` |
| Rule | Isom√©trico: segundos subieron con RIR estable ‚Üí `POSITIVE_PROGRESSION` | `secondsDiff > 0 && rirRise < 1.5` |

**CA-10.03 ‚Äî Clasificaci√≥n como Mantenimiento:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `else` fallthrough en `classifyStandard/Bodyweight/Isometric` | Cualquier caso que no sea progresi√≥n ni regresi√≥n |
| Definici√≥n | Mismo peso, mismas reps, RIR estable | `!isWeightChanged && repsDiff == 0 && rirRise < 1.5` ‚Üí cae en `else` |

**CA-10.04 ‚Äî Clasificaci√≥n como Regresi√≥n:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | Peso baj√≥ ‚Üí `REGRESSION` | `isWeightLower` |
| Rule | Mismo peso + reps totales bajaron ‚Üí `REGRESSION` | `isWeightEqual && repsDiff < 0` |
| Rule | Mismo peso + RIR subi√≥ ‚â• 1.5 ‚Üí `REGRESSION` | `isWeightEqual && rirRise >= 1.5` |
| Nota | Usa `totalReps` (simplificaci√≥n); RF29 per-series es responsabilidad de HU-12 | Ver Nota T√©cnica 8 |

**CA-10.05 ‚Äî C√°lculo y almacenamiento del RIR promedio:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Domain | `ExerciseSessionData.avgRir` ‚Äî propiedad derivada | `sets.sumOf { it.rir.toDouble() } / sets.size` |
| Storage | NO se almacena (Modelo de Datos ¬ß2) | Derivable: `AVG(exercise_set.rir) WHERE session_exercise_id = ?` |
| Uso | Comparaci√≥n in-memory durante clasificaci√≥n | `current.avgRir - previous.avgRir` |

**CA-10.06 ‚Äî RIR promedio con series parciales:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Domain | `avgRir` calcula con sets disponibles (1, 2 o 3) | `sum / size` opera con cualquier cantidad |
| "Parcial" | El status de sesi√≥n `INCOMPLETE` ya indica datos parciales | No se requiere flag adicional |

**CA-10.07 ‚Äî Ejercicio sin historial previo:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| DAO | `getLastHistoricalSets` retorna lista vac√≠a ‚Üí `previousData = null` | Sin sets hist√≥ricos = sin comparaci√≥n |
| Rule | `if (previous == null) return null` | No emite clasificaci√≥n |
| Entity | `session_exercise.progression_classification` queda `NULL` | Persistido v√≠a `updateProgressionClassification(id, null)` |
| Estado | `exercise_progression.status` se mantiene `NO_HISTORY` | `resolveNewProgressionState` con `null` retorna `currentStatus` |

**CA-10.08 ‚Äî Actualizaci√≥n del estado persistente de progresi√≥n:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `resolveNewProgressionState()` ‚Äî m√°quina de estados pura | Funci√≥n en `ProgressionClassificationRule` |
| NO_HISTORY + clasificaci√≥n | ‚Üí `IN_PROGRESSION` | `currentStatus == "NO_HISTORY" ‚Üí "IN_PROGRESSION"` |
| POSITIVE_PROGRESSION | ‚Üí `IN_PROGRESSION`, counter = 0 | Reset del contador |
| MAINTENANCE/REGRESSION | Counter++ ; si ‚â• 3 ‚Üí `IN_PLATEAU` | Transici√≥n de meseta (HU-14 agregar√° alertas) |
| IN_DELOAD | Se mantiene (HU-17 gestiona salida) | Guard: `currentStatus == "IN_DELOAD"` ‚Üí no change |
| MASTERED | Se mantiene (terminal) | Guard: `currentStatus == "MASTERED"` ‚Üí no change |

**CA-10.09 ‚Äî Almacenamiento de la clasificaci√≥n por sesi√≥n:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| DAO | `updateProgressionClassification(sessionExerciseId, classification)` | UPDATE en `session_exercise` |
| Persistencia | `"POSITIVE_PROGRESSION"`, `"MAINTENANCE"`, `"REGRESSION"`, o `NULL` | `.name` del enum o null |
| Consulta futura | E5 (HU-13), F2 (HU-24), F3 (HU-23) | Columna ya existe desde HU-05 |

**CA-10.10 ‚Äî Progresi√≥n de peso corporal por repeticiones totales:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `classifyBodyweight()` ‚Äî compara `totalReps` | `current.totalReps - previous.totalReps` |
| RF31 | No aplica Doble Umbral (HU-11 lo excluir√°) | Clasificaci√≥n independiente de carga |
| Regla 6 MDS | "progresi√≥n por repeticiones logradas" | `repsDiff > 0 ‚Üí POSITIVE_PROGRESSION` |

**CA-10.11 ‚Äî Progresi√≥n de isom√©tricos por tiempo sostenido:**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `classifyIsometric()` ‚Äî compara `totalReps` (= segundos) | `current.totalReps - previous.totalReps` |
| RF32 | Segundos en campo `reps` (Modelo de Datos ¬ß3.12) | Interpretaci√≥n por flags del ejercicio |
| Regla 7 MDS | "progresi√≥n por segundos sostenidos" | `secondsDiff > 0 ‚Üí POSITIVE_PROGRESSION` |

**CA-10.12 ‚Äî Marcado de isom√©trico como "dominado":**

| Capa | Implementaci√≥n | Evidencia |
|------|----------------|-----------|
| Rule | `isIsometricMastered()` ‚Äî 4/4 sets ‚â• 45s | `setCount >= 4 && sets.all { it.reps >= 45 }` |
| Estado | `resolveNewProgressionState` ‚Üí `"MASTERED"` si mastered | Prioridad m√°xima en la funci√≥n |
| Modelo de Datos | ¬ß3.13 CHECK: `MASTERED` es valor v√°lido | `CHECK(status IN (..., 'MASTERED'))` |
| RF33 | "las 4 series alcancen ‚â• 45 segundos" | Match exacto |

### Validaci√≥n de Impacto

**Archivos nuevos:**

| Archivo | Prop√≥sito |
|---|---|
| `domain/model/ProgressionClassification.kt` | Enum con los 3 valores de clasificaci√≥n |
| `domain/model/ExerciseSessionData.kt` | Modelos de dominio para la regla (`SetData` + `ExerciseSessionData`) |
| `domain/rules/ProgressionClassificationRule.kt` | Regla pura: clasificaci√≥n + mastered + m√°quina de estados |
| `test/.../domain/rules/ProgressionClassificationRuleTest.kt` | Tests unitarios de la regla |

**Archivos modificados:**

| Archivo | Acci√≥n | Secci√≥n |
|---|---|---|
| `SessionExerciseDao.kt` | Agregar DTO `SessionExerciseForProgression` + 2 queries | DAO |
| `ExerciseSetDao.kt` | Agregar DTO `ExerciseSetData` + 2 queries | DAO |
| `SessionRepositoryImpl.kt` | Agregar `evaluateProgression()` + modificar `closeSession()` | Repository |

**Archivos NO tocados:**

| Archivo | Raz√≥n |
|---|---|
| `SessionRepository.kt` | `closeSession()` mantiene misma firma ‚Äî evaluaci√≥n es detalle interno |
| `CloseSessionUseCase.kt` | Sigue delegando a `closeSession()` ‚Äî sin cambios |
| `ActiveSessionViewModel.kt` | HU-10 no tiene UI ‚Äî sin cambios |
| `ActiveSessionScreen.kt` | Sin cambios |
| `ExerciseProgressionDao.kt` | M√©todos existentes (`getByExerciseId`, `update`) son suficientes |
| `ExerciseProgressionEntity.kt` | Schema ya tiene campos necesarios (`status`, `sessionsWithoutProgression`) |
| `SessionExerciseEntity.kt` | Columna `progression_classification` ya existe |

### Notas T√©cnicas

1. **Patr√≥n N+1 dentro de transacci√≥n.** `evaluateProgression` ejecuta 2-3 queries por ejercicio (sets actuales, sets hist√≥ricos, progression entity) dentro de la transacci√≥n. Para 11-16 ejercicios √ó 3 queries = ~45 queries m√°ximo. En SQLite local con √≠ndices, esto toma < 50ms. No se justifica optimizaci√≥n batch para este volumen.

2. **El `ProgressionClassificationRule` es el PRIMER archivo en `domain/rules/`.** Este paquete no existe a√∫n. Se crea con HU-10, estableciendo el precedente para `DoubleThresholdRule` (HU-11), `RegressionDetectionRule` (HU-12), y `PlateauDetectionRule` (HU-14).

3. **Tolerancia en comparaci√≥n de pesos.** `WEIGHT_TOLERANCE = 0.01` Kg. Los incrementos m√≠nimos reales son 1.25 Kg (microincremento) o 2.5 Kg (est√°ndar). Una tolerancia de 0.01 Kg absorbe errores de punto flotante sin confundir cambios reales de carga.

4. **La comparaci√≥n usa `totalReps` para bodyweight e isom√©tricos.** CA-10.10 dice "total de repeticiones logradas en las 4 series". Cuando ambas sesiones tienen el mismo n√∫mero de sets (caso normal: 4 y 4), el total es directamente comparable. Para sesiones con diferente cantidad de sets (raro, solo en incompletas), el total refleja la realidad (menos sets = menos reps). Esto es admisible porque CA-10.06 indica que los datos parciales se marcan como tales (la sesi√≥n `INCOMPLETE` sirve como indicador).

5. **La propiedad `moduleCode` en `SessionExerciseForProgression` se incluye proactivamente.** HU-10 no la usa, pero HU-11 la necesitar√° para determinar el incremento por m√≥dulo (+2.5 Kg para A/B, +5 Kg para C). Incluirla ahora (costo marginal cero ‚Äî el JOIN ya existe) evita crear otra query id√©ntica en HU-11.

6. **Deload awareness en la m√°quina de estados.** `resolveNewProgressionState` respeta `IN_DELOAD`: si el ejercicio est√° en descarga, la clasificaci√≥n se persiste pero el estado no cambia. HU-17 gestionar√° la entrada/salida de `IN_DELOAD`. Esta guard previene que una regresi√≥n durante descarga (esperada ‚Äî cargas al 60%) active falsamente el contador de meseta.

7. **La evaluaci√≥n opera sobre TODOS los ejercicios con sets, incluidos los sustituidos.** `session_exercise.exercise_id` apunta al ejercicio ejecutado (sustituto si lo hay), no al original. La comparaci√≥n hist√≥rica busca el √∫ltimo registro del `exercise_id` real (ADR D-06, HU-07). Sustituciones son transparentes ‚Äî no requieren l√≥gica condicional.

8. **Simplificaci√≥n deliberada de la detecci√≥n de regresi√≥n por repeticiones (CA-10.04 vs RF29).** CA-10.04 dice *"disminuy√≥ las repeticiones"* sin especificar per-serie. RF29 (scoped a HU-12) dice *"las repeticiones caen en ‚â• 2 de las 4 series"* ‚Äî un criterio per-serie m√°s estricto. HU-10 usa `totalReps` (comparaci√≥n de suma) porque: (a) CA-10.04 no exige per-serie, (b) es computacionalmente m√°s simple, (c) cubre la mayor√≠a de los casos. **Frontera con HU-12:** Los CAs de HU-12 (CA-12.01/02/03) usan el verbo *"clasifica"*, lo que sugiere que HU-12 podr√≠a reevaluar la regresi√≥n con criterio per-serie m√°s estricto. HU-10 no pretende reemplazar la detecci√≥n de HU-12 ‚Äî solo persiste una clasificaci√≥n base en `session_exercise.progression_classification`. Cuando HU-12 se analice, deber√° definir expl√≠citamente si: (a) consume el flag `REGRESSION` de HU-10 para conteo de fatiga acumulada (CA-12.04), o (b) reclasifica independientemente con l√≥gica per-serie. En caso (b), puede haber ejercicios donde HU-10 clasifica `MAINTENANCE` (total reps subi√≥) pero HU-12 detecta regresi√≥n per-serie (reps cayeron en ‚â•2 series individuales) ‚Äî el an√°lisis de HU-12 deber√° resolver este conflicto.

9. **El conteo de meseta es global por ejercicio, no por versi√≥n de m√≥dulo.** MDS ¬ß6-A R3 dice *"en la misma versi√≥n del m√≥dulo"*, pero RF34, Modelo de Datos ¬ß3.13 y ADR D-06 omiten esta restricci√≥n. La decisi√≥n de implementaci√≥n sigue el Modelo de Datos (columna √∫nica `sessions_without_progression` sin partici√≥n por versi√≥n) y RF34. Justificaci√≥n: un ejercicio que no progresa durante 3 sesiones indica meseta independientemente de qu√© versi√≥n del m√≥dulo se ejecut√≥ ‚Äî el est√≠mulo diferente de cada versi√≥n deber√≠a producir progreso si no hay meseta real. **Frontera con HU-14:** Los CAs de HU-14 (CA-14.01, CA-14.08) usan *"marca el ejercicio"* y *"el estado cambia de 'En Progresi√≥n' a 'En Meseta'"*, sugiriendo que HU-14 realiza la transici√≥n. Sin embargo, el Modelo de Datos ¬ß3.13 paso 3 ubica esta transici√≥n en la l√≥gica de cierre de sesi√≥n (HU-10). **HU-10 transiciona el estado; HU-14 emite alertas y an√°lisis causal.** El verbo *"marca"* en HU-14 se interpreta como *"detecta y alerta"*, no como *"cambia estado"*. **Continuidad del contador:** `sessions_without_progression` NO tiene cap en 3 ‚Äî sigue increment√°ndose (4, 5, 6...) para soportar la l√≥gica de acci√≥n escalonada de HU-15 (CA-15.01: sesi√≥n 4, CA-15.02: sesi√≥n 6). El c√≥digo no guarda `IN_PLATEAU` en `resolveNewProgressionState`, por lo que el ejercicio en meseta sigue acumulando sesiones sin progresi√≥n.

### Historias Relacionadas

**Predecesoras (datos que HU-10 consume):**

- HU-05: Cre√≥ `ExerciseProgressionEntity` con `status`, `prescribedLoadKg`, `sessionsWithoutProgression`. Cre√≥ `SessionExerciseEntity` con `progressionClassification`. Proporcion√≥ `RotationStateDao.update()`.
- HU-06: Persisti√≥ datos de `exercise_set` (peso, reps, RIR) que HU-10 compara. `registerSet()` crea `ExerciseProgressionEntity` con `insertIfNotExists()`.
- HU-07: Sustituciones apuntan `exercise_id` al ejercicio real ejecutado ‚Äî transparente para la comparaci√≥n.
- HU-08: Defini√≥ CAs de progresi√≥n de bodyweight (CA-08.02 ‚Üí CA-10.10) e isom√©tricos (CA-08.06 ‚Üí CA-10.11, CA-08.07 ‚Üí CA-10.12). Infraestructura de datos ya implementada.
- HU-09: Proporcion√≥ `closeSession()` con el punto de extensi√≥n para progression evaluation. Transacci√≥n at√≥mica.

**Sucesoras (dependen de HU-10):**

- HU-11: Doble Umbral ‚Äî usar√° la clasificaci√≥n de HU-10 y extender√° `evaluateProgression()` para calcular `prescribed_load_kg`. Usar√° `moduleCode` de `SessionExerciseForProgression`.
- HU-12: Detecci√≥n de regresi√≥n/fatiga ‚Äî puede consumir clasificaciones `REGRESSION` de HU-10 para detectar fatiga acumulada (‚â• 50% del m√≥dulo), o reevaluar con criterio per-serie (ver Nota T√©cnica 8). Se integra despu√©s de HU-10 en el flujo de cierre.
- HU-13: E5 (Resumen Post-Sesi√≥n) ‚Äî leer√° `session_exercise.progression_classification` para mostrar clasificaci√≥n visual por ejercicio.
- HU-14: Detecci√≥n de meseta ‚Äî emitir√° alertas con an√°lisis causal cuando `exercise_progression.status == IN_PLATEAU` (transici√≥n ya realizada por HU-10).
- HU-15: Recomendaciones escalonadas ‚Äî usar√° `sessions_without_progression` (sesiones 4 y 6) para acciones escalonadas.
- HU-16: Se√±al de descarga ‚Äî usar√° `exercise_progression.status == IN_PLATEAU` y/o clasificaciones `REGRESSION` para evaluar si activar descarga.
- HU-19: Tasa de progresi√≥n ‚Äî contar√° `POSITIVE_PROGRESSION` en `session_exercise.progression_classification` para calcular (sesiones con progresi√≥n / total sesiones).
- HU-23: Historial de ejercicio (F3) ‚Äî leer√° `session_exercise.progression_classification` para mostrar clasificaci√≥n por sesi√≥n.
- HU-24: Detalle de sesi√≥n pasada (F2) ‚Äî leer√° `session_exercise.progression_classification`.

**Consumidoras indirectas:**

- HU-17: Protocolo de descarga ‚Äî establecer√° `exercise_progression.status = IN_DELOAD`. HU-10 ya respeta este estado (no modifica durante deload).
- HU-20: M√©tricas globales ‚Äî usar√° clasificaciones para calcular tasa de progresi√≥n.
- HU-22: KPIs por ejercicio ‚Äî usar√° `sessions_without_progression` y clasificaciones.

### Referencias y Validaci√≥n

**Documentaci√≥n consultada:**

- Modelo de Datos ¬ß2 (Convenciones): "Datos calculados: No se almacenan en base de datos" ‚Äî RIR promedio es derivable.
- Modelo de Datos ¬ß3.11 (`session_exercise`): columna `progression_classification` con CHECK constraint.
- Modelo de Datos ¬ß3.12 (`exercise_set`): campo `reps` almacena repeticiones o segundos.
- Modelo de Datos ¬ß3.13 (`exercise_progression`): m√°quina de estados completa con l√≥gica de actualizaci√≥n.
- MDS ¬ß5.C: Ciclo de vida de progresi√≥n: `NO_HISTORY ‚Üí IN_PROGRESSION ‚áÑ IN_PLATEAU ‚Üí IN_DELOAD ‚Üí IN_PROGRESSION`.
- MDS ¬ß6-A Reglas 1-7: Doble Umbral, Mantenimiento, Meseta, Regresi√≥n, Descarga, Peso Corporal, Isom√©tricos.
- ADR-06: Motor de reglas como Kotlin puro en `domain.rules`.
- ADR D-06: Comparaci√≥n independiente de versi√≥n.
- ADR D-07: Incremento diferenciado por m√≥dulo (preparaci√≥n para HU-11).
- HU-08 an√°lisis: CAs de progresi√≥n redistribuidos a HU-10 (CA-08.02‚Üí10.10, CA-08.06‚Üí10.11, CA-08.07‚Üí10.12).
- HU-09 an√°lisis: Punto de extensi√≥n en `closeSession()`, entre `updateStatus` y `advanceRotation`.
- Arquitectura T√©cnica ¬ß5.2: Naming `{Nombre}Rule` para reglas del motor.
- Requerimientos: RF23, RF24, RF28, RF31, RF32, RF33, RF43.

### Verificaci√≥n Cruzada de CAs

| CA | Estado | Mecanismo | Implementado en |
|---|---|---|---|
| CA-10.01 | üî® Por implementar | `getLastHistoricalSets()` + `classify()` | HU-10 (DAO + Rule) |
| CA-10.02 | üî® Por implementar | `classifyStandard/Bodyweight/Isometric` ‚Üí `POSITIVE_PROGRESSION` | HU-10 (Rule) |
| CA-10.03 | üî® Por implementar | `else` fallthrough ‚Üí `MAINTENANCE` | HU-10 (Rule) |
| CA-10.04 | üî® Por implementar | Peso ‚Üì / Reps ‚Üì / RIR ‚Üë ‚â• 1.5 ‚Üí `REGRESSION` | HU-10 (Rule) |
| CA-10.05 | ‚è≥ Parcial | `avgRir` in-memory (no almacenado ‚Äî Modelo de Datos ¬ß2) | HU-10 (c√°lculo); consulta futura por KPIs |
| CA-10.06 | üî® Por implementar | `avgRir` calcula con sets disponibles; sesi√≥n `INCOMPLETE` indica parcial | HU-10 (Rule) |
| CA-10.07 | üî® Por implementar | `previous == null ‚Üí return null`; status queda `NO_HISTORY` | HU-10 (Rule) |
| CA-10.08 | üî® Por implementar | `resolveNewProgressionState()` ‚Äî m√°quina de estados | HU-10 (Rule + Repository) |
| CA-10.09 | üî® Por implementar | `updateProgressionClassification()` en `session_exercise` | HU-10 (DAO) |
| CA-10.10 | üî® Por implementar | `classifyBodyweight()` ‚Äî `totalReps` | HU-10 (Rule) |
| CA-10.11 | üî® Por implementar | `classifyIsometric()` ‚Äî `totalReps` (= segundos) | HU-10 (Rule) |
| CA-10.12 | üî® Por implementar | `isIsometricMastered()` ‚Üí `MASTERED` | HU-10 (Rule) |

### Hitos de implementaci√≥n

| # | Entregable | Archivos | CAs |
|---|---|---|---|
| 1 | Modelos de dominio ‚Äî `ProgressionClassification` enum + `ExerciseSessionData` / `SetData` | `ProgressionClassification.kt`, `ExerciseSessionData.kt` | ‚Äî (infraestructura) |
| 2 | Regla pura ‚Äî `ProgressionClassificationRule` + tests unitarios exhaustivos | `ProgressionClassificationRule.kt`, `ProgressionClassificationRuleTest.kt` | CA-10.02, CA-10.03, CA-10.04, CA-10.07, CA-10.08, CA-10.10, CA-10.11, CA-10.12 |
| 3 | Queries DAO ‚Äî DTOs + queries en `SessionExerciseDao` y `ExerciseSetDao` | `SessionExerciseDao.kt`, `ExerciseSetDao.kt` | CA-10.01, CA-10.09 |
| 4 | Integraci√≥n ‚Äî `evaluateProgression()` en `SessionRepositoryImpl.closeSession()` | `SessionRepositoryImpl.kt` | CA-10.01 a CA-10.12 (todos) |
