# HU-06 — Registrar series de ejercicios en sesión activa

## Requisitos relacionados

RF13, RF14, RF15, RF17, RF22, RNF02, RNF03, RNF04, RNF10, RNF12

## Descripción

Como ejecutante, quiero registrar los datos de cada serie de cada ejercicio durante una sesión activa de forma rápida, en cualquier orden y con los datos precargados de mi última sesión, para capturar mi entrenamiento con la menor fricción posible mientras mantengo precisión y completitud en los registros.

## Criterios de Aceptación

### CA-06.01 — Captura de datos por serie

**Dado que** el ejecutante tiene una sesión activa y selecciona un ejercicio para registrar una serie,
**cuando** accede al formulario de registro de serie,
**entonces** el sistema solicita exactamente tres datos: Peso en Kg, Repeticiones logradas y RIR (Reps In Reserve), todos obligatorios para completar el registro.

### CA-06.02 — Registro en máximo 3 toques

**Dado que** el ejecutante ha seleccionado un ejercicio en la sesión activa,
**cuando** registra una serie,
**entonces** el flujo de registro requiere un máximo de 3 toques para completarse: ingresar peso, ingresar repeticiones, ingresar RIR y confirmar, aprovechando la precarga de datos y minimizando la fricción.

### CA-06.03 — Teclado numérico para campos de entrada

**Dado que** el ejecutante está registrando una serie durante la sesión activa,
**cuando** activa cualquier campo de entrada numérica (peso, repeticiones o RIR),
**entonces** el sistema despliega un teclado numérico optimizado, no el teclado alfanumérico completo.

### CA-06.04 — Precarga del último peso utilizado

**Dado que** el ejecutante tiene historial previo para el ejercicio que está registrando,
**cuando** accede al formulario de registro de serie para ese ejercicio,
**entonces** el campo de peso se precarga automáticamente con el último peso utilizado para ese ejercicio, permitiendo al ejecutante confirmar rápidamente si la carga no cambió.

### CA-06.05 — Validación de peso

**Dado que** el ejecutante ingresa un valor de peso en el registro de serie,
**cuando** el valor es menor que 0,
**entonces** el sistema rechaza el registro y muestra un mensaje de error claro indicando que el peso debe ser ≥ 0 Kg (donde 0 es válido exclusivamente para ejercicios de peso corporal).

### CA-06.06 — Validación de repeticiones

**Dado que** el ejecutante ingresa un valor de repeticiones en el registro de serie,
**cuando** el valor es menor que 1,
**entonces** el sistema rechaza el registro y muestra un mensaje de error claro indicando que las repeticiones deben ser ≥ 1.

### CA-06.07 — Validación de RIR

**Dado que** el ejecutante ingresa un valor de RIR en el registro de serie,
**cuando** el valor está fuera del rango 0 a 5,
**entonces** el sistema rechaza el registro y muestra un mensaje de error claro indicando que el RIR debe estar entre 0 y 5.

### CA-06.08 — Asociación automática de metadatos

**Dado que** el ejecutante confirma el registro de una serie con datos válidos,
**cuando** el sistema persiste el registro,
**entonces** asocia automáticamente la serie con: la Fecha actual, el Módulo de la sesión, la Versión del módulo, el Ejercicio ejecutado y el Número de Serie secuencial (1, 2, 3 o 4), sin requerir que el ejecutante ingrese ninguno de estos datos manualmente.

### CA-06.09 — Secuencia de series por ejercicio

**Dado que** el ejecutante registra series de un ejercicio durante la sesión activa,
**cuando** registra cada serie,
**entonces** el sistema asigna automáticamente el número de serie secuencial: la primera serie registrada es 1, la segunda es 2, la tercera es 3 y la cuarta es 4, sin permitir más de 4 series por ejercicio.

### CA-06.10 — Orden libre de registro de ejercicios

**Dado que** el ejecutante tiene una sesión activa con múltiples ejercicios prescritos,
**cuando** decide registrar series,
**entonces** el sistema permite registrar los ejercicios en cualquier orden, sin imponer la secuencia en que aparecen en el Plan de Entrenamiento. El ejecutante puede empezar por cualquier ejercicio, registrar series parciales de uno, cambiar a otro y volver.

### CA-06.11 — Vinculación al ejercicio realmente ejecutado

**Dado que** el ejecutante ha realizado una sustitución puntual de un ejercicio durante la sesión,
**cuando** registra las series del ejercicio sustituto,
**entonces** el sistema vincula los datos registrados al ejercicio que realmente se ejecutó (el sustituto), no al ejercicio originalmente prescrito, garantizando coherencia entre lo registrado y lo efectivamente realizado.

### CA-06.12 — Estado visual de ejercicios en la sesión

**Dado que** el ejecutante tiene una sesión activa,
**cuando** visualiza la lista de ejercicios de la sesión,
**entonces** el sistema muestra el estado de cada ejercicio: "No Iniciado" cuando tiene 0 series registradas, "En Ejecución" cuando tiene entre 1 y 3 series registradas, o "Completado" cuando tiene 4 series registradas.

### CA-06.13 — Preservación de datos ante cierre inesperado

**Dado que** el ejecutante tiene una sesión activa con series registradas,
**cuando** la aplicación se cierra inesperadamente (cierre por el usuario, falta de batería o crash),
**entonces** el sistema preserva todos los datos de la sesión en progreso y todas las series registradas hasta ese momento. Al reabrir la aplicación, la sesión puede continuarse desde el punto donde quedó.

## Análisis Arquitectónico (Arquitecto)

### Decisiones de Diseño

**Patrón Arquitectónico:** Clean Architecture (MVVM + Use Cases + Repository) — consistente con HU-01 a HU-05.

**Justificación:** HU-06 sigue el mismo flujo de datos del resto de la app: pantalla E2 → ViewModel → UseCase → Repository → DAOs → Room. La complejidad reside en la lógica de validación (3 campos, 3 reglas) y la transacción atómica de registro con asignación secuencial del número de serie. Ambas están bien servidas por este patrón sin necesidad de alternativas.

**Componentes Afectados:**

#### 1. Data Layer — DAOs (Modificaciones)

Paquete: `data.local.dao`.

- **`ExerciseSetDao`** (Modificación Mayor): Actualmente stub vacío (creado en HU-05). Se convierte en DAO funcional con:

  - `insert(set: ExerciseSetEntity): Long` — `@Insert`. Persiste una serie individual. Retorna el `id` generado por autoincrement.

  - `getNextSetNumber(sessionExerciseId: Long): Int` — `@Query` suspend. Calcula `COUNT(*) + 1` para asignar automáticamente el número secuencial (CA-06.09). Si ya hay 4 series, retornará 5 — la capa de repository lo valida como error.

    ```sql
    SELECT COUNT(*) + 1 FROM exercise_set
    WHERE session_exercise_id = :sessionExerciseId
    ```

  - `getLastWeightForExercise(exerciseId: Long): Double?` — `@Query` suspend. Query cross-session para precarga del último peso utilizado (CA-06.04, RNF04). Busca en todas las sesiones anteriores, no solo la sesión activa. Retorna `null` si sin historial (primera sesión del ejercicio).

    ```sql
    SELECT es.weight_kg
    FROM exercise_set es
    INNER JOIN session_exercise se ON es.session_exercise_id = se.id
    WHERE se.exercise_id = :exerciseId
    ORDER BY es.id DESC
    LIMIT 1
    ```

    **Justificación del ORDER BY `es.id` DESC:** El `id` autoincrement de `exercise_set` es monotónicamente creciente. La última serie insertada para un ejercicio dado será siempre la de mayor `id`. Esto es más eficiente que un JOIN adicional a `session.date` + `es.set_number` y produce el mismo resultado.

- **`SessionExerciseDao`** (Modificación Menor): Agregar query suspend para obtener la información del ejercicio necesaria para poblar el formulario E2.

  - `getExerciseInfoForSet(sessionExerciseId: Long): SetExerciseInfo?` — `@Query` suspend. Query JOIN multi-tabla que retorna nombre del ejercicio, flags booleanos, y `totalSets`. Usa LEFT JOIN para `plan_assignment` con `COALESCE(pa.sets, 4)` como protección ante ejercicios sustituidos (HU-07 futuro) donde `exercise_id` podría no existir en `plan_assignment` para ese `module_version_id`.

    ```sql
    SELECT
        se.exercise_id AS exerciseId,
        e.name AS exerciseName,
        e.is_bodyweight AS isBodyweight,
        e.is_isometric AS isIsometric,
        e.is_to_technical_failure AS isToTechnicalFailure,
        COALESCE(pa.sets, 4) AS totalSets
    FROM session_exercise se
    INNER JOIN exercise e ON se.exercise_id = e.id
    INNER JOIN session s ON se.session_id = s.id
    LEFT JOIN plan_assignment pa ON pa.module_version_id = s.module_version_id
        AND pa.exercise_id = se.exercise_id
    WHERE se.id = :sessionExerciseId
    ```

  - **`SetExerciseInfo`**: Data class intermedia (no `@Entity`), definida en `SessionExerciseDao.kt` (mismo patrón de `SessionExerciseWithDetails` y `ActiveSessionInfo`). Campos: `exerciseId: Long`, `exerciseName: String`, `isBodyweight: Int`, `isIsometric: Int`, `isToTechnicalFailure: Int`, `totalSets: Int`.

- **`ExerciseProgressionDao`** (Modificación Menor): Agregar método para creación idempotente de la fila de progresión.

  - `insertIfNotExists(progression: ExerciseProgressionEntity)` — `@Insert(onConflict = OnConflictStrategy.IGNORE)`. Al registrar la primera serie de un ejercicio, se crea la fila `exercise_progression` con defaults (`status = "NO_HISTORY"`, `prescribedLoadKg = null`, `sessionsWithoutProgression = 0`). La PK es `exercise_id`, por lo tanto el IGNORE asegura idempotencia: si la fila ya existe (ejercicio con historial previo), no se modifica (Modelo de Datos §3.13: "Se crea una fila por ejercicio al registrar la primera serie del ejercicio").

#### 2. Domain Layer — Modelo Nuevo

Paquete: `domain.model`.

- **`RegisterSetInfo`**: Data class que encapsula la información necesaria para poblar el formulario E2.
  - `sessionExerciseId: Long` — ID del ejercicio-en-sesión. Usado para el INSERT.
  - `exerciseId: Long` — ID del ejercicio base. Usado para consultar último peso.
  - `exerciseName: String` — Nombre mostrado en el Top Bar de E2.
  - `currentSetNumber: Int` — Próximo número de serie a registrar (1-4). Calculado via `getNextSetNumber()`.
  - `totalSets: Int` — Siempre 4 en MVP. Viene del `COALESCE(pa.sets, 4)`.
  - `lastWeightKg: Double?` — Último peso utilizado para precarga (CA-06.04). `null` = sin historial → campo vacío. `0.0` = peso corporal/isométrico → campo fijo no editable.
  - `isBodyweight: Boolean` — Flag de peso corporal (CA-08.01).
  - `isIsometric: Boolean` — Flag de isométrico (CA-08.04, CA-08.05).
  - `isToTechnicalFailure: Boolean` — Flag de fallo técnico (informativo).

#### 3. Domain Layer — Repository Interface (Modificación)

Paquete: `domain.repository`.

- **`SessionRepository`** (Modificación): Agregar 2 métodos al contrato existente.

  - `suspend fun getRegisterSetInfo(sessionExerciseId: Long): RegisterSetInfo?` — Obtiene la información necesaria para poblar E2. Retorna `null` si `sessionExerciseId` no existe (defensa contra argumento inválido). Método `suspend` (no Flow) porque es una consulta one-shot al abrir E2.

  - `suspend fun registerSet(sessionExerciseId: Long, weightKg: Double, reps: Int, rir: Int)` — Ejecuta la transacción atómica de registro: calcula número de serie, INSERT en `exercise_set`, INSERT idempotente en `exercise_progression`. Lanza `IllegalStateException` si el ejercicio ya tiene 4 series (defensa en profundidad).

#### 4. Domain Layer — Use Cases Nuevos

Paquete: `domain.usecase.session`.

- **`GetRegisterSetInfoUseCase`** (Nuevo): Wrapper de `SessionRepository.getRegisterSetInfo()`.

  ```kotlin
  class GetRegisterSetInfoUseCase @Inject constructor(
      private val sessionRepository: SessionRepository,
  ) {
      suspend operator fun invoke(sessionExerciseId: Long): RegisterSetInfo? {
          return sessionRepository.getRegisterSetInfo(sessionExerciseId)
      }
  }
  ```

  Justificación como clase separada: mantiene consistencia con el patrón de use cases de HU-01 a HU-05 y permite agregar lógica de dominio futura (e.g., cálculo de carga sugerida) sin modificar el ViewModel.

- **`RegisterSetUseCase`** (Nuevo): Valida reglas de negocio y delega persistencia.

  ```kotlin
  class RegisterSetUseCase @Inject constructor(
      private val sessionRepository: SessionRepository,
  ) {
      suspend operator fun invoke(
          sessionExerciseId: Long,
          weightKg: Double,
          reps: Int,
          rir: Int,
      ) {
          require(weightKg >= 0) { "Weight must be >= 0" }
          require(reps >= 1) { "Reps must be >= 1" }
          require(rir in 0..5) { "RIR must be between 0 and 5" }
          sessionRepository.registerSet(sessionExerciseId, weightKg, reps, rir)
      }
  }
  ```

  **Validación en `require()` vs. UI:** La validación en el Use Case es la última línea de defensa. La UI también valida en tiempo real (feedback inmediato al usuario). La redundancia es intencional: el Use Case protege la integridad de los datos independientemente de qué UI lo invoque (principio de la Clean Architecture). **Los mensajes de `require()` van en inglés** (Arquitectura Técnica §5.7: mensajes de validación de dominio son uso interno, no visibles al usuario). El ViewModel mapea las excepciones `IllegalArgumentException` a strings localizados en español (`strings.xml`) para mostrar en la UI.

#### 5. Data Layer — Repository Implementation (Modificación Mayor)

Paquete: `data.repository`.

- **`SessionRepositoryImpl`** (Modificación Mayor): Implementar los 2 nuevos métodos. Requiere inyección de `ExerciseSetDao` y `ExerciseProgressionDao` (ambos ya provistos en `DatabaseModule` desde HU-05).

  - `getRegisterSetInfo(sessionExerciseId: Long): RegisterSetInfo?`:
    1. Consulta `sessionExerciseDao.getExerciseInfoForSet(sessionExerciseId)`. Si `null` → retorna `null`.
    2. Consulta `exerciseSetDao.getNextSetNumber(sessionExerciseId)`. Si > 4 → retorna `null` (ejercicio ya completado, no se puede registrar más).
    3. Determina `lastWeightKg`:
       - Si `isBodyweight == 1` o `isIsometric == 1` → `0.0` (peso fijo no editable, CA-08.01).
       - Si no → `exerciseSetDao.getLastWeightForExercise(info.exerciseId)` (puede ser `null` si sin historial).
    4. Mapea a `RegisterSetInfo` convirtiendo flags `Int` → `Boolean`.

  - `registerSet(sessionExerciseId: Long, weightKg: Double, reps: Int, rir: Int)`:
    Ejecuta en `database.withTransaction {}`:
    1. `val nextSetNumber = exerciseSetDao.getNextSetNumber(sessionExerciseId)`.
    2. Valida `nextSetNumber <= 4`. Si no, lanza `IllegalStateException("Exercise already has 4 sets")`.
    3. INSERT: `exerciseSetDao.insert(ExerciseSetEntity(sessionExerciseId = sessionExerciseId, setNumber = nextSetNumber, weightKg = weightKg, reps = reps, rir = rir))`.
    4. Obtiene `exerciseId` via `sessionExerciseDao.getExerciseInfoForSet(sessionExerciseId)`.
    5. INSERT idempotente: `exerciseProgressionDao.insertIfNotExists(ExerciseProgressionEntity(exerciseId = exerciseId))` con defaults. Si la fila ya existe, `IGNORE` la descarta silenciosamente.

  **¿Por qué la transacción es necesaria?** Los pasos 1-3 deben ser atómicos para evitar condiciones de carrera en la asignación de `setNumber`. Sin transacción, dos llamadas rápidas podrían obtener el mismo `nextSetNumber` y violar el UNIQUE constraint `(session_exercise_id, set_number)`. La transacción serializa el acceso.

  **Inyección adicional en constructor:** Agregar `exerciseSetDao: ExerciseSetDao` y `exerciseProgressionDao: ExerciseProgressionDao` al constructor de `SessionRepositoryImpl`. Los providers ya existen en `DatabaseModule` (creados en HU-05).

#### 6. UI Layer — Estado y ViewModel

Paquete: `ui.session`.

- **`RegisterSetUiState`** (Nuevo): Data class de estado reactivo del formulario E2.

  ```kotlin
  data class RegisterSetUiState(
      val isLoading: Boolean = true,
      val exerciseName: String = "",
      val currentSetNumber: Int = 1,
      val totalSets: Int = 4,
      val weightKg: String = "",
      val reps: String = "",
      val selectedRir: Int? = null,
      val isWeightEditable: Boolean = true,
      val isIsometric: Boolean = false,
      val isBodyweight: Boolean = false,
      val weightError: String? = null,
      val repsError: String? = null,
      val isSaving: Boolean = false,
  ) {
      val isConfirmEnabled: Boolean
          get() = selectedRir != null &&
              weightKg.isNotBlank() &&
              reps.isNotBlank() &&
              weightError == null &&
              repsError == null &&
              !isSaving
  }
  ```

  **Campos de texto como `String`:** Los campos `weightKg` y `reps` son `String` (no `Double`/`Int`) porque representan el texto del `OutlinedTextField`. El parseo a tipo numérico se realiza en `onConfirm()`. Esto permite que el usuario vea exactamente lo que escribió y reciba errores solo al intentar confirmar o durante la validación en tiempo real.

- **`RegisterSetViewModel`** (Nuevo): `@HiltViewModel`. Gestiona el ciclo de vida del formulario E2.

  - **Inyecta:** `GetRegisterSetInfoUseCase`, `RegisterSetUseCase`, `SavedStateHandle`.
  - **Session exercise ID:** `savedStateHandle.get<Long>("sessionExerciseId")` — extraído del argumento de navegación.
  - **Estado:** `MutableStateFlow<RegisterSetUiState>` → `StateFlow<RegisterSetUiState>`.
  - **Evento de navegación:** `MutableSharedFlow<Boolean>(replay = 0)` → la UI observa con `LaunchedEffect` y navega back al emitir `true`.

  - **`init`:** Llama a `GetRegisterSetInfoUseCase(sessionExerciseId)` en `viewModelScope.launch`. Si resultado es `null`, permanece en loading (E2 no debería alcanzarse con ID inválido). Si resultado es válido:
    - `exerciseName` ← `info.exerciseName`.
    - `currentSetNumber` ← `info.currentSetNumber`.
    - `totalSets` ← `info.totalSets`.
    - `isWeightEditable` ← `!info.isBodyweight && !info.isIsometric`.
    - `isIsometric` ← `info.isIsometric`.
    - `isBodyweight` ← `info.isBodyweight`.
    - `weightKg`:
      - Si bodyweight/isometric → `"0"` (fijo, CA-08.01).
      - Si `lastWeightKg != null` → formateado (e.g., `"60.0"`).
      - Si `null` → `""` (vacío, sin historial).

  - **`onWeightChanged(value: String)`:** Actualiza `weightKg`. Valida: parsea a Double, si `< 0` → `weightError = "El peso debe ser ≥ 0 Kg"`. Si vacío o inválido → `weightError = null` (no mostrar error hasta que intente confirmar). Se limita a validación no-bloqueante.

  - **`onRepsChanged(value: String)`:** Actualiza `reps`. Valida: parsea a Int, si `< 1` → `repsError` con mensaje según variante ("Las repeticiones deben ser ≥ 1" o "La duración debe ser ≥ 1 segundo" para isométrico).

  - **`onRirSelected(rir: Int)`:** Actualiza `selectedRir`. Sin validación necesaria — los chips 0-5 garantizan rango válido por diseño (CA-06.07 se cumple por construcción, no por validación).

  - **`onConfirm()`:** Ejecuta en `viewModelScope.launch`:
    1. Parsea `weightKg` → `Double`, `reps` → `Int`. Si parseo falla, actualiza errores y retorna.
    2. Marca `isSaving = true` (deshabilita botón, protección anti-double-tap).
    3. `try { registerSetUseCase(sessionExerciseId, weight, reps, rir) }` — el UC valida y persiste.
    4. Si éxito: emite `true` en `navigateBack` SharedFlow.
    5. Si `IllegalArgumentException`: actualiza errores en UI.
    6. Si `IllegalStateException`: "Exercise already has 4 sets" — emite `true` igualmente (graceful: retorna a E1 donde el estado ya refleja completado).
    7. `finally { isSaving = false }` — reestablece por si hubo error no terminal.

#### 7. UI Layer — Pantalla E2

Paquete: `ui.session`.

- **`RegisterSetScreen`** (Nuevo): Composable que implementa la vista E2 según Wireframes E2 y Especificación Visual §8 E2.

  Firma:
  ```kotlin
  @Composable
  fun RegisterSetScreen(
      onNavigateBack: () -> Unit,
      viewModel: RegisterSetViewModel = hiltViewModel(),
  )
  ```

  **Estructura de layout:**

  - **Top Bar:** `CenterAlignedTopAppBar` (M3).
    - `navigationIcon`: `IconButton` con `Icons.Default.Close` (✕), tint `On Surface`. `onClick = onNavigateBack` (descarta sin registrar).
    - `title`: `Column` con:
      - `Text` nombre del ejercicio — `Title Large`.
      - `Text` "Serie N de 4" — `Title Small`, `On Surface Variant`. Formato: `register_set_title_format`.

  - **Body:** `Column` con padding 16 dp, spacing vertical 16 dp.
    - **Campo "Peso (Kg)":** `OutlinedTextField`.
      - **Variante estándar:** `enabled = true`, `keyboardType = KeyboardType.Decimal`, texto precargado con último peso, label "Peso (Kg)", trailingIcon "Kg" en `Body Small, On Surface Variant`. Borde: `Outline` → `Primary` al focus. `supportingText` con error si `weightError != null` (color `Error #BA1A1A`).
      - **Variante peso corporal:** `enabled = false`, valor "0", label "Peso (Kg) (Peso corporal)", fondo `Surface Container Highest (#EDE0D5)` con opacity 0.5, texto `On Surface Variant`.
      - **Variante isométrico:** `enabled = false`, valor "0", label "Peso (Kg) (Isométrico)", mismos estilos deshabilitado.

    - **Campo "Repeticiones" / "Segundos sostenidos":** `OutlinedTextField`.
      - **Estándar y peso corporal:** label "Repeticiones", `keyboardType = KeyboardType.Number`, trailingIcon "reps", sin precarga (vacío).
      - **Isométrico:** label "Segundos sostenidos", `keyboardType = KeyboardType.Number`, trailingIcon "seg", `supportingText = "(Referencia: 30-45 seg)"` en `Body Small, On Surface Variant` (CA-08.05).
      - Error inline si `repsError != null`.

    - **Selector RIR:** `Column` con:
      - Label "RIR" en `Label Medium, On Surface Variant`.
      - `Row` horizontal con spacing 8 dp, 6 chips circulares (0, 1, 2, 3, 4, 5).
      - Cada chip: `Box` 48×48 dp (RNF06), `CircleShape`.
        - No seleccionado: fondo `Surface Container (#F8EBE0)`, borde `Outline`, texto `On Surface`.
        - Seleccionado: fondo `Primary (#8B1A1A)`, sin borde, texto `On Primary (#FFFFFF)`.
      - Single select. Sin precarga.

    - **Botón "Confirmar":** `FilledButton` full width, `containerColor = Primary`, height 48 dp, margin top 24 dp. `enabled = isConfirmEnabled`. Al click → `viewModel.onConfirm()`.

    - **"Cancelar":** `TextButton` centrado, color `Primary`. Al click → `onNavigateBack()` (descarta sin cambios).

  - **Sin Bottom Navigation** (Arquitectura Técnica §4.5.1: E2 siempre oculta).

  - **Navegación de retorno:** `LaunchedEffect` que observa `viewModel.navigateBack` SharedFlow y llama a `onNavigateBack()` cuando emite `true`. Esto garantiza que la navegación ocurra después de la persistencia exitosa.

  **Cumplimiento de RNF02 (máximo 3 toques):** Con peso precargado, el flujo óptimo es: (1) ingresar repeticiones, (2) tocar chip RIR, (3) tocar "Confirmar". El peso ya está precargado y no requiere interacción si no cambió. Para primera sesión (sin precarga), el flujo es 4 toques: peso + reps + RIR + confirmar, que es aceptable dado que la precarga no es posible sin historial.

#### 8. Navegación (Modificaciones)

Paquete: `ui.navigation`.

- **`NavigationRoutes`** (Modificación Menor): Agregar ruta E2.
  - `const val REGISTER_SET = "register-set/{sessionExerciseId}"` (Arquitectura Técnica §4.3 ruta #10).
  - `fun registerSetRoute(sessionExerciseId: Long) = "register-set/$sessionExerciseId"`.

- **`TensionNavHost`** (Modificación): 2 cambios.
  - **Wiring del callback** en `ACTIVE_SESSION`: reemplazar `onNavigateToRegisterSet = { /* TODO: HU-06 */ }` por:
    ```kotlin
    onNavigateToRegisterSet = { sessionExerciseId ->
        navController.navigate(NavigationRoutes.registerSetRoute(sessionExerciseId))
    }
    ```
  - **Nuevo composable entry:** `composable(route = NavigationRoutes.REGISTER_SET, arguments = listOf(navArgument("sessionExerciseId") { type = NavType.LongType }))` que monta `RegisterSetScreen(onNavigateBack = { navController.popBackStack() })`.

  **Nota sobre `showBottomBar`:** La condición existente `!currentRoute.startsWith("active-session")` NO cubre `register-set`. Agregar exclusión: `&& !currentRoute.startsWith("register-set")`.

#### 9. Recursos

Archivo: `app/src/main/res/values/strings.xml`.

- Agregar ~12 strings para E2:
  ```xml
  <!-- Register Set E2 -->
  <string name="register_set_title_format">Serie %1$d de %2$d</string>
  <string name="register_set_weight_label">Peso (Kg)</string>
  <string name="register_set_weight_bodyweight_label">Peso (Kg) (Peso corporal)</string>
  <string name="register_set_weight_isometric_label">Peso (Kg) (Isométrico)</string>
  <string name="register_set_weight_suffix">Kg</string>
  <string name="register_set_reps_label">Repeticiones</string>
  <string name="register_set_reps_suffix">reps</string>
  <string name="register_set_seconds_label">Segundos sostenidos</string>
  <string name="register_set_seconds_suffix">seg</string>
  <string name="register_set_seconds_reference">(Referencia: 30\u201345 seg)</string>
  <string name="register_set_rir_label">RIR</string>
  <string name="register_set_confirm">Confirmar</string>
  <string name="register_set_cancel">Cancelar</string>
  <string name="error_weight_negative">El peso debe ser \u2265 0 Kg</string>
  <string name="error_reps_min">Las repeticiones deben ser \u2265 1</string>
  <string name="error_seconds_min">La duración debe ser \u2265 1 segundo</string>
  ```

### Validación de Impacto

**Código verificado antes de proponer (paso 1.5):**

| Archivo | Estado verificado | Hallazgo |
|---|---|---|
| `ExerciseSetDao.kt` | Stub vacío — solo `@Dao interface ExerciseSetDao` | ✅ Confirma necesidad de 3 métodos nuevos |
| `ExerciseSetEntity.kt` | Completa con 6 columnas (id, sessionExerciseId, setNumber, weightKg, reps, rir) | ✅ Columnas coinciden con INSERT propuesto. UNIQUE(session_exercise_id, set_number) + FK CASCADE definidos. Room no soporta CHECK constraints nativamente — validación de rangos cubierta por UseCase `require()` + UI |
| `SessionExerciseDao.kt` | `getBySessionId()` y `getBySessionIdWithDetails()` existen | ✅ No hay método para obtener info individual. Se necesita `getExerciseInfoForSet()` |
| `ExerciseProgressionDao.kt` | Tiene `insert()` y `update()` | ✅ `insert()` usa `@Insert` default (ABORT on conflict) — no serve para idempotencia. Se necesita `insertIfNotExists()` con IGNORE |
| `SessionRepositoryImpl.kt` | 164 líneas, inyecta 5 DAOs + TensionDatabase (6 parámetros) | ✅ No inyecta `ExerciseSetDao` ni `ExerciseProgressionDao`. Se agregan al constructor |
| `SessionRepository.kt` | 6 métodos actuales | ✅ Ninguno cubre registro de series. Se agregan 2 |
| `NavigationRoutes.kt` | 8 rutas, sin `REGISTER_SET` | ✅ Se agrega |
| `TensionNavHost.kt` | `onNavigateToRegisterSet = { /* TODO: HU-06 */ }` | ✅ Stub confirmado. Se reemplaza con navegación real |
| `TensionNavHost.kt` — `showBottomBar` | Excluye `REGISTER` y `active-session` | ⚠️ No excluye `register-set`. Se agrega |
| `ActiveSessionScreen.kt` | "Registrar" button navega via `onNavigateToRegisterSet(exercise.sessionExerciseId)` | ✅ Ya pasa `sessionExerciseId` correcto |
| `DatabaseModule.kt` | `provideExerciseSetDao()` y `provideExerciseProgressionDao()` ya existen | ✅ No se necesitan nuevos providers |
| `RepositoryModule.kt` | Binding `SessionRepository → SessionRepositoryImpl` ya existe | ✅ No se necesitan nuevos bindings |
| `strings.xml` | Sin strings de E2 | ✅ Se agregan ~12 strings |

**Impacto en el Flow reactivo de E1:** Al insertar una serie en `exercise_set`, Room invalida automáticamente el query `getBySessionIdWithDetails()` en E1 (que hace `COUNT(exercise_set)` como subquery). El Flow re-emite la lista actualizada y `completedSets` refleja la nueva serie. El estado del ejercicio cambia reactivamente: 0 → `NOT_STARTED`, 1-3 → `IN_PROGRESS`, 4 → `COMPLETED`. No se requiere ningún refresh manual ni notificación explícita.

**Impacto en la Card "Reanudar" de B1:** El `completedExercises` en `ActiveSessionInfo` también se recalcula reactivamente cuando se completa un ejercicio (4 series). Si el usuario mata la app y reabre, B1 mostrará el progreso actualizado.

### Notas Técnicas

1. **CA-06.08 (metadatos automáticos) se cumple por contexto relacional.** La cadena `exercise_set → session_exercise → session → module_version` proporciona: Fecha (`session.date`), Módulo (`module_version.module_code`), Versión (`module_version.version_number`), Ejercicio (`session_exercise.exercise_id`), Número de serie (`exercise_set.set_number`). El ejecutante solo ingresa: peso, reps, RIR. Los 5 metadatos se derivan automáticamente.

2. **CA-06.10 (orden libre) se cumple por diseño de E1.** Cada ejercicio tiene su propio botón "Registrar" independiente. No hay secuencia forzada. El ejecutante puede registrar 2 series de Press de banca, 1 de Remo, volver a Press para la 3ra, etc. El `set_number` es secuencial *dentro de cada ejercicio*, no a nivel de sesión.

3. **CA-06.11 (vinculación al ejercicio sustituto) se cumple automáticamente.** La serie se inserta con referencia al `session_exercise_id`, que apunta al `exercise_id` que realmente se ejecutó. Si hubo sustitución (HU-07), `session_exercise.exercise_id` ya contiene el sustituto. La query `getLastWeightForExercise()` busca por `exercise_id`, por lo que el historial del sustituto se precarga correctamente.

4. **CA-06.12 (estado visual) ya fue implementado en HU-05.** Los 3 estados (No Iniciado, En Ejecución, Completado) se derivan en `SessionRepositoryImpl.getSessionExercises()` del `completedSets` count. Al insertar una serie, Room invalida el Flow y E1 re-renderiza con el nuevo estado. No se requiere trabajo adicional en HU-06 para este CA.

5. **CA-06.13 (preservación ante cierre) se cumple por Room.** Cada INSERT en `exercise_set` se persiste en SQLite de forma inmediata tras el `withTransaction` commit. Si la app se cierra 1ms después de confirmar, la serie está persistida. Si la app se cierra *durante* la transacción, Room hace rollback y es como si el usuario no hubiera tocado "Confirmar" (no hay pérdida de datos parciales).

6. **Relación con HU-08.** Los CAs de HU-08 referenciados en E2 (CA-08.01, CA-08.04, CA-08.05, CA-08.08) se cubren en este diseño:
   - CA-08.01 (peso = 0 bodyweight): `isWeightEditable = false`, valor fijo "0".
   - CA-08.04 (input en segundos para isométrico): label/suffix cambian a "Segundos sostenidos" / "seg".
   - CA-08.05 (referencia 30-45 seg): `supportingText = "(Referencia: 30-45 seg)"`.
   - CA-08.08 (validación): misma lógica `reps >= 1` aplica tanto a repeticiones como a segundos (el campo `exercise_set.reps` almacena ambos, como documenta Modelo de Datos §3.12).
   - **Nota:** CA-08.02 (progresión por repeticiones totales), CA-08.03 (exclusión Doble Umbral), CA-08.06 (progresión isométrica), CA-08.07 (marcado "dominado") son responsabilidad de HU-10/HU-11, no de HU-06. El registro de datos es agnóstico al tipo — la interpretación ocurre al cerrar sesión.

7. **Impacto en la HU-07 (sustitución).** El LEFT JOIN en `getExerciseInfoForSet()` con `COALESCE(pa.sets, 4)` prepara E2 para recibir ejercicios sustituidos. Cuando HU-07 reemplace `session_exercise.exercise_id`, E2 funcionará sin cambios porque la query busca por `se.exercise_id` (el ejercicio actual, no el original).

8. **`getLastWeightForExercise()` es cross-session.** Busca el último peso en TODAS las sesiones (actuales y pasadas), no solo en la sesión activa. Esto permite que si un ejercicio tuvo peso 60 Kg en la sesión anterior, al iniciar una nueva sesión el peso se precargue correctamente. Si el ejercicio no tiene historial en ninguna sesión previa, retorna `null` y el campo queda vacío.

9. **Decisión diferida: precarga vs. carga prescrita post-descarga (HU-17).** La query `getLastWeightForExercise()` retorna el "último peso utilizado" sin filtrar sesiones de descarga. Tras un ciclo de descarga (HU-17), el E2 precargaría el peso de descarga (60% de la carga habitual) mientras E1 muestra la carga prescrita de reinicio (90% de la carga pre-descarga) desde `exercise_progression.prescribed_load_kg`. Esta discrepancia es **intencionada** según CA-06.04 ("último peso utilizado") vs. la carga objetivo de E1 ("carga prescrita"). Si HU-17 requiere cambiar el comportamiento de precarga (e.g., usar `prescribed_load_kg` cuando disponible, o filtrar sesiones de descarga), la modificación se aplica sobre la query de HU-06 sin cambiar la interfaz. Modelo de Datos §3.15 confirma que la "carga habitual" para cálculos de descarga usa una query diferente que SÍ filtra sesiones de descarga (`WHERE session.deload_id IS NULL AND session.date < deload.activation_date`).

10. **`keyboardType` para campo Peso: `Decimal` (no `Number`).** La Especificación Visual §8 E2 usa el término genérico "keyboardType: Number" para todos los campos numéricos. Sin embargo, `weight_kg` es `REAL` (Double) en la BD y las cargas usan incrementos de 2.5 Kg (HU-11, MDS §6-A R1), requiriendo entrada decimal. Se implementa con `KeyboardType.Decimal` (muestra teclado con separador decimal) para peso, y `KeyboardType.Number` (solo dígitos, sin decimal) para repeticiones/segundos (ambos `INTEGER`). Esta es una refinación técnica del término genérico de la especificación, no una desviación.

### Referencias y Validación

**Documentación consultada:**

- Modelo de Datos (§3.10-§3.13) — Estructura de session, session_exercise, exercise_set, exercise_progression
- Wireframes E2 — Registro de Serie (estándar, isométrico, peso corporal)
- Especificación Visual §8 E2 — Componentes M3, estilos, estados de validación
- Mapa de Navegación §5 (E2) — Flujo E1→E2→E1
- Arquitectura Técnica §4.3 (ruta #10: `register-set/{sessionExerciseId}`) y §4.5.1 (Bottom Nav oculta en E2)
- ADR (D-03: inmutabilidad post-cierre, D-04: E4 es diálogo no ruta)
- Requerimientos: RF13, RF14, RF15, RF17, RF22, RNF02, RNF03, RNF04, RNF10, RNF12
- Manifiesto de Dominio Sistémico §5.A.5 — "Registro de datos por serie"
- Plan de Entrenamiento — Prescripciones (4 series, 8-12 reps, TO_TECHNICAL_FAILURE, 30-45_SEC)

**Historias relacionadas:**

- HU-05: Determinar e iniciar sesión — Creó ExerciseSetEntity/Dao como stubs. Creó E1 con callbacks `onNavigateToRegisterSet`. Creó SessionRepository y su impl.
- HU-07: Sustitución puntual de ejercicios — El LEFT JOIN en getExerciseInfoForSet() prepara para ejercicios sustituidos donde exercise_id no existe en plan_assignment.
- HU-08: Ejercicios de peso corporal e isométricos — Los CAs de registro (CA-08.01, CA-08.04, CA-08.05, CA-08.08) se implementan en HU-06 como variantes del formulario E2. Los CAs de progresión (CA-08.02, CA-08.03, CA-08.06, CA-08.07) son responsabilidad de HU-10/HU-11.
- HU-09: Cerrar sesión — Lee de exercise_set para determinar estado completado vs incompleto. HU-06 proporciona los datos que HU-09 consumirá.
- HU-10: Clasificación de progresión — Lee exercise_set para calcular promedios de peso/reps/RIR y comparar con sesión anterior.
- HU-11: Señal de subir carga (Doble Umbral) — Lee exercise_set para verificar condiciones de progresión y escribir exercise_progression.prescribed_load_kg.
- HU-12: Detección de regresión y fatiga acumulada — Lee exercise_set (weight_kg, reps, rir) para comparar contra registro histórico y detectar regresión. Consumidor directo al mismo nivel que HU-10/HU-11.
- HU-13: Resumen post-sesión — Lee exercise_set para calcular tonelaje, promedios y clasificación visual.
- HU-17: Activar y gestionar ciclo de descarga — Lee exercise_set.weight_kg para calcular 60% (carga de descarga) y 90% (carga de reinicio). Ver Nota Técnica 9 sobre decisión diferida de precarga vs. carga prescrita post-descarga.
- HU-23: Historial y tendencia de carga de un ejercicio — Lee exercise_set (weight_kg, reps, rir) para mostrar historial completo por ejercicio, independiente de versión.
- HU-24: Historial de sesiones pasadas — Lee exercise_set para mostrar detalle de series registradas (peso, reps, RIR) en vista de sesión pasada.

**Validado por:** esteban.colorado | **Fecha:** 2026-02-14 | **Enfoque:** Exploratorio

---

### Hitos de implementación

| # | Entregable | Dependencia |
|---|---|---|
| 1 | Data Layer — DAOs: `ExerciseSetDao` (+3 métodos: `insert`, `getNextSetNumber`, `getLastWeightForExercise`), `SessionExerciseDao` (+`getExerciseInfoForSet` + `SetExerciseInfo`), `ExerciseProgressionDao` (+`insertIfNotExists`) | — |
| 2 | Domain — Model: `RegisterSetInfo` | — |
| 3 | Domain — Repository Interface: `SessionRepository` (+2 métodos: `getRegisterSetInfo`, `registerSet`) | Hito 2 |
| 4 | Domain — Use Cases: `GetRegisterSetInfoUseCase`, `RegisterSetUseCase` | Hito 3 |
| 5 | Data — Repository Impl: `SessionRepositoryImpl` (+2 métodos, +2 DAOs inyectados) | Hito 1, 3 |
| 6 | UI — State + ViewModel: `RegisterSetUiState`, `RegisterSetViewModel` | Hito 4 |
| 7 | UI — Screen: `RegisterSetScreen` (E2 completo con variantes estándar/bodyweight/isométrico) | Hito 6 |
| 8 | Navegación: `NavigationRoutes` (+REGISTER_SET), `TensionNavHost` (wiring E1→E2 + showBottomBar exclusión) | Hito 7 |
| 9 | Recursos: `strings.xml` (~12 strings E2) | — (independiente) |

### Notas de auditoría

1. **CA-06.01 (captura de 3 datos) se resuelve con 3 campos en E2.** OutlinedTextField "Peso (Kg)" + OutlinedTextField "Repeticiones" / "Segundos sostenidos" + Selector RIR (6 chips). Los 3 son obligatorios — el botón "Confirmar" se deshabilita hasta que todos tengan valor válido.
2. **CA-06.02 (máximo 3 toques) se cumple con precarga.** Con peso precargado: (1) reps, (2) RIR chip, (3) Confirmar. Sin precarga (primera sesión): 4 toques, aceptable dado la ausencia de historial.
3. **CA-06.03 (teclado numérico) se cumple via `keyboardType`.** Peso: `KeyboardType.Decimal` (permite decimales). Repeticiones/Segundos: `KeyboardType.Number` (solo enteros). RIR: chips de selección directa, no requiere teclado.
4. **CA-06.04 (precarga último peso) se cumple via `getLastWeightForExercise()`.** Query cross-session que busca la última serie del ejercicio. Retorna `null` si sin historial → campo vacío. Para bodyweight/isometric → value fijo `"0"`.
5. **CA-06.05 a CA-06.07 (validaciones) cubiertos con doble capa.** Validación en tiempo real en ViewModel (feedback inmediato) + validación en UseCase `require()` (última línea de defensa). Room no soporta CHECK constraints nativamente — la protección de BD se limita a UNIQUE y FK constraints. El UseCase es la barrera de integridad de datos.
6. **CA-06.08 (metadatos automáticos) se cumple por estructura relacional.** La cadena `exercise_set → session_exercise → session → module_version` proporciona fecha, módulo, versión, ejercicio y número de serie sin input del ejecutante.
7. **CA-06.09 (secuencia 1-2-3-4) se cumple con `COUNT(*) + 1`.** Dentro de transacción para evitar race conditions. UNIQUE constraint como safety net. Validación `<= 4` antes de INSERT.
8. **CA-06.10 (orden libre) se cumple por diseño.** Cada ejercicio es independiente — no hay secuencia forzada entre ejercicios ni entre series de distintos ejercicios.
9. **CA-06.11 (vinculación al sustituto) se cumple automáticamente.** `session_exercise.exercise_id` ya apunta al ejercicio efectivamente ejecutado tras sustitución (HU-07).
10. **CA-06.12 (estado visual) ya implementado en HU-05.** El Flow reactivo de Room actualiza E1 tras cada INSERT en `exercise_set` vía subquery COUNT. No requiere trabajo adicional.
11. **CA-06.13 (preservación ante cierre) se cumple por Room.** INSERT atómico en `withTransaction`. Datos persistidos inmediatamente tras commit. Crash recovery de B1 (HU-05) detecta sesión `IN_PROGRESS` y permite reanudar.
12. **RNF02 (3 toques) implementado via precarga + chips.** Flujo óptimo: reps → RIR chip → Confirmar = 3 toques.
13. **RNF03 (teclado numérico) implementado via `keyboardType`.** No se muestra teclado alfanumérico en ningún campo.
14. **RNF04 (precarga peso) implementado via `getLastWeightForExercise()`.** Cross-session, busca por exercise_id.
15. **RNF10 (crash recovery) cubierto por Room + HU-05 B1 Card "Reanudar".** Series ya registradas se preservan. Sesión `IN_PROGRESS` se detecta al reabrir.
16. **RNF12 (validación rangos) cubierto en 2 capas:** UI (validación RT en ViewModel) → UseCase (`require()`, última línea de defensa). Room no genera CHECK constraints — UNIQUE y FK constraints proporcionan integridad estructural.

### Riesgos y mitigaciones

| Riesgo | Probabilidad | Impacto | Mitigación |
|---|---|---|---|
| Condición de carrera en asignación de `set_number` (doble-tap rápido) | Baja | Alto | `database.withTransaction {}` serializa accesos. `UNIQUE(session_exercise_id, set_number)` como safety net. UI deshabilita botón via `isSaving = true` |
| LEFT JOIN `plan_assignment` falla con ejercicio sustituido (HU-07 futuro) | Nula en HU-06 | Alto en HU-07 | LEFT JOIN + `COALESCE(pa.sets, 4)` protege. En HU-06 no hay sustituciones |
| Registro de serie 5+ por error de lógica | Baja | Alto | Validación en repository (`nextSetNumber <= 4`). `CHECK(set_number >= 1 AND set_number <= 4)` en BD. UI no muestra "Registrar" en ejercicios COMPLETED |
| Pérdida de datos entre confirm y persist (crash) | Baja | Medio | Room transacción atómica: o se persiste todo o nada. No hay estado intermedio |
| Precarga del peso retorna valores del ejercicio en otra sesión | Esperado | Nulo | Comportamiento correcto por diseño: el peso del ejercicio es cross-session (CA-06.04) |
| El ejecutante mata la app antes de navegar back a E1 tras confirmar | Baja | Nulo | La serie ya está persistida (transacción committed). Al reabrir, B1 detecta sesión activa → E1 muestra la serie registrada |

### Verificación cruzada de CAs

| CA | Mecanismo de cumplimiento | Verificado contra |
|---|---|---|
| CA-06.01 | 3 campos obligatorios en E2: Peso, Reps/Segundos, RIR | Wireframes E2, Especificación Visual §8 E2, RF13 |
| CA-06.02 | Precarga peso + chips RIR = 3 toques (reps, chip, confirmar) | RNF02, Wireframes E2 §Comportamiento #7 |
| CA-06.03 | `keyboardType = Decimal/Number` en OutlinedTextField | RNF03, Especificación Visual §8 E2 |
| CA-06.04 | `getLastWeightForExercise()` cross-session | RNF04, Wireframes E2 #4 "Precargado con último peso" |
| CA-06.05 | `require(weightKg >= 0)` + CHECK en BD | RNF12, Modelo de Datos §3.12 |
| CA-06.06 | `require(reps >= 1)` + CHECK en BD | RNF12, Modelo de Datos §3.12 |
| CA-06.07 | Chips 0-5 (imposible seleccionar fuera de rango) + `require(rir in 0..5)` | RNF12, Modelo de Datos §3.12 |
| CA-06.08 | Relación `exercise_set → session_exercise → session → module_version` | MDS §5.A.5, RF14, Modelo de Datos §3.12 nota metadatos |
| CA-06.09 | `COUNT(*) + 1` en transacción + UNIQUE constraint | Modelo de Datos §3.12, RF15 |
| CA-06.10 | Botón "Registrar" independiente por ejercicio en E1 | Wireframes E1 #7, MDS §5.A.3 "el orden que decida" |
| CA-06.11 | `session_exercise.exercise_id` = ejercicio efectivo tras sustitución (HU-07) | Modelo de Datos §3.11, MDS §5.A.4 |
| CA-06.12 | `completedSets` derivado via COUNT subquery en E1 (HU-05 existente) | Modelo de Datos §3.11 "no se almacena — se deriva", RF17 |
| CA-06.13 | Room INSERT atómico + crash recovery B1 | RNF10, Modelo de Datos §3.12 "inmutable tras creación" |

---

## Refinamiento Técnico (Developer)

<!-- SECCIÓN AGREGADA POR: Workflow refinamiento-tecnico -->
<!-- ETAPA: Refinamiento Técnico -->
<!-- RESPONSABLE: Developer -->
<!-- BASE: Análisis Arquitectónico (Arquitecto) - Ver sección arriba -->
<!-- FECHA: 2026-02-14 -->
<!-- ESTADO: Listo para Desarrollo -->
<!-- AUDITORÍA: Completada 2026-02-14 — SEGUNDA AUDITORÍA EXHAUSTIVA: cruce archivo-por-archivo contra TODA la documentación + 32 HUs + código implementado.

DIMENSIONES AUDITADAS (10):
- A. Modelo de Datos §3.4/§3.6/§3.7/§3.10/§3.11/§3.12/§3.13/§3.15: 79/79 checks PASS. SQL queries, column names, types, FKs, UNIQUE, indices — todo verificado.
- B. Especificación Visual §8 E2 + §7.6: Componentes M3, tipografía, colores hex, dimensiones dp — todo correcto. 1 desviación LOW documentada (keyboardType Decimal vs Number para peso, Nota Técnica #10).
- C. Wireframes E2: 8/8 elementos + 3 variantes + navegación E1↔E2 — todo cubierto.
- D. Arquitectura Técnica §3.2/§4.3/§4.4/§4.5.1/§4.6/§4.7/§5.1-§5.4/§5.7: Paquetes, rutas, session-graph, bottom nav, top bar, naming — todo correcto.
- E. ADRs: D-03/D-05/ADR-05/ADR-18 + 11 ADRs adicionales verificados — todo conforme.
- F. Requerimientos: RF13/RF14/RF15/RF17/RF22/RNF02/RNF03/RNF04/RNF06/RNF10/RNF12 — todo cubierto.
- G. Manifiesto de Dominio Sistémico §5.A.5/§4.B.1/§4.C.5/§4.C.7/§7.A.2 — todo alineado.
- H. Mapa de Navegación §E2 catálogo + transiciones + dirección + mermaid — todo correcto.
- I. Plan de Entrenamiento: 4 series, 30-45 seg isométricos, 8-12 reps — todo compatible.
- J. Código implementado (HU-01 a HU-05): 17 archivos, 15/17 claims TRUE, 2 corregidos (ver abajo).

CROSS-CHECK 32 HUs:
- HU-01 a HU-16: 16/16 PASS (HU-05 handoff 7/7 stubs addressed, HU-08 4/4 registration CAs verified, HU-07 LEFT JOIN forward-compat verified)
- HU-17 a HU-32: 14 PASS + 2 INFO (HU-17 deload precarga documented, HU-20 añadida a refs)

CORRECCIONES APLICADAS EN ESTA AUDITORÍA (2 MEDIUM + 6 LOW):
(M1) Domain require() messages cambiados de español a inglés per §5.7 — Los UseCase existentes (CreateExerciseUseCase, AssignExerciseToVersionUseCase) usan inglés; HU-06 ahora también.
(M2) Eliminadas referencias falsas a "BD CHECK constraints" — Room no genera CHECK constraints nativamente. Validación corregida a 2 capas (UI + UseCase) en lugar de 3. UNIQUE + FK constraints siguen existiendo a nivel BD.
(L1) Referencia MDS §7.7 corregida — no existe, el contenido correcto está en §6.B.7 (restricción reps ≥ 1) y §4.C.7.
(L2) "inyecta 6 DAOs" corregido a "6 parámetros (5 DAOs + TensionDatabase)".
(L3) "158 líneas" corregido a "164 líneas" en SessionRepositoryImpl.
(L4) Agregadas HU-20 (tonelaje via exercise_set), HU-21 (RIR promedio), HU-27 (alertas RIR) a lista de HUs futuras dependientes.
(L5) Conteo de strings ~12 vs ~16 — sección developer es autoritativa con 16 strings correctas (auditoría anterior).
(L6) Ejemplo de formateo de peso corregido a String.format("%.1f") por consistencia visual (auditoría anterior).

RESULTADO FINAL: 0 HIGH, 0 MEDIUM (2 corregidos), 1 LOW documentada (keyboardType Decimal), 6 LOW corregidas. -->

### Consideraciones Generales

**Basado en análisis arquitectónico:**
Análisis Arquitectónico de HU-06 con 9 hitos, ~8 componentes nuevos/modificados, 6 riesgos identificados. Patrón MVVM con capa Domain explícita (ADR-05). Sexta historia — primera historia de captura de datos transaccional. Introduce el formulario E2 (Registro de Serie) con 3 variantes (estándar, peso corporal, isométrico), validación en 2 capas (UI + UseCase `require()`), transacción atómica para asignación secuencial de número de serie, y precarga cross-session del último peso utilizado.

**Nivel de complejidad:**
MEDIA — No introduce entidades nuevas (las 4 tablas de sesión ya existen desde HU-05). Modifica 3 DAOs existentes (agregar métodos), extiende `SessionRepository`/`SessionRepositoryImpl` con 2 métodos nuevos y 2 DAOs inyectados, crea 1 modelo de dominio, 2 Use Cases, 1 pantalla (E2) con ViewModel y UiState, 1 ruta de navegación, y ~16 strings. La complejidad reside en: (a) la transacción atómica de registro con asignación secuencial, (b) las 3 variantes del formulario, y (c) la validación en tiempo real con feedback inmediato.

**Riesgos técnicos conocidos:**

1. Condición de carrera en asignación de `set_number` (doble-tap rápido) — `database.withTransaction {}` serializa accesos. `UNIQUE(session_exercise_id, set_number)` como safety net. UI deshabilita botón via `isSaving = true`.
2. LEFT JOIN `plan_assignment` falla con ejercicio sustituido (HU-07 futuro) — LEFT JOIN + `COALESCE(pa.sets, 4)` protege. En HU-06 no hay sustituciones.
3. Registro de serie 5+ por error de lógica — Validación en repository (`nextSetNumber <= 4`). `CHECK(set_number >= 1 AND set_number <= 4)` en BD. UI no muestra "Registrar" en ejercicios COMPLETED (HU-05 ya implementado).
4. Precarga retorna peso de sesión de descarga (HU-17 futuro) — Comportamiento intencionado per CA-06.04 ("último peso utilizado"). Si HU-17 requiere cambio, se modifica la query sin cambiar la interfaz.
5. Pérdida de datos entre confirm y persist (crash) — Room transacción atómica: o se persiste todo o nada.

**Patrones y convenciones del equipo (establecidos en HU-01—HU-05):**

- Código fuente en inglés, UI y datos de dominio en español (Arquitectura Técnica §5.1)
- Naming: `{Feature}Screen`, `{Feature}ViewModel`, `{Acción}{Entidad}UseCase`, `{Entidad}Entity`, `{Entidad}Dao` (§5.2)
- Estructura Composable: `hiltViewModel()` + `collectAsStateWithLifecycle()` + `LaunchedEffect` para eventos oneshot (§5.3)
- Estructura ViewModel: `_uiState MutableStateFlow` / `uiState StateFlow` + `MutableSharedFlow` para eventos de navegación (§5.4)
- `operator fun invoke()` en Use Cases
- Callbacks en Composables con prefijo `on` (`onNavigateBack`)
- Data classes intermedias de query en archivos DAO (patrón `SessionExerciseWithDetails`, `ActiveSessionInfo`)

**Dependencias nuevas a instalar:**
Ninguna. Todas las APIs necesarias (Room, Hilt, Compose Navigation, Material3, Coroutines) ya están en el proyecto.

**Estrategia de testing:**
JUnit 4 (ADR-18) + MockK + kotlinx-coroutines-test | Tests unitarios para los 2 Use Cases (domain): `GetRegisterSetInfoUseCase`, `RegisterSetUseCase` | Cobertura: 100% Use Cases

### Historias Relacionadas Consultadas

**Implementaciones similares analizadas:**
- HU-05 — `SessionRepositoryImpl.startSession()` con transacción atómica `database.withTransaction {}` (patrón reutilizado para `registerSet()`). `ActiveSessionViewModel` con `SavedStateHandle` para recibir `sessionId` (patrón reutilizado para `RegisterSetViewModel` con `sessionExerciseId`). `SessionExerciseDao` con query JOIN multi-tabla y data class intermedia `SessionExerciseWithDetails` (patrón reutilizado para `SetExerciseInfo`).
- HU-04 — `PlanVersionDetailViewModel` con `SavedStateHandle` como referencia para recepción de argumentos de navegación.
- HU-03 — `ExerciseDao` con `@Insert(onConflict = OnConflictStrategy.IGNORE)` no usado directamente, pero el patrón `IGNORE` se aplica a `ExerciseProgressionDao.insertIfNotExists()`.

**Patrones de código reutilizados:**

- `database.withTransaction { }` de `SessionRepositoryImpl.startSession()` → reutilizado en `SessionRepositoryImpl.registerSet()`
- `SavedStateHandle` de `ActiveSessionViewModel` → reutilizado en `RegisterSetViewModel`
- `MutableSharedFlow<Boolean>(replay = 0)` para evento oneshot de navegación back → patrón de `HomeViewModel.navigationEvent` adaptado
- Data class intermedia en DAO (`SessionExerciseWithDetails`) → patrón reutilizado para `SetExerciseInfo`
- `showBottomBar` exclusión por prefijo → se extiende para prefijo `"register-set"`

**HUs futuras que dependen de artefactos de HU-06:**

- HU-07: Sustitución → LEFT JOIN en `getExerciseInfoForSet()` con `COALESCE(pa.sets, 4)` ya prepara E2 para ejercicios sustituidos
- HU-08: Peso corporal/isométricos → CAs de registro (CA-08.01, CA-08.04, CA-08.05, CA-08.08) cubiertos completamente en E2. CAs de progresión (CA-08.02, CA-08.03, CA-08.06, CA-08.07) son de HU-10/HU-11
- HU-09: Cerrar sesión → lee `exercise_set` para determinar estado completado vs incompleto
- HU-10: Clasificación de progresión → lee `exercise_set` para calcular promedios peso/reps/RIR
- HU-11: Doble Umbral → lee `exercise_set` para verificar condiciones de progresión, escribe `exercise_progression.prescribed_load_kg`
- HU-12: Detección de regresión → lee `exercise_set` (weight_kg, reps, rir) para comparar contra historial
- HU-13: Resumen post-sesión → lee `exercise_set` para calcular tonelaje y promedios
- HU-17: Descarga → lee `exercise_set.weight_kg` para calcular 60% (carga descarga) y 90% (carga reinicio)
- HU-20: KPIs de volumen por grupo muscular → lee `exercise_set` (weight_kg × reps) para tonelaje acumulado semanal
- HU-21: KPIs de intensidad → lee `exercise_set.rir` para RIR promedio
- HU-23: Historial de carga → lee `exercise_set` para historial completo por ejercicio
- HU-24: Historial de sesiones → lee `exercise_set` para detalle de series registradas
- HU-27: Alertas de RIR → lee `exercise_set.rir` para promedios por módulo

### Código existente verificado (HU-01 a HU-05 implementados)

| Componente | Archivo | Estado |
| --- | --- | --- |
| `ExerciseSetDao` | `data/local/dao/ExerciseSetDao.kt` | ✅ Existe — stub vacío (`@Dao interface ExerciseSetDao`). Se modifica: +3 métodos (`insert`, `getNextSetNumber`, `getLastWeightForExercise`) |
| `ExerciseSetEntity` | `data/local/entity/ExerciseSetEntity.kt` | ✅ Existe — 6 columnas (id, sessionExerciseId, setNumber, weightKg, reps, rir). UNIQUE(session_exercise_id, set_number). FK CASCADE. No se modifica |
| `SessionExerciseDao` | `data/local/dao/SessionExerciseDao.kt` | ✅ Existe — `insertAll()`, `getBySessionId()`, `getBySessionIdWithDetails()`. Se modifica: +1 método (`getExerciseInfoForSet`) + 1 data class (`SetExerciseInfo`) |
| `ExerciseProgressionDao` | `data/local/dao/ExerciseProgressionDao.kt` | ✅ Existe — `getByExerciseId()`, `insert()`, `update()`. Se modifica: +1 método (`insertIfNotExists`) |
| `ExerciseProgressionEntity` | `data/local/entity/ExerciseProgressionEntity.kt` | ✅ Existe — PK exerciseId, status default "NO_HISTORY", prescribedLoadKg nullable, sessionsWithoutProgression default 0. No se modifica |
| `SessionExerciseEntity` | `data/local/entity/SessionExerciseEntity.kt` | ✅ Existe — id, sessionId, exerciseId, originalExerciseId nullable, progressionClassification nullable. No se modifica |
| `SessionRepository` | `domain/repository/SessionRepository.kt` | ✅ Existe — 6 métodos. Se modifica: +2 métodos (`getRegisterSetInfo`, `registerSet`) |
| `SessionRepositoryImpl` | `data/repository/SessionRepositoryImpl.kt` | ✅ Existe — 164 líneas, 6 parámetros inyectados (5 DAOs + TensionDatabase). Se modifica: +2 métodos, +2 DAOs inyectados (`ExerciseSetDao`, `ExerciseProgressionDao`) |
| `NavigationRoutes` | `ui/navigation/NavigationRoutes.kt` | ✅ Existe — 14 constantes + 4 helper functions. Se modifica: +1 constante (`REGISTER_SET`) + 1 helper |
| `TensionNavHost` | `ui/navigation/TensionNavHost.kt` | ✅ Existe — 279 líneas. `onNavigateToRegisterSet = { /* TODO: HU-06 */ }` confirmado. Se modifica: wiring callback + nuevo composable entry + extensión `showBottomBar` |
| `ActiveSessionScreen` | `ui/session/ActiveSessionScreen.kt` | ✅ Existe — botón "Registrar" pasa `exercise.sessionExerciseId` via `onNavigateToRegisterSet`. No se modifica |
| `TensionDatabase` | `data/local/database/TensionDatabase.kt` | ✅ Existe — version 4, 14 entities, `exerciseSetDao()` ya expuesto. No se modifica |
| `DatabaseModule` | `di/DatabaseModule.kt` | ✅ Existe — `provideExerciseSetDao()` y `provideExerciseProgressionDao()` ya existen. No se modifica |
| `RepositoryModule` | `di/RepositoryModule.kt` | ✅ Existe — `bindSessionRepository()` ya existe. No se modifica |
| `strings.xml` | `res/values/strings.xml` | ✅ Existe — sin strings E2. Se modifica: +~16 strings |
| `PlanAssignmentEntity` | `data/local/entity/PlanAssignmentEntity.kt` | ✅ Existe — composite PK (moduleVersionId, exerciseId), sets, reps. No se modifica (se usa en query JOIN) |
| `showBottomBar` | `ui/navigation/TensionNavHost.kt` líneas 79-87 | ✅ Verificado — excluye `REGISTER`, `active-session`, y `exercise-detail` desde `active-session`. No excluye `register-set`. Se modifica: +exclusión |

---

## Tareas de Implementación (Developer)

### Fase 1: Data Layer — DAOs (3 modificaciones)

> Basado en Hito #1 del Análisis Arquitectónico

- [ ] **Modificar ExerciseSetDao** (+3 métodos) (AC: 06.06, 06.04, 06.09)
  - [ ] Convertir de stub vacío a DAO funcional. Agregar imports necesarios: `@Insert`, `@Query`, `ExerciseSetEntity`.
  - [ ] `@Insert suspend fun insert(set: ExerciseSetEntity): Long` — Persiste una serie individual. Retorna el `id` generado por autoincrement.
  - [ ] `@Query suspend fun getNextSetNumber(sessionExerciseId: Long): Int`:
    ```sql
    SELECT COUNT(*) + 1 FROM exercise_set
    WHERE session_exercise_id = :sessionExerciseId
    ```
    Calcula el próximo número de serie secuencial (CA-06.09). Si ya hay 4 series, retorna 5 — el repository lo valida como error.
  - [ ] `@Query suspend fun getLastWeightForExercise(exerciseId: Long): Double?`:
    ```sql
    SELECT es.weight_kg
    FROM exercise_set es
    INNER JOIN session_exercise se ON es.session_exercise_id = se.id
    WHERE se.exercise_id = :exerciseId
    ORDER BY es.id DESC
    LIMIT 1
    ```
    Query cross-session para precarga del último peso utilizado (CA-06.04, RNF04). `ORDER BY es.id DESC` usa el autoincrement monotónicamente creciente — la última serie insertada para un ejercicio dado será siempre la de mayor `id`. Retorna `null` si sin historial (primera sesión del ejercicio).
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/data/local/dao/ExerciseSetDao.kt`

- [ ] **Modificar SessionExerciseDao** (+1 método + 1 data class) (AC: 06.08)
  - [ ] **Definir `SetExerciseInfo`** como data class fuera de la interfaz (mismo patrón `SessionExerciseWithDetails`): `exerciseId: Long`, `exerciseName: String`, `isBodyweight: Int`, `isIsometric: Int`, `isToTechnicalFailure: Int`, `totalSets: Int`. **No es `@Entity`** — resultado intermedio de query JOIN.
  - [ ] `@Query suspend fun getExerciseInfoForSet(sessionExerciseId: Long): SetExerciseInfo?`:
    ```sql
    SELECT
        se.exercise_id AS exerciseId,
        e.name AS exerciseName,
        e.is_bodyweight AS isBodyweight,
        e.is_isometric AS isIsometric,
        e.is_to_technical_failure AS isToTechnicalFailure,
        COALESCE(pa.sets, 4) AS totalSets
    FROM session_exercise se
    INNER JOIN exercise e ON se.exercise_id = e.id
    INNER JOIN session s ON se.session_id = s.id
    LEFT JOIN plan_assignment pa ON pa.module_version_id = s.module_version_id
        AND pa.exercise_id = se.exercise_id
    WHERE se.id = :sessionExerciseId
    ```
    Usa LEFT JOIN para `plan_assignment` con `COALESCE(pa.sets, 4)` como protección ante ejercicios sustituidos (HU-07 futuro) donde `exercise_id` podría no existir en `plan_assignment` para ese `module_version_id`. El método es `suspend` (no Flow) porque es una consulta one-shot al abrir E2.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/data/local/dao/SessionExerciseDao.kt`

- [ ] **Modificar ExerciseProgressionDao** (+1 método) (AC: 06.08 — creación idempotente)
  - [ ] `@Insert(onConflict = OnConflictStrategy.IGNORE) suspend fun insertIfNotExists(progression: ExerciseProgressionEntity)` — Al registrar la primera serie de un ejercicio, se crea la fila `exercise_progression` con defaults (`status = "NO_HISTORY"`, `prescribedLoadKg = null`, `sessionsWithoutProgression = 0`). La PK es `exercise_id`, por lo tanto el IGNORE asegura idempotencia: si la fila ya existe (ejercicio con historial previo), no se modifica. Agregar import de `OnConflictStrategy`.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/data/local/dao/ExerciseProgressionDao.kt`

### Fase 2: Domain Layer — Model

> Basado en Hito #2 del Análisis Arquitectónico

- [ ] **Crear RegisterSetInfo** (AC: 06.01, 06.04)
  - [ ] Data class Kotlin puro. Campos:
    - `sessionExerciseId: Long` — ID del ejercicio-en-sesión. Usado para el INSERT.
    - `exerciseId: Long` — ID del ejercicio base. Usado para consultar último peso.
    - `exerciseName: String` — Nombre mostrado en el Top Bar de E2.
    - `currentSetNumber: Int` — Próximo número de serie a registrar (1-4). Calculado via `getNextSetNumber()`.
    - `totalSets: Int` — Siempre 4 en MVP. Viene del `COALESCE(pa.sets, 4)`.
    - `lastWeightKg: Double?` — Último peso utilizado para precarga (CA-06.04). `null` = sin historial → campo vacío. `0.0` = peso corporal/isométrico → campo fijo no editable.
    - `isBodyweight: Boolean` — Flag de peso corporal (CA-08.01).
    - `isIsometric: Boolean` — Flag de isométrico (CA-08.04, CA-08.05).
    - `isToTechnicalFailure: Boolean` — Flag de fallo técnico (informativo).
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/domain/model/RegisterSetInfo.kt`

### Fase 3: Domain Layer — Repository Interface (Modificación)

> Basado en Hito #3 del Análisis Arquitectónico

- [ ] **Modificar SessionRepository** (+2 métodos) (AC: 06.01-06.09)
  - [ ] Agregar import de `RegisterSetInfo`.
  - [ ] `suspend fun getRegisterSetInfo(sessionExerciseId: Long): RegisterSetInfo?` — Obtiene la información necesaria para poblar E2. Retorna `null` si `sessionExerciseId` no existe o si el ejercicio ya tiene 4 series (defensa contra argumento inválido o ejercicio completado). Método `suspend` (no Flow) porque es consulta one-shot al abrir E2.
  - [ ] `suspend fun registerSet(sessionExerciseId: Long, weightKg: Double, reps: Int, rir: Int)` — Ejecuta la transacción atómica de registro: calcula número de serie, INSERT en `exercise_set`, INSERT idempotente en `exercise_progression`. Lanza `IllegalStateException` si el ejercicio ya tiene 4 series (defensa en profundidad).
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/domain/repository/SessionRepository.kt`

### Fase 4: Domain Layer — Use Cases (2 nuevos)

> Basado en Hito #4 del Análisis Arquitectónico

- [ ] **Crear GetRegisterSetInfoUseCase** (AC: 06.01, 06.04)
  - [ ] Inyecta `SessionRepository`. `suspend operator fun invoke(sessionExerciseId: Long): RegisterSetInfo?`. Delega a `sessionRepository.getRegisterSetInfo(sessionExerciseId)`. Wrapper puro — mantiene consistencia con el patrón de Use Cases de HU-01 a HU-05.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/domain/usecase/session/GetRegisterSetInfoUseCase.kt`
  - [ ] Test unitario: verifica delegación, caso info encontrada, caso null (exercise no existe o completado). Archivo: `app/src/test/java/com/estebancoloradogonzalez/tension/domain/usecase/session/GetRegisterSetInfoUseCaseTest.kt`

- [ ] **Crear RegisterSetUseCase** (AC: 06.05, 06.06, 06.07, 06.08, 06.09)
  - [ ] Inyecta `SessionRepository`. `suspend operator fun invoke(sessionExerciseId: Long, weightKg: Double, reps: Int, rir: Int)`. Valida reglas de negocio y delega persistencia:
    ```kotlin
    require(weightKg >= 0) { "Weight must be >= 0" }
    require(reps >= 1) { "Reps must be >= 1" }
    require(rir in 0..5) { "RIR must be between 0 and 5" }
    sessionRepository.registerSet(sessionExerciseId, weightKg, reps, rir)
    ```
    La validación en el Use Case es la última línea de defensa (Arquitectura Técnica §5.7: mensajes de dominio en inglés, uso interno). La UI también valida en tiempo real con mensajes en español via `strings.xml`. La redundancia es intencional (principio Clean Architecture). El ViewModel mapea `IllegalArgumentException` del UC a strings localizados para la UI.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/domain/usecase/session/RegisterSetUseCase.kt`
  - [ ] Test unitario: verifica validación peso < 0 lanza `IllegalArgumentException`, reps < 1 lanza, rir fuera de 0-5 lanza, caso exitoso delega a repository. Archivo: `app/src/test/java/com/estebancoloradogonzalez/tension/domain/usecase/session/RegisterSetUseCaseTest.kt`

### Fase 5: Data Layer — Repository Implementation (Modificación)

> Basado en Hito #5 del Análisis Arquitectónico

- [ ] **Modificar SessionRepositoryImpl** (+2 métodos, +2 DAOs inyectados) (AC: 06.01-06.09)
  - [ ] **Agregar al constructor:** `private val exerciseSetDao: ExerciseSetDao` y `private val exerciseProgressionDao: ExerciseProgressionDao`. Ambos providers ya existen en `DatabaseModule` (creados en HU-05). El constructor pasa de 6 a 8 parámetros inyectados.
  - [ ] **Implementar `getRegisterSetInfo(sessionExerciseId: Long): RegisterSetInfo?`:**
    1. `val info = sessionExerciseDao.getExerciseInfoForSet(sessionExerciseId)`. Si `null` → retorna `null`.
    2. `val nextSetNumber = exerciseSetDao.getNextSetNumber(sessionExerciseId)`. Si `> totalSets` (normalmente 4) → retorna `null` (ejercicio ya completado, no se puede registrar más).
    3. Determina `lastWeightKg`:
       - Si `info.isBodyweight == 1` o `info.isIsometric == 1` → `0.0` (peso fijo no editable, CA-08.01).
       - Si no → `exerciseSetDao.getLastWeightForExercise(info.exerciseId)` (puede ser `null` si sin historial).
    4. Mapea a `RegisterSetInfo` convirtiendo flags `Int` → `Boolean`.
  - [ ] **Implementar `registerSet(sessionExerciseId: Long, weightKg: Double, reps: Int, rir: Int)`:**
    Ejecuta en `database.withTransaction {}`:
    1. `val nextSetNumber = exerciseSetDao.getNextSetNumber(sessionExerciseId)`.
    2. Obtiene `info = sessionExerciseDao.getExerciseInfoForSet(sessionExerciseId)`. Si `null` → lanza `IllegalStateException("Session exercise not found")`.
    3. Valida `nextSetNumber <= info.totalSets` (normalmente 4). Si no, lanza `IllegalStateException("Exercise already has maximum sets registered")`.
    4. INSERT: `exerciseSetDao.insert(ExerciseSetEntity(sessionExerciseId = sessionExerciseId, setNumber = nextSetNumber, weightKg = weightKg, reps = reps, rir = rir))`.
    5. INSERT idempotente: `exerciseProgressionDao.insertIfNotExists(ExerciseProgressionEntity(exerciseId = info.exerciseId))` con defaults. Si la fila ya existe, `IGNORE` la descarta silenciosamente.
    **¿Por qué la transacción es necesaria?** Los pasos 1-4 deben ser atómicos para evitar condiciones de carrera en la asignación de `nextSetNumber`. Sin transacción, dos llamadas rápidas podrían obtener el mismo `nextSetNumber` y violar el UNIQUE constraint `(session_exercise_id, set_number)`. La transacción serializa el acceso.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/data/repository/SessionRepositoryImpl.kt`

### Fase 6: UI Layer — State + ViewModel

> Basado en Hito #6 del Análisis Arquitectónico

#### 📦 UiState

- [ ] **Crear RegisterSetUiState** (AC: 06.01, 06.03, 06.04)
  - [ ] Data class:
    ```kotlin
    data class RegisterSetUiState(
        val isLoading: Boolean = true,
        val exerciseName: String = "",
        val currentSetNumber: Int = 1,
        val totalSets: Int = 4,
        val weightKg: String = "",
        val reps: String = "",
        val selectedRir: Int? = null,
        val isWeightEditable: Boolean = true,
        val isIsometric: Boolean = false,
        val isBodyweight: Boolean = false,
        val weightError: String? = null,
        val repsError: String? = null,
        val isSaving: Boolean = false,
    ) {
        val isConfirmEnabled: Boolean
            get() = selectedRir != null &&
                weightKg.isNotBlank() &&
                reps.isNotBlank() &&
                weightError == null &&
                repsError == null &&
                !isSaving
    }
    ```
    **Campos de texto como `String`:** Los campos `weightKg` y `reps` son `String` (no `Double`/`Int`) porque representan el texto del `OutlinedTextField`. El parseo a tipo numérico se realiza en `onConfirm()`. Esto permite que el usuario vea exactamente lo que escribió y reciba errores solo al intentar confirmar o durante la validación en tiempo real.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/ui/session/RegisterSetUiState.kt`

#### 📦 ViewModel

- [ ] **Crear RegisterSetViewModel** (AC: 06.01-06.09)
  - [ ] `@HiltViewModel`. Inyecta `GetRegisterSetInfoUseCase`, `RegisterSetUseCase`, `SavedStateHandle`.
  - **Session exercise ID:** `savedStateHandle.get<Long>("sessionExerciseId")` — extraído del argumento de navegación.
  - **Estado:** `private val _uiState = MutableStateFlow(RegisterSetUiState())` → `val uiState: StateFlow<RegisterSetUiState> = _uiState.asStateFlow()`.
  - **Evento de navegación back:** `private val _navigateBack = MutableSharedFlow<Boolean>(replay = 0)` → `val navigateBack = _navigateBack.asSharedFlow()`. Emite `true` cuando la serie se registra exitosamente. La UI observa con `LaunchedEffect` y navega back.
  - **`init`:** `viewModelScope.launch { }`. Obtiene `sessionExerciseId` del `SavedStateHandle`. Llama a `getRegisterSetInfoUseCase(sessionExerciseId)`. Si resultado `null` → permanece en loading (E2 no debería alcanzarse con ID inválido o ejercicio completado — E1 ya oculta el botón). Si resultado válido:
    - `exerciseName` ← `info.exerciseName`.
    - `currentSetNumber` ← `info.currentSetNumber`.
    - `totalSets` ← `info.totalSets`.
    - `isWeightEditable` ← `!info.isBodyweight && !info.isIsometric`.
    - `isIsometric` ← `info.isIsometric`.
    - `isBodyweight` ← `info.isBodyweight`.
    - `weightKg`:
      - Si bodyweight o isometric → `"0"` (fijo, CA-08.01).
      - Si `info.lastWeightKg != null` → formateado con 1 decimal fijo para consistencia visual (ej: `60.0` → `"60.0"`, `2.5` → `"2.5"`). Usar `String.format("%.1f", info.lastWeightKg)`. Se mantiene siempre 1 decimal porque las cargas se trabajan en incrementos de 2.5 Kg y el campo Weight es `REAL`.
      - Si `null` → `""` (vacío, sin historial).
    - `isLoading` ← `false`.
  - **`onWeightChanged(value: String)`:** Actualiza `_uiState` con `weightKg = value`. Valida:
    - Si vacío → `weightError = null` (no mostrar error hasta que intente confirmar).
    - Parsea a `Double`: si parseo falla → `weightError = null` (no mostrar error en edición intermedia — "1." es estado válido temporal).
    - Si parsea correctamente y `< 0` → `weightError` con mensaje de error de validación.
    - Si parsea correctamente y `>= 0` → `weightError = null`.
  - **`onRepsChanged(value: String)`:** Actualiza `_uiState` con `reps = value`. Valida:
    - Si vacío → `repsError = null`.
    - Parsea a `Int`: si parseo falla → `repsError = null`.
    - Si parsea correctamente y `< 1` → `repsError` con mensaje que depende de variante: si isométrico → mensaje de duración, si estándar → mensaje de repeticiones.
    - Si parsea correctamente y `>= 1` → `repsError = null`.
  - **`onRirSelected(rir: Int)`:** Actualiza `_uiState` con `selectedRir = rir`. Sin validación necesaria — los chips 0-5 garantizan rango válido por diseño (CA-06.07 se cumple por construcción).
  - **`onConfirm()`:** `viewModelScope.launch { }`:
    1. Parsea `weightKg.toDoubleOrNull()` y `reps.toIntOrNull()`. Si alguno falla, actualiza errores correspondientes y retorna.
    2. Si `selectedRir == null` → retorna (botón debería estar deshabilitado, pero defensa en profundidad).
    3. `_uiState.update { it.copy(isSaving = true) }` — deshabilita botón (protección anti-double-tap).
    4. `try { registerSetUseCase(sessionExerciseId, weight, parsedReps, selectedRir!!) }`.
    5. Si éxito: `_navigateBack.emit(true)`.
    6. Si `IllegalArgumentException` (validación del UC): actualiza errores en UI según el mensaje de la excepción.
    7. Si `IllegalStateException` ("Exercise already has maximum sets registered"): `_navigateBack.emit(true)` — graceful: retorna a E1 donde el estado ya refleja completado.
    8. `finally { _uiState.update { it.copy(isSaving = false) } }` — reestablece por si hubo error no terminal.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/ui/session/RegisterSetViewModel.kt`

### Fase 7: UI Layer — Screen E2

> Basado en Hito #7 del Análisis Arquitectónico

- [ ] **Crear RegisterSetScreen** (AC: 06.01-06.09, CA-08.01, CA-08.04, CA-08.05)
  - [ ] Composable de nivel pantalla. Firma:
    ```kotlin
    @Composable
    fun RegisterSetScreen(
        onNavigateBack: () -> Unit,
        viewModel: RegisterSetViewModel = hiltViewModel(),
    )
    ```
  - Recolecta `uiState` con `collectAsStateWithLifecycle()`. Recolecta `navigateBack` en `LaunchedEffect`:
    ```kotlin
    LaunchedEffect(Unit) {
        viewModel.navigateBack.collect { success ->
            if (success) onNavigateBack()
        }
    }
    ```
  - Estructura según Wireframes E2 y Especificación Visual §8 E2:
    - **Top Bar:** `CenterAlignedTopAppBar` (M3) (Arquitectura Técnica §4.6: "Center Aligned con cierre" para E2).
      - `navigationIcon`: `IconButton` con `Icons.Default.Close` (✕), tint On Surface. `onClick = onNavigateBack` (descarta sin registrar, equivalente a "Cancelar", Wireframes E2 #1).
      - `title`: `Column(horizontalAlignment = Alignment.CenterHorizontally)` con:
        - `Text(uiState.exerciseName)` — Title Large, On Surface (Wireframes E2 #2).
        - `Text(stringResource(R.string.register_set_title_format, uiState.currentSetNumber, uiState.totalSets))` — Title Small, On Surface Variant (Wireframes E2 #3: "Serie N de 4").

    - **Body:** `Column` con padding horizontal 16 dp, spacing vertical 16 dp. Dentro de un `Scaffold(topBar = ...)` con `contentPadding` aplicado.

      - **Campo "Peso (Kg)"** (Wireframes E2 #4, Especificación Visual §8 E2):
        - **Variante estándar** (`isWeightEditable == true`): `OutlinedTextField`.
          - `value = uiState.weightKg`.
          - `onValueChange = { viewModel.onWeightChanged(it) }`.
          - `label = { Text(stringResource(R.string.register_set_weight_label)) }` — "Peso (Kg)".
          - `trailingIcon = { Text(stringResource(R.string.register_set_weight_suffix), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant) }` — "Kg".
          - `keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal)` — **`Decimal`** (no `Number`) porque `weight_kg` es `REAL (Double)` y las cargas usan incrementos de 2.5 Kg. Muestra teclado con separador decimal.
          - `isError = uiState.weightError != null`.
          - `supportingText` = si `weightError != null` → `Text(weightError, color = MaterialTheme.colorScheme.error)`.
          - Borde: Outline default → Primary al focus (comportamiento nativo M3 `OutlinedTextField`).
          - `singleLine = true`.
        - **Variante peso corporal** (`isBodyweight == true`): misma estructura pero:
          - `enabled = false`.
          - `value = "0"`.
          - `label = { Text(stringResource(R.string.register_set_weight_bodyweight_label)) }` — "Peso (Kg) (Peso corporal)".
          - Fondo visual al estar disabled: `Surface Container Highest (#EDE0D5)` con opacity 0.5. **Nota:** El color de fondo disabled de `OutlinedTextField` M3 en tema custom ya aplica Surface Container por defecto. Si el color no coincide, usar `colors = OutlinedTextFieldDefaults.colors(disabledContainerColor = ...)` para sobrescribir.
          - Texto: On Surface Variant.
        - **Variante isométrico** (`isIsometric == true`): misma estructura que peso corporal pero:
          - `label = { Text(stringResource(R.string.register_set_weight_isometric_label)) }` — "Peso (Kg) (Isométrico)".

      - **Campo "Repeticiones" / "Segundos sostenidos"** (Wireframes E2 #5, Especificación Visual §8 E2):
        - **Variante estándar y peso corporal** (`isIsometric == false`): `OutlinedTextField`.
          - `value = uiState.reps`.
          - `onValueChange = { viewModel.onRepsChanged(it) }`.
          - `label = { Text(stringResource(R.string.register_set_reps_label)) }` — "Repeticiones".
          - `trailingIcon = { Text(stringResource(R.string.register_set_reps_suffix), ...) }` — "reps".
          - `keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)` — solo dígitos, sin decimal.
          - `isError = uiState.repsError != null`.
          - `supportingText` = si `repsError != null` → error text.
          - `singleLine = true`.
        - **Variante isométrico** (`isIsometric == true`): misma estructura pero:
          - `label = { Text(stringResource(R.string.register_set_seconds_label)) }` — "Segundos sostenidos".
          - `trailingIcon = { Text(stringResource(R.string.register_set_seconds_suffix), ...) }` — "seg".
          - `supportingText` siempre visible (no solo en error): si `repsError != null` → error text. Si no → `Text(stringResource(R.string.register_set_seconds_reference), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)` — "(Referencia: 30–45 seg)" (CA-08.05).

      - **Selector RIR** (Wireframes E2 #6, Especificación Visual §7.6):
        - `Column`:
          - `Text(stringResource(R.string.register_set_rir_label))` — "RIR" en Label Medium, On Surface Variant.
          - Spacer(8 dp).
          - `Row(horizontalArrangement = Arrangement.spacedBy(8.dp))`:
            - Para cada `rir in 0..5`:
              - `Box` circular 48×48 dp (RNF06).
                - Si `rir == uiState.selectedRir` (seleccionado): `background = Primary (#8B1A1A)`, sin borde, `Text("$rir", color = On Primary (#FFFFFF))`.
                - Si `rir != uiState.selectedRir` (no seleccionado): `background = Surface Container (#F8EBE0)`, `border = BorderStroke(1.dp, MaterialTheme.colorScheme.outline)`, `Text("$rir", color = On Surface)`.
              - `Modifier.clip(CircleShape).clickable { viewModel.onRirSelected(rir) }`.
              - `semantics { contentDescription = "RIR $rir" }` para accesibilidad.
        - Single select. Sin precarga (`selectedRir` empieza como `null`).

      - **Botón "Confirmar"** (Wireframes E2 #7, Especificación Visual §8 E2):
        - `Button(onClick = { viewModel.onConfirm() }, modifier = Modifier.fillMaxWidth(), enabled = uiState.isConfirmEnabled)`.
        - `containerColor = Primary`, `contentColor = On Primary`. Height: minimo 48 dp por RNF06.
        - Margin top: 24 dp (Spacer antes del botón).
        - Texto: `stringResource(R.string.register_set_confirm)` — "Confirmar".

      - **"Cancelar"** (Wireframes E2 #8, Especificación Visual §8 E2):
        - `TextButton(onClick = onNavigateBack, modifier = Modifier.align(Alignment.CenterHorizontally))`.
        - Color: Primary.
        - Texto: `stringResource(R.string.register_set_cancel)` — "Cancelar".
        - Descarta sin cambios → retorna a E1.

    - **Sin Bottom Navigation** (Arquitectura Técnica §4.5.1: E2 siempre oculta).
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/ui/session/RegisterSetScreen.kt`

### Fase 8: Navigation + Strings

> Basado en Hitos #8 y #9 del Análisis Arquitectónico

#### 📦 NavigationRoutes

- [ ] **Agregar ruta REGISTER_SET** (AC: 06.06)
  - [ ] Agregar constante: `const val REGISTER_SET = "register-set/{sessionExerciseId}"` (Arquitectura Técnica §4.3 ruta #10).
  - [ ] Agregar helper: `fun registerSetRoute(sessionExerciseId: Long) = "register-set/$sessionExerciseId"`.
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/ui/navigation/NavigationRoutes.kt`

#### 📦 TensionNavHost

- [ ] **Actualizar NavHost** (AC: 06.06)
  - [ ] **Wiring del callback** en composable `ACTIVE_SESSION`: reemplazar `onNavigateToRegisterSet = { /* TODO: HU-06 */ }` por:
    ```kotlin
    onNavigateToRegisterSet = { sessionExerciseId ->
        navController.navigate(NavigationRoutes.registerSetRoute(sessionExerciseId))
    }
    ```
  - [ ] **Nuevo composable entry:**
    ```kotlin
    composable(
        route = NavigationRoutes.REGISTER_SET,
        arguments = listOf(navArgument("sessionExerciseId") { type = NavType.LongType }),
    ) {
        RegisterSetScreen(
            onNavigateBack = { navController.popBackStack() },
        )
    }
    ```
  - [ ] **Extender lógica `showBottomBar`:** La condición actual excluye `REGISTER`, `active-session`, y `exercise-detail` desde `active-session`. Agregar exclusión para `register-set`:
    ```kotlin
    val showBottomBar = currentRoute != null &&
        currentRoute != NavigationRoutes.REGISTER &&
        !currentRoute.startsWith("active-session") &&
        !currentRoute.startsWith("register-set") &&
        !(currentRoute.startsWith("exercise-detail") &&
            navController.previousBackStackEntry?.destination?.route
                ?.startsWith("active-session") == true)
    ```
    Esto oculta la Bottom Nav en E2 (Arquitectura Técnica §4.5.1: E2 siempre oculta).
  - Archivo: `app/src/main/java/com/estebancoloradogonzalez/tension/ui/navigation/TensionNavHost.kt`

#### 📦 Strings

- [ ] **Actualizar strings.xml** (AC: 06.01)
  - [ ] **Agregar sección Register Set E2:**
    ```xml
    <!-- Register Set E2 -->
    <string name="register_set_title_format">Serie %1$d de %2$d</string>
    <string name="register_set_weight_label">Peso (Kg)</string>
    <string name="register_set_weight_bodyweight_label">Peso (Kg) (Peso corporal)</string>
    <string name="register_set_weight_isometric_label">Peso (Kg) (Isométrico)</string>
    <string name="register_set_weight_suffix">Kg</string>
    <string name="register_set_reps_label">Repeticiones</string>
    <string name="register_set_reps_suffix">reps</string>
    <string name="register_set_seconds_label">Segundos sostenidos</string>
    <string name="register_set_seconds_suffix">seg</string>
    <string name="register_set_seconds_reference">(Referencia: 30\u201345 seg)</string>
    <string name="register_set_rir_label">RIR</string>
    <string name="register_set_confirm">Confirmar</string>
    <string name="register_set_cancel">Cancelar</string>
    <string name="error_weight_negative">El peso debe ser \u2265 0 Kg</string>
    <string name="error_reps_min">Las repeticiones deben ser \u2265 1</string>
    <string name="error_seconds_min">La duración debe ser \u2265 1 segundo</string>
    ```
  - Archivo: `app/src/main/res/values/strings.xml`

### Fase 9: QA y Deployment

#### 📦 Code Quality

- [ ] **Ejecutar Agente Peer Review** — MANUAL
- [ ] **Resolver incidentes del Peer Review** (condicional) — MANUAL

#### 📦 Deployment DEV

- [ ] **Crear Pull Request** — MANUAL
- [ ] **Ejecutar pipeline deployment DEV** — MANUAL

#### 📦 Testing Manual

- [ ] **Diseñar set de pruebas manuales** — MANUAL
- [ ] **Ejecutar pruebas manuales** — MANUAL

---

**Notas sobre vinculación con Criterios de Aceptación:**

- CA-06.01 → Fases 2, 6, 7 (RegisterSetInfo model + RegisterSetUiState 3 campos + RegisterSetScreen 3 inputs: Peso, Reps/Segundos, RIR)
- CA-06.02 → Fase 7 (peso precargado + chips RIR = flujo óptimo 3 toques: reps → chip → confirmar, RNF02)
- CA-06.03 → Fase 7 (`KeyboardType.Decimal` para peso, `KeyboardType.Number` para reps/segundos, chips directos para RIR, RNF03)
- CA-06.04 → Fases 1, 5, 6 (`ExerciseSetDao.getLastWeightForExercise()` cross-session → `RegisterSetInfo.lastWeightKg` → `weightKg` precargado en ViewModel, RNF04)
- CA-06.05 → Fases 4, 6, 7 (`RegisterSetUseCase: require(weightKg >= 0)` + `RegisterSetViewModel.onWeightChanged()` validación RT, RNF12). 2 capas: UI + UseCase
- CA-06.06 → Fases 4, 6, 7 (`RegisterSetUseCase: require(reps >= 1)` + `RegisterSetViewModel.onRepsChanged()` validación RT, RNF12). 2 capas: UI + UseCase
- CA-06.07 → Fases 4, 7 (Chips 0-5 garantizan rango por construcción + `RegisterSetUseCase: require(rir in 0..5)`, RNF12). 2 capas: UI + UseCase
- CA-06.08 → Fases 1, 5 (metadatos automáticos por cadena relacional: `exercise_set → session_exercise → session → module_version`, RF14, MDS §5.A.5)
- CA-06.09 → Fases 1, 5 (`ExerciseSetDao.getNextSetNumber()` COUNT(*)+1 + transacción atómica + UNIQUE constraint, RF15)
- CA-06.10 → Sin trabajo en HU-06 (ya implementado en HU-05: E1 botón "Registrar" independiente por ejercicio, RF15)
- CA-06.11 → Sin trabajo en HU-06 (se cumple automáticamente: `session_exercise.exercise_id` = ejercicio efectivo tras sustitución HU-07)
- CA-06.12 → Sin trabajo en HU-06 (ya implementado en HU-05: `completedSets` derivado via COUNT subquery en E1, RF17/RF22). Room invalida Flow reactivamente al INSERT en `exercise_set`
- CA-06.13 → Sin trabajo adicional en HU-06 (ya implementado por Room + HU-05 B1 Card "Reanudar". INSERT atómico en `withTransaction`, RNF10)
