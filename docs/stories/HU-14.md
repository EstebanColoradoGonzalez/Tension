# HU-14 ‚Äî Protocolo de Descarga y Conteo de Microciclos

## Requisitos relacionados

RF38, RF39, RF40, RF41

## Descripci√≥n

Como ejecutante, quiero poder activar un modo de descarga (Deload) que ajuste autom√°ticamente las cargas al 60%, mantenerlo durante un microciclo completo, que al finalizar el sistema calcule mis cargas de reinicio al 90%, y que el sistema lleve un conteo preciso de todos mis microciclos completados, para recuperar mi SNC y tejidos conectivos de forma estructurada, retomar el entrenamiento aprovechando la supercompensaci√≥n, y tener una referencia clara de cu√°ntos ciclos completos de entrenamiento llevo acumulados.

## Historias originales consolidadas

Esta historia consolida las siguientes historias del dise√±o original, que son funcionalmente inseparables (la descarga se mide en microciclos, y el conteo de microciclos incluye los de descarga):

- **HU-17 original** ‚Äî Activar y gestionar ciclo de descarga completo (RF38, RF39, RF40)
- **HU-18 original** ‚Äî Contar microciclos completados (RF41)

---

## Criterios de Aceptaci√≥n

### Bloque A ‚Äî Activaci√≥n y Gesti√≥n del Ciclo de Descarga (RF38, RF39, RF40)

#### CA-14.01 ‚Äî Activaci√≥n del modo Descarga

**Dado que** el sistema ha se√±alado que un m√≥dulo requiere descarga (HU-12) o el ejecutante decide proactivamente descargar,
**cuando** el ejecutante activa el modo de Descarga,
**entonces** el sistema ajusta los par√°metros de prescripci√≥n para todas las sesiones del per√≠odo de descarga: carga al 60% de la carga habitual de cada ejercicio, mantener 4 series por ejercicio, repeticiones en el l√≠mite inferior del rango (8), y RIR objetivo de 4-5.

#### CA-14.02 ‚Äî C√°lculo del 60% de carga por ejercicio

**Dado que** el modo de Descarga est√° activo,
**cuando** el sistema prescribe la carga para un ejercicio en una sesi√≥n de descarga,
**entonces** calcula el 60% de la √∫ltima carga de trabajo registrada para ese ejercicio, redondeando al incremento m√°s cercano disponible (2.5 Kg para tren superior, 5 Kg para tren inferior).

#### CA-14.03 ‚Äî Duraci√≥n del modo Descarga: 1 microciclo completo

**Dado que** el modo de Descarga est√° activo,
**cuando** el ejecutante completa sesiones durante la descarga,
**entonces** el modo se mantiene activo durante exactamente 1 microciclo completo (A-B-C-A-B-C = 6 sesiones), desactiv√°ndose autom√°ticamente al cerrar la sexta sesi√≥n del microciclo de descarga.

#### CA-14.04 ‚Äî Versi√≥n congelada durante la descarga

**Dado que** el modo de Descarga est√° activo,
**cuando** el sistema determina la versi√≥n del m√≥dulo para cada sesi√≥n de descarga,
**entonces** mantiene la misma versi√≥n que estaba activa al momento de activar la descarga para cada m√≥dulo respectivo; la secuencia de versiones no avanza durante el per√≠odo de descarga.

#### CA-14.05 ‚Äî C√°lculo de carga de reinicio post-descarga

**Dado que** el modo de Descarga ha finalizado tras completar el microciclo,
**cuando** el sistema calcula las cargas para el nuevo mesociclo,
**entonces** prescribe para cada ejercicio una carga de reinicio equivalente al 90% de la √∫ltima carga de trabajo pre-descarga, no el 90% de la carga de descarga.

#### CA-14.06 ‚Äî Redondeo de la carga de reinicio

**Dado que** el sistema calcula la carga de reinicio al 90%,
**cuando** el resultado no es un m√∫ltiplo exacto del incremento m√≠nimo (2.5 Kg o 5 Kg),
**entonces** redondea al incremento m√°s cercano disponible seg√∫n el m√≥dulo del ejercicio (redondeando hacia abajo para proteger al ejecutante).

#### CA-14.07 ‚Äî Indicaci√≥n visual del modo Descarga

**Dado que** el modo de Descarga est√° activo,
**cuando** el ejecutante visualiza la sesi√≥n o la prescripci√≥n,
**entonces** el sistema indica claramente que se est√° en per√≠odo de descarga, mostrando las cargas ajustadas y cu√°ntas sesiones restan para completar el microciclo de descarga.

#### CA-14.08 ‚Äî Transici√≥n al nuevo mesociclo

**Dado que** el modo de Descarga finaliza,
**cuando** el ejecutante inicia la primera sesi√≥n post-descarga,
**entonces** el sistema presenta las cargas de reinicio (90% pre-descarga) como cargas objetivo, la secuencia de versiones retoma su avance normal, y los estados de progresi√≥n de los ejercicios se actualizan de "En Descarga" al estado que corresponda seg√∫n los nuevos registros.

#### CA-14.09 ‚Äî Ejercicios de peso corporal e isom√©tricos durante descarga

**Dado que** el modo de Descarga est√° activo y la sesi√≥n incluye ejercicios de peso corporal o isom√©tricos,
**cuando** el sistema prescribe par√°metros de descarga,
**entonces** para ejercicios de peso corporal prescribe 8 repeticiones con RIR 4-5 (sin ajuste de carga porque Peso = 0), y para isom√©tricos prescribe 30 segundos con RIR 4-5.

### Bloque B ‚Äî Conteo de Microciclos (RF41)

#### CA-14.10 ‚Äî Incremento del contador al completar un microciclo

**Dado que** el ejecutante ha cerrado sesiones de entrenamiento,
**cuando** los 6 m√≥dulos de la rotaci√≥n (A-B-C-A-B-C) han sido ejecutados desde el √∫ltimo incremento,
**entonces** el sistema incrementa el conteo de microciclos completados en 1.

#### CA-14.11 ‚Äî Conteo basado en la rotaci√≥n, no en el calendario

**Dado que** el sistema lleva el conteo de microciclos,
**cuando** eval√∫a si un microciclo se ha completado,
**entonces** se basa exclusivamente en la secuencia de sesiones ejecutadas (6 m√≥dulos: A, B, C, A, B, C), independientemente de cu√°ntos d√≠as naturales haya tomado completarlos.

#### CA-14.12 ‚Äî Conteo persistente

**Dado que** el sistema ha registrado microciclos completados,
**cuando** la aplicaci√≥n se cierra, se reinicia el dispositivo o se actualiza la app,
**entonces** el conteo de microciclos persiste y se recupera correctamente al reabrir la aplicaci√≥n.

#### CA-14.13 ‚Äî Conteo durante per√≠odo de descarga

**Dado que** el modo de Descarga est√° activo (CA-14.01),
**cuando** el ejecutante completa las 6 sesiones del microciclo de descarga,
**entonces** el sistema incrementa el contador de microciclos igualmente, ya que un microciclo de descarga es un microciclo completo ejecutado.

#### CA-14.14 ‚Äî Consulta del conteo

**Dado que** el ejecutante desea conocer su progreso temporal,
**cuando** consulta el conteo de microciclos,
**entonces** el sistema muestra el n√∫mero total de microciclos completados desde el inicio del uso del sistema.

## An√°lisis Arquitect√≥nico (Arquitecto)

### Decisiones de Dise√±o

**Patr√≥n Arquitect√≥nico:** MVVM con orquestaci√≥n de dominio en m√∫ltiples capas ‚Äî entidad nueva + reglas puras + modificaci√≥n de flujos existentes (inicio/cierre de sesi√≥n, rotaci√≥n).

**Justificaci√≥n:** HU-14 es la historia m√°s transversal del sistema: introduce una entidad nueva (`deload`), crea dos reglas de dominio (`DeloadLoadRule` para c√°lculo de 60%/90%, redondeo), modifica el flujo de inicio de sesi√≥n (`startSession()` con `deloadId`), modifica el cierre de sesi√≥n (`closeSession()` con completaci√≥n de deload), modifica la rotaci√≥n (`advanceRotation()` con congelamiento de versiones), modifica la progresi√≥n (`evaluateProgression()` con transici√≥n IN_DELOAD ‚Üí IN_PROGRESSION post-deload), y a√±ade una pantalla nueva (I1). Su correcta implementaci√≥n es cr√≠tica porque un error en el flujo de descarga produce prescripciones de carga incorrectas que podr√≠an causar lesiones (sobreentrenamiento al no descargar, o p√©rdida de est√≠mulo por descarga eterna).

### Decisiones Fundamentadas

**1. HU-14 opera en tres fases temporalmente distintas: activaci√≥n ‚Üí ciclo ‚Üí finalizaci√≥n.**

La activaci√≥n (CA-14.01) crea un registro `deload` con estado ACTIVE y congela las versiones del momento. El ciclo (CA-14.03) dura 6 sesiones ‚Äî cada sesi√≥n se crea con `deload_id` apuntando al deload activo, las cargas se prescriben al 60% (CA-14.02), y la rotaci√≥n avanza posici√≥n pero NO versiones (CA-14.04). La finalizaci√≥n (CA-14.05) ocurre al cerrar la sexta sesi√≥n: el deload pasa a COMPLETED, las cargas se reinician al 90% de la carga pre-descarga (CA-14.06), y los estados de progresi√≥n de ejercicios se transicionan de `IN_DELOAD` a `IN_PROGRESSION` (CA-14.08). Estas tres fases se implementan en puntos de extensi√≥n diferentes del c√≥digo existente.

**2. `DeloadEntity` es una entidad nueva en la capa Data que persiste el ciclo de descarga.**

El Modelo de Datos ¬ß3.15 define la tabla `deload` con: `id`, `status` (ACTIVE/COMPLETED), `activation_date`, `completion_date`, `frozen_version_module_a/b/c`. El conteo de sesiones del deload **no se almacena** ‚Äî se calcula como `SELECT COUNT(*) FROM session WHERE deload_id = ? AND status IN ('COMPLETED', 'INCOMPLETE')`. Esto evita una columna derivada que requerir√≠a sincronizaci√≥n. Solo puede existir un deload con `status = 'ACTIVE'` a la vez.

**3. `DeloadLoadRule` es una funci√≥n pura en `domain/rules/` (ADR-06) con tres funciones.**

- `calculateDeloadLoad(lastWeightKg, loadIncrementKg)`: calcula 60% de la carga habitual, redondeado hacia abajo al incremento m√°s cercano. F√≥rmula: `floor(lastWeightKg * 0.60 / loadIncrementKg) * loadIncrementKg`.
- `calculateResetLoad(preDeloadWeightKg, loadIncrementKg)`: calcula 90% de la √∫ltima carga pre-descarga, redondeado hacia abajo. F√≥rmula: `floor(preDeloadWeightKg * 0.90 / loadIncrementKg) * loadIncrementKg`.
- Ambas funciones reciben `loadIncrementKg` como par√°metro (2.5 para m√≥dulos A/B, 5.0 para m√≥dulo C) ‚Äî ya disponible en `module.load_increment_kg` (HU-11 Decisi√≥n 4).
- Para ejercicios de peso corporal e isom√©tricos (`isBodyweight || isIsometric`): no se calcula carga de descarga ni reinicio, ya que `prescribed_load_kg` es siempre NULL para estos tipos (CA-14.09, Modelo de Datos ¬ß3.13).

**4. La "√∫ltima carga de trabajo habitual" se deriva de los datos existentes, no se almacena.**

Modelo de Datos ¬ß3.15: "La carga habitual de cada ejercicio antes de la descarga [...] se deriva consultando el √∫ltimo `exercise_set.weight_kg` registrado por ejercicio en sesiones anteriores a `activation_date` que no sean de descarga." La query busca `AVG(weight_kg)` de las series del ejercicio en la √∫ltima sesi√≥n no-deload antes de la activaci√≥n. Para la carga de reinicio (90% post-deload), se usa la misma referencia: la carga pre-descarga, no la carga de descarga. Esto se implementa como un DAO query `getPreDeloadAvgWeight(exerciseId, activationDate)`.

**5. `RotationResolver.advanceRotation()` se modifica para recibir `isDeload: Boolean`.**

HU-09 Decisi√≥n 6 anticip√≥ esta modificaci√≥n: *"Cuando HU-17 se implemente, `advanceRotation` recibir√° `isDeload: Boolean` adicional."* Cuando `isDeload = true` y `position == 6`:
- La posici√≥n vuelve a 1 (el microciclo de descarga se completa normalmente).
- `microcycleCount` se incrementa (CA-14.13: un microciclo de descarga cuenta como microciclo completado).
- Las versiones **NO avanzan** ‚Äî se mantienen iguales (CA-14.04: versiones congeladas durante descarga).

Cuando `isDeload = false`, el comportamiento permanece id√©ntico al actual (posici√≥n avanza, versiones rotan al completar posici√≥n 6). Los tests existentes de `RotationResolver` se mantienen v√°lidos para el caso `isDeload = false`.

**6. `startSession()` se modifica para pasar `deloadId` cuando hay deload activo.**

Actualmente, `startSession()` siempre crea `SessionEntity(deloadId = null)`. Con HU-14, antes de crear la sesi√≥n, se consulta `deloadDao.getActiveDeload()`. Si retorna un deload activo:
- `SessionEntity.deloadId` se asigna con el ID del deload activo.
- Las versiones para la sesi√≥n se toman de `deload.frozen_version_module_X`, no de `rotation_state.current_version_module_X` (CA-14.04). La resoluci√≥n del `moduleVersionId` debe usar las versiones congeladas.
- No se modifica la determinaci√≥n del m√≥dulo (la posici√≥n de la rotaci√≥n sigue avanzando normalmente).

**7. `closeSession()` se ampl√≠a con l√≥gica de finalizaci√≥n de deload.**

Cuando la sesi√≥n cerrada tiene `deloadId != null`, despu√©s de `evaluateProgression()` y `advanceRotation()`:
1. Contar sesiones del deload: `sessionDao.countDeloadSessions(deloadId)`.
2. Si el conteo == 6 (microciclo completo):
   a. Marcar deload como COMPLETED: `deloadDao.complete(deloadId, today)`.
   b. Para cada ejercicio est√°ndar (no bodyweight, no isometric) que tenga `exercise_progression.status == 'IN_DELOAD'`:
      - Obtener la carga pre-deload: `getPreDeloadAvgWeight(exerciseId, deload.activationDate)`.
      - Calcular carga de reinicio: `DeloadLoadRule.calculateResetLoad(preDeloadWeight, loadIncrementKg)`.
      - Actualizar `exercise_progression.prescribed_load_kg = resetLoad`.
      - Transicionar `exercise_progression.status` de `IN_DELOAD` a `IN_PROGRESSION`.
      - Resetear `sessions_without_progression = 0`.
   c. Resolver alertas: `alertDao.resolveByModuleAndType(moduleCode, "MODULE_REQUIRES_DELOAD", today)` para todos los m√≥dulos.

**8. La activaci√≥n del deload transiciona TODOS los ejercicios a estado `IN_DELOAD`.**

CA-14.01 dice "ajusta los par√°metros de prescripci√≥n para TODAS las sesiones del per√≠odo de descarga". Al activar el deload:
1. Se crea `DeloadEntity(status = ACTIVE, activationDate = hoy, frozenVersionA/B/C = rotation_state.current_version_module_a/b/c)`.
2. Se transicionan TODOS los ejercicios con estado != `NO_HISTORY` y != `MASTERED` a `IN_DELOAD`: `exerciseProgressionDao.transitionToDeload()`.
3. Se congela el `sessions_without_progression` (el contador no se resetea al activar ‚Äî se preserva para cuando el deload termine y se retome el tracking de meseta, pero esto es debatible: Regla 5 dice "post-descarga se reinicia" ‚Üí se resetea a 0 al finalizar, no al activar).

Esta transici√≥n es global (no por m√≥dulo) porque la descarga afecta a TODO el plan ‚Äî MDS R5: "Ejercicios: Mantener los mismos del plan."

**9. La pantalla I1 tiene 3 estados mutuamente excluyentes gestionados por `DeloadManagementUiState`.**

Wireframe I1 y Especificaci√≥n Visual ¬ßI1 definen 3 estados:
- **Estado A (Descarga requerida):** No hay deload activo pero existe alerta `MODULE_REQUIRES_DELOAD`. Muestra info del m√≥dulo afectado, protocolo detallado, bot√≥n "Activar Descarga".
- **Estado B (Descarga activa):** Deload activo con progreso N/6 sesiones. Barra de progreso, par√°metros vigentes, versiones congeladas.
- **Estado C (Post-descarga):** Deload reci√©n completado, primera visita post-deload. Muestra cargas de reinicio (90%) por ejercicio est√°ndar. Las versiones retoman avance normal.

Un cuarto estado impl√≠cito: **Sin descarga requerida ni activa** ‚Äî I1 no es accesible directamente (el card en B1 no se muestra y el enlace desde H2 no existe). Si el usuario llega por deep link, se muestra un mensaje "No hay descarga pendiente" con bot√≥n de retorno.

**10. El conteo de microciclos (Bloque B) ya est√° implementado.**

`RotationResolver.advanceRotation()` ya incrementa `microcycleCount` al cerrar posici√≥n 6 (HU-09). `GetMicrocycleCountUseCase` ya existe y `HomeUiState.microcycleCount` ya se muestra en B1. Los CAs 14.10-14.14 se satisfacen con la implementaci√≥n existente:
- CA-14.10: `advanceRotation()` ya incrementa al completar posici√≥n 6. ‚úÖ
- CA-14.11: La rotaci√≥n es agn√≥stica al calendario (MDS ¬ß6-B.9). ‚úÖ
- CA-14.12: Persistido en `rotation_state.microcycle_count` v√≠a Room. ‚úÖ
- CA-14.13: El deload s√≠ incrementa `microcycleCount` ‚Äî `advanceRotation(isDeload=true)` al llegar a posici√≥n 6 incrementa el contador. ‚úÖ (ya cubierto por Decisi√≥n 5).
- CA-14.14: `HomeScreen` ya muestra el contador. ‚úÖ

**No se requiere c√≥digo nuevo para el Bloque B.** Solo verificar que `advanceRotation(isDeload=true)` incrementa `microcycleCount` (nuevo test).

**11. La versi√≥n de la sesi√≥n durante deload usa las versiones congeladas del DeloadEntity.**

Cuando hay deload activo, la resoluci√≥n de versi√≥n debe usar `deload.frozen_version_module_X` en vez de `rotation_state.current_version_module_X`. Esto afecta dos puntos del c√≥digo:

- `SessionRepositoryImpl.getNextModuleVersionId()` (l√≠nea 56): actualmente usa `rotationStateDao.getRotationState()` para obtener las versiones. Con deload activo, debe consultar el deload activo y usar las versiones congeladas.
- `GetNextSessionInfoUseCase.invoke()`: tambi√©n usa `sessionRepository.getRotationState()` para resolver m√≥dulo/versi√≥n y pasarlos a `NextSession`. Con deload activo, debe usar las versiones congeladas del deload para resolver `versionNumber`.
- `startSession()`: el `moduleVersionId` que recibe ya viene resuelto por los dos puntos anteriores, por lo que solo necesita asignar `deloadId`.
- La resoluci√≥n del m√≥dulo (A/B/C) sigue usando `rotation_state.microcycle_position` ‚Äî la posici√≥n NO se congela, solo las versiones.

**12. `evaluateProgression()` durante deload NO ejecuta clasificaci√≥n ni actualizaci√≥n de progresi√≥n.**

El c√≥digo actual tiene `if (isDeloadSession) return` al inicio del bloque del m√≥dulo (HU-12: skip module-level detection during deload). Para HU-14, la l√≥gica debe extenderse: durante sesiones de deload, `evaluateProgression()` ejecuta la clasificaci√≥n individual per-exercise (para que `session_exercise.progression_classification` tenga valor para E5), pero NO actualiza `exercise_progression` (status, counter, prescribed_load_kg permanecen en IN_DELOAD). El guard `if (isDeloadSession)` se mueve del final (bloque m√≥dulo) al punto correcto: justo despu√©s de guardar la clasificaci√≥n, antes de actualizar `exercise_progression`.

Correcci√≥n: Actualmente `isDeloadSession` hace `return` al inicio del bloque post-loop (module-level detection, l√≠nea 442). Pero el loop s√≠ ejecuta todo incluyendo updateProgression. `ProgressionClassificationRule.resolveNewProgressionState()` (l√≠nea 48) tiene `if (currentStatus == "IN_DELOAD") return currentStatus to currentCounter` ‚Äî el estado y contador no cambian durante deload ‚úÖ. Sin embargo, `DoubleThresholdRule.prescribeLoad()` (l√≠neas 397-401) S√ç se ejecuta y sobreescribe `prescribed_load_kg` ‚Äî esto es incorrecto. Hay que agregar un guard: si `isDeloadSession`, preservar la `prescribed_load_kg` actual del `exerciseProgressionDao` en vez de recalcularla. Tambi√©n hay que proteger la gesti√≥n de alertas de meseta (l√≠neas 415-430): durante deload no deber√≠a crearse ni resolverse alertas PLATEAU porque el estado es IN_DELOAD y los ejercicios no est√°n progresando normalmente.

**13. El redondeo de carga de descarga/reinicio es hacia ABAJO (protector).**

CA-14.06: "redondea al incremento m√°s cercano disponible seg√∫n el m√≥dulo del ejercicio (redondeando hacia abajo para proteger al ejecutante)." Esto se implementa con `floor()` en `DeloadLoadRule`:
- 60% de 60 Kg = 36.0 Kg ‚Üí `floor(36.0 / 2.5) * 2.5 = 35.0 Kg` (m√≥dulo A/B, increment=2.5).
- 60% de 55 Kg = 33.0 Kg ‚Üí `floor(33.0 / 2.5) * 2.5 = 32.5 Kg`.
- 90% de 60 Kg = 54.0 Kg ‚Üí `floor(54.0 / 2.5) * 2.5 = 52.5 Kg`.
- 60% de 100 Kg = 60.0 Kg ‚Üí `floor(60.0 / 5.0) * 5.0 = 60.0 Kg` (m√≥dulo C, increment=5.0).
- 90% de 100 Kg = 90.0 Kg ‚Üí `floor(90.0 / 5.0) * 5.0 = 90.0 Kg`.

**14. Pantalla I1 usa `DeloadManagementViewModel` con `SavedStateHandle` y navegaci√≥n desde B1/H2.**

El ViewModel carga:
- Deload activo: `deloadDao.getActiveDeload()` (Flow reactivo).
- Si no hay deload activo, verificar si hay alerta `MODULE_REQUIRES_DELOAD` activa: `alertDao.getActiveModuleAlerts("MODULE_REQUIRES_DELOAD")`.
- Si hay deload completado reciente (√∫ltimo deload donde `completion_date == today` o las cargas prescribidas son post-deload): mostrar Estado C con cargas de reinicio.
- Acciones: `activateDeload()` lanza el UseCase `ActivateDeloadUseCase` que ejecuta la transacci√≥n de activaci√≥n.

La navegaci√≥n B1 ‚Üí I1 se habilita cuando el card "Estado de Descarga" es visible (deload activo o alerta MODULE_REQUIRES_DELOAD). Ruta: `deload-management` (sin par√°metros ‚Äî el estado se carga del deload activo/alertas).

**Componentes Afectados:**

**Componentes nuevos:**

| # | Componente | Capa | Responsabilidad |
|---|---|---|---|
| 1 | `DeloadEntity` | Data (entity) | Entidad Room para tabla `deload`: id, status, activation_date, completion_date, frozen_version_module_a/b/c |
| 2 | `DeloadDao` | Data (dao) | DAO Room: `insert()`, `getActiveDeload()` (Flow), `getActiveDeloadOnce()` (suspend), `complete()`, `getById()`, `countSessions()` |
| 3 | `DeloadLoadRule` | Domain (rules) | Funci√≥n pura: `calculateDeloadLoad()` (60% con redondeo down) y `calculateResetLoad()` (90% con redondeo down). ADR-06 |
| 4 | `ActivateDeloadUseCase` | Domain (usecase/deload) | Orquesta: crear DeloadEntity + transicionar ejercicios a IN_DELOAD + guardar versiones congeladas |
| 5 | `GetDeloadStateUseCase` | Domain (usecase/deload) | Lee estado de deload activo/completado + alertas MODULE_REQUIRES_DELOAD ‚Üí `DeloadState` |
| 6 | `DeloadState` | Domain (model) | Sealed interface: `NoDeloadNeeded`, `DeloadRequired(modules)`, `DeloadActive(progress, frozenVersions)`, `DeloadCompleted(resetLoads)` |
| 7 | `DeloadManagementViewModel` | UI (deload) | Carga estado v√≠a UseCase, acci√≥n `activateDeload()`, expone `StateFlow<DeloadManagementUiState>` |
| 8 | `DeloadManagementUiState` | UI (deload) | Sealed interface: `Loading`, `Content(deloadState)`, `Error(message)` |
| 9 | `DeloadManagementScreen` | UI (deload) | Composable I1: 3 estados (requerida/activa/post-descarga) + Bottom Navigation |

**Componentes modificados:**

| # | Componente | Modificaci√≥n | Nivel |
|---|---|---|---|
| 1 | `TensionDatabase` | Agregar `DeloadEntity` a entities, bump version a 6, agregar migration 5‚Üí6, agregar `deloadDao()` | Mayor |
| 2 | `SessionEntity` | Agregar FK constraint a `deload(id)` ahora que la tabla existe | Menor |
| 3 | `RotationResolver.advanceRotation()` | Agregar par√°metro `isDeload: Boolean = false`. Cuando `isDeload && position == 6`: posici√≥n‚Üí1, microcycleCount++, versiones NO avanzan | Mayor |
| 4 | `SessionRepositoryImpl.startSession()` | Consultar deload activo. Si existe: asignar `deloadId`, resolver `moduleVersionId` con versiones congeladas | Mayor |
| 5 | `SessionRepositoryImpl.closeSession()` | Pasar `isDeload` a `advanceRotation()`. Despu√©s de rotaci√≥n: si deload y conteo == 6 ‚Üí finalizar deload (COMPLETED, reset loads 90%, transicionar IN_DELOAD ‚Üí IN_PROGRESSION, resolver alertas) | Mayor |
| 6 | `SessionRepositoryImpl.evaluateProgression()` | Durante deload: mantener clasificaci√≥n per-exercise pero proteger `prescribed_load_kg` de recalculaci√≥n y saltar gesti√≥n de alertas PLATEAU. Guards: no prescribir carga + no crear/resolver alertas plateau durante deload | Medio |
| 7 | `SessionRepositoryImpl.getNextModuleVersionId()` | Consultar deload activo. Si existe: usar versiones congeladas para resoluci√≥n de moduleVersionId | Medio |
| 7b | `GetNextSessionInfoUseCase` | Consultar deload activo. Si existe: usar versiones congeladas para resoluci√≥n de versionNumber en NextSession | Medio |
| 7c | `ExerciseSetDao.getLastWeightForExercise()` | Excluir sesiones de deload del query para que la precarga E2 post-deload sea la carga pre-descarga (Nota 8, HU-06) | Menor |
| 8 | `SessionRepository` (interfaz) | Agregar `activateDeload()`, `getDeloadState()` | Menor |
| 9 | `HomeUiState` | Agregar `deloadState: DeloadHomeState?` (info m√≠nima para card B1) | Menor |
| 10 | `HomeViewModel` | Cargar estado de deload para card B1 (descarga activa + progreso, o m√≥dulo requiere descarga) | Menor |
| 11 | `HomeScreen` | Agregar Card "Estado de Descarga" condicional con enlace "Ver gesti√≥n de descarga ‚Üí" ‚Üí I1 | Medio |
| 12 | `TensionNavHost` | Registrar composable I1 en ruta `deload-management`, agregar navegaci√≥n B1 ‚Üí I1 | Menor |
| 13 | `NavigationRoutes` | Agregar ruta `DELOAD_MANAGEMENT = "deload-management"` | Menor |
| 14 | `DatabaseModule` | Proveer `DeloadDao` via `@Provides` | Menor |
| 15 | `RepositoryModule` | Inyectar `DeloadDao` en `SessionRepositoryImpl` | Menor |

**Hitos de Implementaci√≥n:**

| # | Componente(s) | Descripci√≥n | Dependencias |
|---|---|---|---|
| 1 | `DeloadLoadRule` + tests | Regla pura: `calculateDeloadLoad()` (60%, round down), `calculateResetLoad()` (90%, round down). Tests JUnit con edge cases de redondeo | Ninguna |
| 2 | `DeloadEntity` + `DeloadDao` + migration | Entity Room, DAO con queries, migration 5‚Üí6 (CREATE TABLE deload), FK en SessionEntity | Ninguna |
| 3 | `RotationResolver` modificaci√≥n + tests | Agregar `isDeload: Boolean = false`. Test: isDeload=true en position 6 ‚Üí versions no avanzan, microcycleCount s√≠. Tests existentes pasan sin cambio (default false) | Ninguna |
| 4 | `SessionRepositoryImpl` ‚Äî activaci√≥n | `activateDeload()`: crear DeloadEntity, transicionar ejercicios a IN_DELOAD, congelar versiones. `ActivateDeloadUseCase` | Hitos 2, 3 |
| 5 | `SessionRepositoryImpl` ‚Äî inicio de sesi√≥n | Modificar `startSession()`: consultar deload activo, asignar deloadId. Modificar `getNextModuleVersionId()`: versiones congeladas. Modificar `GetNextSessionInfoUseCase`: versiones congeladas. Modificar `ExerciseSetDao.getLastWeightForExercise()`: excluir deload | Hito 4 |
| 6 | `SessionRepositoryImpl` ‚Äî cierre de sesi√≥n | Modificar `closeSession()`: pasar isDeload a advanceRotation. Finalizaci√≥n al 6to: complete deload, reset loads 90%, IN_DELOAD‚ÜíIN_PROGRESSION, resolver alertas. Guards evaluateProgression: proteger `prescribed_load_kg` + saltar alertas PLATEAU durante deload | Hitos 4, 5 |
| 7 | Domain models + UseCases | `DeloadState` (sealed), `GetDeloadStateUseCase`, `ActivateDeloadUseCase` | Hitos 4, 5, 6 |
| 8 | Home ‚Äî Card Descarga | `DeloadHomeState`, modificar HomeUiState/ViewModel/Screen para card condicional B1 | Hito 7 |
| 9 | I1 ‚Äî Screen + ViewModel | `DeloadManagementUiState`, `DeloadManagementViewModel`, `DeloadManagementScreen` (3 estados), navegaci√≥n | Hito 7 |
| 10 | Navegaci√≥n + integraci√≥n | Ruta en NavigationRoutes, composable en TensionNavHost, enlace B1‚ÜíI1, enlace H2‚ÜíI1 (placeholder) | Hito 9 |

### Validaci√≥n de Impacto

**C√≥digo real verificado (paso 1.5):**

- `SessionEntity.kt`: Campo `deloadId: Long? = null` ya existe con index. Falta FK constraint a tabla `deload` (no existe a√∫n). Se agrega al crear `DeloadEntity`.
- `RotationResolver.kt`: `advanceRotation(current: RotationState)` ‚Äî firma actual sin `isDeload`. Se agrega par√°metro con default `false` para retrocompatibilidad. Los 6 tests existentes en `RotationResolverTest` siguen pasando sin cambio.
- `SessionRepositoryImpl.kt`: `startSession()` (l√≠neas 76-109) siempre crea con `deloadId = null`. `closeSession()` (l√≠neas 279-324) usa `deloadId != null` para `isDeloadSession` pasado a `evaluateProgression()`. El `advanceRotation()` se invoca en l√≠nea 313 sin par√°metro `isDeload` ‚Äî se agrega.
- `ProgressionClassificationRule.kt`: `resolveNewProgressionState()` l√≠nea 48: `if (currentStatus == "IN_DELOAD") return currentStatus to currentCounter` ‚Äî ya maneja IN_DELOAD correctamente. No se necesita modificaci√≥n.
- `evaluateProgression()` (l√≠neas 326-490): El guard `if (isDeloadSession) return` est√° en l√≠nea 442, que es el bloque post-loop (module-level detection). El loop s√≠ ejecuta: clasificaci√≥n ‚úÖ, resolveNewProgressionState (IN_DELOAD ‚Üí no change ‚úÖ), prescribeLoad (‚ö†Ô∏è recalcula carga durante deload ‚Äî necesita guard), alertas PLATEAU (‚ö†Ô∏è se crean/resuelven durante deload ‚Äî necesita guard).
- `DoubleThresholdRule.prescribeLoad()`: Durante deload se ejecuta y sobreescribe `prescribed_load_kg`. Esto es incorrecto ‚Äî durante deload, la carga prescrita debe mantenerse intacta (se sobreescribir√° con 90% post-deload). Se agrega guard en `evaluateProgression`: `if (isDeloadSession) { prescribedLoadKg = currentProgression.prescribedLoadKg }`. Igualmente, la gesti√≥n de alertas PLATEAU (l√≠neas 415-430) se salta durante deload: `if (!isDeloadSession) { /* plateau alert logic */ }`.
- `ExerciseSetDao.kt`: `getLastWeightForExercise()` (l√≠nea 32) existe ‚Äî consulta el √∫ltimo `weight_kg` sin filtrar por deload. Post-deload retornar√≠a la carga de descarga (60%), no la pre-descarga. Ver Nota 8 (precarga E2 post-deload).
- `SessionDao.kt`: `getActiveSession()`, `getDeloadIdBySessionId()` ya existen. Falta `countDeloadSessions(deloadId)`.
- `ExerciseProgressionDao.kt`: `update()` existe. Falta `transitionToDeload()` (UPDATE masivo para activaci√≥n).
- `AlertDao.kt`: `resolveByModuleAndType()` ya existe (HU-12). `existsActiveByModule()` existe. `getActiveAlerts()` retorna todas las alertas activas sin filtro. Falta `getActiveAlertsByType(type)` para I1 Estado A.
- `HomeUiState.kt`: Tiene `microcycleCount` y `alertCount`. Falta `deloadState`.
- `HomeViewModel.kt`: Carga `microcycleCount` y `alertCount`. Falta cargar deload state.
- `HomeScreen.kt`: No tiene Card de Descarga. Se agrega condicionalmente.
- `NavigationRoutes.kt`: No tiene ruta para I1. Se agrega.
- `TensionNavHost.kt`: No tiene composable I1. Se agrega. El placeholder `onNavigateToAlerts` tiene `{ /* TODO: HU-14+ */ }`.
- `TensionDatabase.kt`: version=5, 15 entities. Se bumpa a 6, se agrega `DeloadEntity` (16 entities).
- `DatabaseModule.kt`: Provee DAOs. Se agrega `DeloadDao`.
- `RepositoryModule.kt`: Provee `SessionRepositoryImpl` con 8 DAOs. Se agrega `DeloadDao` como 9no.
- `GetNextSessionInfoUseCase.kt`: Usa `sessionRepository.getRotationState()` para resolver m√≥dulo/versi√≥n. Con deload activo, debe usar versiones congeladas.

**An√°lisis de dependencias:**

- HU-14 depende de: HU-05 (startSession ‚Äî punto de extensi√≥n para asignar deloadId), HU-06 (precarga E2 ‚Äî decisi√≥n diferida post-deload resuelta en Nota 8), HU-08 (ejercicios bodyweight/isom√©tricos ‚Äî prescripciones espec√≠ficas durante deload anticipadas por HU-08), HU-09 (rotaci√≥n + cierre de sesi√≥n ‚Äî punto de extensi√≥n `advanceRotation`), HU-10 (clasificaci√≥n y estado IN_DELOAD ya soportado), HU-11 (prescripci√≥n de carga ‚Äî `prescribedLoadKg` que se sobreescribir√° post-deload), HU-12 (alerta MODULE_REQUIRES_DELOAD ‚Äî trigger visual para activar descarga + acciones correctivas escalonadas), HU-13 (E5 muestra clasificaci√≥n durante deload sessions ‚Äî lectura, se√±ales de acci√≥n inocuas).
- HU-14 alimenta: HU-15 (KPIs y m√©tricas ‚Äî tasa de progresi√≥n y tonelaje durante deload son datos derivados), HU-17 (H1/H2 alertas con enlace "Gestionar descarga" ‚Üí I1; CA-17.19-17.20 verifican si ca√≠da de tonelaje es por descarga planificada).
- HU-14 modifica componentes de: HU-05 (startSession), HU-06 (getLastWeightForExercise exclusi√≥n deload), HU-09 (closeSession, advanceRotation), HomeScreen.

**Impacto en performance:**

- `getActiveDeload()`: 1 SELECT con `WHERE status = 'ACTIVE' LIMIT 1`. Index en `status`. Despreciable.
- `countDeloadSessions(deloadId)`: COUNT con WHERE en columna indexada. O(1).
- `getPreDeloadAvgWeight(exerciseId, activationDate)`: Subquery con JOIN en exercise_set ‚Üí session_exercise ‚Üí session, filtrada por `session.deload_id IS NULL AND session.date < activationDate`. Con √≠ndices existentes, no supera 100 filas. Despreciable.
- `transitionToDeload()`: UPDATE masivo de `exercise_progression` WHERE status NOT IN ('NO_HISTORY', 'MASTERED'). M√°ximo ~40 filas (total ejercicios del sistema). Despreciable.
- Impacto total: m√≠nimo. Todas las operaciones son O(1) o O(n) con n ‚â§ 40.

**Cadena de invocaci√≥n ‚Äî Activaci√≥n:**

```
DeloadManagementScreen ‚Üí onActivateDeload()
  ‚Üí DeloadManagementViewModel.activateDeload()
    ‚Üí ActivateDeloadUseCase(sessionRepository)
      ‚Üí sessionRepository.activateDeload()
        ‚Üí database.withTransaction {
            rotationState = rotationStateDao.getRotationState().first()
            deloadDao.insert(DeloadEntity(
              status = "ACTIVE",
              activationDate = today,
              frozenVersionModuleA = rotationState.currentVersionModuleA,
              frozenVersionModuleB = rotationState.currentVersionModuleB,
              frozenVersionModuleC = rotationState.currentVersionModuleC,
            ))
            exerciseProgressionDao.transitionToDeload()
          }
```

**Cadena de invocaci√≥n ‚Äî Ciclo (inicio de sesi√≥n):**

```
HomeScreen ‚Üí onStartSession(moduleVersionId)
  ‚Üí StartSessionUseCase(sessionRepository)
    ‚Üí sessionRepository.startSession(moduleVersionId)
      ‚Üí deload = deloadDao.getActiveDeloadOnce()
      ‚Üí sessionEntity = SessionEntity(
          moduleVersionId = moduleVersionId,
          deloadId = deload?.id,   // ‚Üê NEW: asigna deloadId
          date = today,
        )
      ‚Üí sessionDao.insert(sessionEntity)
```

**Cadena de invocaci√≥n ‚Äî Finalizaci√≥n (cierre sesi√≥n 6):**

```
ActiveSessionViewModel.onCloseSessionConfirmed()
  ‚Üí closeSessionUseCase(sessionId)
    ‚Üí sessionRepository.closeSession(sessionId)
      ‚Üí evaluateProgression(sessionId, moduleVersionId, isDeloadSession=true)
        ‚Üí [clasificaci√≥n per-exercise, NO recalculo de prescribed_load_kg]
      ‚Üí advanceRotation(currentRotation, isDeload=true)
        ‚Üí [posici√≥n avanza, microcycleCount++, versiones NO rotan]
      ‚Üí sessionCount = sessionDao.countDeloadSessions(deloadId)
      ‚Üí if (sessionCount == 6) {
          deloadDao.complete(deloadId, today)
          // Reset loads to 90% pre-deload
          for each standard exercise:
            preDeloadWeight = getPreDeloadAvgWeight(exerciseId, activationDate)
            resetLoad = DeloadLoadRule.calculateResetLoad(preDeloadWeight, loadIncrementKg)
            exerciseProgressionDao.update(
              status = "IN_PROGRESSION",
              prescribedLoadKg = resetLoad,
              sessionsWithoutProgression = 0,
            )
          // Resolve MODULE_REQUIRES_DELOAD alerts
          alertDao.resolveAllByType("MODULE_REQUIRES_DELOAD", today)
        }
```

### Notas T√©cnicas

**Nota 1 ‚Äî La FK de `session.deload_id` a `deload.id` se agrega en la migration 5‚Üí6.**

Actualmente `SessionEntity` tiene la columna `deload_id` con index pero sin FK constraint (la tabla `deload` no exist√≠a). La migration 5‚Üí6 crea la tabla `deload` y luego agrega la FK. En SQLite, no se puede `ALTER TABLE ADD CONSTRAINT` ‚Äî se necesita recrear la tabla session. **Sin embargo**, dado que la columna ya existe y tiene los valores correctos (todos NULL), una alternativa m√°s simple es: crear tabla `deload` y dejar la FK como "l√≥gica" (verificada a nivel de aplicaci√≥n, no a nivel DB). Esto es consistente con el patr√≥n existente: `session.deload_id` ya tiene Index pero no FK en el Entity actual. Se mantiene este enfoque por simplicidad de migraci√≥n.

**Nota 2 ‚Äî `getNextModuleVersionId()` y `GetNextSessionInfoUseCase` ya no pueden usar solo `rotation_state` para versiones.**

Actualmente, `SessionRepositoryImpl.getNextModuleVersionId()` (l√≠neas 56-75) usa `rotationStateDao.getRotationState()` para resolver m√≥dulo y versi√≥n. `GetNextSessionInfoUseCase.invoke()` tambi√©n usa `sessionRepository.getRotationState()` para resolver `versionNumber` y construir `NextSession`. Con deload activo, la versi√≥n debe venir de `deload.frozen_version_module_X`. Se modifica el Flow para: consultar deload activo ‚Üí si existe, usar versiones congeladas ‚Üí si no, usar rotation_state normal. Esto requiere combinar dos Flows con `combine()` o consultar deload como suspend inside the map. Ambos puntos (`getNextModuleVersionId` y `GetNextSessionInfoUseCase`) deben ser consistentes.

**Nota 3 ‚Äî El "Estado C: Post-descarga" de I1 es ef√≠mero.**

El Estado C (cargas de reinicio) se muestra entre que el deload se completa y la primera sesi√≥n post-deload se cierra. Despu√©s, las cargas de reinicio ya est√°n persistidas en `exercise_progression.prescribed_load_kg` y el deload tiene `status = COMPLETED`. Para determinar si mostrar Estado C: verificar si existe un deload COMPLETED cuya `completion_date` sea reciente Y no se haya iniciado ninguna sesi√≥n posterior sin `deload_id`. Alternativa m√°s simple: el Estado C se muestra cuando el √∫ltimo deload es COMPLETED y no se ha iniciado sesi√≥n post-deload. Una vez que el ejecutante inicia la siguiente sesi√≥n, el Estado C desaparece de I1 y la pantalla muestra "No hay descarga pendiente".

**Nota 4 ‚Äî Bodyweight e isom√©tricos durante deload: no se calcula carga.**

CA-14.09 especifica: bodyweight ‚Üí 8 reps, RIR 4-5 (Peso=0); isom√©tricos ‚Üí 30 segundos, RIR 4-5. Estos par√°metros son de **prescripci√≥n visual** (se muestran en E1 y I1), pero no se persisten en `exercise_progression` (prescribed_load_kg sigue NULL). La UI de E1 ya muestra el rango de reps del plan_assignment ‚Äî durante deload, la prescripci√≥n visual puede mostrar "8 reps" y "RIR 4-5" como overlay informativo. La implementaci√≥n de E1-deload visual es responsabilidad de esta HU (CA-14.07).

**Nota 5 ‚Äî La sesi√≥n incompleta durante deload s√≠ cuenta para el progreso del microciclo de descarga.**

El conteo de sesiones del deload usa `status IN ('COMPLETED', 'INCOMPLETE')`. Una sesi√≥n cerrada como incompleta durante deload avanza el progreso (4/6 ‚Üí 5/6). El ejecutante no puede "saltarse" la descarga cerrando sesiones incompletas a prop√≥sito ‚Äî las sesiones registradas tienen datos reales que ser√°n clasificados.

**Nota 6 ‚Äî Solo puede haber una descarga activa a la vez.**

`activateDeload()` verifica que no exista deload con `status = 'ACTIVE'` antes de crear uno nuevo. Si ya hay uno activo, la operaci√≥n lanza una excepci√≥n o simplemente no crea otro (el bot√≥n "Activar Descarga" solo aparece en Estado A, que requiere ausencia de deload activo).

**Nota 7 ‚Äî La migration 5‚Üí6 es destructiva solo si hay datos inconsistentes.**

La tabla `deload` se crea vac√≠a. La columna `session.deload_id` ya existe con todos valores NULL. No hay datos que migrar ‚Äî solo se crea la estructura. La migration es una simple `CREATE TABLE IF NOT EXISTS deload (...)`.

**Nota 8 ‚Äî Precarga en E2 post-deload: decisi√≥n diferida de HU-06.**

HU-06 (Nota 9) identifica un conflicto post-deload: `ExerciseSetDao.getLastWeightForExercise()` (l√≠nea 32) consulta el √∫ltimo `weight_kg` para un ejercicio sin filtrar sesiones de deload. Post-deload, la primera sesi√≥n normal precargar√≠a la carga de descarga (60%) en E2, mientras que E1 mostrar√≠a la carga de reinicio (90% pre-descarga) de `exercise_progression.prescribed_load_kg`. Existen dos opciones:

- **Opci√≥n A (recomendada):** Modificar `getLastWeightForExercise()` para excluir sesiones de deload: agregar `INNER JOIN session s ON s.id = se.session_id WHERE s.deload_id IS NULL` al query. As√≠ la precarga en E2 ser√≠a la carga pre-descarga, coherente con la carga de reinicio (90%).
- **Opci√≥n B:** Aceptar la discrepancia: E2 precarga la √∫ltima carga usada (60% deload), E1 muestra la carga objetivo (90% reinicio). El ejecutante ajustar√≠a manualmente al registrar.

Se elige la **Opci√≥n A** para consistencia UX. Este cambio se implementa en HU-14 y resuelve la decisi√≥n diferida de HU-06.

**Nota 9 ‚Äî Se√±ales de acci√≥n en E5 durante sesiones de deload.**

HU-13 define `ActionSignalRule` que genera se√±ales para E5 ("Subir carga", "Mantener carga", "Considerar descarga"). Durante una sesi√≥n de deload, estas se√±ales son sem√°nticamente innecesarias porque las cargas est√°n fijadas al 60% y la progresi√≥n est√° congelada (IN_DELOAD). El `ActionSignalRule` puede generar se√±ales incorrectas (ej: "Subir carga" porque la clasificaci√≥n fue POSITIVE_PROGRESSION comparada con la serie reducida de deload). Sin embargo, como `prescribed_load_kg` est√° protegido por el guard de Decisi√≥n 12 y los estados no cambian, las se√±ales son inocuas ‚Äî no se persisten ni afectan la l√≥gica. Para mayor claridad UX, el desarrollador puede optar por mostrar una se√±al gen√©rica "Sesi√≥n de descarga" en E5 cuando `deloadId != null`, suprimiendo las se√±ales individuales.

### Verificaci√≥n Cruzada de CAs

| CA | Estado | Mecanismo | Implementado en |
|---|---|---|---|
| CA-14.01 | üî® Por implementar | `ActivateDeloadUseCase` ‚Üí crear `DeloadEntity(ACTIVE)` + `transitionToDeload()` | HU-14 (UseCase + Repository) |
| CA-14.02 | üî® Por implementar | `DeloadLoadRule.calculateDeloadLoad(lastWeight, increment)` ‚Üí 60% redondeado down. Se muestra en E1 como prescripci√≥n visual | HU-14 (Rule + UI E1) |
| CA-14.03 | üî® Por implementar | `countDeloadSessions(deloadId) == 6` ‚Üí `deloadDao.complete()` en `closeSession()` | HU-14 (Repository) |
| CA-14.04 | üî® Por implementar | `advanceRotation(isDeload=true)` ‚Üí versiones NO avanzan. `startSession()` usa `deload.frozen_version_module_X` | HU-14 (RotationResolver + Repository) |
| CA-14.05 | üî® Por implementar | `DeloadLoadRule.calculateResetLoad(preDeloadWeight, increment)` ‚Üí 90% redondeado down. Persistido en `prescribed_load_kg` al finalizar deload | HU-14 (Rule + Repository) |
| CA-14.06 | üî® Por implementar | `floor(value / increment) * increment` con `loadIncrementKg` de `module.load_increment_kg` | HU-14 (Rule) |
| CA-14.07 | üî® Por implementar | I1 Estado B muestra progreso + par√°metros. Indicador en B1 (Card Descarga). Indicador en E1 (badge deload) | HU-14 (Screen I1 + HomeScreen + ActiveSessionScreen indicator) |
| CA-14.08 | üî® Por implementar | Al finalizar deload: `exercise_progression.status` ‚Üí `IN_PROGRESSION`, `sessions_without_progression = 0`, `prescribed_load_kg = resetLoad (90%)` | HU-14 (Repository) |
| CA-14.09 | üî® Por implementar | Guard: `if (isBodyweight \|\| isIsometric)` ‚Üí no calcula carga deload/reinicio. Prescripci√≥n visual: 8 reps / 30 seg, RIR 4-5 | HU-14 (Rule guard + UI) |
| CA-14.10 | ‚úÖ Ya implementado | `advanceRotation()` incrementa `microcycleCount` al cerrar posici√≥n 6 | HU-09 (RotationResolver) |
| CA-14.11 | ‚úÖ Ya implementado | Rotaci√≥n agn√≥stica al calendario ‚Äî basada en secuencia de sesiones | HU-09 (RotationResolver) |
| CA-14.12 | ‚úÖ Ya implementado | `rotation_state.microcycle_count` persistido en Room | HU-09 (RotationStateEntity) |
| CA-14.13 | üî® Por implementar | `advanceRotation(isDeload=true)` en posici√≥n 6 ‚Üí incrementa microcycleCount (nuevo test) | HU-14 (RotationResolver test) |
| CA-14.14 | ‚úÖ Ya implementado | `HomeScreen` ya muestra `microcycleCount` via `GetMicrocycleCountUseCase` | HU-05 (HomeScreen) |

### Referencias y Validaci√≥n

**Documentaci√≥n consultada:**

- Manifiesto de Dominio Sist√©mico ¬ß6-A R5 ‚Äî Protocolo de Descarga (60%, 4 series, 8 reps, RIR 4-5, 1 microciclo, post-descarga 90%)
- Modelo de Datos ¬ß3.10 (session.deload_id), ¬ß3.13 (exercise_progression.status IN_DELOAD), ¬ß3.14 (rotation_state.microcycle_count), ¬ß3.15 (deload ‚Äî entidad nueva completa)
- ADR-06 ‚Äî Motor de reglas Kotlin puro
- ADR D-08 ‚Äî Descarga dura 1 microciclo (6 sesiones), versiones congeladas
- Arquitectura T√©cnica ¬ß5.2 ‚Äî Naming: `DeloadLoadRule`, `DeloadManagementScreen`, `DeloadManagementViewModel`
- Wireframes I1 ‚Äî Gesti√≥n de Descarga (3 estados: requerida/activa/post-descarga)
- Especificaci√≥n Visual ¬ßI1 ‚Äî Componentes M3, colores azul descarga (#1565C0/#64B5F6), LinearProgressIndicator
- Wireframes B1 ‚Äî Card "Estado de Descarga" condicional
- Especificaci√≥n Visual ¬ßB1 ‚Äî Card Descarga: Secondary Container, enlace "Ver gesti√≥n de descarga ‚Üí"
- Mapa de Navegaci√≥n ¬ß6 (I1) ‚Äî B1‚ÜíI1, H2‚ÜíI1
- Requerimientos RF38-41

**Historias relacionadas:**

- HU-05: Establece `startSession()` ‚Äî punto de extensi√≥n para asignar `deloadId` y resolver versiones congeladas.
- HU-06: Define `getLastWeightForExercise()` para precarga en E2. Nota 9 de HU-06 defiere la decisi√≥n post-deload a HU-14. Resuelta en Nota 8 (excluir sesiones de deload del query).
- HU-08: Anticipa prescripciones espec√≠ficas para bodyweight (8 reps, RIR 4-5) e isom√©tricos (30 seg, RIR 4-5) durante deload ‚Äî referencia "CA-17.09" (ahora CA-14.09).
- HU-09: Establece `closeSession()`, `advanceRotation()`, `RotationState` ‚Äî puntos de extensi√≥n principales de HU-14. Decisi√≥n 6 de HU-09 anticipa el par√°metro `isDeload: Boolean`.
- HU-10: Produce `session_exercise.progression_classification` y `exercise_progression.status`. `resolveNewProgressionState()` (l√≠nea 48) ya maneja IN_DELOAD (no change). Nota 6 de HU-10 discute la frontera con el deload.
- HU-11: Produce `exercise_progression.prescribed_load_kg`. HU-14 sobreescribe este valor post-deload con 90% de carga pre-deload.
- HU-12: Produce alerta `MODULE_REQUIRES_DELOAD` ‚Äî trigger visual para I1 Estado A y Card B1. Guard `isDeloadSession` ya aplicado en module-level detection. Tambi√©n contiene acciones correctivas escalonadas (Bloque C/D).
- HU-13: E5 muestra clasificaci√≥n durante sesiones de deload. `ActionSignalRule` genera se√±ales que son inocuas durante deload (ver Nota 9). `moduleRequiresDeload` se consulta via `alertDao.existsActiveByModule()`.
- HU-15: KPIs y m√©tricas ‚Äî la tasa de progresi√≥n y el tonelaje durante deload son datos derivados que HU-15 consumir√°.
- HU-17 (futuro): Sistema de Alertas H1/H2 con enlace "Gestionar descarga" ‚Üí I1. CA-17.19 y CA-17.20 verifican si una ca√≠da de tonelaje es por descarga planificada, referenciando HU-14 expl√≠citamente.

**Validado por:** esteban.colorado | **Fecha:** 2026-02-17 | **Enfoque:** Exploratorio
