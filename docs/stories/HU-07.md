# HU-07 — Sustituir ejercicio puntualmente en sesión activa

## Requisitos relacionados

RF16

## Descripción

Como ejecutante, quiero poder sustituir puntualmente un ejercicio prescrito por otro ejercicio del mismo módulo durante una sesión activa sin modificar el Plan de Entrenamiento, para adaptar el entrenamiento a las circunstancias del gimnasio (equipo no disponible, dolor articular) sin comprometer la cobertura muscular ni corromper mi plan original.

## Criterios de Aceptación

### CA-07.01 — Sustitución durante sesión activa

**Dado que** el ejecutante tiene una sesión activa y un ejercicio prescrito no puede ejecutarse (equipo ocupado, en mantenimiento o genera dolor articular),
**cuando** selecciona la opción de sustituir ese ejercicio,
**entonces** el sistema presenta la lista de ejercicios elegibles como sustitutos: todos los ejercicios del mismo módulo (A, B o C) del Diccionario — incluyendo tanto los precargados como los creados por el ejecutante — disponibles en cualquier versión del módulo, excluyendo los ya prescritos en la sesión activa.

### CA-07.02 — Restricción al mismo módulo

**Dado que** el ejecutante está seleccionando un ejercicio sustituto,
**cuando** el sistema presenta los ejercicios disponibles,
**entonces** únicamente muestra ejercicios que pertenecen al mismo módulo de la sesión activa; ningún ejercicio de otro módulo es elegible como sustituto.

### CA-07.03 — Sustitución puntual sin alterar el plan

**Dado que** el ejecutante realiza una sustitución de un ejercicio en la sesión activa,
**cuando** la sesión se cierra (Completada o Incompleta),
**entonces** el Plan de Entrenamiento original permanece intacto e inalterado para todas las sesiones futuras; la sustitución solo afecta la sesión en curso.

### CA-07.04 — Sesión futura sin rastro de sustitución anterior

**Dado que** el ejecutante sustituyó un ejercicio en una sesión anterior,
**cuando** inicia la próxima sesión del mismo módulo y versión,
**entonces** el sistema prescribe los ejercicios originales del Plan de Entrenamiento, sin arrastrar la sustitución de la sesión anterior.

### CA-07.05 — Sustitución de ejercicio no iniciado

**Dado que** el ejecutante desea sustituir un ejercicio que aún está en estado "No Iniciado" (0 series registradas),
**cuando** ejecuta la sustitución,
**entonces** el sistema reemplaza el ejercicio prescrito por el sustituto en la sesión activa, y las series registradas posteriormente se vincularán al ejercicio sustituto.

### CA-07.06 — Restricción de sustitución con series registradas

**Dado que** el ejecutante desea sustituir un ejercicio que ya tiene series registradas ("En Ejecución" o "Completado"),
**cuando** intenta ejecutar la sustitución,
**entonces** el sistema no permite la sustitución, ya que las series ya registradas están vinculadas al ejercicio original y cambiar el ejercicio después de registrar datos corrompería la integridad de los registros.

## Análisis Arquitectónico (Arquitecto)

### Decisiones de Diseño

**Patrón Arquitectónico:** Clean Architecture (MVVM + Use Cases + Repository) — consistente con HU-01 a HU-06.

**Justificación:** HU-07 introduce la pantalla E3 (Selección de Ejercicio Sustituto) con un flujo simple: lista filtrada + diálogo de confirmación + UPDATE atómico. La complejidad reside en: (1) el query correcto para la lista de sustitutos elegibles, (2) la corrección del query de E1 que actualmente usa INNER JOIN a `plan_assignment` y rompería con ejercicios sustituidos, y (3) la preservación del `original_exercise_id` ante sustituciones múltiples. No se requieren entidades nuevas — `SessionExerciseEntity` ya tiene la columna `original_exercise_id` (creada en HU-05).

**Hallazgo Crítico — Bug en query de E1:**

La query `getBySessionIdWithDetails()` actualmente usa:

```sql
INNER JOIN plan_assignment pa ON pa.module_version_id = s.module_version_id
    AND pa.exercise_id = se.exercise_id
```

Un ejercicio sustituido (cuyo `exercise_id` es el sustituto, no el original del plan) **no existe** en `plan_assignment` para ese `module_version_id`. Resultado: el ejercicio sustituido **desaparece de E1** tras la sustitución — bug bloqueante que se corrige obligatoriamente en HU-07.

**Corrección:** Cambiar `INNER JOIN` → `LEFT JOIN` + `COALESCE(pa.sets, 4)` + `COALESCE(pa.reps, '8-12')`. Este patrón ya fue validado exitosamente en `getExerciseInfoForSet()` de HU-06.

**Componentes Afectados:**

```
┌─────────────────────────────────────────────────────────────────────┐
│  Archivos NUEVOS (4)                                                │
│  SubstituteExerciseInfo.kt          (domain/model)                  │
│  SubstituteExerciseUseCase.kt       (domain/usecase/session)        │
│  SubstituteExerciseViewModel.kt     (ui/session)                    │
│  SubstituteExerciseScreen.kt        (ui/session)                    │
├─────────────────────────────────────────────────────────────────────┤
│  Archivos MODIFICADOS (9)                                           │
│  SessionExerciseDao.kt              (+3 métodos, fix query E1)      │
│  ExerciseDao.kt                     (+1 método)                     │
│  SessionRepository.kt               (+3 métodos)                    │
│  SessionRepositoryImpl.kt           (+3 métodos)                    │
│  ExerciseRepository.kt              (+1 método)                     │
│  ExerciseRepositoryImpl.kt          (+1 método)                     │
│  NavigationRoutes.kt                (+1 ruta + helper)              │
│  TensionNavHost.kt                  (wiring E1→E3 + showBottomBar)  │
│  strings.xml                        (+8 strings)                    │
└─────────────────────────────────────────────────────────────────────┘
```

#### 1. Data Layer — DAOs (Modificaciones)

Paquete: `data.local.dao`.

- **`SessionExerciseDao`** (Modificación Mayor):

  - **Corrección de `getBySessionIdWithDetails()`** (Bug fix): Cambiar INNER JOIN → LEFT JOIN en `plan_assignment` + COALESCE para `sets` y `reps`. Esto asegura que ejercicios sustituidos (cuyo `exercise_id` no está en `plan_assignment` para el `module_version_id` actual) sigan apareciendo en E1. La sustitución solo cambia `exercise_id` en `session_exercise`, no modifica `plan_assignment`.

    **Cambio concreto en la query:**

    ```sql
    -- ANTES (INNER JOIN — ROMPE con sustitución):
    INNER JOIN plan_assignment pa ON pa.module_version_id = s.module_version_id
        AND pa.exercise_id = se.exercise_id

    -- DESPUÉS (LEFT JOIN + COALESCE — CORRECTO):
    LEFT JOIN plan_assignment pa ON pa.module_version_id = s.module_version_id
        AND pa.exercise_id = se.exercise_id
    ```

    Y en los campos SELECT:

    ```sql
    -- ANTES:
    pa.sets,
    pa.reps,

    -- DESPUÉS:
    COALESCE(pa.sets, 4) AS sets,
    COALESCE(pa.reps, '8-12') AS reps,
    ```

    **Justificación de defaults `4` y `'8-12'`:** Son los valores estándar del Plan de Entrenamiento (Plan de Entrenamiento: "4 series con rango de 8-12 repeticiones"). Todo módulo usa 4 series y 8-12 reps. El COALESCE solo activa cuando `plan_assignment` no tiene fila para el ejercicio sustituido, lo cual es correcto: un sustituto no prescrito hereda los parámetros estándar.

  - **`updateExerciseId(sessionExerciseId: Long, newExerciseId: Long, originalExerciseId: Long)`** (Nuevo): `@Query` UPDATE suspend. Ejecuta la sustitución atómica en `session_exercise`.

    ```sql
    UPDATE session_exercise
    SET exercise_id = :newExerciseId,
        original_exercise_id = :originalExerciseId
    WHERE id = :sessionExerciseId
    ```

    **¿Por qué UPDATE directo y no `@Update` de Room?** El `@Update` de Room actualiza TODAS las columnas de la entity. Con `@Query` UPDATE controlamos exactamente qué columnas cambian, evitando sobrescribir accidentalmente `progression_classification` u otros campos que no deben modificarse durante la sustitución.

  - **`getExerciseIdsForSession(sessionId: Long): List<Long>`** (Nuevo): `@Query` suspend. Retorna los IDs de los ejercicios actualmente en la sesión, para excluirlos de la lista de sustitutos (CA-07.01).

    ```sql
    SELECT exercise_id FROM session_exercise WHERE session_id = :sessionId
    ```

  - **`getSessionExerciseForSubstitution(sessionExerciseId: Long): SessionExerciseForSubstitution?`** (Nuevo): `@Query` suspend. Obtiene datos del `session_exercise` individual necesarios para validar y ejecutar la sustitución.

    ```sql
    SELECT
        se.id,
        se.session_id AS sessionId,
        se.exercise_id AS exerciseId,
        se.original_exercise_id AS originalExerciseId,
        e.name AS exerciseName,
        e.module_code AS moduleCode,
        (SELECT COUNT(*) FROM exercise_set es WHERE es.session_exercise_id = se.id) AS completedSets
    FROM session_exercise se
    INNER JOIN exercise e ON se.exercise_id = e.id
    WHERE se.id = :sessionExerciseId
    ```

  - **`SessionExerciseForSubstitution`**: Data class intermedia (no `@Entity`), definida en `SessionExerciseDao.kt` (mismo patrón de `SessionExerciseWithDetails` y `SetExerciseInfo`). Campos: `id: Long`, `sessionId: Long`, `exerciseId: Long`, `originalExerciseId: Long?`, `exerciseName: String`, `moduleCode: String`, `completedSets: Int`.

- **`ExerciseDao`** (Modificación Menor):

  - **`getByModuleCodeNotInIds(moduleCode: String, excludedExerciseIds: List<Long>): Flow<List<ExerciseWithDetails>>`** (Nuevo): Query para la lista de sustitutos elegibles (CA-07.01). Filtra por módulo y excluye los ejercicios ya en la sesión activa.

    ```sql
    SELECT
        e.id,
        e.name,
        e.module_code AS moduleCode,
        m.name AS moduleName,
        et.name AS equipmentTypeName,
        e.is_bodyweight AS isBodyweight,
        e.is_isometric AS isIsometric,
        e.is_to_technical_failure AS isToTechnicalFailure,
        e.is_custom AS isCustom,
        e.media_resource AS mediaResource,
        GROUP_CONCAT(mz.name, ', ') AS muscleZones
    FROM exercise e
    INNER JOIN module m ON e.module_code = m.code
    INNER JOIN equipment_type et ON e.equipment_type_id = et.id
    LEFT JOIN exercise_muscle_zone emz ON e.id = emz.exercise_id
    LEFT JOIN muscle_zone mz ON emz.muscle_zone_id = mz.id
    WHERE e.module_code = :moduleCode
      AND e.id NOT IN (:excludedExerciseIds)
    GROUP BY e.id
    ORDER BY e.name ASC
    ```

    **¿Por qué no reusar `getByModuleCodeNotInVersion()`?** Ese método excluye ejercicios del `plan_assignment` para un `module_version_id`. HU-07 necesita excluir los ejercicios **actualmente en la sesión** (que podrían incluir sustitutos de otra versión). La semántica de exclusión es diferente: por sesión vs. por plan.

    **¿Por qué `Flow` y no `suspend`?** Mantiene consistencia con los otros queries de `ExerciseDao` que retornan `Flow<List<ExerciseWithDetails>>` (`getAll()`, `getById()`, `getByModuleCodeNotInVersion()`). Aunque la lista es una consulta puntual (E3 se abre, se carga y se cierra), usar `Flow` permite que si se agregan ejercicios custom en el futuro desde otra pantalla, la lista se actualice reactivamente (hipótesis de bajo costo técnico vs. alto valor de consistencia con el patrón establecido).

#### 2. Domain Layer — Modelo Nuevo

Paquete: `domain.model`.

- **`SubstituteExerciseInfo`**: Data class que encapsula la información necesaria para inicializar E3.
  - `sessionExerciseId: Long` — ID del ejercicio-en-sesión a sustituir.
  - `currentExerciseId: Long` — ID del ejercicio actual (el que se va a reemplazar).
  - `currentExerciseName: String` — Nombre mostrado en el subtítulo de E3 ("Reemplazar: [nombre]").
  - `moduleCode: String` — Código del módulo de la sesión. Usado para filtrar sustitutos por módulo (CA-07.02).
  - `sessionId: Long` — ID de la sesión activa. Usado para obtener los `exercise_ids` a excluir.

#### 3. Domain Layer — Repository Interfaces (Modificaciones)

Paquete: `domain.repository`.

- **`SessionRepository`** (Modificación): Agregar 3 métodos al contrato existente.

  - `suspend fun getSubstituteExerciseInfo(sessionExerciseId: Long): SubstituteExerciseInfo?` — Obtiene la información necesaria para inicializar E3. Retorna `null` si `sessionExerciseId` no existe o si el ejercicio ya tiene series registradas (`completedSets > 0`). Método `suspend` (no Flow) porque es una consulta one-shot al abrir E3.

  - `suspend fun getExerciseIdsForSession(sessionId: Long): List<Long>` — Retorna los `exercise_id` actualmente asignados a la sesión. Usado para construir la lista de exclusión de E3.

  - `suspend fun substituteExercise(sessionExerciseId: Long, newExerciseId: Long)` — Ejecuta la sustitución atómica. Lanza `IllegalStateException` si el ejercicio ya tiene series registradas (defensa en profundidad, CA-07.06).

- **`ExerciseRepository`** (Modificación): Agregar 1 método al contrato existente.

  - `fun getEligibleSubstitutes(moduleCode: String, excludedExerciseIds: List<Long>): Flow<List<Exercise>>` — Retorna la lista de ejercicios del módulo excluyendo los ya presentes en la sesión. El mapeo de `ExerciseWithDetails` → `Exercise` se realiza en el repository impl (patrón existente en `getAllExercises()`).

#### 4. Domain Layer — Use Case Nuevo

Paquete: `domain.usecase.session`.

- **`SubstituteExerciseUseCase`** (Nuevo): Delega la sustitución al repository.

  ```kotlin
  class SubstituteExerciseUseCase @Inject constructor(
      private val sessionRepository: SessionRepository,
  ) {
      suspend operator fun invoke(sessionExerciseId: Long, newExerciseId: Long) {
          sessionRepository.substituteExercise(sessionExerciseId, newExerciseId)
      }
  }
  ```

  **¿Por qué no hay `GetSubstituteExerciseInfoUseCase`?** El ViewModel necesita coordinar 3 operaciones secuenciales: (1) obtener info del ejercicio, (2) obtener IDs de la sesión, (3) cargar sustitutos. Crear un UseCase que coordine los 3 repos (Session + Exercise) violaría el principio de responsabilidad única del UseCase (que debe ser un wrapper fino de una operación de negocio atómica). El ViewModel inyecta directamente los 2 repositories para estas operaciones de lectura, y usa `SubstituteExerciseUseCase` para la operación de escritura. Este patrón es consistente con `ActiveSessionViewModel` (que inyecta `SessionRepository` directamente para `getSessionModuleVersion()`) y `RegisterSetViewModel` (que inyecta UseCase solo para las operaciones de negocio).

#### 5. Data Layer — Repository Implementations (Modificaciones)

Paquete: `data.repository`.

- **`SessionRepositoryImpl`** (Modificación): Implementar los 3 nuevos métodos. No requiere inyección de DAOs adicionales — `sessionExerciseDao`, `exerciseSetDao` y `database` ya están inyectados.

  - `getSubstituteExerciseInfo(sessionExerciseId: Long): SubstituteExerciseInfo?`:
    1. Consulta `sessionExerciseDao.getSessionExerciseForSubstitution(sessionExerciseId)`. Si `null` → retorna `null`.
    2. Si `info.completedSets > 0` → retorna `null` (ejercicio con series, no sustituible; CA-07.06).
    3. Mapea a `SubstituteExerciseInfo(sessionExerciseId, info.exerciseId, info.exerciseName, info.moduleCode, info.sessionId)`.

  - `getExerciseIdsForSession(sessionId: Long): List<Long>`:
    Delega a `sessionExerciseDao.getExerciseIdsForSession(sessionId)`.

  - `substituteExercise(sessionExerciseId: Long, newExerciseId: Long)`:
    Ejecuta en `database.withTransaction {}`:
    1. `val info = sessionExerciseDao.getSessionExerciseForSubstitution(sessionExerciseId)`. Si `null` → `IllegalStateException("Session exercise not found")`.
    2. Valida `info.completedSets == 0`. Si no → `IllegalStateException("Cannot substitute exercise with registered sets")`.
    3. Determina `originalExerciseId`:
       - Si `info.originalExerciseId != null` → usa `info.originalExerciseId` (ya fue sustituido antes; preserva el original del plan).
       - Si `info.originalExerciseId == null` → usa `info.exerciseId` (primera sustitución; el actual ES el del plan).
    4. Ejecuta `sessionExerciseDao.updateExerciseId(sessionExerciseId, newExerciseId, originalExerciseId)`.

    **¿Por qué transacción?** Los pasos 1-4 deben ser atómicos para evitar que entre la validación de `completedSets` y el UPDATE, se registre una serie por otra corrutina (defensa ante race condition teórica).

    **Nota sobre sustitución doble:** CA-07 no prohíbe sustituir un ejercicio que ya fue sustituido (siempre que tenga 0 series). Si el ejecutante sustituye A→B y luego B→C, `original_exercise_id` debe seguir siendo A (el del plan original), no B. El paso 3 garantiza esto.

- **`ExerciseRepositoryImpl`** (Modificación): Implementar 1 nuevo método.

  - `getEligibleSubstitutes(moduleCode: String, excludedExerciseIds: List<Long>): Flow<List<Exercise>>`:
    Delega a `exerciseDao.getByModuleCodeNotInIds(moduleCode, excludedExerciseIds)` y mapea `ExerciseWithDetails` → `Exercise` con el mismo patrón de `getAllExercises()`.

#### 6. UI Layer — Estado y ViewModel

Paquete: `ui.session`.

- **`SubstituteExerciseUiState`** (Nuevo — definido dentro de `SubstituteExerciseViewModel.kt`): Data class de estado reactivo del formulario E3.

  ```kotlin
  data class SubstituteExerciseUiState(
      val isLoading: Boolean = true,
      val originalExerciseName: String = "",
      val eligibleExercises: List<SubstituteExerciseUiItem> = emptyList(),
      val selectedExercise: SubstituteExerciseUiItem? = null,
      val showConfirmDialog: Boolean = false,
      val isSubstituting: Boolean = false,
  )

  data class SubstituteExerciseUiItem(
      val exerciseId: Long,
      val name: String,
      val muscleZones: String,
      val equipmentTypeName: String,
  )
  ```

  **Campo `isSubstituting`:** Protección anti-double-tap. Mientras la transacción de sustitución está en curso, el botón "Confirmar" del diálogo se deshabilita.

- **`SubstituteExerciseViewModel`** (Nuevo): `@HiltViewModel`. Gestiona el ciclo de vida de E3.

  - **Inyecta:** `SubstituteExerciseUseCase`, `SessionRepository`, `ExerciseRepository`, `SavedStateHandle`.
  - **Session exercise ID:** `savedStateHandle.get<Long>("sessionExerciseId")` — extraído del argumento de navegación.
  - **Estado:** `MutableStateFlow<SubstituteExerciseUiState>` → `StateFlow<SubstituteExerciseUiState>`.
  - **Evento de navegación:** `MutableSharedFlow<Boolean>(replay = 0)` → la UI observa con `LaunchedEffect` y navega back al emitir `true`.

  - **`init`:** En `viewModelScope.launch`:
    1. `val info = sessionRepository.getSubstituteExerciseInfo(sessionExerciseId)`. Si `null` → permanece en loading (E3 no debería alcanzarse con ID inválido o ejercicio con series).
    2. `val excludedIds = sessionRepository.getExerciseIdsForSession(info.sessionId)`.
    3. Observa `exerciseRepository.getEligibleSubstitutes(info.moduleCode, excludedIds).collect { exercises -> ... }`. Mapea `Exercise` → `SubstituteExerciseUiItem(exerciseId, name, muscleZones.joinToString(", "), equipmentTypeName)`. Se usa coma como separador entre zonas musculares (consistente con `ActiveSessionViewModel`, `ExerciseDictionaryViewModel`, `PlanVersionDetailViewModel`); el separador ` · ` se usa solo al concatenar zonas con tipo de equipo en el `supportingContent` de E3.
    4. Actualiza estado: `isLoading = false`, `originalExerciseName = info.currentExerciseName`, `eligibleExercises = mappedList`.

  - **`onExerciseSelected(exercise: SubstituteExerciseUiItem)`:** Actualiza `selectedExercise = exercise`, `showConfirmDialog = true`.

  - **`onDismissDialog()`:** Actualiza `showConfirmDialog = false`, `selectedExercise = null`.

  - **`onConfirmSubstitution()`:** Ejecuta en `viewModelScope.launch`:
    1. Si `selectedExercise == null` → retorna (defensa).
    2. Marca `isSubstituting = true`.
    3. `try { substituteExerciseUseCase(sessionExerciseId, selectedExercise.exerciseId) }`.
    4. Si éxito: emite `true` en `navigateBack` SharedFlow.
    5. Si `IllegalStateException`: emite `true` igualmente (graceful: ejercicio ya tiene series, retorna a E1).
    6. `finally { isSubstituting = false }`.

#### 7. UI Layer — Pantalla E3

Paquete: `ui.session`.

- **`SubstituteExerciseScreen`** (Nuevo): Composable que implementa la vista E3 según Wireframes E3 y Especificación Visual §8 E3.

  Firma:
  ```kotlin
  @Composable
  fun SubstituteExerciseScreen(
      onNavigateBack: () -> Unit,
      viewModel: SubstituteExerciseViewModel = hiltViewModel(),
  )
  ```

  **Estructura de layout:**

  - **Top Bar:** `CenterAlignedTopAppBar` (M3).
    - `navigationIcon`: `IconButton` con `Icons.Default.Close` (✕), tint `On Surface`. `onClick = onNavigateBack` (cancela sin sustituir).
    - `title`: `Column` con:
      - `Text` "Sustituir ejercicio" — `Title Large`.
      - `Text` "Reemplazar: [nombre]" — `Title Small`, `On Surface Variant`.

  - **Body:** `Column` con padding 16 dp.
    - **Texto informativo:** `Column` con 2 textos:
      - "Selecciona un ejercicio del mismo módulo como reemplazo." — `Body Medium`, `On Surface Variant`.
      - "La sustitución es puntual y no modifica el Plan." — `Body Medium`, `On Surface Variant`.
      - Spacer 16 dp.

    - **Lista de ejercicios elegibles:** `LazyColumn`.
      - Cada fila: `ListItem` M3 (64 dp).
        - `headlineContent`: `Text` nombre — `Title Medium`, `On Surface`.
        - `supportingContent`: `Text` "zona(s) muscular(es) · tipo equipo" — `Body Medium`, `On Surface Variant`.
        - `clickable` → `viewModel.onExerciseSelected(exercise)`.
      - `Divider` M3 entre filas: 1 dp, `Outline Variant`.

    - **TextButton "Cancelar":** Color `Primary`. Margin top 16 dp. `onClick = onNavigateBack`.

  - **Diálogo de confirmación:** `AlertDialog` M3. Condicional: solo visible cuando `uiState.showConfirmDialog == true`.
    - `title`: "¿Sustituir [original] por [sustituto]?" — `Title Medium`.
    - `text`: "Esta sustitución es solo para esta sesión." — `Body Medium`.
    - `confirmButton`: `Button` "Confirmar" con `containerColor = Primary`. `enabled = !uiState.isSubstituting`. `onClick = viewModel.onConfirmSubstitution()`.
    - `dismissButton`: `TextButton` "Cancelar". `onClick = viewModel.onDismissDialog()`.
    - Corner: 28 dp.

  - **Sin Bottom Navigation** (Arquitectura Técnica §4.5.1: E3 siempre oculta).

  - **Navegación de retorno:** `LaunchedEffect` que observa `viewModel.navigateBack` SharedFlow y llama a `onNavigateBack()` cuando emite `true`. Esto garantiza que la navegación ocurra después de la persistencia exitosa.

#### 8. Navegación (Modificaciones)

Paquete: `ui.navigation`.

- **`NavigationRoutes`** (Modificación Menor): Agregar ruta E3.
  - `const val SUBSTITUTE_EXERCISE = "substitute-exercise/{sessionExerciseId}"` (Arquitectura Técnica §4.3 ruta #11).
  - `fun substituteExerciseRoute(sessionExerciseId: Long) = "substitute-exercise/$sessionExerciseId"`.

- **`TensionNavHost`** (Modificación): 3 cambios.
  - **Wiring del callback** en `ACTIVE_SESSION`: reemplazar `onNavigateToSubstitute = { /* TODO: HU-07 */ }` por:
    ```kotlin
    onNavigateToSubstitute = { sessionExerciseId ->
        navController.navigate(NavigationRoutes.substituteExerciseRoute(sessionExerciseId))
    }
    ```
  - **Nuevo composable entry:** `composable(route = NavigationRoutes.SUBSTITUTE_EXERCISE, arguments = listOf(navArgument("sessionExerciseId") { type = NavType.LongType }))` que monta `SubstituteExerciseScreen(onNavigateBack = { navController.popBackStack() })`.

  - **`showBottomBar` exclusión:** Agregar `&& !currentRoute.startsWith("substitute-exercise")` a la condición existente.

#### 9. Recursos

Archivo: `app/src/main/res/values/strings.xml`.

- Agregar ~8 strings para E3:
  ```xml
  <!-- Substitute Exercise E3 -->
  <string name="substitute_exercise_title">Sustituir ejercicio</string>
  <string name="substitute_exercise_subtitle_format">Reemplazar: %1$s</string>
  <string name="substitute_exercise_info_line1">Selecciona un ejercicio del mismo módulo como reemplazo.</string>
  <string name="substitute_exercise_info_line2">La sustitución es puntual y no modifica el Plan.</string>
  <string name="substitute_exercise_dialog_title_format">¿Sustituir %1$s por %2$s?</string>
  <string name="substitute_exercise_dialog_text">Esta sustitución es solo para esta sesión.</string>
  <string name="substitute_exercise_confirm">Confirmar</string>
  <string name="substitute_exercise_cancel">Cancelar</string>
  ```

### Validación de Impacto

**Código verificado antes de proponer (paso 1.5):**

| Archivo | Estado verificado | Hallazgo |
|---|---|---|
| `SessionExerciseEntity.kt` | Completa con `original_exercise_id: Long? = null` (FK nullable) | ✅ Columna ya existe desde HU-05. No se necesita migración |
| `SessionExerciseDao.kt` | `getBySessionIdWithDetails()` usa INNER JOIN a `plan_assignment` | ⚠️ Bug: ejercicio sustituido desaparecería de E1. Se corrige a LEFT JOIN + COALESCE |
| `SessionExerciseDao.kt` | `SetExerciseInfo` y `SessionExerciseWithDetails` como data classes | ✅ Patrón establecido para `SessionExerciseForSubstitution` |
| `ExerciseDao.kt` | `getByModuleCodeNotInVersion()` existe como patrón de referencia | ✅ `getByModuleCodeNotInIds()` sigue el mismo patrón pero con semántica de exclusión diferente |
| `SessionRepositoryImpl.kt` | Inyecta 7 DAOs + database (8 params). 206 líneas | ✅ No requiere DAOs adicionales |
| `ExerciseRepositoryImpl.kt` | Mapeo `ExerciseWithDetails → Exercise` establecido en `getAllExercises()` | ✅ Reusar patrón para `getEligibleSubstitutes()` |
| `SessionRepository.kt` | 8 métodos actuales | ✅ Se agregan 3 |
| `ExerciseRepository.kt` | 8 métodos actuales | ✅ Se agrega 1 |
| `NavigationRoutes.kt` | 15 rutas + 5 helpers, sin `SUBSTITUTE_EXERCISE` | ✅ Se agrega |
| `TensionNavHost.kt` | `onNavigateToSubstitute = { /* TODO: HU-07 */ }` | ✅ Stub confirmado. Se reemplaza con navegación real |
| `TensionNavHost.kt` — `showBottomBar` | Excluye `active-session`, `register-set`, `exercise-detail` desde sesión | ⚠️ No excluye `substitute-exercise`. Se agrega |
| `ActiveSessionScreen.kt` | Botón "Sustituir" solo en `NotStartedExerciseRow`. `onSubstitute` callback recibe `sessionExerciseId` | ✅ CA-07.06 ya cumplido por diseño de E1. No se necesita cambio en E1 |
| `strings.xml` | Sin strings de E3 | ✅ Se agregan 8 strings |

**Impacto en el Flow reactivo de E1:** Al hacer UPDATE en `session_exercise` (cambiar `exercise_id`), Room invalida automáticamente el query `getBySessionIdWithDetails()`. El Flow re-emite la lista actualizada y el ejercicio sustituido aparece con su nuevo nombre, equipo, zonas musculares, etc. La card se re-renderiza en estado "No Iniciado" (0 series, como debe ser post-sustitución). No se requiere ningún refresh manual.

**Impacto en E2 (RegisterSetScreen):** E2 usa `getExerciseInfoForSet()` que busca por `se.id` (sessionExerciseId), no por `exercise_id`. Tras la sustitución, el `exercise_id` cambió pero el `sessionExerciseId` sigue siendo el mismo. E2 funciona correctamente sin cambios: el JOIN a `exercise` retorna los datos del nuevo ejercicio (sustituto) y el LEFT JOIN a `plan_assignment` con COALESCE (ya implementado en HU-06) retorna defaults si el sustituto no está en el plan.

**Impacto en `getLastWeightForExercise()` (HU-06):** Esta query busca el último peso por `exercise_id`. Tras sustituir A→B, E2 busca el historial de B (el sustituto). Si B fue usado antes en otra sesión, precarga su último peso. Si es la primera vez que se usa B, el campo queda vacío (`null`). Esto es correcto por diseño (CA-06.04: "último peso utilizado" para ese ejercicio específico).

### Notas Técnicas

1. **CA-07.01 (lista de sustitutos) se resuelve con query por módulo + exclusión por sesión.** La query `getByModuleCodeNotInIds()` filtra por `module_code` (CA-07.02) y excluye los `exercise_id` actualmente en la sesión (no los del plan). Esto incluye ejercicios de CUALQUIER versión del módulo y ejercicios custom del ejecutante (CA-07.01: "disponibles en cualquier versión del módulo").

2. **CA-07.03 y CA-07.04 (sustitución puntual) se cumplen por diseño.** La sustitución solo modifica `session_exercise` (tabla de runtime). `plan_assignment` (tabla del plan) permanece intacta. `startSession()` (HU-05) crea `session_exercise` desde `plan_assignment` — no consulta sustituciones de sesiones anteriores.

3. **CA-07.05 (sustitución de ejercicio no iniciado) se implementa como UPDATE.** `session_exercise.exercise_id = newExerciseId`, `session_exercise.original_exercise_id = currentExerciseId`. Las series registradas posteriormente se vincularán al nuevo `exercise_id` porque se insertan referenciando `session_exercise_id` (que no cambió), y `session_exercise.exercise_id` ahora apunta al sustituto.

4. **CA-07.06 (restricción con series registradas) se cumple en 3 capas.**
   - **UI (capa 1):** El botón "Sustituir" solo aparece en `NotStartedExerciseRow` (implementado en HU-05). No existe en `InProgressExerciseRow` ni `CompletedExerciseRow`.
   - **Repository (capa 2):** `getSubstituteExerciseInfo()` retorna `null` si `completedSets > 0`. E3 no se abre.
   - **Transacción (capa 3):** `substituteExercise()` valida `completedSets == 0` dentro de la transacción. Defensa ante race condition teórica.

5. **Sustitución doble (A→B→C).** CA-07 no prohíbe sustituir un ejercicio ya sustituido. Si el ejecutante sustituye A por B, y luego B por C (sin haber registrado series de B), `original_exercise_id` debe preservar A (el del plan original). El paso 3 del repositorio implementa esta lógica: `if (info.originalExerciseId != null) use it; else use info.exerciseId`.

6. **UNIQUE constraint `(session_id, exercise_id)`.** Tras sustituir, el nuevo `exercise_id` no puede ser uno que ya esté en la sesión. La exclusión en la lista de E3 (`getExerciseIdsForSession()`) previene que el ejecutante seleccione un ejercicio ya presente. Si por algún error se intentara, el UNIQUE constraint de la BD actuaría como safety net y la transacción fallaría con error (no hay datos corruptos).

7. **Relación con HU-06 (query de E2).** El LEFT JOIN en `getExerciseInfoForSet()` con `COALESCE(pa.sets, 4)` ya fue implementado en HU-06. Un ejercicio sustituido funciona correctamente en E2 sin cambios: la query busca por `session_exercise_id`, obtiene el nuevo `exercise_id` del sustituto, y si no está en `plan_assignment`, COALESCE proporciona defaults (4 series).

8. **Relación con HU-24 (historial de sesiones).** Cuando F2 muestre el detalle de una sesión pasada, el `session_exercise.exercise_id` apuntará al sustituto y `session_exercise.original_exercise_id` al ejercicio del plan. Esto permite mostrar "Sustituyó a: [original]" (CA-24.04). No se requiere acción en HU-07 — HU-24 consultará estos campos en su implementación.

### Referencias y Validación

**Documentación consultada:**

- Modelo de Datos (§3.11 `session_exercise`) — Columnas `exercise_id`, `original_exercise_id`, validación de integridad a nivel de aplicación
- Wireframes E3 — Selección de Ejercicio Sustituto (lista, diálogo, comportamiento)
- Especificación Visual §8 E3 — Componentes M3: ListItem 64 dp, AlertDialog 28 dp corner, estilos de texto
- Mapa de Navegación §5 (E3) — Flujo E1→E3→E1 (confirm/cancel)
- Arquitectura Técnica §4.3 (ruta #11: `substitute-exercise/{sessionExerciseId}`) y §4.5.1 (Bottom Nav oculta en E3) y §4.6 (Top Bar: Center Aligned con cierre)
- ADR (D-02: sustitución solo con "No Iniciado")
- Requerimientos: RF16
- Manifiesto de Dominio Sistémico §4 — Sustitución de Ejercicio: "temporal y no modifica el Plan de Entrenamiento original"
- Plan de Entrenamiento — Defaults (4 series, 8-12 reps) para COALESCE

**Historias relacionadas:**

- HU-03: Crear ejercicio — CA-03.10: un ejercicio custom creado por el ejecutante "queda disponible en las sustituciones de sesión (HU-07)". La query `getByModuleCodeNotInIds()` incluye ejercicios custom (`is_custom = 1`) del mismo módulo sin exclusión.
- HU-05: Determinar e iniciar sesión — Creó `SessionExerciseEntity` con `original_exercise_id`. Creó E1 con callbacks `onNavigateToSubstitute`. Botón "Sustituir" solo en `NotStartedExerciseRow`.
- HU-06: Registrar series — `getExerciseInfoForSet()` ya usa LEFT JOIN + COALESCE. `getLastWeightForExercise()` busca por `exercise_id` del sustituto, retornando historial correcto.
- HU-08: Ejercicios de peso corporal e isométricos — Un ejercicio sustituto puede ser bodyweight o isométrico. E2 (HU-06) ya maneja las 3 variantes, por lo que la sustitución no requiere lógica adicional para estos tipos.
- HU-09: Cerrar sesión — `session_exercise.exercise_id` apunta al ejercicio efectivamente ejecutado (sustituto). El cierre de sesión y cálculo de progresión operan sobre los datos reales. No se requiere lógica condicional para sustituciones.
- HU-10: Clasificación de progresión — Compara datos de `exercise_set` del sustituto con historial previo **del sustituto** (no del original). Si el sustituto no tiene historial, CA-10.07 aplica: "Sin Historial", no se emite clasificación.
- HU-23: Historial de ejercicio — CA-23.03: "un ejercicio puede haber sido ejecutado como sustitución → incluye todos los registros independientemente del módulo-versión". La query de historial busca por `exercise_id` (el sustituto), consolidando datos de todas las sesiones donde fue usado (como prescrito o como sustituto). No requiere lógica especial — `session_exercise.exercise_id` ya apunta al ejercicio real.
- HU-24: Historial de sesiones pasadas — Usará `session_exercise.original_exercise_id` para mostrar "Sustituyó a: [original]" (CA-24.04). Los datos están disponibles desde HU-07.

**Validado por:** esteban.colorado | **Fecha:** 2026-02-14 | **Enfoque:** Exploratorio

---

### Hitos de implementación

| # | Entregable | Dependencia |
|---|---|---|
| 1 | Data Layer — DAOs: `SessionExerciseDao` (fix query E1 + 3 nuevos métodos + `SessionExerciseForSubstitution`), `ExerciseDao` (+`getByModuleCodeNotInIds`) | — |
| 2 | Domain — Model: `SubstituteExerciseInfo` | — |
| 3 | Domain — Repository Interfaces: `SessionRepository` (+3 métodos), `ExerciseRepository` (+1 método) | Hito 2 |
| 4 | Domain — Use Case: `SubstituteExerciseUseCase` | Hito 3 |
| 5 | Data — Repository Impls: `SessionRepositoryImpl` (+3 métodos), `ExerciseRepositoryImpl` (+1 método) | Hito 1, 3 |
| 6 | UI — ViewModel: `SubstituteExerciseViewModel` (+ `SubstituteExerciseUiState`, `SubstituteExerciseUiItem`) | Hito 4 |
| 7 | UI — Screen: `SubstituteExerciseScreen` (E3 completo con lista + diálogo) | Hito 6 |
| 8 | Navegación: `NavigationRoutes` (+SUBSTITUTE_EXERCISE), `TensionNavHost` (wiring E1→E3 + showBottomBar exclusión) | Hito 7 |
| 9 | Recursos: `strings.xml` (~8 strings E3) | — (independiente) |

### Notas de auditoría

1. **CA-07.01 (lista de sustitutos elegibles) se resuelve con query por módulo + exclusión.** `WHERE module_code = :moduleCode AND id NOT IN (sessionExerciseIds)`. Incluye ejercicios de cualquier versión y custom (seed + runtime). CA validado contra Wireframes E3 #5 y Especificación Visual §8 E3.
2. **CA-07.02 (restricción al mismo módulo) se cumple con `WHERE module_code = :moduleCode`.** La `moduleCode` se obtiene del JOIN `exercise e ON se.exercise_id = e.id` → `e.module_code`. El módulo del ejercicio actual y el módulo de la sesión son siempre el mismo (la sesión es de un `module_version`, y todos los ejercicios del plan pertenecen a ese módulo).
3. **CA-07.03 y CA-07.04 (sustitución puntual, sin efecto en futuro) se cumplen por arquitectura.** `session_exercise` = runtime. `plan_assignment` = plan estable. `startSession()` siempre crea desde `plan_assignment`.
4. **CA-07.05 (reemplazo efectivo) se cumple con UPDATE atómico.** `exercise_id = newExerciseId`. Series futuras se vincularán al nuevo ejercicio via `session_exercise_id`.
5. **CA-07.06 (bloqueo con series registradas) se cumple en 3 capas.** UI: botón solo en `NotStartedExerciseRow`. Repository: `completedSets > 0 → null`. Transacción: validación final atómica.
6. **RF16 (sustitución puntual sin modificar plan) cubierto integralmente.** La sustitución modifica solo `session_exercise`, no `plan_assignment`. El botón "Sustituir" está condicionado a estado "No Iniciado". La lista filtra por módulo y excluye prescritos en la sesión.

### Riesgos y mitigaciones

| Riesgo | Probabilidad | Impacto | Mitigación |
|---|---|---|---|
| Ejercicio sustituido desaparece de E1 (INNER JOIN bug) | Segura sin fix | Bloqueante | Fix obligatorio: INNER JOIN → LEFT JOIN + COALESCE en `getBySessionIdWithDetails()` |
| Race condition: registro de serie entre validación y UPDATE | Muy baja | Alto | `database.withTransaction {}` serializa. UI: botón "Sustituir" solo en estado "No Iniciado" |
| UNIQUE constraint violation al sustituir por ejercicio ya en sesión | Nula (por diseño) | Alto | Lista de E3 excluye `exerciseIds` de la sesión. UNIQUE constraint como safety net |
| Sustitución doble pierde `original_exercise_id` | Media sin lógica | Medio | Paso 3 del repository: `if (info.originalExerciseId != null) use it` preserva el original del plan |
| Lista de sustitutos vacía (ningún ejercicio elegible) | Baja | Bajo | E3 muestra lista vacía. El ejecutante cancela y vuelve a E1. No se requiere manejo especial |
| `COALESCE(pa.reps, '8-12')` no coincide con reps del ejercicio real | Nula en MVP | Bajo | Todos los ejercicios del plan usan '8-12'. En futuro, si se agregan rangos diferentes, el COALESCE se ajustará |

### Verificación cruzada de CAs

| CA | Mecanismo de cumplimiento | Verificado contra |
|---|---|---|
| CA-07.01 | Query `getByModuleCodeNotInIds()`: filtra por módulo, excluye IDs de la sesión | Wireframes E3 #5, Especificación Visual §8 E3, RF16 |
| CA-07.02 | `WHERE module_code = :moduleCode` en la query de sustitutos | MDS §4 "mismo módulo" |
| CA-07.03 | UPDATE solo en `session_exercise` (runtime). `plan_assignment` intacto | MDS §4 "no modifica el Plan de Entrenamiento original" |
| CA-07.04 | `startSession()` (HU-05) crea desde `plan_assignment`, no consulta sustituciones | Modelo de Datos §3.11 |
| CA-07.05 | `updateExerciseId()` cambia `exercise_id` + registra `original_exercise_id` | Modelo de Datos §3.11 columnas |
| CA-07.06 | 3 capas: UI (botón condicional), Repository (`completedSets == 0`), Transacción (validación atómica) | ADR D-02, Modelo de Datos §3.11 validación |
